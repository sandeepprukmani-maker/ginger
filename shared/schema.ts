import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, jsonb, integer } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Automation Run - represents a single execution of a natural language command
export const automationRuns = pgTable("automation_runs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  command: text("command").notNull(),
  status: text("status").notNull().default("pending"), // pending, running, completed, failed
  createdAt: timestamp("created_at").notNull().defaultNow(),
  completedAt: timestamp("completed_at"),
  error: text("error"),
});

// Execution Steps - individual steps generated by LLM and executed by Playwright
export const executionSteps = pgTable("execution_steps", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  runId: varchar("run_id").notNull().references(() => automationRuns.id, { onDelete: "cascade" }),
  stepNumber: integer("step_number").notNull(),
  stepType: text("step_type").notNull(), // navigate, click, type, extract, assert, wait, screenshot
  description: text("description").notNull(),
  selector: text("selector"), // how the element was identified
  status: text("status").notNull().default("pending"), // pending, running, completed, failed
  result: jsonb("result"), // extracted data, assertion outcome, etc
  error: text("error"),
  screenshotPath: text("screenshot_path"),
  executedAt: timestamp("executed_at"),
});

// Scraped Data - structured data extracted during automation
export const scrapedData = pgTable("scraped_data", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  runId: varchar("run_id").notNull().references(() => automationRuns.id, { onDelete: "cascade" }),
  stepId: varchar("step_id").references(() => executionSteps.id, { onDelete: "cascade" }),
  data: jsonb("data").notNull(), // flexible JSON structure for scraped content
  extractedAt: timestamp("extracted_at").notNull().defaultNow(),
});

// Assertion Results - validation checks performed during automation
export const assertionResults = pgTable("assertion_results", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  runId: varchar("run_id").notNull().references(() => automationRuns.id, { onDelete: "cascade" }),
  stepId: varchar("step_id").references(() => executionSteps.id, { onDelete: "cascade" }),
  assertionType: text("assertion_type").notNull(), // exists, text_match, count, visible, enabled
  expected: text("expected"),
  actual: text("actual"),
  passed: text("passed").notNull(), // "true" or "false" as text
  message: text("message"),
  checkedAt: timestamp("checked_at").notNull().defaultNow(),
});

// Insert schemas
export const insertAutomationRunSchema = createInsertSchema(automationRuns).omit({
  id: true,
  createdAt: true,
});

export const insertExecutionStepSchema = createInsertSchema(executionSteps).omit({
  id: true,
});

export const insertScrapedDataSchema = createInsertSchema(scrapedData).omit({
  id: true,
  extractedAt: true,
});

export const insertAssertionResultSchema = createInsertSchema(assertionResults).omit({
  id: true,
  checkedAt: true,
});

// Types
export type AutomationRun = typeof automationRuns.$inferSelect;
export type InsertAutomationRun = z.infer<typeof insertAutomationRunSchema>;

export type ExecutionStep = typeof executionSteps.$inferSelect;
export type InsertExecutionStep = z.infer<typeof insertExecutionStepSchema>;

export type ScrapedData = typeof scrapedData.$inferSelect;
export type InsertScrapedData = z.infer<typeof insertScrapedDataSchema>;

export type AssertionResult = typeof assertionResults.$inferSelect;
export type InsertAssertionResult = z.infer<typeof insertAssertionResultSchema>;

// WebSocket message types
export const wsMessageSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("run_status"),
    runId: z.string(),
    status: z.enum(["pending", "running", "completed", "failed"]),
    error: z.string().optional(),
  }),
  z.object({
    type: z.literal("step_update"),
    runId: z.string(),
    step: z.object({
      id: z.string(),
      stepNumber: z.number(),
      stepType: z.string(),
      description: z.string(),
      status: z.string(),
      result: z.any().optional(),
      error: z.string().optional(),
    }),
  }),
  z.object({
    type: z.literal("scraped_data"),
    runId: z.string(),
    data: z.any(),
  }),
  z.object({
    type: z.literal("assertion_result"),
    runId: z.string(),
    assertion: z.any(),
  }),
  z.object({
    type: z.literal("log"),
    runId: z.string(),
    message: z.string(),
    level: z.enum(["info", "warn", "error"]),
  }),
]);

export type WSMessage = z.infer<typeof wsMessageSchema>;
