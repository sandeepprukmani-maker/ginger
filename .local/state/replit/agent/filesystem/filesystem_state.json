{"file_contents":{"main.py":{"content":"#!/usr/bin/env python3\nimport argparse\nimport asyncio\nimport sys\nimport os\nfrom dotenv import load_dotenv\nfrom automation_engine import BrowserAutomationEngine\n\ndef print_header():\n    print(\"\\n\" + \"=\"*60)\n    print(\"  AI Browser Automation CLI\")\n    print(\"  Powered by OpenAI & browser-use\")\n    print(\"=\"*60 + \"\\n\")\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser(\n        description=\"AI-powered browser automation using natural language\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Run automation and see results\n  python main.py \"search for Python tutorials on Google\"\n  \n  # Generate reusable Playwright code\n  python main.py \"go to example.com and click login\" --generate-code --output login.py\n  \n  # Execute generated code with self-healing\n  python main.py --execute-code login.py\n  \n  # Run with visible browser\n  python main.py \"scrape Hacker News\" --no-headless\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"task\",\n        type=str,\n        nargs=\"?\",\n        help=\"Natural language description of the task to perform\"\n    )\n    \n    parser.add_argument(\n        \"--headless\",\n        action=\"store_true\",\n        default=False,\n        help=\"Run browser in headless mode (default: False)\"\n    )\n    \n    parser.add_argument(\n        \"--no-headless\",\n        action=\"store_true\",\n        help=\"Show browser window during automation\"\n    )\n    \n    parser.add_argument(\n        \"--model\",\n        type=str,\n        default=\"gpt-4o-mini\",\n        help=\"OpenAI model to use (default: gpt-4o-mini)\"\n    )\n    \n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Show detailed logs during execution\"\n    )\n    \n    parser.add_argument(\n        \"--generate-code\",\n        action=\"store_true\",\n        help=\"Generate reusable Playwright Python code from the automation\"\n    )\n    \n    parser.add_argument(\n        \"--output\",\n        type=str,\n        default=\"generated_automation.py\",\n        help=\"Output file for generated code (default: generated_automation.py)\"\n    )\n    \n    parser.add_argument(\n        \"--execute-code\",\n        type=str,\n        metavar=\"FILE\",\n        help=\"Execute a previously generated automation script with self-healing\"\n    )\n    \n    return parser.parse_args()\n\nasync def execute_generated_code(code_file: str, api_key: str, model: str, verbose: bool):\n    \"\"\"Execute a previously generated automation script with self-healing\"\"\"\n    from self_healing_executor import SelfHealingExecutor\n    import importlib.util\n    \n    if not os.path.exists(code_file):\n        print(f\"‚ùå Error: File not found: {code_file}\")\n        sys.exit(1)\n    \n    print(f\"üîß Loading automation script: {code_file}\")\n    print(f\"ü§ñ Self-healing enabled with model: {model}\")\n    print(\"\\n\" + \"-\"*60 + \"\\n\")\n    \n    executor = SelfHealingExecutor(\n        api_key=api_key,\n        model=model,\n        verbose=verbose\n    )\n    \n    spec = importlib.util.spec_from_file_location(\"automation_module\", code_file)\n    if spec is None or spec.loader is None:\n        print(f\"‚ùå Error: Could not load module from {code_file}\")\n        sys.exit(1)\n    \n    module = importlib.util.module_from_spec(spec)\n    \n    try:\n        spec.loader.exec_module(module)\n        \n        if hasattr(module, 'automated_task'):\n            automation_func = module.automated_task\n        else:\n            func_names = [name for name in dir(module) if not name.startswith('_') and callable(getattr(module, name))]\n            if func_names:\n                automation_func = getattr(module, func_names[0])\n            else:\n                print(\"‚ùå Error: No automation function found in script\")\n                sys.exit(1)\n        \n        print(\"üöÄ Starting self-healing execution...\\n\")\n        await executor.execute_with_healing(automation_func)\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"‚úÖ Automation completed successfully!\")\n        print(\"-\"*60)\n        \n    except Exception as e:\n        print(f\"\\n‚ùå Execution failed: {str(e)}\")\n        if verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n\n\nasync def main():\n    load_dotenv()\n    \n    api_key = os.getenv('OPENAI_API_KEY')\n    if not api_key:\n        print(\"‚ùå Error: OPENAI_API_KEY not found in environment variables\")\n        print(\"\\nPlease set your OpenAI API key:\")\n        print(\"1. Copy .env.example to .env\")\n        print(\"2. Add your OpenAI API key to the .env file\")\n        print(\"\\nGet your API key from: https://platform.openai.com/api-keys\")\n        sys.exit(1)\n    \n    args = parse_arguments()\n    \n    print_header()\n    \n    if args.execute_code:\n        await execute_generated_code(\n            code_file=args.execute_code,\n            api_key=api_key,\n            model=args.model,\n            verbose=args.verbose\n        )\n        return\n    \n    if not args.task:\n        print(\"‚ùå Error: Task description required\")\n        print(\"Use --help for usage information\")\n        sys.exit(1)\n    \n    headless = args.headless and not args.no_headless\n    \n    print(f\"üìã Task: {args.task}\")\n    print(f\"ü§ñ Model: {args.model}\")\n    print(f\"üåê Headless Mode: {'Yes' if headless else 'No'}\")\n    print(f\"üìä Verbose: {'Yes' if args.verbose else 'No'}\")\n    if args.generate_code:\n        print(f\"üìù Code Generation: Enabled (output: {args.output})\")\n    print(\"\\n\" + \"-\"*60 + \"\\n\")\n    \n    engine = BrowserAutomationEngine(\n        api_key=api_key,\n        model=args.model,\n        headless=headless,\n        verbose=args.verbose,\n        generate_code=args.generate_code\n    )\n    \n    try:\n        print(\"üöÄ Starting browser automation...\\n\")\n        response = await engine.run_task(\n            args.task,\n            output_file=args.output if args.generate_code else None\n        )\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"‚úÖ Task completed successfully!\")\n        print(\"-\"*60 + \"\\n\")\n        \n        if response.get('result'):\n            print(\"üìÑ Result:\")\n            print(response['result'])\n            print()\n        \n        if response.get('code_file'):\n            print(f\"üìù Generated code saved to: {response['code_file']}\")\n            print(f\"\\nTo execute with self-healing:\")\n            print(f\"  python main.py --execute-code {response['code_file']}\")\n            print()\n        \n    except KeyboardInterrupt:\n        print(\"\\n\\n‚ö†Ô∏è  Task interrupted by user\")\n        sys.exit(0)\n    except Exception as e:\n        print(f\"\\n‚ùå Error: {str(e)}\")\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":6730},"self_healing_executor.py":{"content":"import asyncio\nimport os\nfrom typing import Optional, Dict, Any, List, Callable\nfrom playwright.async_api import Page, Browser, Locator, async_playwright\nfrom browser_use import Agent, Browser as BrowserUseWrapper, ChatOpenAI\n\n\nclass SelfHealingExecutor:\n    \"\"\"\n    Executes Playwright code with AI-powered self-healing capabilities.\n    When a locator fails, browser-use AI intervenes in the same session to fix it.\n    \"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.verbose = verbose\n        self.llm = None\n        self.healed_locators: Dict[str, str] = {}\n        self.healing_attempts = 0\n        self.max_healing_attempts = 3\n    \n    def _initialize_llm(self) -> ChatOpenAI:\n        \"\"\"Initialize OpenAI LLM for browser-use\"\"\"\n        if not self.llm:\n            self.llm = ChatOpenAI(\n                model=self.model,\n                api_key=self.api_key\n            )\n            if self.verbose:\n                print(f\"‚úì Initialized healing LLM: {self.model}\")\n        return self.llm\n    \n    async def heal_locator(\n        self,\n        page: Page,\n        failed_locator: str,\n        action_description: str,\n        element_description: str = \"\",\n        playwright_context = None\n    ) -> Optional[str]:\n        \"\"\"\n        Use browser-use AI to find and fix a broken locator in the same session.\n        \n        Args:\n            page: The Playwright page object\n            failed_locator: The locator that failed\n            action_description: What action we're trying to perform (e.g., \"click login button\")\n            element_description: Additional context about the element\n            playwright_context: The Playwright browser context to reuse\n        \n        Returns:\n            New working locator string, or None if healing failed\n        \"\"\"\n        if self.healing_attempts >= self.max_healing_attempts:\n            if self.verbose:\n                print(f\"‚ö†Ô∏è  Max healing attempts ({self.max_healing_attempts}) reached\")\n            return None\n        \n        self.healing_attempts += 1\n        \n        if self.verbose:\n            print(f\"\\nüîß Healing attempt {self.healing_attempts}/{self.max_healing_attempts}\")\n            print(f\"   Failed locator: {failed_locator}\")\n            print(f\"   Action: {action_description}\")\n        \n        try:\n            llm = self._initialize_llm()\n            \n            current_url = page.url\n            page_title = await page.title()\n            \n            task = f\"\"\"On this page ({current_url}), locate the element for: {action_description}.\n\nThe previous locator failed: {failed_locator}\nElement description: {element_description}\n\nIMPORTANT: After finding the correct element:\n1. Click or interact with it to confirm it's the right one\n2. Report back its exact attributes: text content, role, id, class, aria-label, placeholder, or any other identifying attributes\n3. Describe its location on the page for verification\n\nYour response should include the element's attributes in detail.\"\"\"\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI analyzing page to find element...\")\n            \n            cdp_url = await self._get_cdp_url(page)\n            \n            if not cdp_url:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not connect to existing browser session, fallback to heuristics\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üîó Connecting to browser session: {cdp_url}\")\n            \n            browser_wrapper = BrowserUseWrapper(\n                browser_session={'cdp_url': cdp_url}\n            )\n            \n            agent = Agent(\n                task=task,\n                llm=llm,\n                browser=browser_wrapper,\n            )\n            \n            result = await agent.run()\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI task result: {str(result)[:100] if result else 'None'}...\")\n            \n            history = agent.history if hasattr(agent, 'history') else None\n            \n            if not history:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  No history found on agent object\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üìã Analyzing agent history with {len(history.model_actions) if hasattr(history, 'model_actions') else 0} actions\")\n            \n            new_locator = await self._extract_locator_from_agent_history(\n                page=page,\n                history=history,\n                action_desc=action_description,\n                element_desc=element_description\n            )\n            \n            if new_locator:\n                self.healed_locators[failed_locator] = new_locator\n                if self.verbose:\n                    print(f\"   ‚úÖ Healing successful! New locator: {new_locator}\")\n                return new_locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not extract locator from AI, trying heuristics...\")\n                new_locator = await self._extract_locator_from_healing(page, action_description, element_description)\n                if new_locator:\n                    self.healed_locators[failed_locator] = new_locator\n                    if self.verbose:\n                        print(f\"   ‚úÖ Heuristic healing successful! New locator: {new_locator}\")\n                    return new_locator\n                \n                if self.verbose:\n                    print(f\"   ‚ùå Healing failed - could not determine new locator\")\n                return None\n                \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Healing error: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n            return None\n    \n    async def _get_cdp_url(self, page: Page) -> Optional[str]:\n        \"\"\"\n        Get CDP URL from the current Playwright browser session.\n        Uses multiple strategies to ensure compatibility.\n        \"\"\"\n        try:\n            browser = page.context.browser\n            \n            if hasattr(browser, '_impl_obj'):\n                impl_obj = browser._impl_obj\n                \n                if hasattr(impl_obj, '_connection') and hasattr(impl_obj._connection, 'url'):\n                    return impl_obj._connection.url\n                \n                if hasattr(impl_obj, '_transport') and hasattr(impl_obj._transport, 'url'):\n                    return impl_obj._transport.url\n            \n            if hasattr(browser, '_cdp_url'):\n                return browser._cdp_url\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Could not extract CDP URL: {str(e)}\")\n        \n        return None\n    \n    async def _extract_locator_from_agent_history(\n        self,\n        page: Page,\n        history,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Extract a working locator from browser-use agent's action history.\n        This parses what the AI actually found and interacted with.\n        \"\"\"\n        if not history:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  History object is None\")\n            return None\n        \n        try:\n            if hasattr(history, 'model_actions'):\n                try:\n                    actions = history.model_actions()\n                    if self.verbose:\n                        print(f\"   üìã Found {len(actions) if actions else 0} model actions in history\")\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ö†Ô∏è  Could not call model_actions(): {str(e)}\")\n                    actions = []\n                \n                for i, action in enumerate(reversed(actions)):\n                    if self.verbose:\n                        print(f\"   üîç Analyzing action {len(actions) - i}: {type(action)}\")\n                    \n                    if hasattr(action, '__dict__'):\n                        action_dict = action.__dict__\n                    elif isinstance(action, dict):\n                        action_dict = action\n                    else:\n                        continue\n                    \n                    action_type = action_dict.get('action', {})\n                    \n                    if isinstance(action_type, dict):\n                        if 'click_element' in action_type:\n                            element = action_type['click_element'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found click_element action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n                        \n                        if 'input_text' in action_type:\n                            element = action_type['input_text'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found input_text action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  History has no model_actions attribute\")\n            \n            if hasattr(history, 'history') and history.history:\n                if self.verbose:\n                    print(f\"   üîç Checking history.history list with {len(history.history)} items\")\n                for item in reversed(history.history):\n                    if hasattr(item, 'result') and hasattr(item.result, 'extracted_content'):\n                        if self.verbose:\n                            print(f\"   ‚úì Found extracted content in history item\")\n                        element_data = item.result.extracted_content\n                        if isinstance(element_data, dict) and 'attributes' in element_data:\n                            locator = await self._build_locator_from_element(page, element_data)\n                            if locator:\n                                return locator\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Error extracting from agent history: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n        \n        if self.verbose:\n            print(f\"   ‚ö†Ô∏è  Could not extract locator from agent history - falling back to heuristics\")\n        return None\n    \n    async def _build_locator_from_element(self, page: Page, element: Dict) -> Optional[str]:\n        \"\"\"Build a Playwright locator string from element attributes found by browser-use\"\"\"\n        if not element:\n            return None\n        \n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        attributes = element.get('attributes', {}) or {}\n        \n        strategies_to_try = []\n        \n        if attributes.get('data-testid'):\n            strategies_to_try.append(f'page.get_by_test_id(\"{attributes[\"data-testid\"]}\")')\n        \n        if attributes.get('id'):\n            strategies_to_try.append(f'page.locator(\"#{attributes[\"id\"]}\")')\n        \n        if attributes.get('aria-label'):\n            strategies_to_try.append(f'page.get_by_label(\"{attributes[\"aria-label\"]}\")')\n        \n        if role and text:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\", name=\"{text}\")')\n        elif role:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\")')\n        \n        if text:\n            strategies_to_try.append(f'page.get_by_text(\"{text}\")')\n        \n        if attributes.get('placeholder'):\n            strategies_to_try.append(f'page.get_by_placeholder(\"{attributes[\"placeholder\"]}\")')\n        \n        for strategy in strategies_to_try:\n            try:\n                locator = eval(strategy)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    return strategy if count == 1 else f'{strategy}.first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def _extract_locator_from_healing(\n        self,\n        page: Page,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Try to intelligently find a working locator based on common patterns.\n        This uses smart heuristics to locate elements after AI exploration.\n        \"\"\"\n        desc_lower = (action_desc + \" \" + element_desc).lower()\n        \n        common_selectors = []\n        \n        if \"login\" in desc_lower or \"sign in\" in desc_lower:\n            common_selectors.extend([\n                'button:has-text(\"Login\")',\n                'button:has-text(\"Sign in\")',\n                '[type=\"submit\"]',\n                'button[type=\"submit\"]',\n            ])\n        \n        if \"search\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"search\"]',\n                'input[name=\"q\"]',\n                'input[placeholder*=\"search\" i]',\n                '[aria-label*=\"search\" i]',\n            ])\n        \n        if \"submit\" in desc_lower or \"button\" in desc_lower:\n            common_selectors.extend([\n                'button[type=\"submit\"]',\n                'input[type=\"submit\"]',\n                'button',\n            ])\n        \n        if \"email\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"email\"]',\n                'input[name=\"email\"]',\n                'input[autocomplete=\"email\"]',\n            ])\n        \n        if \"password\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"password\"]',\n                'input[name=\"password\"]',\n                'input[autocomplete=\"current-password\"]',\n            ])\n        \n        for selector in common_selectors:\n            try:\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    if self.verbose:\n                        print(f\"   üîç Found working selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        text_elements = []\n        if \"click\" in desc_lower:\n            words = element_desc.split()\n            for word in words:\n                if len(word) > 3:\n                    text_elements.append(word)\n        \n        for text in text_elements[:3]:\n            try:\n                selector = f'text={text}'\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    if self.verbose:\n                        print(f\"   üîç Found working text selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def safe_locator(\n        self,\n        page: Page,\n        locator_str: str,\n        action_description: str = \"\",\n        element_description: str = \"\",\n        timeout: int = 10000\n    ) -> Optional[Locator]:\n        \"\"\"\n        Get a locator with automatic self-healing if it fails.\n        \n        Args:\n            page: Playwright page object\n            locator_str: Locator string (e.g., 'page.get_by_text(\"Login\")')\n            action_description: Description of the action being performed\n            element_description: Description of the element\n            timeout: Timeout in milliseconds\n        \n        Returns:\n            Working Locator object, or None if all attempts fail\n        \"\"\"\n        if locator_str in self.healed_locators:\n            locator_str = self.healed_locators[locator_str]\n            if self.verbose:\n                print(f\"   üìù Using previously healed locator: {locator_str}\")\n        \n        try:\n            locator = eval(locator_str)\n            await locator.wait_for(timeout=timeout)\n            return locator\n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Locator failed: {locator_str}\")\n                print(f\"      Error: {str(e)[:100]}\")\n            \n            healed_locator_str = await self.heal_locator(\n                page=page,\n                failed_locator=locator_str,\n                action_description=action_description,\n                element_description=element_description\n            )\n            \n            if healed_locator_str:\n                try:\n                    healed_locator = eval(healed_locator_str)\n                    await healed_locator.wait_for(timeout=timeout)\n                    return healed_locator\n                except Exception as heal_error:\n                    if self.verbose:\n                        print(f\"   ‚ùå Healed locator also failed: {str(heal_error)[:100]}\")\n            \n            return None\n    \n    async def execute_with_healing(\n        self,\n        automation_func: Callable,\n        *args,\n        **kwargs\n    ) -> Any:\n        \"\"\"\n        Execute an automation function with self-healing support.\n        \n        Args:\n            automation_func: Async function to execute\n            *args, **kwargs: Arguments to pass to the function\n        \n        Returns:\n            Result of the automation function\n        \"\"\"\n        self.healing_attempts = 0\n        self.healed_locators.clear()\n        \n        if self.verbose:\n            print(\"\\nüöÄ Starting execution with self-healing enabled\")\n            print(f\"   Max healing attempts per locator: {self.max_healing_attempts}\")\n        \n        try:\n            result = await automation_func(*args, **kwargs)\n            \n            if self.verbose:\n                print(\"\\n‚úÖ Execution completed successfully!\")\n                if self.healed_locators:\n                    print(f\"   Healed {len(self.healed_locators)} locator(s) during execution\")\n            \n            return result\n        except Exception as e:\n            if self.verbose:\n                print(f\"\\n‚ùå Execution failed: {str(e)}\")\n            raise\n\n\nclass HealingContext:\n    \"\"\"Context manager for self-healing Playwright automation\"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.executor = SelfHealingExecutor(\n            api_key=api_key,\n            model=model,\n            verbose=verbose\n        )\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright = None\n    \n    async def __aenter__(self):\n        \"\"\"Set up Playwright browser with healing support\"\"\"\n        self.playwright = await async_playwright().start()\n        self.browser = await self.playwright.chromium.launch(headless=False)\n        context = await self.browser.new_context()\n        self.page = await context.new_page()\n        \n        setattr(self.page, 'healing_locator', self._create_healing_locator_method())\n        \n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Clean up browser\"\"\"\n        if self.browser:\n            await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n    \n    def _create_healing_locator_method(self):\n        \"\"\"Create a healing locator method bound to the page\"\"\"\n        async def healing_locator(\n            locator_str: str,\n            action_desc: str = \"\",\n            element_desc: str = \"\"\n        ) -> Optional[Locator]:\n            return await self.executor.safe_locator(\n                page=self.page,\n                locator_str=locator_str,\n                action_description=action_desc,\n                element_description=element_desc\n            )\n        \n        return healing_locator\n","size_bytes":20627},"playwright_code_generator.py":{"content":"import re\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass LocatorStrategy:\n    \"\"\"Represents a locator with multiple fallback strategies\"\"\"\n    primary: str\n    fallbacks: List[str]\n    description: str\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"Converts browser-use action history to reusable Playwright Python code\"\"\"\n    \n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n        self.actions: List[Dict[str, Any]] = []\n        self.imports = set([\n            \"import asyncio\",\n            \"from playwright.async_api import async_playwright, Page, Browser, Locator\",\n            \"from typing import Optional\",\n        ])\n    \n    def parse_history(self, history) -> None:\n        \"\"\"Parse browser-use history and extract actions\"\"\"\n        if not history:\n            return\n        \n        if self.verbose:\n            print(\"üîç Parsing action history...\")\n        \n        if hasattr(history, 'model_actions'):\n            model_actions = history.model_actions()\n            for action in model_actions:\n                self._extract_action(action)\n        elif hasattr(history, 'history') and history.history:\n            for item in history.history:\n                self._extract_action(item)\n        \n        if self.verbose:\n            print(f\"‚úì Parsed {len(self.actions)} actions\")\n    \n    def _extract_action(self, action) -> None:\n        \"\"\"Extract action details from browser-use action object\"\"\"\n        action_data = {\n            'type': 'unknown',\n            'params': {},\n            'element': None,\n            'locators': []\n        }\n        \n        if hasattr(action, '__dict__'):\n            action_dict = action.__dict__\n        elif isinstance(action, dict):\n            action_dict = action\n        else:\n            action_dict = {}\n        \n        action_type = action_dict.get('action', {}) if isinstance(action_dict.get('action'), dict) else {}\n        \n        if 'go_to_url' in action_dict or (isinstance(action_type, dict) and 'go_to_url' in action_type):\n            url_data = action_dict.get('go_to_url', action_type.get('go_to_url', {}))\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': url_data.get('url', '')}\n        \n        elif 'click_element' in action_dict or (isinstance(action_type, dict) and 'click_element' in action_type):\n            click_data = action_dict.get('click_element', action_type.get('click_element', {}))\n            action_data['type'] = 'click'\n            action_data['element'] = click_data.get('element', {})\n            action_data['locators'] = self._generate_locators(action_data['element'])\n        \n        elif 'input_text' in action_dict or (isinstance(action_type, dict) and 'input_text' in action_type):\n            input_data = action_dict.get('input_text', action_type.get('input_text', {}))\n            action_data['type'] = 'fill'\n            action_data['element'] = input_data.get('element', {})\n            action_data['params'] = {'text': input_data.get('text', '')}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n        \n        elif 'extract_content' in action_dict or (isinstance(action_type, dict) and 'extract_content' in action_type):\n            action_data['type'] = 'extract'\n            action_data['params'] = action_dict.get('extract_content', action_type.get('extract_content', {}))\n        \n        if action_data['type'] != 'unknown':\n            self.actions.append(action_data)\n    \n    def _generate_locators(self, element: Dict[str, Any]) -> List[LocatorStrategy]:\n        \"\"\"Generate multiple locator strategies for an element\"\"\"\n        strategies = []\n        \n        if not element:\n            return strategies\n        \n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        tag = element.get('tag', '').strip()\n        attributes = element.get('attributes', {})\n        \n        if text:\n            strategies.append(LocatorStrategy(\n                primary=f'page.get_by_text(\"{self._escape_quotes(text)}\")',\n                fallbacks=[\n                    f'page.locator(\\'text=\"{self._escape_quotes(text)}\"\\')',\n                    f'page.locator(\\'//*[contains(text(), \"{self._escape_quotes(text)}\")]\\')',\n                ],\n                description=f\"Text: {text[:50]}\"\n            ))\n        \n        if role:\n            role_locator = f'page.get_by_role(\"{role}\"'\n            if text:\n                role_locator += f', name=\"{self._escape_quotes(text)}\"'\n            role_locator += ')'\n            \n            strategies.append(LocatorStrategy(\n                primary=role_locator,\n                fallbacks=[f'page.locator(\\'[role=\"{role}\"]\\')', ],\n                description=f\"Role: {role}\"\n            ))\n        \n        if attributes:\n            for key, value in attributes.items():\n                if key in ['id', 'data-testid', 'name', 'aria-label']:\n                    if key == 'id':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\"#{value}\")',\n                            fallbacks=[f'page.get_by_test_id(\"{value}\")'],\n                            description=f\"ID: {value}\"\n                        ))\n                    elif key == 'data-testid':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_test_id(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[data-testid=\"{value}\"]\\')', ],\n                            description=f\"Test ID: {value}\"\n                        ))\n                    elif key == 'name':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\\'[name=\"{value}\"]\\')',\n                            fallbacks=[f'page.get_by_label(\"{value}\")'],\n                            description=f\"Name: {value}\"\n                        ))\n                    elif key == 'aria-label':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_label(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[aria-label=\"{value}\"]\\')', ],\n                            description=f\"Aria-label: {value}\"\n                        ))\n        \n        if tag and not strategies:\n            strategies.append(LocatorStrategy(\n                primary=f'page.locator(\"{tag}\")',\n                fallbacks=[],\n                description=f\"Tag: {tag}\"\n            ))\n        \n        return strategies\n    \n    def _escape_quotes(self, text: str) -> str:\n        \"\"\"Escape quotes in text for code generation\"\"\"\n        return text.replace('\"', '\\\\\"').replace(\"'\", \"\\\\'\")\n    \n    def generate_code(self, function_name: str = \"automated_task\") -> str:\n        \"\"\"Generate complete Playwright Python code from actions\"\"\"\n        if not self.actions:\n            return \"# No actions to generate code from\"\n        \n        code_lines = []\n        \n        code_lines.extend(sorted(self.imports))\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n        \n        code_lines.append(f\"async def {function_name}():\")\n        code_lines.append('    \"\"\"Generated Playwright automation code with self-healing support\"\"\"')\n        code_lines.append(\"    async with async_playwright() as p:\")\n        code_lines.append(\"        browser = await p.chromium.launch(headless=False)\")\n        code_lines.append(\"        context = await browser.new_context()\")\n        code_lines.append(\"        page = await context.new_page()\")\n        code_lines.append(\"\")\n        code_lines.append(\"        try:\")\n        \n        for i, action in enumerate(self.actions):\n            code_lines.append(f\"            # Step {i + 1}: {action['type']}\")\n            \n            if action['type'] == 'goto':\n                url = action['params'].get('url', '')\n                code_lines.append(f'            await page.goto(\"{url}\")')\n                code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n            \n            elif action['type'] == 'click':\n                locators = action.get('locators', [])\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f\"            await element.click()\")\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for click action\")\n            \n            elif action['type'] == 'fill':\n                locators = action.get('locators', [])\n                text = action['params'].get('text', '')\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f'            await element.fill(\"{self._escape_quotes(text)}\")')\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for fill action\")\n            \n            elif action['type'] == 'extract':\n                code_lines.append(\"            # Extract content (implement based on your needs)\")\n                code_lines.append(\"            content = await page.content()\")\n            \n            code_lines.append(\"\")\n        \n        code_lines.append('            print(\"‚úÖ Task completed successfully!\")')\n        code_lines.append(\"\")\n        code_lines.append(\"        except Exception as e:\")\n        code_lines.append('            print(f\"‚ùå Error during automation: {e}\")')\n        code_lines.append(\"            raise\")\n        code_lines.append(\"        finally:\")\n        code_lines.append(\"            await browser.close()\")\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n        \n        code_lines.append(\"async def self_healing_locator(page: Page, primary: str, fallbacks: List[str] = None) -> Locator:\")\n        code_lines.append('    \"\"\"Try primary locator, fall back to alternatives if it fails\"\"\"')\n        code_lines.append(\"    fallbacks = fallbacks or []\")\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try primary locator\")\n        code_lines.append(\"    try:\")\n        code_lines.append(\"        locator = eval(primary)\")\n        code_lines.append(\"        await locator.wait_for(timeout=5000)\")\n        code_lines.append(\"        return locator\")\n        code_lines.append(\"    except Exception as e:\")\n        code_lines.append('        print(f\"‚ö†Ô∏è  Primary locator failed: {primary}\")')\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try fallback locators\")\n        code_lines.append(\"    for fallback in fallbacks:\")\n        code_lines.append(\"        try:\")\n        code_lines.append(\"            locator = eval(fallback)\")\n        code_lines.append(\"            await locator.wait_for(timeout=5000)\")\n        code_lines.append('            print(f\"‚úì Fallback locator succeeded: {fallback}\")')\n        code_lines.append(\"            return locator\")\n        code_lines.append(\"        except Exception:\")\n        code_lines.append(\"            continue\")\n        code_lines.append(\"    \")\n        code_lines.append('    raise Exception(f\"All locators failed for: {primary}\")')\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n        code_lines.append('if __name__ == \"__main__\":')\n        code_lines.append(f\"    asyncio.run({function_name}())\")\n        \n        return \"\\n\".join(code_lines)\n    \n    def save_code(self, filepath: str, function_name: str = \"automated_task\") -> None:\n        \"\"\"Generate and save code to a file\"\"\"\n        code = self.generate_code(function_name)\n        with open(filepath, 'w') as f:\n            f.write(code)\n        \n        if self.verbose:\n            print(f\"‚úì Code saved to: {filepath}\")\n","size_bytes":12864},"README.md":{"content":"# AI Browser Automation CLI with Self-Healing Code Generation\n\nA powerful Python CLI tool that performs AI-powered browser automation and generates reusable Playwright code with automatic self-healing capabilities. Simply describe what you want to do in natural language, and the AI handles everything‚Äîincluding fixing broken locators in generated code.\n\n## Features\n\n### Core Capabilities\n- **Natural Language Interface**: Describe tasks in plain English\n- **Advanced Browser Automation**: Navigation, clicking, form filling, data extraction, multi-step workflows\n- **AI-Powered**: Uses OpenAI gpt-4o-mini with browser-use for intelligent task execution\n\n### NEW: Self-Healing Code Generation ‚≠ê\n- **Generate Reusable Code**: Convert automation into clean Playwright Python scripts\n- **Multiple Locator Strategies**: Text, role, ID, label, CSS, XPath with automatic fallbacks\n- **AI-Powered Self-Healing**: When locators fail in generated code, AI automatically finds elements and fixes locators **within the same browser session**\n- **Production-Ready**: Generated code is maintainable, testable, and adapts to page changes\n\n**Important**: Self-healing applies only to **generated code execution**, not initial automation (which already uses AI natively).\n\n## Prerequisites\n\n- Python 3.11 or higher\n- OpenAI API key ([Get one here](https://platform.openai.com/api-keys))\n\n## Installation\n\n1. Install dependencies:\n```bash\npip install browser-use langchain-openai python-dotenv\n```\n\n2. Install Playwright browser (if not using system Chromium):\n```bash\nplaywright install chromium\n```\n\n3. Set up your OpenAI API key:\n```bash\ncp .env.example .env\n# Edit .env and add your OpenAI API key\n```\n\n**Note:** The tool will automatically detect system Chromium/Chrome. If you need to specify a custom path, set `CHROMIUM_PATH` in your `.env` file.\n\n## Usage\n\n### Basic Usage\n\nRun a task with natural language:\n\n```bash\npython main.py \"search for Python tutorials on Google\"\n```\n\n### Advanced Examples\n\n**Web Scraping:**\n```bash\npython main.py \"scrape the top 10 Hacker News posts with their titles and URLs\"\n```\n\n**Form Automation:**\n```bash\npython main.py \"go to example.com/contact and fill out the contact form with name: John Doe, email: john@example.com\"\n```\n\n**Multi-step Workflows:**\n```bash\npython main.py \"compare prices for iPhone 15 on Amazon and Best Buy\"\n```\n\n**Data Collection:**\n```bash\npython main.py \"find the top 5 Python automation libraries on GitHub and extract their star counts\"\n```\n\n### Command Options\n\n```bash\npython main.py [OPTIONS] \"task description\"\n\nOptions:\n  -h, --help        Show help message\n  --headless        Run browser in headless mode (default: True)\n  --no-headless     Show browser window\n  --model MODEL     OpenAI model to use (default: gpt-4o-mini)\n  --verbose         Show detailed logs\n```\n\n## Examples\n\n### Example 1: Simple Search\n```bash\npython main.py \"search Google for 'best Python IDE'\"\n```\n\n### Example 2: Extract Information\n```bash\npython main.py \"go to news.ycombinator.com and get the title of the top story\"\n```\n\n### Example 3: Multi-step Task\n```bash\npython main.py \"search for 'Replit' on Google, click the first result, and tell me the page title\"\n```\n\n## How It Works\n\n1. You provide a natural language task description\n2. The CLI initializes the browser automation agent with OpenAI\n3. The AI agent interprets your task and executes the necessary browser actions\n4. You see real-time progress as the agent works\n5. The agent returns the results when complete\n\n## Troubleshooting\n\n**Error: Missing OPENAI_API_KEY**\n- Make sure you've created a `.env` file with your OpenAI API key\n\n**Browser fails to start**\n- Check that Chromium is properly installed\n- Try running with `--no-headless` to see what's happening\n\n## Advanced Usage\n\nThe tool uses the browser-use library which provides:\n- Automatic page navigation\n- Intelligent element detection\n- Form filling\n- Data extraction\n- Multi-page workflows\n- Dynamic content handling\n\n## Technology Stack\n\n- **browser-use**: AI-powered browser automation\n- **OpenAI gpt-4o-mini**: Natural language understanding\n- **Playwright**: Browser automation backend\n- **Python 3.11+**: Modern Python features\n\n## License\n\nMIT License\n","size_bytes":4231},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.5.9\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=2.6.0\",\n    \"playwright>=1.55.0\",\n    \"python-dotenv>=1.1.1\",\n]\n","size_bytes":276},"automation_engine.py":{"content":"import os\nfrom typing import Optional, Dict, Any\nfrom browser_use import Agent, Browser, BrowserProfile, ChatOpenAI\nfrom playwright_code_generator import PlaywrightCodeGenerator\n\nclass BrowserAutomationEngine:\n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        headless: bool = False,\n        verbose: bool = False,\n        generate_code: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.headless = headless\n        self.verbose = verbose\n        self.generate_code = generate_code\n        \n        self.llm = self._initialize_llm()\n        self.browser = self._initialize_browser()\n        self.code_generator = PlaywrightCodeGenerator(verbose=verbose) if generate_code else None\n    \n    def _initialize_llm(self) -> ChatOpenAI:\n        # the newest OpenAI model is \"gpt-4o-mini\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        llm = ChatOpenAI(\n            model=self.model,\n            api_key=self.api_key\n        )\n        \n        if self.verbose:\n            print(f\"‚úì Initialized LLM: {self.model}\")\n        \n        return llm\n    \n    def _initialize_browser(self) -> Browser:\n        import shutil\n        \n        chromium_path = os.getenv(\"CHROMIUM_PATH\")\n        if not chromium_path:\n            chromium_path = shutil.which(\"chromium\") or shutil.which(\"chromium-browser\") or shutil.which(\"chrome\")\n        \n        if chromium_path:\n            if self.verbose:\n                print(f\"‚úì Using Chromium at: {chromium_path}\")\n            profile = BrowserProfile(\n                headless=self.headless,\n                executable_path=chromium_path\n            )\n        else:\n            profile = BrowserProfile(\n                headless=self.headless\n            )\n        \n        browser = Browser(\n            browser_profile=profile\n        )\n        \n        if self.verbose:\n            print(f\"‚úì Initialized Browser (headless={self.headless})\")\n        \n        return browser\n    \n    async def run_task(self, task: str, output_file: Optional[str] = None) -> Dict[str, Any]:\n        if self.verbose:\n            print(f\"\\nüéØ Creating agent for task: {task}\\n\")\n        \n        agent = Agent(\n            task=task,\n            llm=self.llm,\n            browser=self.browser,\n        )\n        \n        if self.verbose:\n            print(\"üîÑ Agent created, starting execution...\\n\")\n        \n        history = await agent.run()\n        \n        if self.verbose:\n            print(f\"\\nüìä Task execution completed\")\n            print(f\"   Steps taken: {len(history.history) if hasattr(history, 'history') else 'N/A'}\")\n        \n        result = self._extract_result(history)\n        \n        response = {\n            'result': result,\n            'history': history,\n            'generated_code': None,\n            'code_file': None\n        }\n        \n        if self.generate_code and self.code_generator:\n            if self.verbose:\n                print(\"\\nüìù Generating Playwright code from actions...\")\n            \n            self.code_generator.parse_history(history)\n            generated_code = self.code_generator.generate_code()\n            response['generated_code'] = generated_code\n            \n            if output_file:\n                self.code_generator.save_code(output_file)\n                response['code_file'] = output_file\n                if self.verbose:\n                    print(f\"‚úì Code saved to: {output_file}\")\n        \n        return response\n    \n    def _extract_result(self, history) -> Optional[str]:\n        if not history:\n            return None\n        \n        if hasattr(history, 'final_result'):\n            return str(history.final_result())\n        \n        if hasattr(history, 'history') and history.history:\n            last_action = history.history[-1]\n            if hasattr(last_action, 'result'):\n                return str(last_action.result)\n        \n        return \"Task completed successfully\"\n","size_bytes":4046},"test_workflow.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script to verify the complete workflow:\n1. Run browser-use automation\n2. Generate Playwright code\n3. Execute with self-healing\n\"\"\"\n\nimport asyncio\nimport os\nfrom automation_engine import BrowserAutomationEngine\n\n\nasync def test_code_generation():\n    \"\"\"Test generating code from browser-use automation\"\"\"\n    api_key = os.getenv('OPENAI_API_KEY')\n    if not api_key:\n        print(\"‚ùå OPENAI_API_KEY not set\")\n        return False\n    \n    print(\"=\"*60)\n    print(\"TEST: Code Generation from Browser-Use Automation\")\n    print(\"=\"*60)\n    \n    engine = BrowserAutomationEngine(\n        api_key=api_key,\n        model=\"gpt-4o-mini\",\n        headless=False,\n        verbose=True,\n        generate_code=True\n    )\n    \n    task = \"go to example.com and tell me the page title\"\n    \n    try:\n        print(f\"\\nüéØ Running task: {task}\")\n        response = await engine.run_task(task, output_file=\"test_generated.py\")\n        \n        print(\"\\n\" + \"=\"*60)\n        print(\"RESULTS:\")\n        print(\"=\"*60)\n        print(f\"Task Result: {response.get('result')}\")\n        print(f\"Code Generated: {'Yes' if response.get('generated_code') else 'No'}\")\n        print(f\"Code File: {response.get('code_file')}\")\n        \n        if response.get('generated_code'):\n            print(\"\\n\" + \"-\"*60)\n            print(\"GENERATED CODE PREVIEW:\")\n            print(\"-\"*60)\n            lines = response['generated_code'].split('\\n')[:30]\n            print('\\n'.join(lines))\n            if len(response['generated_code'].split('\\n')) > 30:\n                print(\"... (truncated)\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"\\n‚ùå Test failed: {str(e)}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\nasync def main():\n    success = await test_code_generation()\n    \n    print(\"\\n\" + \"=\"*60)\n    if success:\n        print(\"‚úÖ Test completed successfully!\")\n        print(\"\\nNext steps:\")\n        print(\"1. Check test_generated.py for the generated code\")\n        print(\"2. Run: python main.py --execute-code test_generated.py\")\n        print(\"   (This will execute with self-healing enabled)\")\n    else:\n        print(\"‚ùå Test failed - check errors above\")\n    print(\"=\"*60)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":2313},"replit.md":{"content":"# AI Browser Automation CLI with Self-Healing Code Generation\n\n## Overview\nA Python CLI tool that performs OpenAI-powered browser automation with **self-healing Playwright code generation**. The tool has two key features:\n1. **AI Browser Automation**: Run tasks using natural language with browser-use\n2. **Self-Healing Code Generation**: Convert browser-use actions into reusable Playwright code with automatic locator healing\n\n## Current State\n- **Status**: Active Development - Self-Healing Features Added\n- **Language**: Python 3.11\n- **Framework**: browser-use + OpenAI gpt-4o-mini + Playwright + LangChain\n- **Last Updated**: October 22, 2025\n\n## Recent Changes\n### October 22, 2025 - Self-Healing Code Generation Added\n- **NEW**: PlaywrightCodeGenerator - Converts browser-use actions to reusable Playwright code\n- **NEW**: SelfHealingExecutor - AI-powered locator healing for generated code execution\n- **NEW**: CLI modes: --generate-code and --execute-code with self-healing\n- **NEW**: Locator utilities with multiple fallback strategies\n- Updated automation engine to support code generation mode\n- Created test workflow for validation\n- Updated documentation with new features\n\n### October 22, 2025 - Initial Setup\n- Initial project setup\n- Installed dependencies: browser-use, langchain-openai, python-dotenv, playwright\n- Installed Chromium browser via Nix system dependencies\n- Created core CLI application (main.py)\n- Implemented browser automation engine (automation_engine.py)\n- Added project documentation (README.md)\n\n## Project Architecture\n\n### Main Components\n1. **main.py** - CLI entry point with three modes: automation, code generation, and self-healing execution\n2. **automation_engine.py** - Core automation logic with browser-use and code generation support\n3. **playwright_code_generator.py** - Converts browser-use action history to Playwright code\n4. **self_healing_executor.py** - Executes generated code with AI-powered locator healing\n5. **locator_utils.py** - Helper utilities for robust locator strategies\n6. **test_workflow.py** - Test script for the complete workflow\n\n### Dependencies\n- **browser-use (0.5.9+)**: AI-powered browser automation framework\n- **langchain-openai**: OpenAI integration for LangChain\n- **playwright**: Browser automation backend for code execution\n- **python-dotenv**: Environment variable management\n- **openai**: OpenAI API client\n\n### Technology Stack\n- Python 3.11+\n- OpenAI gpt-4o-mini (newest model, released August 7, 2025)\n- Playwright for generated code execution\n- browser-use for initial automation and self-healing\n- LangChain for AI orchestration\n\n## How It Works\n\n### Mode 1: Direct Browser Automation (Original)\n1. User provides natural language task via CLI\n2. browser-use Agent interprets and executes the task\n3. Results returned to user\n\n### Mode 2: Code Generation (NEW)\n1. User provides task with `--generate-code` flag\n2. browser-use Agent performs the automation\n3. Action history is captured and parsed\n4. PlaywrightCodeGenerator converts actions to reusable Python code\n5. Generated code includes multiple locator fallback strategies\n6. Code saved to file for later execution\n\n### Mode 3: Self-Healing Execution (NEW)\n1. User runs generated code with `--execute-code` flag\n2. SelfHealingExecutor loads and runs the Playwright script\n3. **When a locator fails:**\n   - Execution pauses (same browser session maintained)\n   - browser-use AI intervenes to analyze the page\n   - AI finds the element using intelligent heuristics\n   - New working locator is generated and cached\n   - Execution resumes smoothly with remaining steps\n4. Process continues until all steps complete\n\n## Usage Examples\n\n### Basic Automation (Mode 1)\n```bash\n# Simple task\npython main.py \"go to example.com and tell me the page title\"\n\n# Web scraping\npython main.py \"scrape top 10 Hacker News posts\" --verbose\n\n# Form automation\npython main.py \"fill out contact form with test data\" --no-headless\n```\n\n### Code Generation (Mode 2)\n```bash\n# Generate reusable Playwright code\npython main.py \"go to example.com and click login\" --generate-code\n\n# Specify custom output file\npython main.py \"search for Python on Google\" --generate-code --output search_google.py\n\n# Generate with verbose logging\npython main.py \"navigate to GitHub trending\" --generate-code --verbose\n```\n\n### Self-Healing Execution (Mode 3)\n```bash\n# Execute generated code with self-healing\npython main.py --execute-code generated_automation.py\n\n# Execute with verbose healing logs\npython main.py --execute-code search_google.py --verbose\n\n# The self-healing will automatically:\n# - Detect when locators fail\n# - Use AI to find correct elements\n# - Generate new working locators\n# - Resume execution smoothly\n```\n\n### Complete Workflow\n```bash\n# Step 1: Record and generate code\npython main.py \"go to example.com, click login, fill email with test@email.com\" \\\n  --generate-code --output login_flow.py --verbose\n\n# Step 2: Execute with self-healing (even if page changes)\npython main.py --execute-code login_flow.py --verbose\n```\n\n## Environment Variables\n- `OPENAI_API_KEY` (required): OpenAI API key for gpt-4o-mini access\n\n## Key Features\n\n### 1. Multiple Locator Strategies\nGenerated code includes fallback locators:\n- Text-based locators (exact and partial match)\n- Role-based locators (ARIA roles)\n- Label-based locators\n- ID and test-ID locators\n- CSS and XPath selectors\n\n### 2. AI-Powered Self-Healing\nWhen locators break (page changes, updates, etc.):\n- **Same browser session maintained** - no restart needed\n- AI analyzes the current page state\n- Intelligent element detection using heuristics\n- New locator generated and cached\n- Execution continues without manual intervention\n\n### 3. Verbose Logging\nTrack the entire process:\n- Initial automation steps\n- Code generation progress\n- Locator failure detection\n- Healing attempts and results\n- Final execution status\n\n## User Preferences\n- Prefers AI-powered self-healing for generated code execution\n- Wants healing to happen within the same browser session\n- Wants clear separation: browser-use for initial automation, self-healing for generated code\n\n## Technical Implementation Notes\n\n### Self-Healing Flow\n1. **Generated code execution starts** with Playwright\n2. **Locator fails** ‚Üí Exception caught\n3. **Browser session preserved** ‚Üí No browser restart\n4. **AI intervention** ‚Üí browser-use analyzes page via CDP connection\n5. **Smart heuristics** ‚Üí Match element by common patterns (login, search, submit, etc.)\n6. **New locator created** ‚Üí Cached for reuse\n7. **Execution resumes** ‚Üí Remaining steps continue\n\n### Code Generation Process\n1. browser-use records all actions (goto, click, fill, extract, etc.)\n2. Action history parsed to extract element details\n3. For each element, multiple locator strategies generated\n4. Python code template populated with async/await Playwright syntax\n5. Self-healing helper function included in generated code\n6. Output saved as executable Python script\n\n## Future Enhancements\n- Export to Playwright Codegen format\n- Video recording of healing process\n- Locator confidence scoring\n- Multi-language code generation (TypeScript, Java, C#)\n- Configuration file for healing strategies\n- Session replay and debugging tools\n","size_bytes":7263},"locator_utils.py":{"content":"\"\"\"\nHelper utilities for robust locator strategies and self-healing.\nThese are used when executing GENERATED Playwright code, not during initial browser-use automation.\n\"\"\"\n\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Locator\n\n\nclass LocatorBuilder:\n    \"\"\"Build robust locators with multiple fallback strategies\"\"\"\n    \n    @staticmethod\n    def by_text(text: str, exact: bool = False) -> List[str]:\n        \"\"\"Generate text-based locator strategies\"\"\"\n        escaped = text.replace('\"', '\\\\\"')\n        strategies = [\n            f'page.get_by_text(\"{escaped}\", exact={exact})',\n            f'page.locator(\\'text={escaped}\\')',\n        ]\n        if not exact:\n            strategies.append(f'page.locator(\\'//*[contains(text(), \"{escaped}\")]\\')')\n        return strategies\n    \n    @staticmethod\n    def by_role(role: str, name: Optional[str] = None) -> List[str]:\n        \"\"\"Generate role-based locator strategies\"\"\"\n        if name:\n            name_escaped = name.replace('\"', '\\\\\"')\n            return [\n                f'page.get_by_role(\"{role}\", name=\"{name_escaped}\")',\n                f'page.locator(\\'[role=\"{role}\"][aria-label=\"{name_escaped}\"]\\')',\n                f'page.locator(\\'[role=\"{role}\"]\\')',\n            ]\n        return [\n            f'page.get_by_role(\"{role}\")',\n            f'page.locator(\\'[role=\"{role}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_label(label: str) -> List[str]:\n        \"\"\"Generate label-based locator strategies\"\"\"\n        escaped = label.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_label(\"{escaped}\")',\n            f'page.locator(\\'[aria-label=\"{escaped}\"]\\')',\n            f'page.locator(\\'label:has-text(\"{escaped}\")\\')',\n        ]\n    \n    @staticmethod\n    def by_placeholder(placeholder: str) -> List[str]:\n        \"\"\"Generate placeholder-based locator strategies\"\"\"\n        escaped = placeholder.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_placeholder(\"{escaped}\")',\n            f'page.locator(\\'[placeholder=\"{escaped}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_test_id(test_id: str) -> List[str]:\n        \"\"\"Generate test-id based locator strategies\"\"\"\n        return [\n            f'page.get_by_test_id(\"{test_id}\")',\n            f'page.locator(\\'[data-testid=\"{test_id}\"]\\')',\n            f'page.locator(\\'[data-test-id=\"{test_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_id(element_id: str) -> List[str]:\n        \"\"\"Generate id-based locator strategies\"\"\"\n        return [\n            f'page.locator(\"#{element_id}\")',\n            f'page.locator(\\'[id=\"{element_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_css(selector: str) -> List[str]:\n        \"\"\"Generate CSS selector locator\"\"\"\n        return [f'page.locator(\"{selector}\")']\n    \n    @staticmethod\n    def by_xpath(xpath: str) -> List[str]:\n        \"\"\"Generate XPath locator\"\"\"\n        return [f'page.locator(\\'{xpath}\\')']\n\n\nasync def try_locator_strategies(\n    page: Page,\n    strategies: List[str],\n    timeout: int = 5000,\n    verbose: bool = False\n) -> Optional[Locator]:\n    \"\"\"\n    Try multiple locator strategies until one works.\n    Used in generated code for fallback locator support.\n    \n    Args:\n        page: Playwright page object\n        strategies: List of locator strategy strings\n        timeout: Timeout in milliseconds per strategy\n        verbose: Print debug information\n    \n    Returns:\n        Working Locator object, or None if all fail\n    \"\"\"\n    for i, strategy in enumerate(strategies):\n        try:\n            locator = eval(strategy)\n            await locator.wait_for(timeout=timeout)\n            if verbose and i > 0:\n                print(f\"   ‚úì Fallback strategy {i} worked: {strategy}\")\n            return locator\n        except Exception:\n            if verbose:\n                print(f\"   ‚ö†Ô∏è  Strategy {i} failed: {strategy}\")\n            continue\n    \n    return None\n\n\nclass LocatorHealer:\n    \"\"\"\n    Context information for self-healing locators.\n    This is used ONLY when executing generated Playwright code.\n    \"\"\"\n    \n    @staticmethod\n    def extract_element_info(locator_str: str) -> Dict[str, str]:\n        \"\"\"Extract information from a locator string for healing context\"\"\"\n        info = {\n            'type': 'unknown',\n            'value': '',\n            'description': ''\n        }\n        \n        if 'get_by_text' in locator_str:\n            info['type'] = 'text'\n            info['description'] = 'element with text'\n        elif 'get_by_role' in locator_str:\n            info['type'] = 'role'\n            info['description'] = 'element with role'\n        elif 'get_by_label' in locator_str:\n            info['type'] = 'label'\n            info['description'] = 'element with label'\n        elif 'get_by_placeholder' in locator_str:\n            info['type'] = 'placeholder'\n            info['description'] = 'input with placeholder'\n        elif 'get_by_test_id' in locator_str:\n            info['type'] = 'test_id'\n            info['description'] = 'element with test ID'\n        elif 'locator' in locator_str:\n            if 'text=' in locator_str:\n                info['type'] = 'text'\n                info['description'] = 'element with text'\n            elif '[role=' in locator_str:\n                info['type'] = 'role'\n                info['description'] = 'element with role'\n            elif '#' in locator_str:\n                info['type'] = 'id'\n                info['description'] = 'element with ID'\n            else:\n                info['type'] = 'css'\n                info['description'] = 'element matching CSS selector'\n        \n        return info\n    \n    @staticmethod\n    def build_healing_task(\n        locator_str: str,\n        action: str,\n        url: str,\n        title: str\n    ) -> str:\n        \"\"\"Build a task description for browser-use to heal a broken locator\"\"\"\n        element_info = LocatorHealer.extract_element_info(locator_str)\n        \n        task = f\"\"\"On the current page (URL: {url}, Title: {title}), find the {element_info['description']} that we need to {action}.\n\nThe previous locator ({locator_str}) no longer works. Analyze the page and locate the correct element, then provide information about its attributes so we can create a new working locator.\"\"\"\n        \n        return task\n","size_bytes":6328}},"version":2}