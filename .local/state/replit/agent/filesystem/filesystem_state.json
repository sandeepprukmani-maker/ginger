{"file_contents":{"tests/unit/test_security.py":{"content":"\"\"\"\nUnit tests for security middleware\n\"\"\"\nimport pytest\nfrom app.middleware.security import (\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\n\n\ndef test_validate_engine_type():\n    \"\"\"Test engine type validation\"\"\"\n    # Valid engines\n    assert validate_engine_type('browser_use')[0] is True\n    assert validate_engine_type('playwright_mcp')[0] is True\n    \n    # Invalid engine\n    is_valid, error = validate_engine_type('invalid_engine')\n    assert is_valid is False\n    assert 'invalid_engine' in error.lower()\n\n\ndef test_validate_instruction():\n    \"\"\"Test instruction validation\"\"\"\n    # Valid instruction\n    assert validate_instruction('Navigate to Google')[0] is True\n    \n    # Empty instruction\n    assert validate_instruction('')[0] is False\n    assert validate_instruction('   ')[0] is False\n    \n    # Too long instruction\n    long_instruction = 'a' * 5001\n    is_valid, error = validate_instruction(long_instruction)\n    assert is_valid is False\n    assert 'too long' in error.lower()\n\n\ndef test_sanitize_error_message():\n    \"\"\"Test error message sanitization\"\"\"\n    # OpenAI error\n    error = Exception(\"OpenAI API key invalid\")\n    sanitized = sanitize_error_message(error)\n    assert 'api key' not in sanitized.lower()\n    assert 'service error' in sanitized.lower()\n    \n    # Timeout error\n    error = Exception(\"Operation timeout after 300 seconds\")\n    sanitized = sanitize_error_message(error)\n    assert 'timeout' in sanitized.lower()\n","size_bytes":1494},"app/engines/browser_use/popup_handler.py":{"content":"\"\"\"\nEnhanced Popup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows with advanced features\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Enhanced popup window handler with advanced detection and management\n    Features:\n    - Automatic popup detection and switching\n    - Configurable timeouts\n    - Detailed logging and tracking\n    - Multi-popup orchestration\n    - Popup priority rules\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext, popup_timeout: int = 10000, \n                 auto_switch: bool = True, log_verbose: bool = True):\n        \"\"\"\n        Initialize the enhanced popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n            popup_timeout: Timeout in milliseconds for popup operations (default: 10000ms)\n            auto_switch: Automatically switch to new popups (default: True)\n            log_verbose: Enable detailed logging (default: True)\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        self.popup_timeout = popup_timeout\n        self.auto_switch = auto_switch\n        self.log_verbose = log_verbose\n        \n        self.popup_history: List[Dict[str, Any]] = []\n        self.popup_count = 0\n        \n        context.on(\"page\", self._on_new_page)\n        \n        if self.log_verbose:\n            logger.info(f\"üîç Enhanced popup handler initialized (timeout: {popup_timeout}ms, auto_switch: {auto_switch})\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Enhanced event handler for new pages/windows with tracking\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        self.popup_count += 1\n        popup_info = {\n            \"popup_number\": self.popup_count,\n            \"url\": page.url or \"about:blank\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"auto_switched\": self.auto_switch\n        }\n        \n        self.popup_history.append(popup_info)\n        self.new_pages.append(page)\n        self.popup_detected = True\n        \n        if self.log_verbose:\n            logger.info(f\"üÜï Popup #{self.popup_count} detected: {popup_info['url']}\")\n            logger.info(f\"üìä Total popups opened: {self.popup_count}\")\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page with enhanced timeout handling\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages and self.auto_switch:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=self.popup_timeout)\n                \n                if self.log_verbose:\n                    logger.info(f\"‚úÖ Switched to popup window: {latest_page.url}\")\n                \n                return latest_page\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è Popup not ready within {self.popup_timeout}ms: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    async def wait_for_popup(self, timeout: Optional[int] = None) -> Optional[Page]:\n        \"\"\"\n        Wait for a popup to appear\n        \n        Args:\n            timeout: Optional custom timeout in milliseconds\n            \n        Returns:\n            New popup page or None if timeout\n        \"\"\"\n        wait_timeout = timeout or self.popup_timeout\n        start_time = datetime.now()\n        \n        while (datetime.now() - start_time).total_seconds() * 1000 < wait_timeout:\n            if self.new_pages:\n                new_page = self.new_pages[-1]\n                if self.log_verbose:\n                    logger.info(f\"‚úÖ Popup appeared: {new_page.url}\")\n                return new_page\n            await asyncio.sleep(0.1)\n        \n        logger.warning(f\"‚è±Ô∏è  No popup appeared within {wait_timeout}ms\")\n        return None\n    \n    def get_popup_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about popup handling\n        \n        Returns:\n            Dictionary with popup statistics\n        \"\"\"\n        return {\n            \"total_popups\": self.popup_count,\n            \"active_popups\": len(self.new_pages),\n            \"popup_history\": self.popup_history,\n            \"auto_switch_enabled\": self.auto_switch,\n            \"timeout_ms\": self.popup_timeout\n        }\n    \n    def reset(self):\n        \"\"\"Reset the handler state with enhanced logging\"\"\"\n        previous_count = self.popup_count\n        self.new_pages.clear()\n        self.popup_detected = False\n        \n        if self.log_verbose:\n            logger.info(f\"üîÑ Popup handler reset (processed {previous_count} popups this session)\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":5279},"app/engines/browser_use/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom app.engines.browser_use.engine import BrowserUseEngine\nfrom app.engines.browser_use.engine_optimized import OptimizedBrowserUseEngine\n\n\ndef create_engine(headless: bool = False, use_optimized: bool = True):\n    \"\"\"\n    Factory function to create a Browser-Use engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        use_optimized: Use optimized engine with advanced features (default: True)\n        \n    Returns:\n        BrowserUseEngine or OptimizedBrowserUseEngine instance\n    \"\"\"\n    if use_optimized:\n        return OptimizedBrowserUseEngine(headless=headless, enable_advanced_features=True)\n    else:\n        return BrowserUseEngine(headless=headless)\n\n\n__all__ = ['BrowserUseEngine', 'OptimizedBrowserUseEngine', 'create_engine']\n","size_bytes":876},"app/utils/timeout.py":{"content":"\"\"\"\nCross-platform timeout utility\nWorks on Windows, Linux, and macOS with proper cancellation\n\"\"\"\nimport threading\nimport logging\nfrom typing import Callable, Any, Optional\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeoutError(Exception):\n    \"\"\"Raised when operation times out\"\"\"\n    pass\n\n\ndef run_with_timeout(func: Callable, timeout_seconds: int, *args, **kwargs) -> Any:\n    \"\"\"\n    Run a function with a timeout (cross-platform)\n    \n    Note: This implementation returns promptly on timeout but cannot\n    forcefully terminate the underlying function if it's stuck. The\n    worker thread continues in the background but HTTP request returns.\n    \n    Args:\n        func: Function to execute\n        timeout_seconds: Timeout in seconds\n        *args: Positional arguments to pass to func\n        **kwargs: Keyword arguments to pass to func\n        \n    Returns:\n        Result from func\n        \n    Raises:\n        TimeoutError: If function execution exceeds timeout\n    \"\"\"\n    executor = ThreadPoolExecutor(max_workers=1)\n    future = executor.submit(func, *args, **kwargs)\n    \n    try:\n        result = future.result(timeout=timeout_seconds)\n        executor.shutdown(wait=False)\n        return result\n    except FutureTimeoutError:\n        logger.warning(f\"‚è±Ô∏è Operation timed out after {timeout_seconds} seconds\")\n        future.cancel()\n        executor.shutdown(wait=False)\n        raise TimeoutError(f\"Operation timed out after {timeout_seconds} seconds\")\n    except Exception as e:\n        logger.error(f\"‚ùå Error during timed execution: {str(e)}\")\n        executor.shutdown(wait=False)\n        raise\n","size_bytes":1714},"tests/conftest.py":{"content":"\"\"\"\nPytest configuration and fixtures for tests\n\"\"\"\nimport pytest\nimport sys\nfrom pathlib import Path\n\n# Add project root to Python path\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))\n\n\n@pytest.fixture\ndef sample_instruction():\n    \"\"\"Sample instruction for testing\"\"\"\n    return \"Navigate to example.com\"\n\n\n@pytest.fixture\ndef mock_openai_key(monkeypatch):\n    \"\"\"Mock OpenAI API key for tests\"\"\"\n    monkeypatch.setenv(\"OPENAI_API_KEY\", \"test-key-123\")\n","size_bytes":490},"app/services/__init__.py":{"content":"\"\"\"\nFlask Services Module\n\"\"\"\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n__all__ = ['EngineOrchestrator']\n","size_bytes":128},"app/engines/browser_use/retry_mechanism.py":{"content":"\"\"\"\nSmart Retry Mechanism for Browser Automation\nImplements exponential backoff and intelligent retry logic\n\"\"\"\nimport time\nimport logging\nimport asyncio\nfrom typing import Callable, Any, Optional, List\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior\"\"\"\n    \n    def __init__(self, \n                 max_retries: int = 3,\n                 initial_delay: float = 1.0,\n                 max_delay: float = 30.0,\n                 backoff_factor: float = 2.0,\n                 retry_on_exceptions: Optional[List[type]] = None):\n        \"\"\"\n        Initialize retry configuration\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            initial_delay: Initial delay in seconds before first retry\n            max_delay: Maximum delay between retries\n            backoff_factor: Multiplier for exponential backoff\n            retry_on_exceptions: List of exception types to retry on (None = all)\n        \"\"\"\n        self.max_retries = max_retries\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.backoff_factor = backoff_factor\n        self.retry_on_exceptions = retry_on_exceptions or [Exception]\n\n\nclass RetryMechanism:\n    \"\"\"\n    Smart retry handler with exponential backoff\n    Handles both sync and async operations\n    \"\"\"\n    \n    def __init__(self, config: Optional[RetryConfig] = None):\n        \"\"\"\n        Initialize retry mechanism\n        \n        Args:\n            config: Retry configuration (uses defaults if None)\n        \"\"\"\n        self.config = config or RetryConfig()\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n    \n    def retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for synchronous functions with retry logic\n        \n        Args:\n            func: Function to wrap with retry logic\n            \n        Returns:\n            Wrapped function with retry capability\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return self._execute_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def async_retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for asynchronous functions with retry logic\n        \n        Args:\n            func: Async function to wrap with retry logic\n            \n        Returns:\n            Wrapped async function with retry capability\n        \"\"\"\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await self._execute_async_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def _execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute synchronous function with retry logic\n        \n        Args:\n            func: Function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"‚úÖ Operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"‚ùå Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"‚ö†Ô∏è  Attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"üîÑ Retrying in {delay:.1f}s...\")\n                    \n                    time.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"‚ùå All {self.config.max_retries + 1} attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All retry attempts exhausted without capturing an exception\")\n    \n    async def _execute_async_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute asynchronous function with retry logic\n        \n        Args:\n            func: Async function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"‚úÖ Async operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"‚ùå Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"‚ö†Ô∏è  Async attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"üîÑ Retrying in {delay:.1f}s...\")\n                    \n                    await asyncio.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"‚ùå All {self.config.max_retries + 1} async attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All async retry attempts exhausted without capturing an exception\")\n    \n    def _should_retry(self, exception: Exception) -> bool:\n        \"\"\"\n        Determine if an exception should trigger a retry\n        \n        Args:\n            exception: The caught exception\n            \n        Returns:\n            True if should retry, False otherwise\n        \"\"\"\n        for exc_type in self.config.retry_on_exceptions:\n            if isinstance(exception, exc_type):\n                return True\n        return False\n    \n    def get_stats(self) -> dict:\n        \"\"\"\n        Get retry statistics\n        \n        Returns:\n            Dictionary with retry statistics\n        \"\"\"\n        return {\n            **self.retry_stats,\n            \"success_rate\": (\n                (self.retry_stats[\"total_attempts\"] - self.retry_stats[\"failed_operations\"]) \n                / max(self.retry_stats[\"total_attempts\"], 1) * 100\n            ),\n            \"config\": {\n                \"max_retries\": self.config.max_retries,\n                \"initial_delay\": self.config.initial_delay,\n                \"max_delay\": self.config.max_delay,\n                \"backoff_factor\": self.config.backoff_factor\n            }\n        }\n    \n    def reset_stats(self):\n        \"\"\"Reset retry statistics\"\"\"\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n        logger.info(\"üìä Retry statistics reset\")\n\n\ndef create_retry_mechanism(max_retries: int = 3, \n                          initial_delay: float = 1.0,\n                          backoff_factor: float = 2.0) -> RetryMechanism:\n    \"\"\"\n    Factory function to create a retry mechanism with custom settings\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for exponential backoff\n        \n    Returns:\n        Configured RetryMechanism instance\n    \"\"\"\n    config = RetryConfig(\n        max_retries=max_retries,\n        initial_delay=initial_delay,\n        backoff_factor=backoff_factor\n    )\n    return RetryMechanism(config)\n","size_bytes":9108},"app/engines/playwright_mcp/config/__init__.py":{"content":"\"\"\"\nPlaywright MCP Configuration Module\n\"\"\"\n","size_bytes":44},"app/engines/browser_use/state_manager.py":{"content":"\"\"\"\nState Management for Complex Multi-Step Workflows\nPreserves context and state across automation steps\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass WorkflowState:\n    \"\"\"\n    Manages state for complex multi-step automation workflows\n    Preserves context, variables, and execution history\n    \"\"\"\n    \n    def __init__(self, workflow_id: Optional[str] = None, persist_to_disk: bool = False):\n        \"\"\"\n        Initialize workflow state manager\n        \n        Args:\n            workflow_id: Unique identifier for this workflow\n            persist_to_disk: Save state to disk for recovery\n        \"\"\"\n        self.workflow_id = workflow_id or f\"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.persist_to_disk = persist_to_disk\n        \n        self.state: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.execution_history: List[Dict[str, Any]] = []\n        self.checkpoints: List[Dict[str, Any]] = []\n        \n        self.metadata = {\n            \"workflow_id\": self.workflow_id,\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"step_count\": 0\n        }\n        \n        if self.persist_to_disk:\n            self.state_dir = Path(\"workflow_states\")\n            self.state_dir.mkdir(exist_ok=True)\n            self.state_file = self.state_dir / f\"{self.workflow_id}.json\"\n        \n        logger.info(f\"üîÑ Workflow state initialized: {self.workflow_id}\")\n    \n    def set_variable(self, key: str, value: Any):\n        \"\"\"\n        Set a workflow variable\n        \n        Args:\n            key: Variable name\n            value: Variable value\n        \"\"\"\n        self.variables[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"üìù Variable set: {key} = {value}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_variable(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a workflow variable\n        \n        Args:\n            key: Variable name\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Variable value or default\n        \"\"\"\n        return self.variables.get(key, default)\n    \n    def set_state(self, key: str, value: Any):\n        \"\"\"\n        Set a state value\n        \n        Args:\n            key: State key\n            value: State value\n        \"\"\"\n        self.state[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"üíæ State set: {key}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_state(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a state value\n        \n        Args:\n            key: State key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            State value or default\n        \"\"\"\n        return self.state.get(key, default)\n    \n    def add_step(self, step_name: str, step_data: Dict[str, Any], success: bool = True):\n        \"\"\"\n        Record a workflow step\n        \n        Args:\n            step_name: Name of the step\n            step_data: Data associated with the step\n            success: Whether the step succeeded\n        \"\"\"\n        step_record = {\n            \"step_number\": self.metadata[\"step_count\"] + 1,\n            \"step_name\": step_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"success\": success,\n            \"data\": step_data\n        }\n        \n        self.execution_history.append(step_record)\n        self.metadata[\"step_count\"] += 1\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"‚úÖ Step {self.metadata['step_count']} recorded: {step_name} (success: {success})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def create_checkpoint(self, checkpoint_name: str):\n        \"\"\"\n        Create a checkpoint of current state\n        \n        Args:\n            checkpoint_name: Name for this checkpoint\n        \"\"\"\n        checkpoint = {\n            \"name\": checkpoint_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"state\": self.state.copy(),\n            \"variables\": self.variables.copy(),\n            \"step_count\": self.metadata[\"step_count\"]\n        }\n        \n        self.checkpoints.append(checkpoint)\n        logger.info(f\"üîñ Checkpoint created: {checkpoint_name} (at step {self.metadata['step_count']})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def restore_checkpoint(self, checkpoint_name: str) -> bool:\n        \"\"\"\n        Restore state from a checkpoint\n        \n        Args:\n            checkpoint_name: Name of checkpoint to restore\n            \n        Returns:\n            True if restored successfully, False if checkpoint not found\n        \"\"\"\n        for checkpoint in reversed(self.checkpoints):\n            if checkpoint[\"name\"] == checkpoint_name:\n                self.state = checkpoint[\"state\"].copy()\n                self.variables = checkpoint[\"variables\"].copy()\n                \n                logger.info(f\"‚ôªÔ∏è  Restored checkpoint: {checkpoint_name} (from step {checkpoint['step_count']})\")\n                \n                if self.persist_to_disk:\n                    self._save_to_disk()\n                \n                return True\n        \n        logger.warning(f\"‚ö†Ô∏è  Checkpoint not found: {checkpoint_name}\")\n        return False\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of the workflow state\n        \n        Returns:\n            Dictionary with state summary\n        \"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"metadata\": self.metadata,\n            \"total_steps\": self.metadata[\"step_count\"],\n            \"total_checkpoints\": len(self.checkpoints),\n            \"variable_count\": len(self.variables),\n            \"state_keys\": list(self.state.keys()),\n            \"success_rate\": self._calculate_success_rate()\n        }\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate success rate of executed steps\"\"\"\n        if not self.execution_history:\n            return 100.0\n        \n        successful = sum(1 for step in self.execution_history if step[\"success\"])\n        return (successful / len(self.execution_history)) * 100\n    \n    def _save_to_disk(self):\n        \"\"\"Save state to disk\"\"\"\n        try:\n            state_data = {\n                \"workflow_id\": self.workflow_id,\n                \"metadata\": self.metadata,\n                \"state\": self.state,\n                \"variables\": self.variables,\n                \"execution_history\": self.execution_history,\n                \"checkpoints\": self.checkpoints\n            }\n            \n            with open(self.state_file, 'w') as f:\n                json.dump(state_data, f, indent=2)\n            \n            logger.debug(f\"üíæ State saved to: {self.state_file}\")\n        except Exception as e:\n            logger.error(f\"‚ùå Failed to save state: {str(e)}\")\n    \n    @classmethod\n    def load_from_disk(cls, workflow_id: str) -> Optional['WorkflowState']:\n        \"\"\"\n        Load workflow state from disk\n        \n        Args:\n            workflow_id: Workflow ID to load\n            \n        Returns:\n            WorkflowState instance or None if not found\n        \"\"\"\n        state_file = Path(\"workflow_states\") / f\"{workflow_id}.json\"\n        \n        if not state_file.exists():\n            logger.warning(f\"‚ö†Ô∏è  Workflow state not found: {workflow_id}\")\n            return None\n        \n        try:\n            with open(state_file, 'r') as f:\n                state_data = json.load(f)\n            \n            instance = cls(workflow_id=workflow_id, persist_to_disk=True)\n            instance.metadata = state_data[\"metadata\"]\n            instance.state = state_data[\"state\"]\n            instance.variables = state_data[\"variables\"]\n            instance.execution_history = state_data[\"execution_history\"]\n            instance.checkpoints = state_data[\"checkpoints\"]\n            \n            logger.info(f\"üìÇ Workflow state loaded: {workflow_id}\")\n            return instance\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Failed to load state: {str(e)}\")\n            return None\n    \n    def reset(self):\n        \"\"\"Reset workflow state\"\"\"\n        self.state.clear()\n        self.variables.clear()\n        self.execution_history.clear()\n        self.checkpoints.clear()\n        self.metadata[\"step_count\"] = 0\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"üîÑ Workflow state reset: {self.workflow_id}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n","size_bytes":9020},"app/engines/browser_use/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"app/engines/playwright_mcp/agent/__init__.py":{"content":"\"\"\"\nPlaywright MCP Agent Module\n\"\"\"\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\n\n__all__ = ['BrowserAgent']\n","size_bytes":141},"app/__init__.py":{"content":"\"\"\"\nFlask Application Factory\n\"\"\"\nimport os\nimport logging\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.routes.api import create_api_routes\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\ndef create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \n    Returns:\n        Configured Flask app instance\n    \"\"\"\n    # Configure detailed logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S',\n        handlers=[\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n    \n    # Set browser-use and agent loggers to INFO to see detailed steps\n    logging.getLogger('browser_use').setLevel(logging.INFO)\n    logging.getLogger('Agent').setLevel(logging.INFO)\n    logging.getLogger('service').setLevel(logging.INFO)\n    logging.getLogger('tools').setLevel(logging.INFO)\n    logging.getLogger('BrowserSession').setLevel(logging.INFO)\n    \n    logger = logging.getLogger(__name__)\n    logger.info(\"üöÄ Starting AI Browser Automation application\")\n    \n    app = Flask(__name__)\n    app.config['SECRET_KEY'] = os.environ.get(\"SESSION_SECRET\")\n    \n    allowed_origins = os.environ.get('CORS_ALLOWED_ORIGINS', '*').split(',')\n    CORS(app, \n         resources={r\"/api/*\": {\"origins\": allowed_origins}},\n         methods=[\"GET\", \"POST\", \"OPTIONS\"],\n         allow_headers=[\"Content-Type\", \"X-API-Key\"],\n         supports_credentials=True)\n    \n    logger.info(f\"üîí CORS configured with origins: {allowed_origins}\")\n    logger.info(\"üì¶ Initializing Engine Orchestrator\")\n    orchestrator = EngineOrchestrator()\n    \n    logger.info(\"üîó Registering API routes\")\n    api_routes = create_api_routes(orchestrator)\n    app.register_blueprint(api_routes)\n    \n    # Add cache control headers to prevent browser caching issues\n    @app.after_request\n    def add_cache_control_headers(response):\n        \"\"\"Add Cache-Control headers to all responses to prevent caching\"\"\"\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, public, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        return response\n    \n    logger.info(\"‚úÖ Application initialization complete\")\n    \n    return app\n","size_bytes":2572},"tests/unit/__init__.py":{"content":"","size_bytes":0},"integrations/playwright_mcp_node/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"app/engines/browser_use/data_extractor.py":{"content":"\"\"\"\nAdvanced Data Extraction Capabilities\nStructured data scraping, table extraction, and content parsing\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass DataExtractor:\n    \"\"\"\n    Advanced data extraction for web automation\n    Handles tables, lists, structured data, and custom selectors\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize data extractor\"\"\"\n        logger.info(\"üìä Data extractor initialized\")\n    \n    async def extract_table(self, page, selector: str = \"table\", \n                          include_headers: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Extract data from HTML table\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for table\n            include_headers: Extract header row\n            \n        Returns:\n            Dictionary with table data\n        \"\"\"\n        try:\n            table_data = await page.evaluate(f\"\"\"(selector) => {{\n                const table = document.querySelector(selector);\n                if (!table) return null;\n                \n                const rows = Array.from(table.querySelectorAll('tr'));\n                const data = [];\n                \n                rows.forEach((row, index) => {{\n                    const cells = Array.from(row.querySelectorAll('td, th'));\n                    const rowData = cells.map(cell => cell.textContent.trim());\n                    if (rowData.length > 0) {{\n                        data.push(rowData);\n                    }}\n                }});\n                \n                return data;\n            }}\"\"\", selector)\n            \n            if not table_data:\n                return {\"success\": False, \"error\": \"Table not found\"}\n            \n            result = {\n                \"success\": True,\n                \"rows\": table_data,\n                \"row_count\": len(table_data),\n                \"column_count\": len(table_data[0]) if table_data else 0\n            }\n            \n            if include_headers and table_data:\n                result[\"headers\"] = table_data[0]\n                result[\"data\"] = table_data[1:]\n            \n            logger.info(f\"üìä Table extracted: {result['row_count']} rows, {result['column_count']} columns\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Table extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_list(self, page, selector: str, item_selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract items from a list\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for list container\n            item_selector: Optional selector for individual items\n            \n        Returns:\n            Dictionary with list items\n        \"\"\"\n        try:\n            if item_selector:\n                query = f\"{selector} {item_selector}\"\n            else:\n                query = f\"{selector} li\"\n            \n            items = await page.evaluate(f\"\"\"(query) => {{\n                const elements = document.querySelectorAll(query);\n                return Array.from(elements).map(el => el.textContent.trim());\n            }}\"\"\", query)\n            \n            logger.info(f\"üìã List extracted: {len(items)} items\")\n            \n            return {\n                \"success\": True,\n                \"items\": items,\n                \"item_count\": len(items)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå List extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_structured_data(self, page, schema: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data using a schema\n        \n        Args:\n            page: Playwright page object\n            schema: Dictionary mapping field names to CSS selectors\n            \n        Returns:\n            Dictionary with extracted data\n        \"\"\"\n        try:\n            extracted_data = {}\n            \n            for field_name, selector in schema.items():\n                try:\n                    value = await page.evaluate(f\"\"\"(selector) => {{\n                        const element = document.querySelector(selector);\n                        return element ? element.textContent.trim() : null;\n                    }}\"\"\", selector)\n                    \n                    extracted_data[field_name] = value\n                except:\n                    extracted_data[field_name] = None\n            \n            logger.info(f\"üì¶ Structured data extracted: {len(extracted_data)} fields\")\n            \n            return {\n                \"success\": True,\n                \"data\": extracted_data,\n                \"field_count\": len(extracted_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Structured data extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_all_links(self, page, base_url: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract all links from page\n        \n        Args:\n            page: Playwright page object\n            base_url: Optional base URL for relative links\n            \n        Returns:\n            Dictionary with links\n        \"\"\"\n        try:\n            links = await page.evaluate(\"\"\"() => {\n                const anchors = document.querySelectorAll('a[href]');\n                return Array.from(anchors).map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    rel_href: a.getAttribute('href')\n                }));\n            }\"\"\")\n            \n            logger.info(f\"üîó Links extracted: {len(links)} links\")\n            \n            return {\n                \"success\": True,\n                \"links\": links,\n                \"link_count\": len(links),\n                \"page_url\": page.url\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Link extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_images(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract all images from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with image data\n        \"\"\"\n        try:\n            images = await page.evaluate(\"\"\"() => {\n                const imgs = document.querySelectorAll('img');\n                return Array.from(imgs).map(img => ({\n                    src: img.src,\n                    alt: img.alt,\n                    width: img.width,\n                    height: img.height\n                }));\n            }\"\"\")\n            \n            logger.info(f\"üñºÔ∏è  Images extracted: {len(images)} images\")\n            \n            return {\n                \"success\": True,\n                \"images\": images,\n                \"image_count\": len(images)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Image extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_metadata(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract page metadata (title, description, etc.)\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with metadata\n        \"\"\"\n        try:\n            metadata = await page.evaluate(\"\"\"() => {\n                const getMeta = (name) => {\n                    const element = document.querySelector(`meta[name=\"${name}\"], meta[property=\"${name}\"]`);\n                    return element ? element.content : null;\n                };\n                \n                return {\n                    title: document.title,\n                    description: getMeta('description') || getMeta('og:description'),\n                    keywords: getMeta('keywords'),\n                    author: getMeta('author'),\n                    og_title: getMeta('og:title'),\n                    og_image: getMeta('og:image'),\n                    canonical: document.querySelector('link[rel=\"canonical\"]')?.href\n                };\n            }\"\"\")\n            \n            metadata[\"url\"] = page.url\n            \n            logger.info(f\"‚ÑπÔ∏è  Metadata extracted from: {page.url}\")\n            \n            return {\n                \"success\": True,\n                \"metadata\": metadata\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Metadata extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_text_content(self, page, selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract text content from page or specific element\n        \n        Args:\n            page: Playwright page object\n            selector: Optional CSS selector for specific element\n            \n        Returns:\n            Dictionary with text content\n        \"\"\"\n        try:\n            if selector:\n                text = await page.evaluate(f\"\"\"(selector) => {{\n                    const element = document.querySelector(selector);\n                    return element ? element.textContent.trim() : null;\n                }}\"\"\", selector)\n            else:\n                text = await page.evaluate(\"\"\"() => {\n                    return document.body.textContent.trim();\n                }\"\"\")\n            \n            logger.info(f\"üìù Text content extracted: {len(text)} characters\")\n            \n            return {\n                \"success\": True,\n                \"text\": text,\n                \"length\": len(text) if text else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Text extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n","size_bytes":10037},"app/engines/browser_use/engine.py":{"content":"\"\"\"\nBrowser-Use Engine\nAI-powered browser automation using browser-use library\n\nThread Safety Notes:\n- This engine creates a fresh Browser instance per request\n- Each request runs on its own event loop to ensure thread safety\n- Browser instances are NOT cached to prevent asyncio loop affinity issues\n- Memory is cleaned up after each request via finally block\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List\nfrom dotenv import load_dotenv\nfrom browser_use import Agent, Browser\nfrom browser_use.llm import ChatOpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BrowserUseEngine:\n    \"\"\"\n    Browser automation engine using browser-use library\n    \n    Thread Safety: This engine is designed for Flask's multi-threaded environment.\n    Each request creates its own event loop and browser instance, which are\n    properly cleaned up after execution.\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        \n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        # Browser performance settings - using reliable defaults\n        self.minimum_wait_page_load_time = float(config.get('browser_performance', 'minimum_wait_page_load_time', fallback='1.0'))\n        self.wait_for_network_idle_page_load_time = float(config.get('browser_performance', 'wait_for_network_idle_page_load_time', fallback='1.5'))\n        self.wait_between_actions = float(config.get('browser_performance', 'wait_between_actions', fallback='1.0'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n    \n    async def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        try:\n            logger.info(\"ü§ñ Initializing Browser-Use Agent\")\n            logger.info(f\"üìã Task: {instruction}\")\n            logger.info(f\"üî¢ Max steps: {self.max_steps}\")\n            \n            # System instructions optimized for efficiency while maintaining safety\n            system_instructions = f\"\"\"\nTASK: \"{instruction}\"\n\nCORE RULES:\n1. Execute ONLY explicitly stated actions - nothing more\n2. After completing all explicit steps ‚Üí use done() immediately\n3. Verify each action succeeded before proceeding\n4. Keep thinking concise but thorough\n\nPOPUP/NEW WINDOW HANDLING:\n- After clicking button that opens popup ‚Üí wait 3s for window switch\n- Verify popup content loaded correctly\n- If content not ready ‚Üí wait 2s more ‚Üí retry\n- Continue with explicit instructions in the new window\n\nPAGE LOADING & ERRORS:\n- If element not found ‚Üí page still loading ‚Üí wait 2s ‚Üí retry with fresh page state\n- Verify critical actions (form submissions, clicks) succeeded\n- Do NOT assume success without verification\n\nSECURITY:\n- Never navigate to unintended domains\n- Confirm sensitive actions before executing\n            \"\"\"\n            \n            logger.info(\"‚öôÔ∏è  Configuring agent with literal execution instructions\")\n            \n            # Create browser instance with optimized performance settings\n            browser = Browser(\n                headless=self.headless,\n                disable_security=False,  # Keep security enabled for production\n                minimum_wait_page_load_time=self.minimum_wait_page_load_time,\n                wait_for_network_idle_page_load_time=self.wait_for_network_idle_page_load_time,\n                wait_between_actions=self.wait_between_actions\n            )\n            logger.info(f\"üåê Browser initialized (headless={self.headless})\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                browser=browser,  # Pass browser for proper popup/multi-window handling\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"‚ñ∂Ô∏è  Starting agent execution...\")\n            history = await agent.run(max_steps=self.max_steps)\n            logger.info(f\"‚èπÔ∏è  Agent execution completed\")\n            \n            logger.info(\"üìä Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from app.engines.browser_use.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"üé≠ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            # Check if task actually succeeded - if 0 steps executed, it likely failed\n            if len(steps) == 0:\n                logger.error(f\"‚ùå Task failed - no steps were executed successfully\")\n                return {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps. This usually means the browser could not launch.\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            \n            logger.info(f\"‚úÖ Task completed successfully!\")\n            logger.info(f\"üìà Total steps executed: {len(steps)}\")\n            if final_result:\n                logger.info(f\"üéØ Final result: {str(final_result)[:200]}\")\n            \n            result = {\n                \"success\": True,\n                \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                \"steps\": steps,\n                \"iterations\": len(steps),\n                \"final_result\": final_result\n            }\n            \n            # Add Playwright code if generated\n            if playwright_code:\n                result[\"playwright_code\"] = playwright_code\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Browser-Use execution failed: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        Each call creates a new event loop to ensure thread safety\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n","size_bytes":9164},"app/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\nconst engineSelect = document.getElementById('engine-select');\nconst headlessToggle = document.getElementById('headless-toggle');\nconst statusBadge = document.getElementById('status-badge');\nconst currentEngineDisplay = document.getElementById('current-engine');\nconst currentModeDisplay = document.getElementById('current-mode');\n\n// Update footer display when engine or mode changes\nfunction updateFooterDisplay() {\n    const engineText = engineSelect.value === 'browser_use' ? 'Browser-Use' : 'Playwright MCP';\n    const modeText = headlessToggle.checked ? 'Headless' : 'Headful';\n    \n    currentEngineDisplay.textContent = engineText;\n    currentModeDisplay.textContent = modeText;\n}\n\n// Initialize\nengineSelect.addEventListener('change', updateFooterDisplay);\nheadlessToggle.addEventListener('change', updateFooterDisplay);\nupdateFooterDisplay();\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    const engine = engineSelect.value;\n    const headless = headlessToggle.checked;\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    showStatusBadge('running', 'Processing...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ \n                instruction,\n                engine,\n                headless\n            }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `‚úÖ Completed in ${data.iterations} iteration(s) using ${data.engine}`);\n            showStatusBadge('success', 'Completed');\n            displayResults(data);\n        } else {\n            showStatus('error', `‚ùå Error: ${data.error || 'Unknown error'}`);\n            showStatusBadge('error', 'Failed');\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `‚ùå Failed to execute: ${error.message}`);\n        showStatusBadge('error', 'Failed');\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history and browser state.')) {\n        return;\n    }\n    \n    const engine = engineSelect.value;\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ engine }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', '‚úÖ Agent reset successfully');\n            showStatusBadge('', '');\n            resultsDiv.innerHTML = '<div class=\"empty-state\"><div class=\"empty-icon\">üöÄ</div><p>Enter an instruction and click Execute to begin automation</p></div>';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `‚ùå Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `‚ùå Failed to reset: ${error.message}`);\n    }\n});\n\n// Example buttons\ndocument.querySelectorAll('.example-btn').forEach(btn => {\n    btn.addEventListener('click', () => {\n        instructionInput.value = btn.dataset.instruction;\n        instructionInput.focus();\n    });\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction showStatusBadge(type, text) {\n    statusBadge.className = `status-badge ${type}`;\n    statusBadge.textContent = text;\n    statusBadge.style.display = text ? 'block' : 'none';\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.style.cssText = 'background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 16px; border-radius: 8px; margin-top: 16px; font-weight: 500; color: #0c4a6e;';\n        messageEl.innerHTML = `<strong>Final Result:</strong> ${data.message}`;\n        resultsDiv.appendChild(messageEl);\n    }\n    \n    // Display engine info\n    const engineInfo = document.createElement('div');\n    engineInfo.style.cssText = 'margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; font-size: 0.9rem; color: #666;';\n    engineInfo.innerHTML = `<strong>Engine:</strong> ${data.engine || 'unknown'} | <strong>Mode:</strong> ${data.headless ? 'Headless' : 'Headful'}`;\n    resultsDiv.appendChild(engineInfo);\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? '‚úì Success' : '‚úó Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `üîß Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.textContent = `‚ùå Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'üìÑ View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            console.log('Application is healthy and ready');\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":8901},"integrations/playwright_mcp_node/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"app/engines/playwright_mcp/agent/conversation_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom pathlib import Path\nfrom typing import List, Dict, Any\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,\n                    tools=tools,\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name\n                        tool_args = json.loads(tool_call.function.arguments)\n                        \n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    final_response = message.content or \"Task completed\"\n                    \n                    # Generate Playwright code from MCP steps\n                    playwright_code = None\n                    try:\n                        from app.engines.playwright_mcp.mcp_code_generator import generate_playwright_code_from_mcp_steps\n                        playwright_code = generate_playwright_code_from_mcp_steps(\n                            steps,\n                            task_description=instruction\n                        )\n                    except Exception as e:\n                        # Code generation is optional, don't fail the task\n                        pass\n                    \n                    result = {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n                    if playwright_code:\n                        result[\"playwright_code\"] = playwright_code\n                    \n                    return result\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        # Generate Playwright code even if max iterations reached\n        playwright_code = None\n        try:\n            from app.engines.playwright_mcp.mcp_code_generator import generate_playwright_code_from_mcp_steps\n            playwright_code = generate_playwright_code_from_mcp_steps(\n                steps,\n                task_description=instruction\n            )\n        except Exception:\n            pass\n        \n        result = {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n        \n        if playwright_code:\n            result[\"playwright_code\"] = playwright_code\n        \n        return result\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":7466},"integrations/playwright_mcp_node/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"tests/integration/__init__.py":{"content":"","size_bytes":0},"tests/integration/test_api.py":{"content":"\"\"\"\nIntegration tests for API endpoints\n\"\"\"\nimport pytest\n\n\ndef test_health_endpoint():\n    \"\"\"Test the health check endpoint\"\"\"\n    from app import create_app\n    \n    app = create_app()\n    client = app.test_client()\n    \n    response = client.get('/health')\n    assert response.status_code == 200\n    \n    data = response.get_json()\n    assert data['status'] == 'healthy'\n    assert 'browser_use' in data['engines']\n    assert 'playwright_mcp' in data['engines']\n\n\ndef test_execute_endpoint_validation():\n    \"\"\"Test execute endpoint input validation\"\"\"\n    from app import create_app\n    \n    app = create_app()\n    client = app.test_client()\n    \n    # Empty instruction should fail\n    response = client.post('/api/execute', json={'instruction': ''})\n    assert response.status_code == 400\n    \n    # Invalid engine should fail\n    response = client.post('/api/execute', json={\n        'instruction': 'test',\n        'engine': 'invalid_engine'\n    })\n    assert response.status_code == 400\n","size_bytes":996},"app/engines/playwright_mcp/client/__init__.py":{"content":"\"\"\"\nPlaywright MCP Client Module\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\n\n__all__ = ['MCPStdioClient']\n","size_bytes":141},"app/middleware/security.py":{"content":"\"\"\"\nSecurity Middleware\nAuthentication, rate limiting, and security utilities\n\"\"\"\nimport os\nimport time\nimport logging\nfrom functools import wraps\nfrom flask import request, jsonify\nfrom typing import Dict, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self, max_requests: int = 10, window_seconds: int = 60):\n        \"\"\"\n        Initialize rate limiter\n        \n        Args:\n            max_requests: Maximum requests allowed in the time window\n            window_seconds: Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests: Dict[str, list] = {}\n    \n    def is_allowed(self, client_id: str) -> Tuple[bool, Optional[int]]:\n        \"\"\"\n        Check if request is allowed for client\n        \n        Args:\n            client_id: Unique identifier for the client\n            \n        Returns:\n            Tuple of (is_allowed, retry_after_seconds)\n        \"\"\"\n        now = time.time()\n        \n        if client_id not in self.requests:\n            self.requests[client_id] = []\n        \n        requests = self.requests[client_id]\n        requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n        \n        if len(requests) >= self.max_requests:\n            oldest_request = min(requests)\n            retry_after = int(self.window_seconds - (now - oldest_request)) + 1\n            return False, retry_after\n        \n        requests.append(now)\n        self.requests[client_id] = requests\n        \n        self._cleanup_old_entries(now)\n        \n        return True, None\n    \n    def _cleanup_old_entries(self, now: float):\n        \"\"\"Clean up old entries to prevent memory bloat\"\"\"\n        clients_to_remove = []\n        for client_id, requests in self.requests.items():\n            active_requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n            if not active_requests:\n                clients_to_remove.append(client_id)\n            else:\n                self.requests[client_id] = active_requests\n        \n        for client_id in clients_to_remove:\n            del self.requests[client_id]\n\n\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n\n\ndef require_api_key(f):\n    \"\"\"\n    Decorator to require API key authentication\n    \n    Checks for API key in:\n    1. X-API-Key header\n    2. api_key query parameter\n    \n    Set API_KEY environment variable to enable authentication.\n    If API_KEY is not set, authentication is disabled (development mode).\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        expected_api_key = os.environ.get('API_KEY')\n        \n        if not expected_api_key:\n            logger.warning(\"‚ö†Ô∏è  API_KEY not set - authentication disabled (development mode)\")\n            return f(*args, **kwargs)\n        \n        provided_api_key = request.headers.get('X-API-Key') or request.args.get('api_key')\n        \n        if not provided_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - no API key provided\")\n            return jsonify({\n                'success': False,\n                'error': 'Authentication required',\n                'message': 'Please provide an API key via X-API-Key header or api_key parameter'\n            }), 401\n        \n        if provided_api_key != expected_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - invalid API key\")\n            return jsonify({\n                'success': False,\n                'error': 'Invalid API key'\n            }), 403\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef rate_limit(f):\n    \"\"\"\n    Decorator to apply rate limiting\n    \n    Uses IP address as client identifier\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        client_id = request.remote_addr or 'unknown'\n        \n        allowed, retry_after = rate_limiter.is_allowed(client_id)\n        \n        if not allowed:\n            logger.warning(f\"‚ö†Ô∏è  Rate limit exceeded for {client_id}\")\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded',\n                'message': f'Too many requests. Please try again in {retry_after} seconds.',\n                'retry_after': retry_after\n            }), 429\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef validate_engine_type(engine_type: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate engine type parameter\n    \n    Args:\n        engine_type: Engine type to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    valid_engines = ['browser_use', 'playwright_mcp']\n    \n    if engine_type not in valid_engines:\n        return False, f\"Invalid engine type '{engine_type}'. Must be one of: {', '.join(valid_engines)}\"\n    \n    return True, None\n\n\ndef validate_instruction(instruction: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate instruction parameter\n    \n    Args:\n        instruction: Instruction to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not instruction or not instruction.strip():\n        return False, \"Instruction cannot be empty\"\n    \n    if len(instruction) > 5000:\n        return False, \"Instruction is too long (maximum 5000 characters)\"\n    \n    return True, None\n\n\ndef sanitize_error_message(error: Exception) -> str:\n    \"\"\"\n    Convert internal exception to user-safe error message\n    \n    Args:\n        error: Exception to sanitize\n        \n    Returns:\n        User-safe error message\n    \"\"\"\n    error_str = str(error).lower()\n    \n    if 'openai' in error_str or 'api' in error_str:\n        return \"AI service error. Please try again later.\"\n    \n    if 'browser' in error_str or 'playwright' in error_str:\n        return \"Browser automation error. Please try again.\"\n    \n    if 'timeout' in error_str:\n        return \"Operation timed out. The task took too long to complete.\"\n    \n    if 'permission' in error_str or 'denied' in error_str:\n        return \"Permission denied. Please check your access rights.\"\n    \n    return \"An unexpected error occurred. Please try again.\"\n","size_bytes":6336},"app/engines/browser_use/performance_monitor.py":{"content":"\"\"\"\nPerformance Monitoring and Metrics Tracking\nTracks automation performance, timing, and resource usage\n\"\"\"\nimport time\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\nclass PerformanceMonitor:\n    \"\"\"\n    Monitor and track performance metrics for browser automation\n    Tracks timing, success rates, and resource usage\n    \"\"\"\n    \n    def __init__(self, track_detailed_metrics: bool = True):\n        \"\"\"\n        Initialize performance monitor\n        \n        Args:\n            track_detailed_metrics: Track detailed per-operation metrics\n        \"\"\"\n        self.track_detailed_metrics = track_detailed_metrics\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        \n        self.operation_metrics: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            \"count\": 0,\n            \"success_count\": 0,\n            \"fail_count\": 0,\n            \"total_duration\": 0.0,\n            \"min_duration\": float('inf'),\n            \"max_duration\": 0.0\n        })\n        \n        self.timing_stack: List[Dict[str, Any]] = []\n        \n        logger.info(\"üìä Performance monitor initialized\")\n    \n    def start_operation(self, operation_name: str) -> str:\n        \"\"\"\n        Start tracking an operation\n        \n        Args:\n            operation_name: Name of the operation\n            \n        Returns:\n            Operation ID for stopping later\n        \"\"\"\n        operation_id = f\"{operation_name}_{len(self.timing_stack)}\"\n        \n        timing_info = {\n            \"operation_id\": operation_id,\n            \"operation_name\": operation_name,\n            \"start_time\": time.time(),\n            \"start_timestamp\": datetime.now().isoformat()\n        }\n        \n        self.timing_stack.append(timing_info)\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"‚è±Ô∏è  Started: {operation_name}\")\n        \n        return operation_id\n    \n    def end_operation(self, operation_id: str, success: bool = True, metadata: Optional[Dict] = None):\n        \"\"\"\n        End tracking an operation\n        \n        Args:\n            operation_id: ID returned from start_operation\n            success: Whether operation succeeded\n            metadata: Optional metadata about the operation\n        \"\"\"\n        if not self.timing_stack:\n            logger.warning(\"‚ö†Ô∏è  No operation to end\")\n            return\n        \n        timing_info = self.timing_stack.pop()\n        \n        if timing_info[\"operation_id\"] != operation_id:\n            logger.warning(f\"‚ö†Ô∏è  Operation ID mismatch: expected {timing_info['operation_id']}, got {operation_id}\")\n        \n        duration = time.time() - timing_info[\"start_time\"]\n        operation_name = timing_info[\"operation_name\"]\n        \n        self.metrics[\"total_operations\"] += 1\n        self.metrics[\"total_duration\"] += duration\n        \n        if success:\n            self.metrics[\"successful_operations\"] += 1\n        else:\n            self.metrics[\"failed_operations\"] += 1\n        \n        op_metrics = self.operation_metrics[operation_name]\n        op_metrics[\"count\"] += 1\n        op_metrics[\"total_duration\"] += duration\n        op_metrics[\"min_duration\"] = min(op_metrics[\"min_duration\"], duration)\n        op_metrics[\"max_duration\"] = max(op_metrics[\"max_duration\"], duration)\n        \n        if success:\n            op_metrics[\"success_count\"] += 1\n        else:\n            op_metrics[\"fail_count\"] += 1\n        \n        if self.track_detailed_metrics:\n            status = \"‚úÖ\" if success else \"‚ùå\"\n            logger.info(f\"{status} {operation_name} completed in {duration:.2f}s\")\n    \n    def record_metric(self, metric_name: str, value: Any):\n        \"\"\"\n        Record a custom metric\n        \n        Args:\n            metric_name: Name of the metric\n            value: Metric value\n        \"\"\"\n        if \"custom_metrics\" not in self.metrics:\n            self.metrics[\"custom_metrics\"] = {}\n        \n        self.metrics[\"custom_metrics\"][metric_name] = value\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"üìä Metric recorded: {metric_name} = {value}\")\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get performance summary\n        \n        Returns:\n            Dictionary with performance metrics\n        \"\"\"\n        total_ops = self.metrics[\"total_operations\"]\n        \n        summary = {\n            \"overview\": {\n                \"total_operations\": total_ops,\n                \"successful_operations\": self.metrics[\"successful_operations\"],\n                \"failed_operations\": self.metrics[\"failed_operations\"],\n                \"success_rate\": (self.metrics[\"successful_operations\"] / max(total_ops, 1)) * 100,\n                \"total_duration\": self.metrics[\"total_duration\"],\n                \"average_duration\": self.metrics[\"total_duration\"] / max(total_ops, 1),\n                \"start_time\": self.metrics[\"start_time\"],\n                \"current_time\": datetime.now().isoformat()\n            },\n            \"operation_breakdown\": {}\n        }\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            count = op_metrics[\"count\"]\n            summary[\"operation_breakdown\"][op_name] = {\n                \"count\": count,\n                \"success_count\": op_metrics[\"success_count\"],\n                \"fail_count\": op_metrics[\"fail_count\"],\n                \"success_rate\": (op_metrics[\"success_count\"] / max(count, 1)) * 100,\n                \"total_duration\": op_metrics[\"total_duration\"],\n                \"average_duration\": op_metrics[\"total_duration\"] / max(count, 1),\n                \"min_duration\": op_metrics[\"min_duration\"] if op_metrics[\"min_duration\"] != float('inf') else 0,\n                \"max_duration\": op_metrics[\"max_duration\"]\n            }\n        \n        if \"custom_metrics\" in self.metrics:\n            summary[\"custom_metrics\"] = self.metrics[\"custom_metrics\"]\n        \n        return summary\n    \n    def get_top_slowest_operations(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get the slowest operations\n        \n        Args:\n            limit: Number of operations to return\n            \n        Returns:\n            List of slowest operations with metrics\n        \"\"\"\n        operations = []\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            if op_metrics[\"count\"] > 0:\n                avg_duration = op_metrics[\"total_duration\"] / op_metrics[\"count\"]\n                operations.append({\n                    \"operation\": op_name,\n                    \"average_duration\": avg_duration,\n                    \"max_duration\": op_metrics[\"max_duration\"],\n                    \"count\": op_metrics[\"count\"]\n                })\n        \n        operations.sort(key=lambda x: x[\"average_duration\"], reverse=True)\n        return operations[:limit]\n    \n    def reset(self):\n        \"\"\"Reset all metrics\"\"\"\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        self.operation_metrics.clear()\n        self.timing_stack.clear()\n        \n        logger.info(\"üîÑ Performance metrics reset\")\n    \n    def log_summary(self):\n        \"\"\"Log a formatted summary of metrics\"\"\"\n        summary = self.get_summary()\n        \n        logger.info(\"=\" * 80)\n        logger.info(\"üìä PERFORMANCE SUMMARY\")\n        logger.info(\"=\" * 80)\n        logger.info(f\"Total Operations: {summary['overview']['total_operations']}\")\n        logger.info(f\"Success Rate: {summary['overview']['success_rate']:.1f}%\")\n        logger.info(f\"Total Duration: {summary['overview']['total_duration']:.2f}s\")\n        logger.info(f\"Average Duration: {summary['overview']['average_duration']:.2f}s\")\n        \n        if summary['operation_breakdown']:\n            logger.info(\"\\nüìã Operation Breakdown:\")\n            for op_name, metrics in summary['operation_breakdown'].items():\n                logger.info(f\"  ‚Ä¢ {op_name}: {metrics['count']} ops, \"\n                          f\"avg {metrics['average_duration']:.2f}s, \"\n                          f\"success {metrics['success_rate']:.1f}%\")\n        \n        logger.info(\"=\" * 80)\n","size_bytes":8538},"app/routes/__init__.py":{"content":"\"\"\"\nFlask Routes Module\n\"\"\"\nfrom app.routes.api import create_api_routes\n\n__all__ = ['create_api_routes']\n","size_bytes":106},"app/engines/browser_use/engine_optimized.py":{"content":"\"\"\"\nOptimized Browser-Use Engine\nAI-powered browser automation with advanced features and optimizations\n\nNew Features:\n- Advanced browser capabilities (screenshots, PDFs, cookies, sessions)\n- Enhanced popup handling with configurable timeouts\n- Smart retry mechanism with exponential backoff\n- State management for complex workflows\n- Data extraction capabilities\n- Performance monitoring and metrics\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\nfrom browser_use import Agent, Browser\nfrom browser_use.llm import ChatOpenAI\n\nfrom app.engines.browser_use.advanced_features import AdvancedBrowserFeatures\nfrom app.engines.browser_use.retry_mechanism import RetryConfig, RetryMechanism\nfrom app.engines.browser_use.state_manager import WorkflowState\nfrom app.engines.browser_use.data_extractor import DataExtractor\nfrom app.engines.browser_use.performance_monitor import PerformanceMonitor\n\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedBrowserUseEngine:\n    \"\"\"\n    Optimized browser automation engine with advanced capabilities\n    \n    Features:\n    - Screenshot capture and PDF generation\n    - Cookie and session management\n    - Smart retry with exponential backoff\n    - Workflow state persistence\n    - Data extraction (tables, lists, metadata)\n    - Performance monitoring\n    - Enhanced popup handling\n    \"\"\"\n    \n    def __init__(self, headless: bool = False, enable_advanced_features: bool = True):\n        \"\"\"\n        Initialize Optimized Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n            enable_advanced_features: Enable advanced capabilities\n        \"\"\"\n        self.headless = headless\n        self.enable_advanced_features = enable_advanced_features\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        # Browser performance settings - using reliable defaults\n        self.minimum_wait_page_load_time = float(config.get('browser_performance', 'minimum_wait_page_load_time', fallback='1.0'))\n        self.wait_for_network_idle_page_load_time = float(config.get('browser_performance', 'wait_for_network_idle_page_load_time', fallback='1.5'))\n        self.wait_between_actions = float(config.get('browser_performance', 'wait_between_actions', fallback='1.0'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n        \n        if enable_advanced_features:\n            output_dir = config.get('advanced_features', 'output_directory', fallback='automation_outputs')\n            self.enable_screenshots = config.getboolean('advanced_features', 'enable_screenshots', fallback=True)\n            self.enable_pdf_generation = config.getboolean('advanced_features', 'enable_pdf_generation', fallback=True)\n            self.enable_cookie_management = config.getboolean('advanced_features', 'enable_cookie_management', fallback=True)\n            self.enable_state_persistence = config.getboolean('advanced_features', 'enable_state_persistence', fallback=True)\n            \n            self.advanced_features = AdvancedBrowserFeatures(output_dir=output_dir)\n            \n            max_retries = int(config.get('retry', 'max_retries', fallback='3'))\n            initial_delay = float(config.get('retry', 'initial_delay', fallback='1.0'))\n            max_delay = float(config.get('retry', 'max_delay', fallback='30.0'))\n            backoff_factor = float(config.get('retry', 'backoff_factor', fallback='2.0'))\n            \n            retry_config = RetryConfig(\n                max_retries=max_retries,\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                backoff_factor=backoff_factor\n            )\n            self.retry_mechanism = RetryMechanism(retry_config)\n            \n            track_metrics = config.getboolean('performance', 'track_detailed_metrics', fallback=True)\n            self.performance_monitor = PerformanceMonitor(track_detailed_metrics=track_metrics)\n            \n            self.data_extractor = DataExtractor()\n            self.workflow_state = None\n            \n            logger.info(\"üöÄ Advanced features enabled: Screenshots, PDFs, Cookies, Retry, Performance Tracking\")\n        else:\n            logger.info(\"‚ÑπÔ∏è  Running in basic mode (advanced features disabled)\")\n    \n    async def execute_instruction(self, instruction: str, \n                                  workflow_id: Optional[str] = None,\n                                  save_screenshot: bool = False,\n                                  save_pdf: bool = False) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction with advanced features\n        \n        Args:\n            instruction: User's natural language instruction\n            workflow_id: Optional workflow ID for state management\n            save_screenshot: Capture screenshot after completion\n            save_pdf: Generate PDF after completion\n            \n        Returns:\n            Dictionary with execution results and advanced metrics\n        \"\"\"\n        op_id = None\n        if self.enable_advanced_features:\n            op_id = self.performance_monitor.start_operation(\"execute_instruction\")\n            \n            if workflow_id:\n                self.workflow_state = WorkflowState(workflow_id=workflow_id, persist_to_disk=True)\n        \n        try:\n            logger.info(\"ü§ñ Initializing Browser-Use Agent\")\n            logger.info(f\"üìã Task: {instruction}\")\n            logger.info(f\"üî¢ Max steps: {self.max_steps}\")\n            \n            # System instructions optimized for efficiency while maintaining safety\n            system_instructions = f\"\"\"\nTASK: \"{instruction}\"\n\nCORE RULES:\n1. Execute ONLY explicitly stated actions - nothing more\n2. After completing all explicit steps ‚Üí use done() immediately\n3. Verify each action succeeded before proceeding\n4. Keep thinking concise but thorough\n\nPOPUP/NEW WINDOW HANDLING:\n- After clicking button that opens popup ‚Üí wait 3s for window switch\n- Verify popup content loaded correctly\n- If content not ready ‚Üí wait 2s more ‚Üí retry\n- Continue with explicit instructions in the new window\n\nPAGE LOADING & ERRORS:\n- If element not found ‚Üí page still loading ‚Üí wait 2s ‚Üí retry with fresh page state\n- Verify critical actions (form submissions, clicks) succeeded\n- Do NOT assume success without verification\n\nSECURITY:\n- Never navigate to unintended domains\n- Confirm sensitive actions before executing\n            \"\"\"\n            \n            logger.info(\"‚öôÔ∏è  Configuring agent with optimizations\")\n            \n            # Create browser instance with optimized performance settings\n            browser = Browser(\n                headless=self.headless,\n                disable_security=False,  # Keep security enabled for production\n                minimum_wait_page_load_time=self.minimum_wait_page_load_time,\n                wait_for_network_idle_page_load_time=self.wait_for_network_idle_page_load_time,\n                wait_between_actions=self.wait_between_actions\n            )\n            logger.info(f\"üåê Browser initialized (headless={self.headless})\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                browser=browser,  # Pass browser for proper popup/multi-window handling\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"‚ñ∂Ô∏è  Starting agent execution...\")\n            \n            if self.enable_advanced_features:\n                @self.retry_mechanism.async_retry\n                async def run_with_retry():\n                    return await agent.run(max_steps=self.max_steps)\n                \n                history = await run_with_retry()\n            else:\n                history = await agent.run(max_steps=self.max_steps)\n            \n            logger.info(f\"‚èπÔ∏è  Agent execution completed\")\n            \n            logger.info(\"üìä Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n                \n                if self.enable_advanced_features and self.workflow_state:\n                    self.workflow_state.add_step(\n                        step_name=f\"browser_action_{step_num}\",\n                        step_data={\"action\": action},\n                        success=True\n                    )\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from app.engines.browser_use.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"üé≠ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            if len(steps) == 0:\n                logger.error(f\"‚ùå Task failed - no steps were executed successfully\")\n                result = {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            else:\n                logger.info(f\"‚úÖ Task completed successfully!\")\n                logger.info(f\"üìà Total steps executed: {len(steps)}\")\n                if final_result:\n                    logger.info(f\"üéØ Final result: {str(final_result)[:200]}\")\n                \n                result = {\n                    \"success\": True,\n                    \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result\n                }\n                \n                # Add Playwright code if generated\n                if playwright_code:\n                    result[\"playwright_code\"] = playwright_code\n            \n            if self.enable_advanced_features:\n                if op_id:\n                    self.performance_monitor.end_operation(op_id, success=result[\"success\"])\n                \n                result[\"performance_metrics\"] = self.performance_monitor.get_summary()\n                \n                if self.workflow_state:\n                    result[\"workflow_state\"] = self.workflow_state.get_summary()\n                \n                result[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Browser-Use execution failed: {str(e)}\", exc_info=True)\n            \n            if self.enable_advanced_features and op_id:\n                self.performance_monitor.end_operation(op_id, success=False)\n            \n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            **kwargs: Additional arguments for execute_instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction, **kwargs))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance monitoring summary\"\"\"\n        if self.enable_advanced_features:\n            return self.performance_monitor.get_summary()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def get_retry_stats(self) -> Dict[str, Any]:\n        \"\"\"Get retry mechanism statistics\"\"\"\n        if self.enable_advanced_features:\n            return self.retry_mechanism.get_stats()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics and statistics\"\"\"\n        if self.enable_advanced_features:\n            self.performance_monitor.reset()\n            self.retry_mechanism.reset_stats()\n            logger.info(\"üîÑ All metrics reset\")\n","size_bytes":14408},"replit.md":{"content":"# AI Browser Automation\n\n## Overview\n\nAI-powered browser automation platform providing two distinct automation engines: **Browser-Use** (AI-driven reasoning) and **Playwright MCP** (tool-based execution). The system allows users to describe automation tasks in natural language, which are executed by intelligent agents controlling web browsers.\n\nBuilt as a Flask web service with a modern web interface, supporting both headless and headful browser modes. Designed to handle complex multi-step workflows, data extraction, screenshot capture, and other advanced browser automation tasks.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## Project Structure\n\n```\nai-browser-automation/\n‚îú‚îÄ‚îÄ app/                          # Flask application\n‚îÇ   ‚îú‚îÄ‚îÄ engines/                  # Automation engines\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ browser_use/          # Browser-Use AI engine\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine.py         # Base engine\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine_optimized.py  # Enhanced with advanced features\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ advanced_features.py # Screenshots, PDFs, cookies\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ retry_mechanism.py   # Exponential backoff retry\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state_manager.py     # Workflow state persistence\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data_extractor.py    # Table/list extraction\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ performance_monitor.py # Metrics tracking\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ popup_handler.py     # Popup window handling\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ playwright_code_generator.py # Code export\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ playwright_mcp/       # Playwright MCP tool engine\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ agent/            # Conversation agent\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ client/           # STDIO MCP client\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ mcp_code_generator.py # Code export\n‚îÇ   ‚îú‚îÄ‚îÄ middleware/               # Security & validation\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py           # Auth, rate limiting, validation\n‚îÇ   ‚îú‚îÄ‚îÄ routes/                   # API endpoints\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.py                # REST API routes\n‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Business logic\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ engine_orchestrator.py # Engine management\n‚îÇ   ‚îú‚îÄ‚îÄ static/                   # Frontend assets\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/style.css\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ js/app.js\n‚îÇ   ‚îú‚îÄ‚îÄ templates/                # HTML templates\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html\n‚îÇ   ‚îî‚îÄ‚îÄ utils/                    # Shared utilities\n‚îÇ       ‚îî‚îÄ‚îÄ timeout.py            # Cross-platform timeout handling\n‚îú‚îÄ‚îÄ integrations/                 # External integrations\n‚îÇ   ‚îî‚îÄ‚îÄ playwright_mcp_node/      # Node.js MCP server\n‚îÇ       ‚îú‚îÄ‚îÄ cli.js                # Server entry point\n‚îÇ       ‚îî‚îÄ‚îÄ package.json          # Node dependencies\n‚îú‚îÄ‚îÄ config/                       # Configuration\n‚îÇ   ‚îî‚îÄ‚îÄ config.ini                # OpenAI & browser settings\n‚îú‚îÄ‚îÄ tests/                        # Test suite\n‚îÇ   ‚îú‚îÄ‚îÄ unit/                     # Unit tests\n‚îÇ   ‚îú‚îÄ‚îÄ integration/              # Integration tests\n‚îÇ   ‚îî‚îÄ‚îÄ conftest.py               # Pytest configuration\n‚îú‚îÄ‚îÄ main.py                       # Application entry point\n‚îú‚îÄ‚îÄ requirements.txt              # Python dependencies\n‚îú‚îÄ‚îÄ pyproject.toml                # Project metadata\n‚îî‚îÄ‚îÄ .env                          # Environment variables (secrets)\n```\n\n## System Architecture\n\n### Frontend Architecture\n\n**Web Interface**: Single-page application (SPA) using vanilla JavaScript with a two-column layout:\n- Left panel: Configuration controls (engine selection, headless mode toggle, instruction input)\n- Right panel: Real-time execution status, results display, and generated code preview\n- Styling: Gradient purple theme with responsive design using CSS Grid\n\n**Client-Side Features**:\n- Real-time status updates during automation execution\n- JSON result formatting and display\n- Generated Playwright code preview for reusability\n- Engine and mode selection persistence in UI\n\n### Backend Architecture\n\n**Flask Application Factory Pattern**: Modular structure with blueprints, middleware, and services separation.\n\n**Engine Orchestrator** (`app/services/engine_orchestrator.py`): Manages two distinct automation engines with instance caching and lifecycle management.\n\n**Automation Engines**:\n\n1. **Browser-Use Engine** (AI-Powered - Default & Recommended):\n   - Location: `app/engines/browser_use/`\n   - Uses OpenAI's LLM to reason about browser actions\n   - Implements the `browser-use` library with Playwright backend\n   - Features: Advanced popup handling, retry mechanisms with exponential backoff, state management for complex workflows, performance monitoring, data extraction (tables, lists, metadata), screenshot/PDF generation, cookie management\n   - Thread-safe design: Creates fresh browser instances per request with proper cleanup\n   - Two implementations: `engine.py` (base) and `engine_optimized.py` (enhanced)\n\n2. **Playwright MCP Engine** (Tool-Based):\n   - Location: `app/engines/playwright_mcp/`\n   - Uses Model Context Protocol (MCP) for discrete tool calls\n   - OpenAI function calling to map natural language to browser tools\n   - Communicates with Node.js MCP server via STDIO transport (subprocess)\n   - Available tools: navigate, click, fill, snapshot, select, hover, evaluate, screenshot\n   - Node server location: `integrations/playwright_mcp_node/`\n\n**Code Generation**: Both engines include code generators that convert executed automation steps into reusable Playwright Python code.\n\n**Execution Flow**:\n1. User submits natural language instruction via REST API (`/api/execute`)\n2. Orchestrator selects appropriate engine based on request parameter\n3. Engine creates fresh browser instance on new event loop (thread safety)\n4. AI agent interprets instruction and executes browser actions\n5. Results, history, and generated code returned to client\n6. Browser instance cleaned up via finally block\n\n**Security & Middleware** (`app/middleware/security.py`):\n- API key authentication (optional, configurable via `API_KEY` env var)\n- Rate limiting: In-memory limiter (10 requests per 60 seconds by default)\n- Input validation and sanitization\n- Error message sanitization to prevent information leakage\n- CORS support with configurable allowed origins\n\n**Thread Safety Design**: Designed for Flask's multi-threaded WSGI environment. Each request creates its own asyncio event loop and browser instance, avoiding event loop affinity issues. Resources are properly cleaned up after each request.\n\n**Timeout Handling** (`app/utils/timeout.py`): Cross-platform timeout mechanism using ThreadPoolExecutor to prevent hung operations (default: 300 seconds).\n\n### API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute automation instruction\n- `GET /api/tools` - List available tools for an engine\n- `POST /api/reset` - Reset agent conversation history\n- `GET /health` - Health check endpoint\n\n### Data Storage\n\n**No Database**: The current implementation does not use a persistent database. All state is in-memory or written to local files (screenshots, PDFs, workflow states, cookies).\n\n**File-Based Outputs**:\n- Screenshots: `automation_outputs/screenshots/`\n- PDFs: `automation_outputs/pdfs/`\n- Cookies: `automation_outputs/cookies/`\n- Workflow states: `workflow_states/*.json` (for complex multi-step workflows)\n\n**Environment Configuration**: Uses `python-dotenv` to load configuration from `.env` file with explicit override to prevent system environment variable conflicts.\n\n### Authentication & Authorization\n\n**API Key Authentication**: Optional middleware-based API key validation via `X-API-Key` header. Disabled by default (no auth required), can be enabled by setting `API_KEY` environment variable.\n\n**No User Management**: The system does not implement user accounts, sessions, or role-based access control. It's designed as a single-user or team-shared automation service.\n\n## External Dependencies\n\n### Third-Party Services\n\n**OpenAI API** (Required):\n- Purpose: LLM reasoning for natural language instruction interpretation\n- Configuration: `OPENAI_API_KEY` environment variable (never hardcoded)\n- Models used: `gpt-4o-mini` (default, configurable in `config/config.ini`)\n- Usage: Both engines use OpenAI for instruction understanding and action planning\n\n### Core Python Libraries\n\n- **browser-use**: AI-powered browser automation library with LLM reasoning\n- **Playwright**: Cross-browser automation framework (Chromium, Firefox, WebKit)\n- **langchain-openai**: LangChain integration for OpenAI models\n- **Flask**: Web framework for REST API and UI serving\n- **Flask-CORS**: Cross-origin resource sharing support\n- **python-dotenv**: Environment variable management from `.env` files\n- **pytest**, **pytest-cov**: Testing framework and coverage\n- **gunicorn**: Production WSGI server\n\n### Node.js Components\n\n**Playwright MCP Server** (`integrations/playwright_mcp_node/`):\n- Purpose: Provides tool-based browser automation via Model Context Protocol\n- Package: `@playwright/mcp` (custom MCP server implementation)\n- Communication: JSON-RPC over STDIO with Python subprocess\n- Dependencies: `@modelcontextprotocol/sdk`, `playwright`, `playwright-core`\n\n### Browser Requirements\n\n**Playwright Browsers**: Automatically downloads Chromium, Firefox, and WebKit on first run. Configurable via `config/config.ini`:\n- Default browser: Chromium\n- Headless mode: Configurable per request\n- Browser validation: Skipped via `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS=1`\n\n### Configuration Files\n\n**config/config.ini**: Central configuration for OpenAI models and browser settings\n**.env**: Sensitive environment variables (API keys, secrets)\n- `OPENAI_API_KEY`: Required for AI features\n- `SESSION_SECRET`: Flask session secret\n- `CORS_ALLOWED_ORIGINS`: Comma-separated allowed origins for CORS\n\n## Testing\n\n**Test Structure** (`tests/`):\n- `unit/`: Unit tests for individual components (security, validation, utilities)\n- `integration/`: Integration tests for API endpoints and engine orchestration\n- `conftest.py`: Pytest configuration and shared fixtures\n\nRun tests: `pytest tests/`\n\n## Performance Optimization\n\n**Conservative \"Reliability-First\" Optimizations** (2025-10-24):\n- **System Prompt Optimization**: Refined instructions from ~1400 to ~700 characters (50% reduction) while preserving all safety guardrails including verification steps, security checks, error recovery, and popup handling\n- **Reduced Logging Overhead**: Disabled detailed metrics tracking (kept summary logging); disabled verbose popup logging\n- **Configuration**: All reliability settings preserved at safe defaults:\n  - max_steps: 25 (handles complex workflows)\n  - Browser waits: 1.0s/1.5s/1.0s (reliable page loading)\n  - LLM timeout: 180s (handles long-running tasks)\n  - Retry: 3 attempts with exponential backoff\n  - Features: Screenshots, PDFs, cookies, state persistence all enabled\n- **Expected Impact**: ~20% reduction in LLM processing time, ~5% reduction in logging overhead, zero compromise on reliability or functionality\n\n## Recent Changes\n\n**2025-10-24**: Major project restructure\n- Removed hybrid engine implementation (simplified to 2 engines: browser_use, playwright_mcp)\n- Reorganized project structure professionally:\n  - Moved `browser_use_codebase/` ‚Üí `app/engines/browser_use/`\n  - Moved `playwright_mcp_codebase/` ‚Üí `app/engines/playwright_mcp/`\n  - Moved `node/` ‚Üí `integrations/playwright_mcp_node/`\n- Updated all imports to reflect new package structure\n- Deleted unnecessary files (requirements.txt.bak, config.ini duplicate, check_env.py, run_windows.bat, uv.lock)\n- Created professional test suite structure\n- Browser-Use is now the default and recommended engine\n- Applied conservative performance optimizations (prompt refinement, reduced logging overhead)\n","size_bytes":11934},"app/engines/browser_use/advanced_features.py":{"content":"\"\"\"\nAdvanced Browser Automation Features\nProvides screenshot capture, PDF generation, cookie management, and more\n\"\"\"\nimport os\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nfrom browser_use import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass AdvancedBrowserFeatures:\n    \"\"\"\n    Advanced capabilities for browser automation\n    Handles screenshots, PDFs, cookies, sessions, and more\n    \"\"\"\n    \n    def __init__(self, output_dir: str = \"automation_outputs\"):\n        \"\"\"\n        Initialize advanced browser features\n        \n        Args:\n            output_dir: Directory to save screenshots, PDFs, etc.\n        \"\"\"\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(exist_ok=True)\n        \n        self.screenshots_dir = self.output_dir / \"screenshots\"\n        self.pdfs_dir = self.output_dir / \"pdfs\"\n        self.cookies_dir = self.output_dir / \"cookies\"\n        \n        self.screenshots_dir.mkdir(exist_ok=True)\n        self.pdfs_dir.mkdir(exist_ok=True)\n        self.cookies_dir.mkdir(exist_ok=True)\n        \n        logger.info(f\"üìÅ Advanced features initialized with output dir: {self.output_dir}\")\n    \n    async def capture_screenshot(self, page, name: Optional[str] = None, full_page: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Capture screenshot of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for screenshot\n            full_page: Capture full scrollable page\n            \n        Returns:\n            Dictionary with screenshot path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.png\" if name else f\"screenshot_{timestamp}.png\"\n            filepath = self.screenshots_dir / filename\n            \n            await page.screenshot(path=str(filepath), full_page=full_page)\n            \n            logger.info(f\"üì∏ Screenshot saved: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"full_page\": full_page,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Screenshot capture failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def generate_pdf(self, page, name: Optional[str] = None, \n                          landscape: bool = False, \n                          print_background: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Generate PDF of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for PDF\n            landscape: Use landscape orientation\n            print_background: Include background graphics\n            \n        Returns:\n            Dictionary with PDF path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.pdf\" if name else f\"page_{timestamp}.pdf\"\n            filepath = self.pdfs_dir / filename\n            \n            await page.pdf(\n                path=str(filepath),\n                format='A4',\n                landscape=landscape,\n                print_background=print_background,\n                margin={'top': '20px', 'right': '20px', 'bottom': '20px', 'left': '20px'}\n            )\n            \n            logger.info(f\"üìÑ PDF generated: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"landscape\": landscape,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå PDF generation failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def save_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Save browser cookies for session persistence\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name for this session\n            \n        Returns:\n            Dictionary with save status and path\n        \"\"\"\n        try:\n            cookies = await context.cookies()\n            \n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            with open(filepath, 'w') as f:\n                json.dump(cookies, f, indent=2)\n            \n            logger.info(f\"üç™ Cookies saved: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Cookie save failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def load_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Load previously saved cookies to restore session\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name of session to restore\n            \n        Returns:\n            Dictionary with load status\n        \"\"\"\n        try:\n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"error\": f\"Session '{session_name}' not found\"\n                }\n            \n            with open(filepath, 'r') as f:\n                cookies = json.load(f)\n            \n            await context.add_cookies(cookies)\n            \n            logger.info(f\"üç™ Cookies loaded: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Cookie load failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_local_storage(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract localStorage data from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with localStorage contents\n        \"\"\"\n        try:\n            storage_data = await page.evaluate(\"\"\"() => {\n                let data = {};\n                for (let i = 0; i < localStorage.length; i++) {\n                    let key = localStorage.key(i);\n                    data[key] = localStorage.getItem(key);\n                }\n                return data;\n            }\"\"\")\n            \n            logger.info(f\"üíæ LocalStorage extracted: {len(storage_data)} items\")\n            \n            return {\n                \"success\": True,\n                \"data\": storage_data,\n                \"item_count\": len(storage_data)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå LocalStorage extraction failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def set_local_storage(self, page, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set localStorage data on page\n        \n        Args:\n            page: Playwright page object\n            data: Dictionary of key-value pairs to set\n            \n        Returns:\n            Dictionary with operation status\n        \"\"\"\n        try:\n            for key, value in data.items():\n                await page.evaluate(f\"\"\"() => {{\n                    localStorage.setItem('{key}', '{value}');\n                }}\"\"\")\n            \n            logger.info(f\"üíæ LocalStorage set: {len(data)} items\")\n            \n            return {\n                \"success\": True,\n                \"item_count\": len(data)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå LocalStorage set failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    def list_sessions(self) -> List[str]:\n        \"\"\"\n        List all saved cookie sessions\n        \n        Returns:\n            List of session names\n        \"\"\"\n        sessions = []\n        for file in self.cookies_dir.glob(\"*_cookies.json\"):\n            session_name = file.stem.replace(\"_cookies\", \"\")\n            sessions.append(session_name)\n        \n        return sessions\n    \n    def cleanup_old_files(self, days: int = 7):\n        \"\"\"\n        Clean up old screenshots and PDFs\n        \n        Args:\n            days: Delete files older than this many days\n        \"\"\"\n        from datetime import timedelta\n        cutoff = datetime.now() - timedelta(days=days)\n        \n        deleted_count = 0\n        for directory in [self.screenshots_dir, self.pdfs_dir]:\n            for file in directory.glob(\"*\"):\n                if file.stat().st_mtime < cutoff.timestamp():\n                    file.unlink()\n                    deleted_count += 1\n        \n        logger.info(f\"üóëÔ∏è  Cleaned up {deleted_count} old files\")\n        return deleted_count\n","size_bytes":9610},"app/engines/playwright_mcp/client/stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        args = [\"node\", \"integrations/playwright_mcp_node/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        pass\n                except UnicodeDecodeError:\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8262},"app/routes/api.py":{"content":"\"\"\"\nAPI Routes\nRESTful endpoints for browser automation with security and validation\n\"\"\"\nimport os\nimport logging\nfrom flask import Blueprint, render_template, request, jsonify\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.middleware.security import (\n    require_api_key,\n    rate_limit,\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\nfrom app.utils.timeout import run_with_timeout, TimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_api_routes(orchestrator: EngineOrchestrator) -> Blueprint:\n    \"\"\"\n    Create API routes blueprint\n    \n    Args:\n        orchestrator: Engine orchestrator instance\n        \n    Returns:\n        Flask Blueprint with all routes\n    \"\"\"\n    api = Blueprint('api', __name__)\n    \n    @api.route('/')\n    def index():\n        \"\"\"Render main page\"\"\"\n        return render_template('index.html')\n    \n    @api.route('/api/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            instruction = data.get('instruction', '').strip()\n            engine_type = data.get('engine', 'browser_use')\n            headless = data.get('headless', False)\n\n            print(instruction,engine_type)\n            \n            is_valid, error_msg = validate_instruction(instruction)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid instruction: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid instruction',\n                    'message': error_msg\n                }), 400\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid engine type: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            if not isinstance(headless, bool):\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid parameter',\n                    'message': 'headless must be a boolean'\n                }), 400\n            \n            logger.info(\"=\"*80)\n            logger.info(\"üì® NEW AUTOMATION REQUEST\")\n            logger.info(f\"üìù Instruction: {instruction}\")\n            logger.info(f\"üîß Engine: {engine_type}\")\n            logger.info(f\"üëÅÔ∏è  Headless: {headless}\")\n            logger.info(f\"üåê Client: {request.remote_addr}\")\n            logger.info(\"=\"*80)\n            \n            logger.info(\"üöÄ Starting automation execution...\")\n            \n            try:\n                result = run_with_timeout(\n                    orchestrator.execute_instruction,\n                    300,\n                    instruction,\n                    engine_type,\n                    headless\n                )\n            except TimeoutError as e:\n                logger.error(f\"‚è±Ô∏è  Automation timed out: {str(e)}\")\n                orchestrator.cleanup_after_timeout(engine_type, headless)\n                return jsonify({\n                    'success': False,\n                    'error': 'Timeout',\n                    'message': 'Operation timed out. The task took longer than 5 minutes to complete.',\n                    'timeout': True\n                }), 408\n            \n            if result.get('success'):\n                logger.info(f\"‚úÖ Automation completed successfully in {result.get('iterations', 0)} steps\")\n            else:\n                logger.error(f\"‚ùå Automation failed: {result.get('error', 'Unknown error')}\")\n            \n            logger.info(\"=\"*80)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            logger.error(f\"üí• Exception in execute_instruction: {str(e)}\", exc_info=True)\n            \n            user_message = sanitize_error_message(e)\n            \n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': user_message\n            }), 500\n    \n    @api.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            engine_type = request.args.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            tools = orchestrator.get_tools(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'tools': tools,\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting tools: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/reset', methods=['POST'])\n    @require_api_key\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_type = data.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            orchestrator.reset_agent(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully',\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error resetting agent: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            return jsonify({\n                'status': 'healthy',\n                'engines': {\n                    'browser_use': 'available',\n                    'playwright_mcp': 'available'\n                },\n                'message': 'AI browser automation ready',\n                'security': {\n                    'authentication': 'enabled' if os.environ.get('API_KEY') else 'disabled',\n                    'rate_limiting': 'enabled'\n                }\n            })\n        except Exception as e:\n            logger.error(f\"Health check failed: {str(e)}\", exc_info=True)\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Service unavailable'\n            }), 503\n    \n    return api\n","size_bytes":7501},"app/middleware/__init__.py":{"content":"\"\"\"Middleware package\"\"\"\n","size_bytes":25},"app/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n}\n\n/* Header */\nheader {\n    text-align: center;\n    color: white;\n    margin-bottom: 30px;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 10px;\n}\n\nheader .subtitle {\n    font-size: 1.1rem;\n    opacity: 0.95;\n    font-weight: 400;\n}\n\n/* Main Content - Two Column Layout */\n.main-content {\n    display: grid;\n    grid-template-columns: 450px 1fr;\n    gap: 25px;\n    margin-bottom: 20px;\n}\n\n/* Left Panel */\n.left-panel {\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n}\n\n.config-section,\n.instruction-section,\n.examples-section {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n}\n\n.config-section h3,\n.instruction-section h3,\n.examples-section h4 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    margin-bottom: 16px;\n    color: #667eea;\n}\n\n.config-group {\n    margin-bottom: 20px;\n}\n\n.config-group:last-child {\n    margin-bottom: 0;\n}\n\n.config-group label {\n    display: block;\n    font-weight: 600;\n    margin-bottom: 8px;\n    color: #333;\n    font-size: 0.95rem;\n}\n\n.config-select {\n    width: 100%;\n    padding: 12px 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    font-size: 1rem;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.config-select:hover {\n    border-color: #667eea;\n}\n\n.config-select:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n.config-help {\n    margin-top: 6px;\n    font-size: 0.85rem;\n    color: #666;\n    line-height: 1.4;\n}\n\n/* Toggle Switch */\n.toggle-label {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    margin-bottom: 0;\n}\n\n.toggle-label input[type=\"checkbox\"] {\n    display: none;\n}\n\n.toggle-slider {\n    position: relative;\n    width: 52px;\n    height: 28px;\n    background: #e0e0e0;\n    border-radius: 34px;\n    margin-right: 12px;\n    transition: background 0.3s ease;\n}\n\n.toggle-slider::before {\n    content: '';\n    position: absolute;\n    width: 22px;\n    height: 22px;\n    left: 3px;\n    top: 3px;\n    background: white;\n    border-radius: 50%;\n    transition: transform 0.3s ease;\n}\n\n.toggle-label input:checked + .toggle-slider {\n    background: #667eea;\n}\n\n.toggle-label input:checked + .toggle-slider::before {\n    transform: translateX(24px);\n}\n\n.toggle-text {\n    font-weight: 600;\n    color: #333;\n}\n\n/* Instruction Input */\n#instruction-input {\n    width: 100%;\n    padding: 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    transition: border-color 0.3s ease;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n#instruction-input::placeholder {\n    color: #999;\n}\n\n/* Buttons */\n.button-group {\n    display: flex;\n    gap: 12px;\n    margin-top: 16px;\n}\n\n.btn {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n    padding: 14px 24px;\n    border: none;\n    border-radius: 10px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.btn-icon {\n    font-size: 1.1rem;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #f3f4f6;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #e5e7eb;\n}\n\n.spinner {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-top-color: white;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n/* Examples */\n.example-buttons {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.example-btn {\n    padding: 12px 16px;\n    background: #f8f9fa;\n    border: 2px solid #e9ecef;\n    border-radius: 8px;\n    font-size: 0.9rem;\n    cursor: pointer;\n    text-align: left;\n    transition: all 0.2s ease;\n    font-weight: 500;\n    color: #333;\n}\n\n.example-btn:hover {\n    background: #667eea;\n    border-color: #667eea;\n    color: white;\n    transform: translateX(4px);\n}\n\n/* Right Panel - Results */\n.right-panel {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n    display: flex;\n    flex-direction: column;\n}\n\n.results-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n}\n\n.results-header h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #667eea;\n}\n\n.status-badge {\n    padding: 6px 14px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.status-badge.running {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n.status-badge.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.status-badge.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.status {\n    padding: 14px 18px;\n    border-radius: 10px;\n    margin-bottom: 16px;\n    font-weight: 500;\n    display: none;\n}\n\n.status.success {\n    background: #d1fae5;\n    color: #065f46;\n    border-left: 4px solid #10b981;\n    display: block;\n}\n\n.status.error {\n    background: #fee2e2;\n    color: #991b1b;\n    border-left: 4px solid #ef4444;\n    display: block;\n}\n\n.status.processing {\n    background: #fef3c7;\n    color: #92400e;\n    border-left: 4px solid #f59e0b;\n    display: block;\n}\n\n/* Results Container */\n.results-container {\n    flex: 1;\n    overflow-y: auto;\n    max-height: calc(100vh - 400px);\n}\n\n.empty-state {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    padding: 60px 20px;\n    color: #9ca3af;\n}\n\n.empty-icon {\n    font-size: 4rem;\n    margin-bottom: 16px;\n    opacity: 0.5;\n}\n\n.empty-state p {\n    font-size: 1rem;\n}\n\n/* Step Display */\n.step {\n    background: #f8f9fa;\n    border-left: 4px solid #667eea;\n    border-radius: 8px;\n    padding: 16px;\n    margin-bottom: 14px;\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    font-weight: 700;\n    color: #667eea;\n    font-size: 0.95rem;\n}\n\n.step-status {\n    padding: 4px 12px;\n    border-radius: 12px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.step-status.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 8px;\n    font-size: 0.95rem;\n}\n\n.step-args {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    font-family: 'Courier New', monospace;\n    font-size: 0.85rem;\n    color: #555;\n    white-space: pre-wrap;\n    word-break: break-all;\n}\n\n.step-error {\n    color: #991b1b;\n    margin-top: 10px;\n    font-weight: 500;\n}\n\ndetails {\n    margin-top: 10px;\n}\n\nsummary {\n    cursor: pointer;\n    color: #667eea;\n    font-weight: 600;\n    font-size: 0.9rem;\n}\n\ndetails pre {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    margin-top: 8px;\n    font-size: 0.85rem;\n    overflow: auto;\n    max-height: 300px;\n}\n\n/* Footer */\nfooter {\n    background: rgba(255, 255, 255, 0.95);\n    border-radius: 12px;\n    padding: 16px 24px;\n    text-align: center;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.footer-content p {\n    color: #666;\n    margin-bottom: 8px;\n    font-size: 0.9rem;\n}\n\n.footer-links {\n    display: flex;\n    justify-content: center;\n    gap: 24px;\n    font-size: 0.9rem;\n    color: #666;\n}\n\n.footer-links strong {\n    color: #667eea;\n}\n\n/* Responsive */\n@media (max-width: 1024px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n    \n    .left-panel {\n        order: 1;\n    }\n    \n    .right-panel {\n        order: 2;\n    }\n}\n","size_bytes":8389},"app/engines/browser_use/playwright_code_generator.py":{"content":"\"\"\"\nPlaywright Code Generator for Browser-Use\nConverts browser-use automation history into reusable Playwright code\n\nUsage:\n    history = await agent.run(...)\n    generator = PlaywrightCodeGenerator(history)\n    code = generator.generate_python_code()\n    print(code)\n\"\"\"\n\nimport re\nimport json\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass PlaywrightAction:\n    \"\"\"Represents a single Playwright action\"\"\"\n    action_type: str\n    selector: Optional[str] = None\n    value: Optional[str] = None\n    url: Optional[str] = None\n    comment: Optional[str] = None\n    raw_action: Optional[str] = None\n\n\nclass Locator(BaseModel):\n    \"\"\"Represents a reusable locator\"\"\"\n    name: str\n    selector: str\n    action_examples: List[str] = []\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"\n    Generates Playwright Python code from browser-use agent history\n    \n    Features:\n    - Extracts actions from AgentHistoryList\n    - Generates clean, maintainable Playwright code\n    - Creates reusable locators\n    - Includes proper async/await patterns\n    - Adds comments for clarity\n    \"\"\"\n    \n    def __init__(self, history=None, task_description: str = \"Automated browser task\"):\n        \"\"\"\n        Initialize code generator\n        \n        Args:\n            history: AgentHistoryList from browser-use agent.run()\n            task_description: Description of what the automation does\n        \"\"\"\n        self.history = history\n        self.task_description = task_description\n        self.actions: List[PlaywrightAction] = []\n        self.locators: Dict[str, Locator] = {}\n        \n    def parse_history(self) -> List[PlaywrightAction]:\n        \"\"\"\n        Parse browser-use history and extract Playwright actions\n        \n        Returns:\n            List of PlaywrightAction objects\n        \"\"\"\n        if not self.history:\n            return []\n        \n        actions = []\n        \n        # Try to get model_actions if available\n        if hasattr(self.history, 'model_actions'):\n            try:\n                model_actions = self.history.model_actions()\n                for action in model_actions:\n                    pw_action = self._convert_model_action(action)\n                    if pw_action:\n                        actions.append(pw_action)\n            except Exception as e:\n                print(f\"Note: Could not extract model_actions: {e}\")\n        \n        # Fallback: parse from history.history\n        if not actions and hasattr(self.history, 'history'):\n            for item in self.history.history:\n                pw_action = self._parse_history_item(item)\n                if pw_action:\n                    actions.append(pw_action)\n        \n        self.actions = actions\n        return actions\n    \n    def _convert_model_action(self, action: dict) -> Optional[PlaywrightAction]:\n        \"\"\"Convert browser-use model action to Playwright action\"\"\"\n        action_name = action.get('name', '').lower()\n        params = action.get('params', {}) or {}\n        \n        # Navigate action\n        if 'navigate' in action_name or 'goto' in action_name:\n            url = params.get('url') or params.get('target')\n            if url:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url,\n                    comment=f\"Navigate to {url}\",\n                    raw_action=str(action)\n                )\n        \n        # Click action\n        elif 'click' in action_name:\n            selector = self._extract_selector(params)\n            if selector:\n                return PlaywrightAction(\n                    action_type='click',\n                    selector=selector,\n                    comment=f\"Click {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Type/Input action\n        elif 'type' in action_name or 'input' in action_name or 'fill' in action_name:\n            selector = self._extract_selector(params)\n            value = params.get('text') or params.get('value') or params.get('input')\n            if selector and value:\n                return PlaywrightAction(\n                    action_type='fill',\n                    selector=selector,\n                    value=value,\n                    comment=f\"Fill '{value}' into {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Wait action\n        elif 'wait' in action_name:\n            timeout = params.get('timeout') or params.get('duration', 1000)\n            return PlaywrightAction(\n                action_type='wait',\n                value=str(timeout),\n                comment=f\"Wait {timeout}ms\",\n                raw_action=str(action)\n            )\n        \n        # Generic action - store for analysis\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Action: {action_name} - {params}\",\n            raw_action=str(action)\n        )\n    \n    def _parse_history_item(self, item) -> Optional[PlaywrightAction]:\n        \"\"\"Parse individual history item\"\"\"\n        model_output = str(getattr(item, 'model_output', ''))\n        \n        if not model_output or model_output == 'None':\n            return None\n        \n        # Simple heuristic parsing\n        model_lower = model_output.lower()\n        \n        # Navigation\n        if 'goto' in model_lower or 'navigate' in model_lower:\n            # Try to extract URL\n            url_match = re.search(r'https?://[^\\s\\'\"]+', model_output)\n            if url_match:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url_match.group(0),\n                    raw_action=model_output\n                )\n        \n        # Click\n        elif 'click' in model_lower:\n            return PlaywrightAction(\n                action_type='click',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Type/Fill\n        elif any(word in model_lower for word in ['type', 'fill', 'input', 'enter']):\n            return PlaywrightAction(\n                action_type='fill',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Store as comment for manual review\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Step: {model_output[:150]}\",\n            raw_action=model_output\n        )\n    \n    def _extract_selector(self, params: dict) -> Optional[str]:\n        \"\"\"Extract selector from action parameters\"\"\"\n        keys_to_check = [\n            'selector', 'index_selector', 'css', 'xpath', \n            'aria', 'text', 'query', 'target', 'element'\n        ]\n        \n        for key in keys_to_check:\n            value = params.get(key)\n            if value and str(value).strip():\n                return str(value).strip()\n        \n        return None\n    \n    def _normalize_locator_name(self, selector: str) -> str:\n        \"\"\"Create a valid Python variable name from selector\"\"\"\n        # Remove special characters\n        name = re.sub(r'[^0-9a-zA-Z_]+', '_', selector).strip('_')\n        # Remove multiple underscores\n        name = re.sub(r'__+', '_', name)\n        # Truncate and ensure it's not empty\n        name = (name[:50] or \"locator\").lower()\n        # Ensure it doesn't start with a number\n        if name[0].isdigit():\n            name = f\"loc_{name}\"\n        return name\n    \n    def extract_locators(self) -> Dict[str, Locator]:\n        \"\"\"Extract reusable locators from actions\"\"\"\n        seen: Dict[str, Locator] = {}\n        \n        for action in self.actions:\n            if not action.selector:\n                continue\n            \n            sel = action.selector.strip()\n            name_base = self._normalize_locator_name(sel)\n            name = name_base\n            idx = 1\n            \n            # Handle duplicates\n            while name in seen:\n                idx += 1\n                name = f\"{name_base}_{idx}\"\n            \n            seen[name] = Locator(\n                name=name,\n                selector=sel,\n                action_examples=[f\"{action.action_type}({action.comment or sel})\"]\n            )\n        \n        self.locators = seen\n        return seen\n    \n    def generate_python_code(self, \n                           use_locators: bool = True,\n                           include_comments: bool = True,\n                           async_style: bool = True) -> str:\n        \"\"\"\n        Generate complete Playwright Python code\n        \n        Args:\n            use_locators: Extract selectors into constants\n            include_comments: Add explanatory comments\n            async_style: Use async/await (recommended)\n            \n        Returns:\n            Complete Python script as string\n        \"\"\"\n        if not self.actions:\n            self.parse_history()\n        \n        if use_locators:\n            self.extract_locators()\n        \n        code_lines = []\n        \n        # Header\n        code_lines.append('\"\"\"')\n        code_lines.append(f'{self.task_description}')\n        code_lines.append('')\n        code_lines.append('Generated from browser-use automation')\n        code_lines.append('To run: python script.py')\n        code_lines.append('\"\"\"')\n        code_lines.append('')\n        \n        # Imports\n        if async_style:\n            code_lines.append('import asyncio')\n        code_lines.append('from playwright.async_api import async_playwright' if async_style else 'from playwright.sync_api import sync_playwright')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Locators section\n        if use_locators and self.locators:\n            code_lines.append('# Locators extracted from automation')\n            for name, locator in self.locators.items():\n                examples = ', '.join(locator.action_examples)[:100]\n                code_lines.append(f'{name.upper()} = r\"{locator.selector}\"  # {examples}')\n            code_lines.append('')\n            code_lines.append('')\n        \n        # Main function\n        if async_style:\n            code_lines.append('async def main():')\n        else:\n            code_lines.append('def main():')\n        \n        code_lines.append('    \"\"\"Main automation function\"\"\"')\n        \n        # Browser setup\n        if async_style:\n            code_lines.append('    async with async_playwright() as p:')\n            code_lines.append('        browser = await p.chromium.launch(headless=False)')\n            code_lines.append('        page = await browser.new_page()')\n            code_lines.append('')\n        else:\n            code_lines.append('    with sync_playwright() as p:')\n            code_lines.append('        browser = p.chromium.launch(headless=False)')\n            code_lines.append('        page = browser.new_page()')\n            code_lines.append('')\n        \n        # Generate actions\n        indent = '        '\n        \n        if include_comments:\n            code_lines.append(f'{indent}# Automation steps')\n        \n        for i, action in enumerate(self.actions, 1):\n            if include_comments and action.comment:\n                code_lines.append(f'{indent}# Step {i}: {action.comment}')\n            \n            if action.action_type == 'navigate' and action.url:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.goto(\"{action.url}\")')\n            \n            elif action.action_type == 'click' and action.selector:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).click()')\n            \n            elif action.action_type == 'fill' and action.selector and action.value:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).fill(\"{action.value}\")')\n            \n            elif action.action_type == 'wait' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout({action.value})')\n            \n            elif action.action_type == 'comment':\n                code_lines.append(f'{indent}# {action.comment}')\n            \n            code_lines.append('')\n        \n        # Pause before closing (optional)\n        if include_comments:\n            code_lines.append(f'{indent}# Pause to review results')\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout(3000)')\n        code_lines.append('')\n        \n        # Cleanup\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}browser.close()')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Runner\n        code_lines.append('if __name__ == \"__main__\":')\n        if async_style:\n            code_lines.append('    asyncio.run(main())')\n        else:\n            code_lines.append('    main()')\n        \n        return '\\n'.join(code_lines)\n    \n    def _get_locator_or_selector(self, selector: str, use_locators: bool) -> str:\n        \"\"\"Get locator constant name or raw selector\"\"\"\n        if not use_locators:\n            return f'\"{selector}\"'\n        \n        # Find matching locator\n        for name, locator in self.locators.items():\n            if locator.selector == selector:\n                return name.upper()\n        \n        # Fallback to raw selector\n        return f'\"{selector}\"'\n    \n    def save_to_file(self, filename: str, **kwargs) -> str:\n        \"\"\"\n        Generate code and save to file\n        \n        Args:\n            filename: Output filename\n            **kwargs: Arguments passed to generate_python_code()\n            \n        Returns:\n            Generated code\n        \"\"\"\n        code = self.generate_python_code(**kwargs)\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(code)\n        \n        return code\n\n\n# Convenience function\ndef generate_playwright_code_from_history(history, \n                                         task_description: str = \"Automated task\",\n                                         output_file: Optional[str] = None) -> str:\n    \"\"\"\n    Quick function to generate Playwright code from browser-use history\n    \n    Args:\n        history: AgentHistoryList from browser-use\n        task_description: What the automation does\n        output_file: Optional file to save code to\n        \n    Returns:\n        Generated Playwright Python code\n        \n    Example:\n        history = await agent.run()\n        code = generate_playwright_code_from_history(history, output_file=\"automation.py\")\n        print(code)\n    \"\"\"\n    generator = PlaywrightCodeGenerator(history, task_description)\n    \n    if output_file:\n        return generator.save_to_file(output_file)\n    \n    return generator.generate_python_code()\n","size_bytes":15060},"app/engines/playwright_mcp/__init__.py":{"content":"\"\"\"\nPlaywright MCP Codebase\nTool-based browser automation using Playwright's Model Context Protocol\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Playwright MCP engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        Tuple of (mcp_client, browser_agent)\n    \"\"\"\n    mcp_client = MCPStdioClient(headless=headless)\n    browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n__all__ = ['MCPStdioClient', 'BrowserAgent', 'create_engine']\n","size_bytes":706},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\nfrom app import create_app\n\n# Force unbuffered output for better logging\nif hasattr(sys.stdout, 'reconfigure'):\n    sys.stdout.reconfigure(line_buffering=True)  # type: ignore\nos.environ['PYTHONUNBUFFERED'] = '1'\n\n# Load .env file and override any existing environment variables\nload_dotenv(override=True)\n\napp = create_app()\n\nif __name__ == '__main__':\n    # IMPORTANT: Do not hardcode API keys in source files. Read from environment.\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    \n    print(\"=\"*80)\n    print(\"üöÄ AI BROWSER AUTOMATION - STARTING UP\")\n    print(\"=\"*80)\n    \n    if not api_key:\n        print(\"\\n‚ö†Ô∏è  WARNING: OPENAI_API_KEY environment variable is not set.\")\n        print(\"   The application will start but AI features will not work.\")\n        print(\"   Please set the OPENAI_API_KEY in your Replit Secrets.\\n\")\n    else:\n        print(f\"‚úÖ API Key found: {api_key[:20]}...{api_key[-4:]}\")\n    \n    sys.stdout.flush()\n\n    print(\"\\nüåê Starting Flask web server on port 5000...\")\n    print(\"=\"*80)\n    print(\"\\nüí° TIP: Keep this console window open to see automation logs\\n\")\n    sys.stdout.flush()\n\n    # Start the web app with debug mode for better console output\n    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)\n","size_bytes":1393},"app/engines/playwright_mcp/mcp_code_generator.py":{"content":"\"\"\"\nPlaywright Code Generator for MCP Tool Calls\nConverts Playwright MCP tool calls into reusable Playwright Python code\n\nUsage:\n    steps = [{\"tool\": \"browser_navigate_to\", \"arguments\": {\"url\": \"...\"}, ...}]\n    generator = MCPCodeGenerator(steps, task_description=\"My task\")\n    code = generator.generate_python_code()\n\"\"\"\n\nimport re\nfrom typing import List, Dict, Optional, Any\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass PlaywrightAction:\n    \"\"\"Represents a single Playwright action\"\"\"\n    action_type: str\n    selector: Optional[str] = None\n    value: Optional[str] = None\n    url: Optional[str] = None\n    comment: Optional[str] = None\n    ref: Optional[str] = None\n\n\nclass MCPCodeGenerator:\n    \"\"\"\n    Generates Playwright Python code from MCP tool call steps\n    \n    Converts tool calls like:\n    - browser_navigate_to ‚Üí page.goto()\n    - browser_click ‚Üí page.locator().click()\n    - browser_fill ‚Üí page.locator().fill()\n    - browser_snapshot ‚Üí page content inspection\n    \"\"\"\n    \n    def __init__(self, steps: List[Dict[str, Any]], task_description: str = \"MCP Automation\"):\n        \"\"\"\n        Initialize code generator\n        \n        Args:\n            steps: List of MCP tool call steps from agent execution\n            task_description: Description of what the automation does\n        \"\"\"\n        self.steps = steps\n        self.task_description = task_description\n        self.actions: List[PlaywrightAction] = []\n        self.locators: Dict[str, str] = {}\n        \n    def parse_steps(self) -> List[PlaywrightAction]:\n        \"\"\"\n        Parse MCP tool call steps and convert to Playwright actions\n        \n        Returns:\n            List of PlaywrightAction objects\n        \"\"\"\n        actions = []\n        \n        for step in self.steps:\n            tool_name = step.get('tool', '')\n            arguments = step.get('arguments', {})\n            success = step.get('success', False)\n            \n            if not success:\n                # Include failed steps as comments for debugging\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment=f\"Failed: {tool_name} - {step.get('error', 'Unknown error')}\"\n                ))\n                continue\n            \n            # Convert MCP tool calls to Playwright actions\n            if 'navigate' in tool_name.lower():\n                url = arguments.get('url', '')\n                if url:\n                    actions.append(PlaywrightAction(\n                        action_type='navigate',\n                        url=url,\n                        comment=f\"Navigate to {url}\"\n                    ))\n            \n            elif 'click' in tool_name.lower():\n                ref = arguments.get('ref')\n                selector = arguments.get('selector')\n                \n                if ref:\n                    # MCP uses element references like \"e1\", \"e2\"\n                    actions.append(PlaywrightAction(\n                        action_type='click',\n                        ref=ref,\n                        comment=f\"Click element [ref={ref}]\"\n                    ))\n                elif selector:\n                    actions.append(PlaywrightAction(\n                        action_type='click',\n                        selector=selector,\n                        comment=f\"Click {selector}\"\n                    ))\n                else:\n                    actions.append(PlaywrightAction(\n                        action_type='comment',\n                        comment=f\"Click action (selector not captured)\"\n                    ))\n            \n            elif 'fill' in tool_name.lower() or 'type' in tool_name.lower():\n                ref = arguments.get('ref')\n                selector = arguments.get('selector')\n                value = arguments.get('value') or arguments.get('text', '')\n                \n                if (ref or selector) and value:\n                    actions.append(PlaywrightAction(\n                        action_type='fill',\n                        selector=selector,\n                        ref=ref,\n                        value=value,\n                        comment=f\"Fill '{value}' into {selector or f'[ref={ref}]'}\"\n                    ))\n                else:\n                    actions.append(PlaywrightAction(\n                        action_type='comment',\n                        comment=f\"Fill action: {value}\"\n                    ))\n            \n            elif 'snapshot' in tool_name.lower():\n                # Snapshot is used for page inspection, convert to wait\n                actions.append(PlaywrightAction(\n                    action_type='wait',\n                    value='1000',\n                    comment='Wait for page state (snapshot taken)'\n                ))\n            \n            elif 'press' in tool_name.lower():\n                key = arguments.get('key', '')\n                actions.append(PlaywrightAction(\n                    action_type='press',\n                    value=key,\n                    comment=f\"Press key: {key}\"\n                ))\n            \n            elif 'scroll' in tool_name.lower():\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment='Scroll action (implement page.evaluate for scrolling)'\n                ))\n            \n            else:\n                # Generic tool call - add as comment\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment=f\"Tool: {tool_name} - {arguments}\"\n                ))\n        \n        self.actions = actions\n        return actions\n    \n    def extract_locators(self) -> Dict[str, str]:\n        \"\"\"\n        Extract reusable locators from actions\n        \n        Returns:\n            Dictionary mapping locator names to selectors\n        \"\"\"\n        seen_selectors = {}\n        counter = 1\n        \n        for action in self.actions:\n            if action.selector:\n                sel = action.selector.strip()\n                if sel and sel not in seen_selectors:\n                    # Create a meaningful locator name\n                    name = self._create_locator_name(sel, action.action_type, counter)\n                    seen_selectors[sel] = name\n                    counter += 1\n        \n        self.locators = seen_selectors\n        return seen_selectors\n    \n    def _create_locator_name(self, selector: str, action_type: str, counter: int) -> str:\n        \"\"\"Create a valid Python variable name from selector\"\"\"\n        # Extract meaningful parts\n        if 'button' in selector.lower():\n            base = 'button'\n        elif 'input' in selector.lower():\n            base = 'input'\n        elif 'text' in selector.lower():\n            base = 'link'\n        elif selector.startswith('#'):\n            base = selector[1:].split('[')[0]\n        elif selector.startswith('.'):\n            base = selector[1:].split('[')[0]\n        else:\n            base = action_type\n        \n        # Clean and format\n        name = re.sub(r'[^0-9a-zA-Z_]+', '_', base).strip('_')\n        name = re.sub(r'__+', '_', name)\n        name = (name[:30] or f\"element_{counter}\").lower()\n        \n        if name[0].isdigit():\n            name = f\"loc_{name}\"\n        \n        return name.upper()\n    \n    def generate_python_code(self,\n                            use_locators: bool = True,\n                            include_comments: bool = True,\n                            async_style: bool = True) -> str:\n        \"\"\"\n        Generate complete Playwright Python code\n        \n        Args:\n            use_locators: Extract selectors into constants\n            include_comments: Add explanatory comments\n            async_style: Use async/await (recommended)\n            \n        Returns:\n            Complete Python script as string\n        \"\"\"\n        if not self.actions:\n            self.parse_steps()\n        \n        if use_locators:\n            self.extract_locators()\n        \n        code_lines = []\n        \n        # Header\n        code_lines.append('\"\"\"')\n        code_lines.append(f'{self.task_description}')\n        code_lines.append('')\n        code_lines.append('Generated from Playwright MCP automation')\n        code_lines.append('To run: python script.py')\n        code_lines.append('\"\"\"')\n        code_lines.append('')\n        \n        # Imports\n        if async_style:\n            code_lines.append('import asyncio')\n        code_lines.append('from playwright.async_api import async_playwright' if async_style else 'from playwright.sync_api import sync_playwright')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Locators section\n        if use_locators and self.locators:\n            code_lines.append('# Locators extracted from MCP automation')\n            for selector, name in self.locators.items():\n                code_lines.append(f'{name} = r\"{selector}\"')\n            code_lines.append('')\n            code_lines.append('')\n        \n        # Main function\n        if async_style:\n            code_lines.append('async def main():')\n        else:\n            code_lines.append('def main():')\n        \n        code_lines.append('    \"\"\"Main automation function\"\"\"')\n        \n        # Browser setup\n        if async_style:\n            code_lines.append('    async with async_playwright() as p:')\n            code_lines.append('        browser = await p.chromium.launch(headless=False)')\n            code_lines.append('        page = await browser.new_page()')\n            code_lines.append('')\n        else:\n            code_lines.append('    with sync_playwright() as p:')\n            code_lines.append('        browser = p.chromium.launch(headless=False)')\n            code_lines.append('        page = browser.new_page()')\n            code_lines.append('')\n        \n        # Generate actions\n        indent = '        '\n        \n        if include_comments:\n            code_lines.append(f'{indent}# Automation steps')\n        \n        for i, action in enumerate(self.actions, 1):\n            if include_comments and action.comment:\n                code_lines.append(f'{indent}# Step {i}: {action.comment}')\n            \n            if action.action_type == 'navigate' and action.url:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.goto(\"{action.url}\")')\n            \n            elif action.action_type == 'click':\n                if action.selector:\n                    selector = self._get_locator_or_selector(action.selector, use_locators)\n                    code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).click()')\n                elif action.ref:\n                    code_lines.append(f'{indent}# Click element by reference (convert to specific selector)')\n                    code_lines.append(f'{indent}# Original ref: {action.ref}')\n            \n            elif action.action_type == 'fill':\n                if action.selector:\n                    selector = self._get_locator_or_selector(action.selector, use_locators)\n                    code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).fill(\"{action.value}\")')\n                elif action.ref:\n                    code_lines.append(f'{indent}# Fill element by reference (convert to specific selector)')\n                    code_lines.append(f'{indent}# Value: {action.value}, ref: {action.ref}')\n            \n            elif action.action_type == 'press' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.keyboard.press(\"{action.value}\")')\n            \n            elif action.action_type == 'wait' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout({action.value})')\n            \n            elif action.action_type == 'comment':\n                code_lines.append(f'{indent}# {action.comment}')\n            \n            code_lines.append('')\n        \n        # Pause before closing\n        if include_comments:\n            code_lines.append(f'{indent}# Pause to review results')\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout(3000)')\n        code_lines.append('')\n        \n        # Cleanup\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}browser.close()')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Runner\n        code_lines.append('if __name__ == \"__main__\":')\n        if async_style:\n            code_lines.append('    asyncio.run(main())')\n        else:\n            code_lines.append('    main()')\n        \n        return '\\n'.join(code_lines)\n    \n    def _get_locator_or_selector(self, selector: str, use_locators: bool) -> str:\n        \"\"\"Get locator constant name or raw selector\"\"\"\n        if not use_locators or selector not in self.locators:\n            return f'\"{selector}\"'\n        \n        return self.locators[selector]\n    \n    def save_to_file(self, filename: str, **kwargs) -> str:\n        \"\"\"\n        Generate code and save to file\n        \n        Args:\n            filename: Output filename\n            **kwargs: Arguments passed to generate_python_code()\n            \n        Returns:\n            Generated code\n        \"\"\"\n        code = self.generate_python_code(**kwargs)\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(code)\n        \n        return code\n\n\ndef generate_playwright_code_from_mcp_steps(\n    steps: List[Dict[str, Any]],\n    task_description: str = \"MCP Automation\",\n    output_file: Optional[str] = None\n) -> str:\n    \"\"\"\n    Quick function to generate Playwright code from MCP steps\n    \n    Args:\n        steps: List of MCP tool call steps\n        task_description: What the automation does\n        output_file: Optional file to save code to\n        \n    Returns:\n        Generated Playwright Python code\n        \n    Example:\n        result = agent.execute_instruction(\"Go to Google\")\n        code = generate_playwright_code_from_mcp_steps(\n            result['steps'],\n            task_description=\"Google navigation\",\n            output_file=\"google_nav.py\"\n        )\n    \"\"\"\n    generator = MCPCodeGenerator(steps, task_description)\n    \n    if output_file:\n        return generator.save_to_file(output_file)\n    \n    return generator.generate_python_code()\n","size_bytes":14429},"app/services/engine_orchestrator.py":{"content":"\"\"\"\nEngine Orchestrator\nManages and coordinates all browser automation engines\n\"\"\"\nfrom typing import Dict, Any, Tuple, Optional\nimport logging\nimport app.engines.playwright_mcp as playwright_mcp_codebase\nimport app.engines.browser_use as browser_use_codebase\nfrom app.middleware.security import sanitize_error_message\n\nlogger = logging.getLogger(__name__)\n\n\nclass EngineOrchestrator:\n    \"\"\"\n    Orchestrates browser automation engines (Playwright MCP and Browser-Use)\n    Handles engine instantiation, caching, and execution delegation\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the orchestrator with empty engine caches\"\"\"\n        self.playwright_engines = {}\n        self.browser_use_engines = {}\n    \n    def get_playwright_engine(self, headless: bool) -> Tuple[Any, Any]:\n        \"\"\"\n        Get or create Playwright MCP engine instance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            Tuple of (mcp_client, browser_agent)\n        \"\"\"\n        if headless not in self.playwright_engines:\n            mcp_client, browser_agent = playwright_mcp_codebase.create_engine(headless=headless)\n            self.playwright_engines[headless] = (mcp_client, browser_agent)\n        \n        return self.playwright_engines[headless]\n    \n    def get_browser_use_engine(self, headless: bool):\n        \"\"\"\n        Get or create Browser-Use engine instance\n        Caches instances per headless mode for better performance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            BrowserUseEngine instance\n        \"\"\"\n        if headless not in self.browser_use_engines:\n            self.browser_use_engines[headless] = browser_use_codebase.create_engine(headless=headless)\n        \n        return self.browser_use_engines[headless]\n    \n    def execute_instruction(self, instruction: str, engine_type: str, headless: bool) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction using the specified engine\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Run in headless mode\n            \n        Returns:\n            Execution result dictionary\n        \"\"\"\n        valid_engines = ['playwright_mcp', 'browser_use']\n        if engine_type not in valid_engines:\n            logger.error(f\"Invalid engine type: {engine_type}\")\n            return {\n                'success': False,\n                'error': f\"Invalid engine type: {engine_type}. Must be one of: {', '.join(valid_engines)}\",\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n        \n        result = None\n        try:\n            if engine_type == 'playwright_mcp':\n                client, agent = self.get_playwright_engine(headless)\n                \n                try:\n                    if not client.initialized:\n                        logger.info(\"Initializing Playwright MCP client...\")\n                        client.initialize()\n                    \n                    result = agent.execute_instruction(instruction)\n                except Exception as e:\n                    logger.error(f\"Playwright MCP error: {str(e)}, attempting to reinitialize\")\n                    self._reset_playwright_engine(headless)\n                    raise\n                \n            elif engine_type == 'browser_use':\n                engine = self.get_browser_use_engine(headless)\n                result = engine.execute_instruction_sync(instruction)\n            \n            if result is not None:\n                result['engine'] = engine_type\n                result['headless'] = headless\n                return result\n            else:\n                raise ValueError(\"Engine returned no result\")\n            \n        except Exception as e:\n            logger.error(f\"Engine execution error ({engine_type}): {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n    \n    def _reset_playwright_engine(self, headless: bool):\n        \"\"\"\n        Reset Playwright engine if it crashes or becomes unresponsive\n        \n        Args:\n            headless: Headless mode setting\n        \"\"\"\n        if headless in self.playwright_engines:\n            logger.warning(f\"Resetting Playwright engine (headless={headless})\")\n            try:\n                client, _ = self.playwright_engines[headless]\n                if hasattr(client, 'cleanup'):\n                    client.cleanup()\n            except Exception as e:\n                logger.error(f\"Error during Playwright cleanup: {str(e)}\")\n            finally:\n                del self.playwright_engines[headless]\n    \n    def get_tools(self, engine_type: str) -> list:\n        \"\"\"\n        Get available tools for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            \n        Returns:\n            List of available tools\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            client, _ = self.get_playwright_engine(headless=True)\n            \n            if not client.initialized:\n                client.initialize()\n            \n            return client.list_tools()\n        else:\n            return [\n                {'name': 'browser_use_agent', 'description': 'AI-powered browser automation'}\n            ]\n    \n    def cleanup_after_timeout(self, engine_type: str, headless: bool):\n        \"\"\"\n        Clean up resources after a timed-out execution\n        \n        Args:\n            engine_type: Engine that was executing when timeout occurred\n            headless: Headless mode setting\n        \"\"\"\n        logger.warning(f\"Cleaning up after timeout for {engine_type} (headless={headless})\")\n        \n        try:\n            if engine_type == 'playwright_mcp':\n                self._reset_playwright_engine(headless)\n        except Exception as e:\n            logger.error(f\"Error during timeout cleanup: {str(e)}\")\n    \n    def reset_agent(self, engine_type: str, headless: bool = True):\n        \"\"\"\n        Reset the conversation history for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Headless mode (for Playwright MCP)\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            _, agent = self.get_playwright_engine(headless)\n            agent.reset_conversation()\n","size_bytes":6807},"tests/__init__.py":{"content":"","size_bytes":0},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.5.9\",\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=2.6.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pytest>=8.4.2\",\n    \"pytest-cov>=7.0.0\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":508},"app/utils/__init__.py":{"content":"\"\"\"Utilities package\"\"\"\n","size_bytes":24}},"version":2}