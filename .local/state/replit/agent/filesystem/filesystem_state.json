{"file_contents":{"app/middleware/security.py":{"content":"\"\"\"\nSecurity Middleware\nAuthentication, rate limiting, and security utilities\n\"\"\"\nimport os\nimport time\nimport logging\nfrom functools import wraps\nfrom flask import request, jsonify\nfrom typing import Dict, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self, max_requests: int = 10, window_seconds: int = 60):\n        \"\"\"\n        Initialize rate limiter\n        \n        Args:\n            max_requests: Maximum requests allowed in the time window\n            window_seconds: Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests: Dict[str, list] = {}\n    \n    def is_allowed(self, client_id: str) -> Tuple[bool, Optional[int]]:\n        \"\"\"\n        Check if request is allowed for client\n        \n        Args:\n            client_id: Unique identifier for the client\n            \n        Returns:\n            Tuple of (is_allowed, retry_after_seconds)\n        \"\"\"\n        now = time.time()\n        \n        if client_id not in self.requests:\n            self.requests[client_id] = []\n        \n        requests = self.requests[client_id]\n        requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n        \n        if len(requests) >= self.max_requests:\n            oldest_request = min(requests)\n            retry_after = int(self.window_seconds - (now - oldest_request)) + 1\n            return False, retry_after\n        \n        requests.append(now)\n        self.requests[client_id] = requests\n        \n        self._cleanup_old_entries(now)\n        \n        return True, None\n    \n    def _cleanup_old_entries(self, now: float):\n        \"\"\"Clean up old entries to prevent memory bloat\"\"\"\n        clients_to_remove = []\n        for client_id, requests in self.requests.items():\n            active_requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n            if not active_requests:\n                clients_to_remove.append(client_id)\n            else:\n                self.requests[client_id] = active_requests\n        \n        for client_id in clients_to_remove:\n            del self.requests[client_id]\n\n\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n\n\ndef require_api_key(f):\n    \"\"\"\n    Decorator to require API key authentication\n    \n    Checks for API key in:\n    1. X-API-Key header\n    2. api_key query parameter\n    \n    Set API_KEY environment variable to enable authentication.\n    If API_KEY is not set, authentication is disabled (development mode).\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        expected_api_key = os.environ.get('API_KEY')\n        \n        if not expected_api_key:\n            logger.warning(\"âš ï¸  API_KEY not set - authentication disabled (development mode)\")\n            return f(*args, **kwargs)\n        \n        provided_api_key = request.headers.get('X-API-Key') or request.args.get('api_key')\n        \n        if not provided_api_key:\n            logger.warning(f\"ðŸ”’ Unauthorized request from {request.remote_addr} - no API key provided\")\n            return jsonify({\n                'success': False,\n                'error': 'Authentication required',\n                'message': 'Please provide an API key via X-API-Key header or api_key parameter'\n            }), 401\n        \n        if provided_api_key != expected_api_key:\n            logger.warning(f\"ðŸ”’ Unauthorized request from {request.remote_addr} - invalid API key\")\n            return jsonify({\n                'success': False,\n                'error': 'Invalid API key'\n            }), 403\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef rate_limit(f):\n    \"\"\"\n    Decorator to apply rate limiting\n    \n    Uses IP address as client identifier\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        client_id = request.remote_addr or 'unknown'\n        \n        allowed, retry_after = rate_limiter.is_allowed(client_id)\n        \n        if not allowed:\n            logger.warning(f\"âš ï¸  Rate limit exceeded for {client_id}\")\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded',\n                'message': f'Too many requests. Please try again in {retry_after} seconds.',\n                'retry_after': retry_after\n            }), 429\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef validate_engine_type(engine_type: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate engine type parameter\n    \n    Args:\n        engine_type: Engine type to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    valid_engines = ['browser_use', 'playwright_mcp']\n    \n    if engine_type not in valid_engines:\n        return False, f\"Invalid engine type '{engine_type}'. Must be one of: {', '.join(valid_engines)}\"\n    \n    return True, None\n\n\ndef validate_instruction(instruction: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate instruction parameter\n    \n    Args:\n        instruction: Instruction to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not instruction or not instruction.strip():\n        return False, \"Instruction cannot be empty\"\n    \n    if len(instruction) > 5000:\n        return False, \"Instruction is too long (maximum 5000 characters)\"\n    \n    return True, None\n\n\ndef sanitize_error_message(error: Exception) -> str:\n    \"\"\"\n    Convert internal exception to user-safe error message\n    \n    Args:\n        error: Exception to sanitize\n        \n    Returns:\n        User-safe error message\n    \"\"\"\n    error_str = str(error).lower()\n    \n    if 'openai' in error_str or 'api' in error_str:\n        return \"AI service error. Please try again later.\"\n    \n    if 'browser' in error_str or 'playwright' in error_str:\n        return \"Browser automation error. Please try again.\"\n    \n    if 'timeout' in error_str:\n        return \"Operation timed out. The task took too long to complete.\"\n    \n    if 'permission' in error_str or 'denied' in error_str:\n        return \"Permission denied. Please check your access rights.\"\n    \n    return \"An unexpected error occurred. Please try again.\"\n","size_bytes":6336},"app/services/__init__.py":{"content":"\"\"\"\nFlask Services Module\n\"\"\"\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n__all__ = ['EngineOrchestrator']\n","size_bytes":128},"app/routes/api.py":{"content":"\"\"\"\nAPI Routes\nRESTful endpoints for browser automation with security and validation\n\"\"\"\nimport os\nimport logging\nfrom flask import Blueprint, render_template, request, jsonify\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.middleware.security import (\n    require_api_key,\n    rate_limit,\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\nfrom app.utils.timeout import run_with_timeout, TimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_api_routes(orchestrator: EngineOrchestrator) -> Blueprint:\n    \"\"\"\n    Create API routes blueprint\n    \n    Args:\n        orchestrator: Engine orchestrator instance\n        \n    Returns:\n        Flask Blueprint with all routes\n    \"\"\"\n    api = Blueprint('api', __name__)\n    \n    @api.route('/')\n    def index():\n        \"\"\"Render main page\"\"\"\n        return render_template('index.html')\n    \n    @api.route('/api/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            instruction = data.get('instruction', '').strip()\n            engine_type = data.get('engine', 'browser_use')\n            headless = data.get('headless', False)\n\n            print(instruction,engine_type)\n            \n            is_valid, error_msg = validate_instruction(instruction)\n            if not is_valid:\n                logger.warning(f\"âš ï¸  Invalid instruction: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid instruction',\n                    'message': error_msg\n                }), 400\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                logger.warning(f\"âš ï¸  Invalid engine type: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            if not isinstance(headless, bool):\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid parameter',\n                    'message': 'headless must be a boolean'\n                }), 400\n            \n            logger.info(\"=\"*80)\n            logger.info(\"ðŸ“¨ NEW AUTOMATION REQUEST\")\n            logger.info(f\"ðŸ“ Instruction: {instruction}\")\n            logger.info(f\"ðŸ”§ Engine: {engine_type}\")\n            logger.info(f\"ðŸ‘ï¸  Headless: {headless}\")\n            logger.info(f\"ðŸŒ Client: {request.remote_addr}\")\n            logger.info(\"=\"*80)\n            \n            logger.info(\"ðŸš€ Starting automation execution...\")\n            \n            try:\n                result = run_with_timeout(\n                    orchestrator.execute_instruction,\n                    300,\n                    instruction,\n                    engine_type,\n                    headless\n                )\n            except TimeoutError as e:\n                logger.error(f\"â±ï¸  Automation timed out: {str(e)}\")\n                orchestrator.cleanup_after_timeout(engine_type, headless)\n                return jsonify({\n                    'success': False,\n                    'error': 'Timeout',\n                    'message': 'Operation timed out. The task took longer than 5 minutes to complete.',\n                    'timeout': True\n                }), 408\n            \n            if result.get('success'):\n                logger.info(f\"âœ… Automation completed successfully in {result.get('iterations', 0)} steps\")\n            else:\n                logger.error(f\"âŒ Automation failed: {result.get('error', 'Unknown error')}\")\n            \n            logger.info(\"=\"*80)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Exception in execute_instruction: {str(e)}\", exc_info=True)\n            \n            user_message = sanitize_error_message(e)\n            \n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': user_message\n            }), 500\n    \n    @api.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            engine_type = request.args.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            tools = orchestrator.get_tools(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'tools': tools,\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting tools: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/reset', methods=['POST'])\n    @require_api_key\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_type = data.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            orchestrator.reset_agent(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully',\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error resetting agent: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            return jsonify({\n                'status': 'healthy',\n                'engines': {\n                    'browser_use': 'available',\n                    'playwright_mcp': 'available'\n                },\n                'message': 'AI browser automation ready',\n                'security': {\n                    'authentication': 'enabled' if os.environ.get('API_KEY') else 'disabled',\n                    'rate_limiting': 'enabled'\n                }\n            })\n        except Exception as e:\n            logger.error(f\"Health check failed: {str(e)}\", exc_info=True)\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Service unavailable'\n            }), 503\n    \n    return api\n","size_bytes":7501},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.5.9\",\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=2.6.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pytest>=8.4.2\",\n    \"pytest-cov>=7.0.0\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":508},"app/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\nconst engineSelect = document.getElementById('engine-select');\nconst headlessToggle = document.getElementById('headless-toggle');\nconst statusBadge = document.getElementById('status-badge');\nconst currentEngineDisplay = document.getElementById('current-engine');\nconst currentModeDisplay = document.getElementById('current-mode');\n\n// Update footer display when engine or mode changes\nfunction updateFooterDisplay() {\n    const engineText = engineSelect.value === 'browser_use' ? 'Browser-Use' : 'Playwright MCP';\n    const modeText = headlessToggle.checked ? 'Headless' : 'Headful';\n    \n    currentEngineDisplay.textContent = engineText;\n    currentModeDisplay.textContent = modeText;\n}\n\n// Initialize\nengineSelect.addEventListener('change', updateFooterDisplay);\nheadlessToggle.addEventListener('change', updateFooterDisplay);\nupdateFooterDisplay();\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    const engine = engineSelect.value;\n    const headless = headlessToggle.checked;\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    showStatusBadge('running', 'Processing...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ \n                instruction,\n                engine,\n                headless\n            }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `âœ… Completed in ${data.iterations} iteration(s) using ${data.engine}`);\n            showStatusBadge('success', 'Completed');\n            displayResults(data);\n        } else {\n            showStatus('error', `âŒ Error: ${data.error || 'Unknown error'}`);\n            showStatusBadge('error', 'Failed');\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `âŒ Failed to execute: ${error.message}`);\n        showStatusBadge('error', 'Failed');\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history and browser state.')) {\n        return;\n    }\n    \n    const engine = engineSelect.value;\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ engine }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', 'âœ… Agent reset successfully');\n            showStatusBadge('', '');\n            resultsDiv.innerHTML = '<div class=\"empty-state\"><div class=\"empty-icon\">ðŸš€</div><p>Enter an instruction and click Execute to begin automation</p></div>';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `âŒ Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `âŒ Failed to reset: ${error.message}`);\n    }\n});\n\n// Example buttons\ndocument.querySelectorAll('.example-btn').forEach(btn => {\n    btn.addEventListener('click', () => {\n        instructionInput.value = btn.dataset.instruction;\n        instructionInput.focus();\n    });\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction showStatusBadge(type, text) {\n    statusBadge.className = `status-badge ${type}`;\n    statusBadge.textContent = text;\n    statusBadge.style.display = text ? 'block' : 'none';\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.style.cssText = 'background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 16px; border-radius: 8px; margin-top: 16px; font-weight: 500; color: #0c4a6e;';\n        messageEl.innerHTML = `<strong>Final Result:</strong> ${data.message}`;\n        resultsDiv.appendChild(messageEl);\n    }\n    \n    // Display engine info\n    const engineInfo = document.createElement('div');\n    engineInfo.style.cssText = 'margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; font-size: 0.9rem; color: #666;';\n    engineInfo.innerHTML = `<strong>Engine:</strong> ${data.engine || 'unknown'} | <strong>Mode:</strong> ${data.headless ? 'Headless' : 'Headful'}`;\n    resultsDiv.appendChild(engineInfo);\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? 'âœ“ Success' : 'âœ— Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `ðŸ”§ Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.textContent = `âŒ Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'ðŸ“„ View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            console.log('Application is healthy and ready');\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":8901},"app/utils/timeout.py":{"content":"\"\"\"\nCross-platform timeout utility\nWorks on Windows, Linux, and macOS with proper cancellation\n\"\"\"\nimport threading\nimport logging\nfrom typing import Callable, Any, Optional\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeoutError(Exception):\n    \"\"\"Raised when operation times out\"\"\"\n    pass\n\n\ndef run_with_timeout(func: Callable, timeout_seconds: int, *args, **kwargs) -> Any:\n    \"\"\"\n    Run a function with a timeout (cross-platform)\n    \n    Note: This implementation returns promptly on timeout but cannot\n    forcefully terminate the underlying function if it's stuck. The\n    worker thread continues in the background but HTTP request returns.\n    \n    Args:\n        func: Function to execute\n        timeout_seconds: Timeout in seconds\n        *args: Positional arguments to pass to func\n        **kwargs: Keyword arguments to pass to func\n        \n    Returns:\n        Result from func\n        \n    Raises:\n        TimeoutError: If function execution exceeds timeout\n    \"\"\"\n    executor = ThreadPoolExecutor(max_workers=1)\n    future = executor.submit(func, *args, **kwargs)\n    \n    try:\n        result = future.result(timeout=timeout_seconds)\n        executor.shutdown(wait=False)\n        return result\n    except FutureTimeoutError:\n        logger.warning(f\"â±ï¸ Operation timed out after {timeout_seconds} seconds\")\n        future.cancel()\n        executor.shutdown(wait=False)\n        raise TimeoutError(f\"Operation timed out after {timeout_seconds} seconds\")\n    except Exception as e:\n        logger.error(f\"âŒ Error during timed execution: {str(e)}\")\n        executor.shutdown(wait=False)\n        raise\n","size_bytes":1714},"browser_use_codebase/popup_handler.py":{"content":"\"\"\"\nEnhanced Popup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows with advanced features\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Enhanced popup window handler with advanced detection and management\n    Features:\n    - Automatic popup detection and switching\n    - Configurable timeouts\n    - Detailed logging and tracking\n    - Multi-popup orchestration\n    - Popup priority rules\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext, popup_timeout: int = 10000, \n                 auto_switch: bool = True, log_verbose: bool = True):\n        \"\"\"\n        Initialize the enhanced popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n            popup_timeout: Timeout in milliseconds for popup operations (default: 10000ms)\n            auto_switch: Automatically switch to new popups (default: True)\n            log_verbose: Enable detailed logging (default: True)\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        self.popup_timeout = popup_timeout\n        self.auto_switch = auto_switch\n        self.log_verbose = log_verbose\n        \n        self.popup_history: List[Dict[str, Any]] = []\n        self.popup_count = 0\n        \n        context.on(\"page\", self._on_new_page)\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ” Enhanced popup handler initialized (timeout: {popup_timeout}ms, auto_switch: {auto_switch})\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Enhanced event handler for new pages/windows with tracking\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        self.popup_count += 1\n        popup_info = {\n            \"popup_number\": self.popup_count,\n            \"url\": page.url or \"about:blank\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"auto_switched\": self.auto_switch\n        }\n        \n        self.popup_history.append(popup_info)\n        self.new_pages.append(page)\n        self.popup_detected = True\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ†• Popup #{self.popup_count} detected: {popup_info['url']}\")\n            logger.info(f\"ðŸ“Š Total popups opened: {self.popup_count}\")\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page with enhanced timeout handling\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages and self.auto_switch:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=self.popup_timeout)\n                \n                if self.log_verbose:\n                    logger.info(f\"âœ… Switched to popup window: {latest_page.url}\")\n                \n                return latest_page\n            except Exception as e:\n                logger.warning(f\"âš ï¸ Popup not ready within {self.popup_timeout}ms: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    async def wait_for_popup(self, timeout: Optional[int] = None) -> Optional[Page]:\n        \"\"\"\n        Wait for a popup to appear\n        \n        Args:\n            timeout: Optional custom timeout in milliseconds\n            \n        Returns:\n            New popup page or None if timeout\n        \"\"\"\n        wait_timeout = timeout or self.popup_timeout\n        start_time = datetime.now()\n        \n        while (datetime.now() - start_time).total_seconds() * 1000 < wait_timeout:\n            if self.new_pages:\n                new_page = self.new_pages[-1]\n                if self.log_verbose:\n                    logger.info(f\"âœ… Popup appeared: {new_page.url}\")\n                return new_page\n            await asyncio.sleep(0.1)\n        \n        logger.warning(f\"â±ï¸  No popup appeared within {wait_timeout}ms\")\n        return None\n    \n    def get_popup_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about popup handling\n        \n        Returns:\n            Dictionary with popup statistics\n        \"\"\"\n        return {\n            \"total_popups\": self.popup_count,\n            \"active_popups\": len(self.new_pages),\n            \"popup_history\": self.popup_history,\n            \"auto_switch_enabled\": self.auto_switch,\n            \"timeout_ms\": self.popup_timeout\n        }\n    \n    def reset(self):\n        \"\"\"Reset the handler state with enhanced logging\"\"\"\n        previous_count = self.popup_count\n        self.new_pages.clear()\n        self.popup_detected = False\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ”„ Popup handler reset (processed {previous_count} popups this session)\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":5279},"test_engines.py":{"content":"\"\"\"\nEngine Test Script\nTests if the engines can initialize properly with your API key\nRun this BEFORE starting the web app to verify everything works\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\n\nprint(\"=\" * 60)\nprint(\"Engine Initialization Test\")\nprint(\"=\" * 60)\n\n# Step 1: Load .env file\nprint(\"\\n[Step 1] Loading .env file...\")\nif not os.path.exists('.env'):\n    print(\"âŒ FATAL ERROR: .env file not found!\")\n    print(\"   You must create a .env file in this directory\")\n    print(\"   Run: copy .env.example .env\")\n    print(\"   Then edit .env and add your API key\")\n    sys.exit(1)\n\nload_dotenv(override=True)\napi_key = os.environ.get('OPENAI_API_KEY')\n\nif not api_key:\n    print(\"âŒ FATAL ERROR: OPENAI_API_KEY not found in .env file!\")\n    print(\"   Open your .env file and make sure it contains:\")\n    print(\"   OPENAI_API_KEY=sk-your-actual-key-here\")\n    sys.exit(1)\n\nmasked_key = api_key[:10] + \"...\" + api_key[-4:] if len(api_key) > 14 else \"***\"\nprint(f\"âœ… API key loaded: {masked_key}\")\n\n# Step 2: Test Browser-Use engine initialization\nprint(\"\\n[Step 2] Testing Browser-Use engine...\")\ntry:\n    from browser_use_codebase.engine import BrowserUseEngine\n    engine = BrowserUseEngine(headless=True)\n    print(\"âœ… Browser-Use engine initialized successfully!\")\nexcept Exception as e:\n    print(f\"âŒ Browser-Use engine FAILED: {str(e)}\")\n    print(\"\\nThis is the exact error the web app will show!\")\n    sys.exit(1)\n\n# Step 3: Test Playwright MCP engine initialization\nprint(\"\\n[Step 3] Testing Playwright MCP engine...\")\ntry:\n    from playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n    from playwright_mcp_codebase.client.stdio_client import MCPStdioClient\n    \n    # Don't actually initialize the client, just test the agent can be created\n    client = MCPStdioClient(headless=True)\n    agent = BrowserAgent(client)\n    print(\"âœ… Playwright MCP engine initialized successfully!\")\nexcept Exception as e:\n    print(f\"âŒ Playwright MCP engine FAILED: {str(e)}\")\n    print(\"\\nThis is the exact error the web app will show!\")\n    sys.exit(1)\n\n# Step 4: Success!\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ðŸŽ‰ SUCCESS! All engines initialized correctly!\")\nprint(\"=\" * 60)\nprint(\"\\nYour setup is correct. You can now run:\")\nprint(\"  python main.py\")\nprint(\"\\nThe web application should work without API key errors.\")\nprint(\"=\" * 60)\n","size_bytes":2366},"browser_use_codebase/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"app/services/engine_orchestrator.py":{"content":"\"\"\"\nEngine Orchestrator\nManages and coordinates all browser automation engines\n\"\"\"\nfrom typing import Dict, Any, Tuple, Optional\nimport logging\nimport app.engines.playwright_mcp as playwright_mcp_codebase\nimport app.engines.browser_use as browser_use_codebase\nfrom app.middleware.security import sanitize_error_message\n\nlogger = logging.getLogger(__name__)\n\n\nclass EngineOrchestrator:\n    \"\"\"\n    Orchestrates browser automation engines (Playwright MCP and Browser-Use)\n    Handles engine instantiation, caching, and execution delegation\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the orchestrator with empty engine caches\"\"\"\n        self.playwright_engines = {}\n        self.browser_use_engines = {}\n    \n    def get_playwright_engine(self, headless: bool) -> Tuple[Any, Any]:\n        \"\"\"\n        Get or create Playwright MCP engine instance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            Tuple of (mcp_client, browser_agent)\n        \"\"\"\n        if headless not in self.playwright_engines:\n            mcp_client, browser_agent = playwright_mcp_codebase.create_engine(headless=headless)\n            self.playwright_engines[headless] = (mcp_client, browser_agent)\n        \n        return self.playwright_engines[headless]\n    \n    def get_browser_use_engine(self, headless: bool):\n        \"\"\"\n        Get or create Browser-Use engine instance\n        Caches instances per headless mode for better performance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            BrowserUseEngine instance\n        \"\"\"\n        if headless not in self.browser_use_engines:\n            self.browser_use_engines[headless] = browser_use_codebase.create_engine(headless=headless)\n        \n        return self.browser_use_engines[headless]\n    \n    def execute_instruction(self, instruction: str, engine_type: str, headless: bool) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction using the specified engine\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Run in headless mode\n            \n        Returns:\n            Execution result dictionary\n        \"\"\"\n        valid_engines = ['playwright_mcp', 'browser_use']\n        if engine_type not in valid_engines:\n            logger.error(f\"Invalid engine type: {engine_type}\")\n            return {\n                'success': False,\n                'error': f\"Invalid engine type: {engine_type}. Must be one of: {', '.join(valid_engines)}\",\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n        \n        result = None\n        try:\n            if engine_type == 'playwright_mcp':\n                client, agent = self.get_playwright_engine(headless)\n                \n                try:\n                    if not client.initialized:\n                        logger.info(\"Initializing Playwright MCP client...\")\n                        client.initialize()\n                    \n                    result = agent.execute_instruction(instruction)\n                except Exception as e:\n                    logger.error(f\"Playwright MCP error: {str(e)}, attempting to reinitialize\")\n                    self._reset_playwright_engine(headless)\n                    raise\n                \n            elif engine_type == 'browser_use':\n                engine = self.get_browser_use_engine(headless)\n                result = engine.execute_instruction_sync(instruction)\n            \n            if result is not None:\n                result['engine'] = engine_type\n                result['headless'] = headless\n                return result\n            else:\n                raise ValueError(\"Engine returned no result\")\n            \n        except Exception as e:\n            logger.error(f\"Engine execution error ({engine_type}): {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n    \n    def _reset_playwright_engine(self, headless: bool):\n        \"\"\"\n        Reset Playwright engine if it crashes or becomes unresponsive\n        \n        Args:\n            headless: Headless mode setting\n        \"\"\"\n        if headless in self.playwright_engines:\n            logger.warning(f\"Resetting Playwright engine (headless={headless})\")\n            try:\n                client, _ = self.playwright_engines[headless]\n                if hasattr(client, 'cleanup'):\n                    client.cleanup()\n            except Exception as e:\n                logger.error(f\"Error during Playwright cleanup: {str(e)}\")\n            finally:\n                del self.playwright_engines[headless]\n    \n    def get_tools(self, engine_type: str) -> list:\n        \"\"\"\n        Get available tools for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            \n        Returns:\n            List of available tools\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            client, _ = self.get_playwright_engine(headless=True)\n            \n            if not client.initialized:\n                client.initialize()\n            \n            return client.list_tools()\n        else:\n            return [\n                {'name': 'browser_use_agent', 'description': 'AI-powered browser automation'}\n            ]\n    \n    def cleanup_after_timeout(self, engine_type: str, headless: bool):\n        \"\"\"\n        Clean up resources after a timed-out execution\n        \n        Args:\n            engine_type: Engine that was executing when timeout occurred\n            headless: Headless mode setting\n        \"\"\"\n        logger.warning(f\"Cleaning up after timeout for {engine_type} (headless={headless})\")\n        \n        try:\n            if engine_type == 'playwright_mcp':\n                self._reset_playwright_engine(headless)\n        except Exception as e:\n            logger.error(f\"Error during timeout cleanup: {str(e)}\")\n    \n    def reset_agent(self, engine_type: str, headless: bool = True):\n        \"\"\"\n        Reset the conversation history for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Headless mode (for Playwright MCP)\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            _, agent = self.get_playwright_engine(headless)\n            agent.reset_conversation()\n","size_bytes":6807},"playwright_mcp_codebase/agent/conversation_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom pathlib import Path\nfrom typing import List, Dict, Any\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,\n                    tools=tools,\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name\n                        tool_args = json.loads(tool_call.function.arguments)\n                        \n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6087},"browser_use_codebase/engine.py":{"content":"\"\"\"\nBrowser-Use Engine\nAI-powered browser automation using browser-use library\n\nThread Safety Notes:\n- This engine creates a fresh Browser instance per request\n- Each request runs on its own event loop to ensure thread safety\n- Browser instances are NOT cached to prevent asyncio loop affinity issues\n- Memory is cleaned up after each request via finally block\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List\nfrom dotenv import load_dotenv\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BrowserUseEngine:\n    \"\"\"\n    Browser automation engine using browser-use library\n    \n    Thread Safety: This engine is designed for Flask's multi-threaded environment.\n    Each request creates its own event loop and browser instance, which are\n    properly cleaned up after execution.\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        \n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n    \n    async def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        try:\n            logger.info(\"ðŸ¤– Initializing Browser-Use Agent\")\n            logger.info(f\"ðŸ“‹ Task: {instruction}\")\n            logger.info(f\"ðŸ”¢ Max steps: {self.max_steps}\")\n            \n            # Custom system message to ensure literal execution and popup handling\n            # Includes intelligent stopping mechanism (inspired by browser-use PR #61)\n            system_instructions = f\"\"\"\nCRITICAL INSTRUCTIONS - KEEP RESPONSES BRIEF:\n1. Follow the user's instruction LITERALLY - do only what is explicitly asked\n2. STOP IMMEDIATELY once the stated task is complete\n3. Do NOT extract, save, or compile data unless explicitly requested\n4. Do NOT perform additional \"helpful\" actions beyond the instruction\n5. If asked to \"search\", stop when search results appear\n6. If asked to \"navigate\", stop when the page loads\n7. If asked to \"click\", stop after clicking\n8. Only do extra work (extract, save, analyze) if the instruction explicitly asks for it\n9. IMPORTANT: Keep all your reasoning and output SHORT and DIRECT to avoid timeouts\n\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\nDo not continue working after achieving your goal!\n\nPOPUP WINDOW HANDLING:\n- When a button opens a NEW WINDOW or POPUP (like \"Sign in with Google\", \"Continue with X\", etc.):\n  * The browser will automatically switch to the new window\n  * Continue your task in the NEW WINDOW without mentioning the window switch\n  * All subsequent actions should be performed in the NEW WINDOW\n  * Example: If user says \"click sign in with Google, then enter email\", you click the button and the new Google window opens automatically - just proceed to enter the email in that new window\n- DO NOT try to switch windows manually - it happens automatically\n- DO NOT mention window switches in your output - just continue the task seamlessly\n            \"\"\"\n            \n            logger.info(\"âš™ï¸  Configuring agent with literal execution instructions\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"â–¶ï¸  Starting agent execution...\")\n            history = await agent.run(max_steps=self.max_steps)\n            logger.info(f\"â¹ï¸  Agent execution completed\")\n            \n            logger.info(\"ðŸ“Š Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"ðŸŽ­ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            # Check if task actually succeeded - if 0 steps executed, it likely failed\n            if len(steps) == 0:\n                logger.error(f\"âŒ Task failed - no steps were executed successfully\")\n                return {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps. This usually means the browser could not launch.\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            \n            logger.info(f\"âœ… Task completed successfully!\")\n            logger.info(f\"ðŸ“ˆ Total steps executed: {len(steps)}\")\n            if final_result:\n                logger.info(f\"ðŸŽ¯ Final result: {str(final_result)[:200]}\")\n            \n            result = {\n                \"success\": True,\n                \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                \"steps\": steps,\n                \"iterations\": len(steps),\n                \"final_result\": final_result\n            }\n            \n            # Add Playwright code if generated\n            if playwright_code:\n                result[\"playwright_code\"] = playwright_code\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Browser-Use execution failed: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        Each call creates a new event loop to ensure thread safety\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n","size_bytes":8948},"README.md":{"content":"# AI Browser Automation\n\nA professional hybrid-engine browser automation system powered by AI, offering intelligent automation with automatic fallback for maximum reliability through a modern Flask web interface.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Features](#features)\n- [Automation Engines](#automation-engines)\n- [Architecture](#architecture)\n- [Technology Stack](#technology-stack)\n- [Prerequisites](#prerequisites)\n- [Installation & Setup](#installation--setup)\n  - [Windows](#windows-setup)\n  - [Linux](#linux-setup)\n  - [macOS](#macos-setup)\n  - [Replit](#replit-setup)\n- [Running the Application](#running-the-application)\n- [Usage](#usage)\n- [API Documentation](#api-documentation)\n- [Security](#security)\n- [Testing](#testing)\n- [Deployment](#deployment)\n- [Configuration](#configuration)\n- [Troubleshooting](#troubleshooting)\n- [Contributing](#contributing)\n- [License](#license)\n\n---\n\n## Overview\n\nThis project provides intelligent browser automation using natural language instructions. Users can choose between three powerful automation engines through an intuitive web interface, with the Hybrid engine providing the best of both worlds through automatic fallback mechanisms.\n\n### Automation Engines\n\n1. **Hybrid Engine** â­ **Recommended - Default**\n   - **Intelligent Fallback**: Combines Browser-Use with Playwright MCP fallback\n   - Attempts Browser-Use first for autonomous, intelligent automation\n   - Automatically falls back to Playwright MCP if Browser-Use fails\n   - Provides execution metadata showing which engine succeeded\n   - **Best reliability**: Get the power of AI with the stability of tool-based control\n   - Ideal for production use cases requiring high success rates\n\n2. **Browser-Use Engine**\n   - AI-powered automation with advanced reasoning capabilities\n   - Uses the browser-use library with LLM reasoning\n   - Autonomous task completion with minimal tool calls\n   - Best for complex, multi-step workflows requiring adaptability\n\n3. **Playwright MCP Engine**\n   - Tool-based automation using Playwright's Model Context Protocol\n   - Discrete, controllable browser actions\n   - Fine-grained control over each automation step\n   - Best for precise, repeatable tasks with predictable behavior\n\n---\n\n## Features\n\n- **Playwright Code Generation** ðŸŽ­ **NEW**: Convert AI automation into reusable Playwright code\n- **Intelligent Stopping Mechanism** âš¡ **NEW**: 10X efficiency improvement - agent stops immediately after task completion\n- **Hybrid Intelligence**: Smart automation with automatic fallback for reliability\n- **Triple Engine System**: Choose between hybrid, AI-powered, or tool-based automation\n- **Headless/Headful Modes**: Run browser invisibly for speed or visibly for debugging\n- **Natural Language Instructions**: Describe tasks in plain English\n- **Real-time Feedback**: See step-by-step execution progress with engine metadata\n- **Modern Web Interface**: Clean two-column layout with configuration panel\n- **Quick Examples**: Pre-loaded examples for common automation tasks\n- **RESTful API**: Programmatic access to automation capabilities\n- **Security Features**: API authentication, rate limiting, input validation, CORS support\n- **Cross-Platform**: Works on Windows, Linux, macOS, and Replit\n\n---\n\n## Architecture\n\n### Directory Structure\n\n```\n.\nâ”œâ”€â”€ app/                           # Flask web application\nâ”‚   â”œâ”€â”€ __init__.py               # Application factory\nâ”‚   â”œâ”€â”€ middleware/               # Security & validation\nâ”‚   â”‚   â””â”€â”€ security.py           # Auth, rate limiting, validation\nâ”‚   â”œâ”€â”€ services/                 # Business logic layer\nâ”‚   â”‚   â””â”€â”€ engine_orchestrator.py  # Engine coordination\nâ”‚   â”œâ”€â”€ routes/                   # API endpoints\nâ”‚   â”‚   â””â”€â”€ api.py                # REST routes\nâ”‚   â”œâ”€â”€ templates/                # HTML templates\nâ”‚   â”‚   â””â”€â”€ index.html\nâ”‚   â”œâ”€â”€ static/                   # Static assets\nâ”‚   â”‚   â”œâ”€â”€ css/style.css\nâ”‚   â”‚   â””â”€â”€ js/app.js\nâ”‚   â””â”€â”€ utils/                    # Utilities\nâ”‚       â””â”€â”€ timeout.py            # Timeout handling\nâ”œâ”€â”€ browser_use_codebase/         # Browser-Use engine\nâ”‚   â”œâ”€â”€ engine.py                 # Browser-Use implementation\nâ”‚   â””â”€â”€ config/                   # Configuration helpers\nâ”œâ”€â”€ hybrid_engine/                # Hybrid engine (recommended)\nâ”‚   â”œâ”€â”€ __init__.py              # Package initialization\nâ”‚   â””â”€â”€ engine.py                # Intelligent fallback logic\nâ”œâ”€â”€ playwright_mcp_codebase/      # Playwright MCP engine\nâ”‚   â”œâ”€â”€ agent/                    # Conversation agent\nâ”‚   â”‚   â””â”€â”€ conversation_agent.py\nâ”‚   â”œâ”€â”€ client/                   # MCP STDIO client\nâ”‚   â”‚   â””â”€â”€ stdio_client.py\nâ”‚   â””â”€â”€ config/                   # Configuration helpers\nâ”œâ”€â”€ tests/                        # Unit tests\nâ”‚   â”œâ”€â”€ test_api_routes.py\nâ”‚   â””â”€â”€ test_engine_orchestrator.py\nâ”œâ”€â”€ config/                       # Configuration files\nâ”‚   â””â”€â”€ config.ini                # Application configuration\nâ”œâ”€â”€ node/                         # Node.js dependencies\nâ”‚   â”œâ”€â”€ cli.js                    # Playwright MCP server entry point\nâ”‚   â”œâ”€â”€ index.js                  # Package main entry\nâ”‚   â”œâ”€â”€ index.d.ts                # TypeScript definitions\nâ”‚   â”œâ”€â”€ package.json              # Node.js dependencies\nâ”‚   â””â”€â”€ package-lock.json         # Dependency lock file\nâ”œâ”€â”€ main.py                       # Application entry point\nâ”œâ”€â”€ pyproject.toml                # Python dependencies (uv)\nâ”œâ”€â”€ requirements.txt              # Python dependencies (pip)\nâ”œâ”€â”€ uv.lock                       # Python dependency lock file\nâ”œâ”€â”€ LICENSE                       # License file\nâ””â”€â”€ README.md                     # This file\n```\n\n### Design Patterns\n\n**Frontend Architecture:**\n- Vanilla JavaScript with server-side Jinja2 templates\n- Two-column responsive layout\n- RESTful API communication using fetch API\n\n**Backend Architecture:**\n- Application Factory Pattern for Flask initialization\n- Service-oriented architecture with clear separation of concerns\n- Blueprint pattern for modular route organization\n- Engine orchestration for managing multiple automation engines\n\n### Thread Safety\n\n**Browser-Use Engine:**\n- Creates fresh browser instances per request\n- Uses new event loop for each execution\n- No instance caching to prevent loop affinity issues\n- Automatic cleanup in finally blocks\n\n**Playwright MCP Engine:**\n- Subprocess-based communication is thread-safe\n- Instances cached by headless mode setting\n- Shared across requests for efficiency\n\n---\n\n## Technology Stack\n\n### Backend\n- **Python 3.11+** with Flask web framework\n- **OpenAI GPT-4o-mini** for AI reasoning\n- **Playwright** (via browser-use and MCP)\n- **browser-use** library for autonomous automation\n- **langchain-openai** for LLM integration\n- **gunicorn** for production WSGI server\n\n### Frontend\n- Modern HTML5/CSS3/JavaScript\n- RESTful API communication\n- Real-time status updates\n\n### Infrastructure\n- Subprocess-based MCP communication (Playwright)\n- Async execution with thread-safe event loops (Browser-Use)\n- Environment-based secret management\n\n---\n\n## Prerequisites\n\n- **Python 3.11+**: Required for async features\n- **Node.js 18+**: Required for Playwright MCP server\n- **OpenAI API Key**: Get from https://platform.openai.com/api-keys\n\n---\n\n## Installation & Setup\n\n### Windows Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\nDownload from https://www.python.org/downloads/\n\n**Node.js 18+:**\nDownload from https://nodejs.org/\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\nUsing pip:\n```bash\npip install -r requirements.txt\n```\n\nOr using uv (faster):\n```bash\npip install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\n```\n\n#### 6. Configure OpenAI API Key\n\nSet as environment variable (PowerShell):\n```powershell\n$env:OPENAI_API_KEY=\"sk-your-actual-api-key-here\"\n```\n\nOr set as environment variable (Command Prompt):\n```cmd\nset OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to System Environment Variables:\n1. Search \"Environment Variables\" in Windows\n2. Click \"Environment Variables\" button\n3. Add new User or System variable: `OPENAI_API_KEY`\n\n#### 7. Run the Application\n\n```bash\npython main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### Linux Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\n```bash\nsudo apt update\nsudo apt install python3.11 python3.11-venv python3-pip\n```\n\n**Node.js 18+:**\n```bash\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt install -y nodejs\n```\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\n```bash\npip3 install -r requirements.txt\n```\n\nOr using uv:\n```bash\npip3 install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\nnpx playwright install-deps chromium\n```\n\n#### 6. Configure OpenAI API Key\n\n```bash\nexport OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to `~/.bashrc` or `~/.profile`:\n```bash\necho 'export OPENAI_API_KEY=sk-your-actual-api-key-here' >> ~/.bashrc\nsource ~/.bashrc\n```\n\n#### 7. Run the Application\n\n```bash\npython3 main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### macOS Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\n```bash\nbrew install python@3.11\n```\n\n**Node.js 18+:**\n```bash\nbrew install node@18\n```\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\n```bash\npip3 install -r requirements.txt\n```\n\nOr using uv:\n```bash\npip3 install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\n```\n\n#### 6. Configure OpenAI API Key\n\n```bash\nexport OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to `~/.zshrc` or `~/.bash_profile`:\n```bash\necho 'export OPENAI_API_KEY=sk-your-actual-api-key-here' >> ~/.zshrc\nsource ~/.zshrc\n```\n\n#### 7. Run the Application\n\n```bash\npython3 main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### Replit Setup\n\nThis application is pre-configured for Replit with optimized deployment settings.\n\n#### 1. Environment Variables\n\nSet in Replit Secrets (click the lock icon ðŸ”’):\n\n**Required:**\n- `OPENAI_API_KEY`: Your OpenAI API key\n\n**Automatically Provided:**\n- `SESSION_SECRET`: Flask session secret (auto-generated by Replit)\n\n**Optional (for production):**\n- `API_KEY`: Enable API authentication\n- `CORS_ALLOWED_ORIGINS`: Comma-separated allowed origins (default: `*`)\n\n#### 2. Workflow Configuration\n\nThe workflow is pre-configured to run:\n```bash\ngunicorn --bind 0.0.0.0:5000 --reuse-port --reload main:app\n```\n\nPort 5000 is used as it's the only non-firewalled port in Replit.\n\n#### 3. Deployment Configuration\n\n- **Target**: VM (always-running, stateful)\n- **Required for**: Browser automation state persistence\n- **Benefits**: MCP subprocess persistence, no browser recreation overhead\n\n#### 4. Browser Installation\n\nPlaywright browsers are pre-installed. If needed:\n```bash\nnpx playwright install chromium\n```\n\n#### 5. Running on Replit\n\nClick the **Run** button or restart the workflow. The application will:\n- Start on port 5000\n- Disable cache for proper hot-reload\n- Show webview preview automatically\n\nAccess via the Replit webview or your Replit domain.\n\n---\n\n## Running the Application\n\n### Development Mode\n\n**All Platforms:**\n```bash\npython main.py\n```\n\nThe server starts on `http://0.0.0.0:5000`\n\nAccess the web interface:\n```\nhttp://localhost:5000\n```\n\n### Production Mode\n\nUse a production WSGI server like gunicorn:\n\n```bash\npip install gunicorn\ngunicorn --workers 4 --bind 0.0.0.0:5000 main:app\n```\n\nFor Replit (pre-configured):\n```bash\ngunicorn --bind 0.0.0.0:5000 --reuse-port --reload main:app\n```\n\n---\n\n## Usage\n\n### Web Interface\n\n1. **Select Engine**: Choose between Hybrid (Recommended), Browser-Use, or Playwright MCP\n2. **Configure Mode**: Toggle headless mode on/off\n3. **Enter Instruction**: Describe your automation task in natural language\n4. **Execute**: Click the Execute button\n5. **View Results**: See step-by-step execution logs in real-time\n\n### Example Instructions\n\n```\nGo to example.com\n```\n\n```\nNavigate to google.com and search for 'browser automation'\n```\n\n```\nOpen github.com/trending and find the top repository\n```\n\n```\nGo to reddit.com and find the top post on the homepage\n```\n\n---\n\n## API Documentation\n\n### Base URL\n```\nhttp://localhost:5000\n```\n\n### Authentication\n\nIf `API_KEY` environment variable is set, include in requests:\n\n**Header (Recommended):**\n```http\nX-API-Key: your-api-key-here\n```\n\n**Query Parameter:**\n```\n?api_key=your-api-key-here\n```\n\n### Endpoints\n\n#### Execute Instruction\n\n```http\nPOST /api/execute\nContent-Type: application/json\nX-API-Key: your-api-key-here\n\n{\n  \"instruction\": \"Go to example.com\",\n  \"engine\": \"hybrid\",\n  \"headless\": false\n}\n```\n\n**Parameters:**\n- `instruction` (string, required): Natural language instruction\n- `engine` (string, optional): `hybrid`, `browser_use`, or `playwright_mcp` (default: `hybrid`)\n- `headless` (boolean, optional): Run headless browser (default: `false`)\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Task completed successfully\",\n  \"steps\": [...],\n  \"iterations\": 3,\n  \"engine\": \"hybrid\",\n  \"engine_metadata\": {\n    \"primary_engine\": \"browser_use\",\n    \"fallback_used\": false\n  }\n}\n```\n\n#### List Available Tools\n\n```http\nGET /api/tools?engine=playwright_mcp\nX-API-Key: your-api-key-here\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"tools\": [...],\n  \"engine\": \"playwright_mcp\"\n}\n```\n\n#### Reset Agent\n\n```http\nPOST /api/reset\nContent-Type: application/json\nX-API-Key: your-api-key-here\n\n{\n  \"engine\": \"hybrid\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Agent reset successfully\",\n  \"engine\": \"hybrid\"\n}\n```\n\n#### Health Check\n\n```http\nGET /health\n```\n\n**Response:**\n```json\n{\n  \"status\": \"healthy\",\n  \"engines\": {\n    \"hybrid\": \"available\",\n    \"browser_use\": \"available\",\n    \"playwright_mcp\": \"available\"\n  },\n  \"message\": \"Hybrid-engine browser automation ready\",\n  \"security\": {\n    \"authentication\": \"enabled\",\n    \"rate_limiting\": \"enabled\"\n  }\n}\n```\n\n### Rate Limiting\n\n- **Default**: 10 requests per minute per IP\n- **Response on limit**:\n```json\n{\n  \"success\": false,\n  \"error\": \"Rate limit exceeded\",\n  \"message\": \"Too many requests. Please try again in 45 seconds.\",\n  \"retry_after\": 45\n}\n```\n\n---\n\n## Security\n\n### Environment Variables\n\n**Never commit secrets to version control**. Always use environment variables:\n\n| Variable | Required | Default | Description |\n|----------|----------|---------|-------------|\n| `OPENAI_API_KEY` | Yes | - | OpenAI API key for AI automation |\n| `API_KEY` | No | - | API key for endpoint authentication |\n| `CORS_ALLOWED_ORIGINS` | No | `*` | Comma-separated allowed origins |\n| `SESSION_SECRET` | Recommended | - | Flask session secret key |\n\n### Security Features\n\n1. **API Authentication**\n   - Optional API key protection for all automation endpoints\n   - Header or query parameter authentication\n   - Disabled by default (development mode)\n\n2. **Rate Limiting**\n   - 10 requests/minute per IP by default\n   - Prevents abuse and cost exhaustion\n   - Automatic cleanup of old request records\n\n3. **Input Validation**\n   - All inputs validated before processing\n   - Instruction: max 5000 characters\n   - Engine type: must be valid option\n   - Headless: must be boolean\n\n4. **CORS Configuration**\n   - Control which domains can access the API\n   - Configure via `CORS_ALLOWED_ORIGINS`\n   - Default: `*` (all origins - development)\n\n5. **Error Sanitization**\n   - Internal error details hidden from users\n   - Prevents information leakage\n   - Generic user-facing messages\n\n6. **Timeout Protection**\n   - 5-minute timeout on all requests\n   - Cross-platform implementation\n   - Automatic resource cleanup\n\n7. **Process Monitoring**\n   - Automatic subprocess recovery\n   - Detects and handles crashed processes\n   - Zombie process cleanup\n\n### Best Practices\n\n1. **Use HTTPS in production**\n   - Configure with reverse proxy (nginx/Apache)\n   - API keys transmitted over HTTP can be intercepted\n\n2. **Rotate credentials regularly**\n   - Change `API_KEY` periodically\n   - Update `OPENAI_API_KEY` if compromised\n\n3. **Monitor API usage**\n   - Track OpenAI API costs: https://platform.openai.com/usage\n   - Monitor authentication failures\n   - Alert on unusual traffic patterns\n\n4. **Production Deployment Checklist**\n   - [ ] Set `API_KEY` to strong random value\n   - [ ] Set `CORS_ALLOWED_ORIGINS` to specific domains\n   - [ ] Set `SESSION_SECRET` to secure random value\n   - [ ] Enable HTTPS with reverse proxy\n   - [ ] Monitor logs for authentication failures\n   - [ ] Set up alerting for rate limit violations\n\n### Reporting Security Issues\n\nIf you discover a security vulnerability:\n1. **Do NOT** open a public issue\n2. Contact the maintainer privately\n3. Include description, reproduction steps, and potential impact\n\n---\n\n## Testing\n\n### Running Tests\n\nRun all tests:\n```bash\npython -m pytest tests/\n```\n\nRun specific test file:\n```bash\npython -m pytest tests/test_engine_orchestrator.py\npython -m pytest tests/test_api_routes.py\n```\n\nRun with coverage:\n```bash\npython -m pytest --cov=app tests/\n```\n\n### Test Structure\n\n- `test_engine_orchestrator.py` - Engine coordination and caching tests\n- `test_api_routes.py` - Flask API endpoint tests\n\n### Writing New Tests\n\n1. Create file starting with `test_`\n2. Import `unittest` or use `pytest`\n3. Add test methods starting with `test_`\n4. Use mocks for external dependencies (browsers, OpenAI API)\n\n---\n\n## Deployment\n\n### Development\n\nThe application runs on Flask's development server, suitable for testing and local development.\n\n### Production\n\n#### Using Gunicorn (Recommended)\n\n```bash\npip install gunicorn\ngunicorn --workers 4 --bind 0.0.0.0:5000 main:app\n```\n\n#### Using Reverse Proxy\n\n**Nginx Configuration Example:**\n```nginx\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:5000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n#### Docker Deployment\n\nCreate `Dockerfile`:\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -r requirements.txt\nRUN npm install\nRUN npx playwright install chromium --with-deps\n\nEXPOSE 5000\n\nCMD [\"gunicorn\", \"--workers\", \"4\", \"--bind\", \"0.0.0.0:5000\", \"main:app\"]\n```\n\nBuild and run:\n```bash\ndocker build -t ai-browser-automation .\ndocker run -p 5000:5000 -e OPENAI_API_KEY=sk-your-key ai-browser-automation\n```\n\n#### Replit Deployment\n\nPre-configured for Replit VM deployment:\n- Always-running, stateful instance\n- MCP subprocess persistence\n- Port 5000 (non-firewalled)\n- Click \"Deploy\" in Replit UI to publish\n\n---\n\n## Configuration\n\n### config/config.ini\n\nApplication-level configuration file (non-sensitive settings):\n\n```ini\n[server]\nhost = 0.0.0.0\nport = 5000\n\n[browser]\nheadless = true\nbrowser = chromium\n\n[openai]\nmodel = gpt-4o-mini\n\n[agent]\nmax_steps = 100\n```\n\n**Note**: Never store API keys in config.ini. Use environment variables.\n\n### Customizing Rate Limits\n\nEdit `app/middleware/security.py`:\n\n```python\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n```\n\n---\n\n## Troubleshooting\n\n### Port Already in Use\n\n**Linux/macOS:**\n```bash\nlsof -ti:5000 | xargs kill -9\n```\n\n**Windows:**\n```powershell\nnetstat -ano | findstr :5000\ntaskkill /PID <PID> /F\n```\n\n### Missing OpenAI API Key\n\nEnsure environment variable is set:\n\n**Check (Linux/macOS):**\n```bash\necho $OPENAI_API_KEY\n```\n\n**Check (Windows PowerShell):**\n```powershell\n$env:OPENAI_API_KEY\n```\n\n### Playwright Installation Issues\n\n**Linux:**\n```bash\nnpx playwright install-deps chromium\nnpx playwright install chromium\n```\n\n**All platforms:**\n```bash\nnpx playwright install chromium\n```\n\n### Browser Crashes\n\n- Ensure sufficient memory (2GB+ recommended)\n- Try headless mode for lower resource usage\n- Check Playwright logs for specific errors\n\n### Cached CSS Not Loading (Windows)\n\nClear browser cache with hard refresh:\n- Chrome/Edge: `Ctrl + Shift + R` or `Ctrl + F5`\n- Firefox: `Ctrl + Shift + R` or `Ctrl + F5`\n- Alternative: Open DevTools (F12) â†’ Right-click refresh â†’ \"Empty Cache and Hard Reload\"\n\n### Permission Denied Errors (Linux/macOS)\n\n```bash\nchmod +x cli.js\n```\n\n---\n\n## Performance Considerations\n\n### Intelligent Stopping Mechanism âš¡\n\nThis application implements an intelligent stopping mechanism that provides **10X efficiency improvement**:\n\n- **What it does**: Before each action, the AI agent validates if the ultimate task is complete\n- **Benefits**: \n  - 30-50% reduction in average steps\n  - Significant cost savings on API usage\n  - Faster task completion\n  - No unnecessary actions after goal is achieved\n- **Learn more**: See [docs/INTELLIGENT_STOPPING.md](docs/INTELLIGENT_STOPPING.md) for detailed information\n\n### OpenAI API Costs\n\n- Each instruction execution calls OpenAI API multiple times\n- Browser-Use: 1-5 calls per instruction (autonomous)\n- **With intelligent stopping**: Reduced by 30-50% on average\n- Playwright MCP: 2-10+ calls per instruction (iterative)\n- Hybrid: Uses Browser-Use first, falls back to MCP if needed\n- Monitor usage at: https://platform.openai.com/usage\n\n### Resource Usage\n\n- **Headless mode**: ~200-500MB RAM per browser instance\n- **Headful mode**: ~500MB-1GB RAM per browser instance\n- **Recommended**: 4GB+ total system RAM for optimal performance\n\n---\n\n## Contributing\n\nContributions are welcome! Please:\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Add tests if applicable\n5. Ensure all tests pass\n6. Commit your changes (`git commit -m 'Add amazing feature'`)\n7. Push to the branch (`git push origin feature/amazing-feature`)\n8. Submit a pull request\n\n---\n\n## License\n\nSee LICENSE file for details.\n\n---\n\n## Support\n\nFor issues and questions:\n- Check the Troubleshooting section above\n- Review console output for error messages\n- Verify OpenAI API key is valid and has credits\n- Ensure all dependencies are installed correctly\n- Check the health endpoint: `http://localhost:5000/health`\n\n---\n\n**Built with â¤ï¸ using Playwright, browser-use, OpenAI GPT-4o-mini, and Flask**\n","size_bytes":23015},"hybrid_engine/engine.py":{"content":"\"\"\"\nHybrid Engine Implementation\nUses Browser-Use (AI-powered) as primary engine with Playwright MCP (tool-based) as fallback\n\"\"\"\nfrom typing import Dict, Any\nimport browser_use_codebase\nimport playwright_mcp_codebase\n\n\nclass HybridEngine:\n    \"\"\"\n    Hybrid browser automation engine\n    \n    Strategy:\n    1. Attempt execution with Browser-Use (AI-powered, autonomous)\n    2. If Browser-Use fails, fallback to Playwright MCP (tool-based, reliable)\n    3. Track and report which engine was actually used\n    \n    This provides the best of both worlds:\n    - Browser-Use's intelligent autonomous behavior for complex tasks\n    - Playwright MCP's reliability and discrete control as safety net\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Hybrid Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        self.browser_use_engine = None\n        self.playwright_client = None\n        self.playwright_agent = None\n    \n    def _ensure_browser_use_engine(self):\n        \"\"\"Lazily create Browser-Use engine\"\"\"\n        if self.browser_use_engine is None:\n            self.browser_use_engine = browser_use_codebase.create_engine(headless=self.headless)\n        return self.browser_use_engine\n    \n    def _ensure_playwright_engine(self):\n        \"\"\"Lazily create Playwright MCP engine\"\"\"\n        if self.playwright_client is None or self.playwright_agent is None:\n            self.playwright_client, self.playwright_agent = playwright_mcp_codebase.create_engine(\n                headless=self.headless\n            )\n        return self.playwright_client, self.playwright_agent\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute instruction with hybrid approach\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and engine metadata\n        \"\"\"\n        # First attempt: Browser-Use (AI-powered)\n        try:\n            engine = self._ensure_browser_use_engine()\n            result = engine.execute_instruction_sync(instruction)\n            \n            if result.get('success', False):\n                result['engine_used'] = 'browser_use'\n                result['fallback_triggered'] = False\n                result['hybrid_mode'] = True\n                return result\n            else:\n                # Browser-Use returned failure, try fallback\n                browser_use_error = result.get('error', 'Unknown error')\n                return self._fallback_to_playwright(instruction, browser_use_error)\n                \n        except Exception as e:\n            # Browser-Use threw exception, try fallback\n            return self._fallback_to_playwright(instruction, str(e))\n    \n    def _fallback_to_playwright(self, instruction: str, browser_use_error: str) -> Dict[str, Any]:\n        \"\"\"\n        Fallback to Playwright MCP engine\n        \n        Args:\n            instruction: User's natural language instruction\n            browser_use_error: Error message from Browser-Use attempt\n            \n        Returns:\n            Dictionary with execution results and fallback metadata\n        \"\"\"\n        try:\n            client, agent = self._ensure_playwright_engine()\n            \n            # Initialize if needed\n            if not client.initialized:\n                client.initialize()\n            \n            # Execute with Playwright MCP\n            result = agent.execute_instruction(instruction)\n            \n            # Add hybrid metadata\n            result['engine_used'] = 'playwright_mcp'\n            result['fallback_triggered'] = True\n            result['hybrid_mode'] = True\n            result['browser_use_error'] = browser_use_error\n            \n            return result\n            \n        except Exception as e:\n            # Both engines failed\n            return {\n                'success': False,\n                'error': f'Both engines failed. Browser-Use: {browser_use_error}. Playwright MCP: {str(e)}',\n                'engine_used': 'none',\n                'fallback_triggered': True,\n                'hybrid_mode': True,\n                'browser_use_error': browser_use_error,\n                'playwright_error': str(e),\n                'steps': [],\n                'iterations': 0\n            }\n    \n    def reset(self):\n        \"\"\"Reset both engines\"\"\"\n        # Browser-Use doesn't maintain state, so nothing to reset\n        \n        # Reset Playwright agent if it exists\n        if self.playwright_agent is not None:\n            self.playwright_agent.reset_conversation()\n","size_bytes":4698},"browser_use_codebase/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom browser_use_codebase.engine import BrowserUseEngine\nfrom browser_use_codebase.engine_optimized import OptimizedBrowserUseEngine\n\n\ndef create_engine(headless: bool = False, use_optimized: bool = True):\n    \"\"\"\n    Factory function to create a Browser-Use engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        use_optimized: Use optimized engine with advanced features (default: True)\n        \n    Returns:\n        BrowserUseEngine or OptimizedBrowserUseEngine instance\n    \"\"\"\n    if use_optimized:\n        return OptimizedBrowserUseEngine(headless=headless, enable_advanced_features=True)\n    else:\n        return BrowserUseEngine(headless=headless)\n\n\n__all__ = ['BrowserUseEngine', 'OptimizedBrowserUseEngine', 'create_engine']\n","size_bytes":870},"hybrid_engine/__init__.py":{"content":"\"\"\"\nHybrid Engine\nIntelligent browser automation that uses Browser-Use by default with Playwright MCP fallback\n\"\"\"\nfrom hybrid_engine.engine import HybridEngine\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Hybrid engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        HybridEngine instance\n    \"\"\"\n    return HybridEngine(headless=headless)\n\n\n__all__ = ['HybridEngine', 'create_engine']\n","size_bytes":481},"PLEASE_READ_WINDOWS.md":{"content":"# âš ï¸ IMPORTANT: Windows Setup Required\n\n## YOU ARE SEEING THIS ERROR ON WINDOWS\n\nThe error you're seeing:\n```\nâŒ Error: Both engines failed. Browser-Use: OpenAI API key must be set...\n```\n\nThis means **you haven't set up the .env file on your Windows machine yet!**\n\n## ðŸ”‘ Key Point\n\n**The API key you configured in Replit Secrets only works IN REPLIT!**\n\nYour **Windows computer** needs its OWN `.env` file with your API key.\n\n## âœ… How to Fix This (Step by Step)\n\n### 1. Create a `.env` file on your Windows computer\n\nIn the **same folder** where you have `main.py`, create a file named `.env` (not `.env.txt`!)\n\n**Using Notepad:**\n1. Open Notepad\n2. Paste this content:\n   ```\n   OPENAI_API_KEY=sk-your-actual-api-key-here\n   SESSION_SECRET=my-secret-key-123\n   CORS_ALLOWED_ORIGINS=*\n   ```\n3. Replace `sk-your-actual-api-key-here` with your real OpenAI API key\n4. Click \"File\" â†’ \"Save As\"\n5. Change \"Save as type\" to **\"All Files (*.*)\"**\n6. Name it: `.env` (with the dot at the start!)\n7. Save it in your project folder (where `main.py` is)\n\n**Using Command Prompt:**\n```cmd\ncopy .env.example .env\nnotepad .env\n```\nThen edit it to add your actual API key.\n\n### 2. Verify your setup\n\nRun this test script to check if everything is configured correctly:\n\n```bash\npython test_engines.py\n```\n\n**If it passes:** âœ… You're all set! Run `python main.py`\n\n**If it fails:** âŒ The script will tell you exactly what's wrong\n\n### 3. Run the application\n\n**OPTION A - Easy Way (Recommended for Windows):**\n```cmd\nrun_windows.bat\n```\nThis batch file ensures console logs appear properly and checks for the .env file.\n\n**OPTION B - Manual Way:**\n```bash\npython main.py\n```\n\n**ðŸ’¡ IMPORTANT:** Keep the console window open while using the app! \nAll automation logs will appear there when you click \"Execute\".\n\n## ðŸ†˜ Still Not Working?\n\nRun these diagnostic commands and send me the output:\n\n```bash\n# Check if .env file exists\ndir .env\n\n# Check what's in it (will show your key, so be careful sharing!)\ntype .env\n\n# Run the environment checker\npython check_env.py\n\n# Test the engines\npython test_engines.py\n```\n\n## ðŸ’¡ Common Mistakes\n\n1. **File named `.env.txt` instead of `.env`**\n   - Windows hides extensions by default\n   - Check: File Explorer â†’ View â†’ File name extensions\n\n2. **No .env file at all on Windows**\n   - The Replit environment variables don't transfer to your PC!\n   - You MUST create a local .env file\n\n3. **Wrong API key**\n   - Make sure you're using YOUR OpenAI API key\n   - It should start with `sk-` or `sk-proj-`\n\n4. **File in wrong location**\n   - The `.env` file must be in the same folder as `main.py`\n   - Check with: `dir` command in your project folder\n\n5. **No console logs appearing**\n   - Use `run_windows.bat` instead of running `python main.py` directly\n   - This ensures unbuffered output so logs appear immediately\n   - Keep the console window visible while using the web app\n\n## ðŸ“‚ Your Project Folder Should Look Like This\n\n```\nyour-project-folder/\nâ”œâ”€â”€ .env                    â† YOU NEED THIS FILE!\nâ”œâ”€â”€ .env.example           â† Template to copy from\nâ”œâ”€â”€ main.py                â† Main app file\nâ”œâ”€â”€ run_windows.bat        â† Easy launcher for Windows (ensures logs work)\nâ”œâ”€â”€ check_env.py           â† Diagnostic script\nâ”œâ”€â”€ test_engines.py        â† Engine test script\nâ”œâ”€â”€ app/\nâ”œâ”€â”€ browser_use_codebase/\nâ””â”€â”€ ... (other files)\n```\n\n## ðŸ” Troubleshooting: No Console Logs?\n\nIf you click \"Execute\" but don't see any logs in your console:\n\n1. **Make sure you're using the batch file:**\n   ```cmd\n   run_windows.bat\n   ```\n   (Not `python main.py` directly)\n\n2. **Keep the console window visible** - logs only appear in the console where you launched the app, not in the web browser\n\n3. **The logs will show:**\n   - When you start the app\n   - Each time you click \"Execute\"\n   - Every step the AI takes\n   - Any errors that occur\n\n4. **Example of what you should see:**\n   ```\n   ================================================================================\n   ðŸ“¨ NEW AUTOMATION REQUEST\n   ðŸ“ Instruction: go to google.com\n   ðŸ”§ Engine: hybrid\n   ================================================================================\n   ðŸš€ Starting automation execution...\n   ðŸ¤– Initializing Browser-Use Agent\n   â–¶ï¸  Starting agent execution...\n   ```\n","size_bytes":4374},"playwright_mcp_codebase/config/__init__.py":{"content":"\"\"\"\nPlaywright MCP Configuration Module\n\"\"\"\n","size_bytes":44},"app/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n}\n\n/* Header */\nheader {\n    text-align: center;\n    color: white;\n    margin-bottom: 30px;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 10px;\n}\n\nheader .subtitle {\n    font-size: 1.1rem;\n    opacity: 0.95;\n    font-weight: 400;\n}\n\n/* Main Content - Two Column Layout */\n.main-content {\n    display: grid;\n    grid-template-columns: 450px 1fr;\n    gap: 25px;\n    margin-bottom: 20px;\n}\n\n/* Left Panel */\n.left-panel {\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n}\n\n.config-section,\n.instruction-section,\n.examples-section {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n}\n\n.config-section h3,\n.instruction-section h3,\n.examples-section h4 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    margin-bottom: 16px;\n    color: #667eea;\n}\n\n.config-group {\n    margin-bottom: 20px;\n}\n\n.config-group:last-child {\n    margin-bottom: 0;\n}\n\n.config-group label {\n    display: block;\n    font-weight: 600;\n    margin-bottom: 8px;\n    color: #333;\n    font-size: 0.95rem;\n}\n\n.config-select {\n    width: 100%;\n    padding: 12px 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    font-size: 1rem;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.config-select:hover {\n    border-color: #667eea;\n}\n\n.config-select:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n.config-help {\n    margin-top: 6px;\n    font-size: 0.85rem;\n    color: #666;\n    line-height: 1.4;\n}\n\n/* Toggle Switch */\n.toggle-label {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    margin-bottom: 0;\n}\n\n.toggle-label input[type=\"checkbox\"] {\n    display: none;\n}\n\n.toggle-slider {\n    position: relative;\n    width: 52px;\n    height: 28px;\n    background: #e0e0e0;\n    border-radius: 34px;\n    margin-right: 12px;\n    transition: background 0.3s ease;\n}\n\n.toggle-slider::before {\n    content: '';\n    position: absolute;\n    width: 22px;\n    height: 22px;\n    left: 3px;\n    top: 3px;\n    background: white;\n    border-radius: 50%;\n    transition: transform 0.3s ease;\n}\n\n.toggle-label input:checked + .toggle-slider {\n    background: #667eea;\n}\n\n.toggle-label input:checked + .toggle-slider::before {\n    transform: translateX(24px);\n}\n\n.toggle-text {\n    font-weight: 600;\n    color: #333;\n}\n\n/* Instruction Input */\n#instruction-input {\n    width: 100%;\n    padding: 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    transition: border-color 0.3s ease;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n#instruction-input::placeholder {\n    color: #999;\n}\n\n/* Buttons */\n.button-group {\n    display: flex;\n    gap: 12px;\n    margin-top: 16px;\n}\n\n.btn {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n    padding: 14px 24px;\n    border: none;\n    border-radius: 10px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.btn-icon {\n    font-size: 1.1rem;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #f3f4f6;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #e5e7eb;\n}\n\n.spinner {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-top-color: white;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n/* Examples */\n.example-buttons {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.example-btn {\n    padding: 12px 16px;\n    background: #f8f9fa;\n    border: 2px solid #e9ecef;\n    border-radius: 8px;\n    font-size: 0.9rem;\n    cursor: pointer;\n    text-align: left;\n    transition: all 0.2s ease;\n    font-weight: 500;\n    color: #333;\n}\n\n.example-btn:hover {\n    background: #667eea;\n    border-color: #667eea;\n    color: white;\n    transform: translateX(4px);\n}\n\n/* Right Panel - Results */\n.right-panel {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n    display: flex;\n    flex-direction: column;\n}\n\n.results-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n}\n\n.results-header h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #667eea;\n}\n\n.status-badge {\n    padding: 6px 14px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.status-badge.running {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n.status-badge.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.status-badge.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.status {\n    padding: 14px 18px;\n    border-radius: 10px;\n    margin-bottom: 16px;\n    font-weight: 500;\n    display: none;\n}\n\n.status.success {\n    background: #d1fae5;\n    color: #065f46;\n    border-left: 4px solid #10b981;\n    display: block;\n}\n\n.status.error {\n    background: #fee2e2;\n    color: #991b1b;\n    border-left: 4px solid #ef4444;\n    display: block;\n}\n\n.status.processing {\n    background: #fef3c7;\n    color: #92400e;\n    border-left: 4px solid #f59e0b;\n    display: block;\n}\n\n/* Results Container */\n.results-container {\n    flex: 1;\n    overflow-y: auto;\n    max-height: calc(100vh - 400px);\n}\n\n.empty-state {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    padding: 60px 20px;\n    color: #9ca3af;\n}\n\n.empty-icon {\n    font-size: 4rem;\n    margin-bottom: 16px;\n    opacity: 0.5;\n}\n\n.empty-state p {\n    font-size: 1rem;\n}\n\n/* Step Display */\n.step {\n    background: #f8f9fa;\n    border-left: 4px solid #667eea;\n    border-radius: 8px;\n    padding: 16px;\n    margin-bottom: 14px;\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    font-weight: 700;\n    color: #667eea;\n    font-size: 0.95rem;\n}\n\n.step-status {\n    padding: 4px 12px;\n    border-radius: 12px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.step-status.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 8px;\n    font-size: 0.95rem;\n}\n\n.step-args {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    font-family: 'Courier New', monospace;\n    font-size: 0.85rem;\n    color: #555;\n    white-space: pre-wrap;\n    word-break: break-all;\n}\n\n.step-error {\n    color: #991b1b;\n    margin-top: 10px;\n    font-weight: 500;\n}\n\ndetails {\n    margin-top: 10px;\n}\n\nsummary {\n    cursor: pointer;\n    color: #667eea;\n    font-weight: 600;\n    font-size: 0.9rem;\n}\n\ndetails pre {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    margin-top: 8px;\n    font-size: 0.85rem;\n    overflow: auto;\n    max-height: 300px;\n}\n\n/* Footer */\nfooter {\n    background: rgba(255, 255, 255, 0.95);\n    border-radius: 12px;\n    padding: 16px 24px;\n    text-align: center;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.footer-content p {\n    color: #666;\n    margin-bottom: 8px;\n    font-size: 0.9rem;\n}\n\n.footer-links {\n    display: flex;\n    justify-content: center;\n    gap: 24px;\n    font-size: 0.9rem;\n    color: #666;\n}\n\n.footer-links strong {\n    color: #667eea;\n}\n\n/* Responsive */\n@media (max-width: 1024px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n    \n    .left-panel {\n        order: 1;\n    }\n    \n    .right-panel {\n        order: 2;\n    }\n}\n","size_bytes":8389},"docs/POPUP_HANDLING.md":{"content":"# Popup Window Handling\n\n## Overview\n\nThe browser-use engine has been enhanced to automatically handle popup windows and new tabs that open during automation.\n\n## How It Works\n\nWhen a button or link opens a new window (like \"Sign in with Google\", \"Continue with Facebook\", etc.), the browser-use AI agent:\n\n1. **Detects the new window** - Playwright automatically tracks new windows/tabs\n2. **Switches context automatically** - The AI agent continues working in the new window\n3. **Completes the task seamlessly** - No manual window switching required\n\n## Enhanced System Instructions\n\nThe AI agent now receives specific instructions about popup handling:\n\n- When a popup opens, it automatically switches to work in the new window\n- All subsequent actions are performed in the active window\n- Window switches happen transparently without user intervention\n\n## Examples\n\n### LinkedIn Sign-in with Google\n\n**Instruction:**\n```\nOpen https://www.linkedin.com/, click \"Join now\", click \"Continue with Google\", enter email \"test@example.com\", click next\n```\n\n**What happens:**\n1. Opens LinkedIn\n2. Clicks \"Join now\"\n3. Clicks \"Continue with Google\" â†’ **New popup window opens**\n4. **Automatically switches to Google sign-in window**\n5. Enters email in the popup\n6. Clicks next\n\n### Multi-Window Workflow\n\nThe agent can handle complex multi-window scenarios:\n- OAuth flows (Google, Facebook, etc.)\n- Payment gateways\n- External verification pages\n- Pop-up forms\n\n## Configuration\n\nThe popup handling is enabled by default in browser-use engine with these optimizations:\n\n- **LLM Timeout**: 180 seconds (increased from 60s)\n- **Max Steps**: 25 steps (optimized for performance)\n- **System Prompt**: Enhanced with popup handling instructions\n\n## Best Practices\n\n### 1. Be Explicit in Instructions\nâœ… **Good:** \"Click 'Sign in with Google', enter email 'test@example.com' in the popup, click next\"\n\nâŒ **Avoid:** \"Sign in with Google\" (too vague)\n\n### 2. Break Complex Tasks into Steps\nFor very complex workflows, break them into smaller tasks:\n\n**Step 1:**\n```\nNavigate to site.com and click \"Sign in with Google\"\n```\n\n**Step 2:**\n```\nEnter email \"test@example.com\" and click next\n```\n\n### 3. Use Headless Mode for Faster Performance\nHeadless mode (checkbox in UI) runs faster and is more reliable for popup handling.\n\n## Troubleshooting\n\n### Popup Not Detected\nIf the agent doesn't switch to a popup:\n\n1. **Check if it's actually a popup** - Some sites use embedded forms instead\n2. **Use explicit instructions** - Tell the agent to work in the new window\n3. **Try Playwright MCP engine** - More granular control for complex scenarios\n\n### Timeout Issues\nIf actions in popups timeout:\n\n1. **Enable headless mode** - Faster execution\n2. **Simplify the instruction** - Break into smaller steps\n3. **Check network speed** - OpenAI API calls need good connectivity\n\n## Technical Details\n\n### Browser-Use Integration\n- Built on Playwright (version 1.52+)\n- Uses AI-powered element detection\n- Automatically handles browser contexts\n\n### Window Switching Logic\n- Browser-use tracks all open pages/windows\n- AI agent automatically works in the most recently opened window\n- Falls back to main window when popups close\n\n## Limitations\n\n1. **Nested Popups**: Multiple levels of popups may require explicit instructions\n2. **Browser Security**: Some sites block automation in popups\n3. **Timing**: Very fast popup opens/closes might be missed\n\n## Future Enhancements\n\nPlanned improvements:\n- [ ] Explicit popup detection logging\n- [ ] Configurable popup timeout\n- [ ] Popup window priority rules\n- [ ] Multi-popup orchestration\n","size_bytes":3614},"node/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"playwright_mcp_codebase/client/__init__.py":{"content":"\"\"\"\nPlaywright MCP Client Module\n\"\"\"\nfrom playwright_mcp_codebase.client.stdio_client import MCPStdioClient\n\n__all__ = ['MCPStdioClient']\n","size_bytes":138},"tests/__init__.py":{"content":"","size_bytes":0},"tests/test_api_routes.py":{"content":"\"\"\"\nTests for API Routes\n\"\"\"\nimport unittest\nimport json\nfrom unittest.mock import Mock, patch\nfrom app import create_app\n\n\nclass TestAPIRoutes(unittest.TestCase):\n    \"\"\"Test cases for API routes\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.app = create_app()\n        self.app.config['TESTING'] = True\n        self.client = self.app.test_client()\n    \n    def test_index_route(self):\n        \"\"\"Test that index route returns HTML\"\"\"\n        response = self.client.get('/')\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b'AI Browser Automation', response.data)\n    \n    def test_health_check(self):\n        \"\"\"Test health check endpoint\"\"\"\n        response = self.client.get('/health')\n        self.assertEqual(response.status_code, 200)\n        \n        data = json.loads(response.data)\n        self.assertEqual(data['status'], 'healthy')\n        self.assertIn('engines', data)\n    \n    def test_execute_empty_instruction(self):\n        \"\"\"Test that empty instruction returns 400 error\"\"\"\n        response = self.client.post('/api/execute',\n                                   json={'instruction': '', 'engine': 'hybrid'})\n        self.assertEqual(response.status_code, 400)\n        \n        data = json.loads(response.data)\n        self.assertFalse(data['success'])\n        self.assertIn('provide an instruction', data['error'])\n    \n    def test_execute_missing_instruction(self):\n        \"\"\"Test that missing instruction key returns 400 error\"\"\"\n        response = self.client.post('/api/execute',\n                                   json={'engine': 'hybrid'})\n        self.assertEqual(response.status_code, 400)\n        \n        data = json.loads(response.data)\n        self.assertFalse(data['success'])\n    \n    @patch('app.services.engine_orchestrator.EngineOrchestrator.execute_instruction')\n    def test_execute_success(self, mock_execute):\n        \"\"\"Test successful execution\"\"\"\n        mock_execute.return_value = {\n            'success': True,\n            'message': 'Task completed',\n            'iterations': 3,\n            'steps': []\n        }\n        \n        response = self.client.post('/api/execute',\n                                   json={\n                                       'instruction': 'Go to google.com',\n                                       'engine': 'hybrid',\n                                       'headless': True\n                                   })\n        \n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data)\n        self.assertTrue(data['success'])\n        self.assertEqual(data['iterations'], 3)\n    \n    def test_reset_agent(self):\n        \"\"\"Test reset agent endpoint\"\"\"\n        response = self.client.post('/api/reset',\n                                   json={'engine': 'hybrid'})\n        \n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data)\n        self.assertTrue(data['success'])\n        self.assertIn('reset successfully', data['message'])\n\n\nif __name__ == '__main__':\n    unittest.main()\n","size_bytes":3082},"replit.md":{"content":"# AI Browser Automation\n\n## Overview\n\nAI-powered browser automation platform providing two distinct automation engines: **Browser-Use** (AI-driven reasoning) and **Playwright MCP** (tool-based execution). The system allows users to describe automation tasks in natural language, which are executed by intelligent agents controlling web browsers.\n\nBuilt as a Flask web service with a modern web interface, supporting both headless and headful browser modes. Designed to handle complex multi-step workflows, data extraction, screenshot capture, and other advanced browser automation tasks.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## Project Structure\n\n```\nai-browser-automation/\nâ”œâ”€â”€ app/                          # Flask application\nâ”‚   â”œâ”€â”€ engines/                  # Automation engines\nâ”‚   â”‚   â”œâ”€â”€ browser_use/          # Browser-Use AI engine\nâ”‚   â”‚   â”‚   â”œâ”€â”€ engine.py         # Base engine\nâ”‚   â”‚   â”‚   â”œâ”€â”€ engine_optimized.py  # Enhanced with advanced features\nâ”‚   â”‚   â”‚   â”œâ”€â”€ advanced_features.py # Screenshots, PDFs, cookies\nâ”‚   â”‚   â”‚   â”œâ”€â”€ retry_mechanism.py   # Exponential backoff retry\nâ”‚   â”‚   â”‚   â”œâ”€â”€ state_manager.py     # Workflow state persistence\nâ”‚   â”‚   â”‚   â”œâ”€â”€ data_extractor.py    # Table/list extraction\nâ”‚   â”‚   â”‚   â”œâ”€â”€ performance_monitor.py # Metrics tracking\nâ”‚   â”‚   â”‚   â”œâ”€â”€ popup_handler.py     # Popup window handling\nâ”‚   â”‚   â”‚   â””â”€â”€ playwright_code_generator.py # Code export\nâ”‚   â”‚   â””â”€â”€ playwright_mcp/       # Playwright MCP tool engine\nâ”‚   â”‚       â”œâ”€â”€ agent/            # Conversation agent\nâ”‚   â”‚       â”œâ”€â”€ client/           # STDIO MCP client\nâ”‚   â”‚       â””â”€â”€ mcp_code_generator.py # Code export\nâ”‚   â”œâ”€â”€ middleware/               # Security & validation\nâ”‚   â”‚   â””â”€â”€ security.py           # Auth, rate limiting, validation\nâ”‚   â”œâ”€â”€ routes/                   # API endpoints\nâ”‚   â”‚   â””â”€â”€ api.py                # REST API routes\nâ”‚   â”œâ”€â”€ services/                 # Business logic\nâ”‚   â”‚   â””â”€â”€ engine_orchestrator.py # Engine management\nâ”‚   â”œâ”€â”€ static/                   # Frontend assets\nâ”‚   â”‚   â”œâ”€â”€ css/style.css\nâ”‚   â”‚   â””â”€â”€ js/app.js\nâ”‚   â”œâ”€â”€ templates/                # HTML templates\nâ”‚   â”‚   â””â”€â”€ index.html\nâ”‚   â””â”€â”€ utils/                    # Shared utilities\nâ”‚       â””â”€â”€ timeout.py            # Cross-platform timeout handling\nâ”œâ”€â”€ integrations/                 # External integrations\nâ”‚   â””â”€â”€ playwright_mcp_node/      # Node.js MCP server\nâ”‚       â”œâ”€â”€ cli.js                # Server entry point\nâ”‚       â””â”€â”€ package.json          # Node dependencies\nâ”œâ”€â”€ config/                       # Configuration\nâ”‚   â””â”€â”€ config.ini                # OpenAI & browser settings\nâ”œâ”€â”€ tests/                        # Test suite\nâ”‚   â”œâ”€â”€ unit/                     # Unit tests\nâ”‚   â”œâ”€â”€ integration/              # Integration tests\nâ”‚   â””â”€â”€ conftest.py               # Pytest configuration\nâ”œâ”€â”€ main.py                       # Application entry point\nâ”œâ”€â”€ requirements.txt              # Python dependencies\nâ”œâ”€â”€ pyproject.toml                # Project metadata\nâ””â”€â”€ .env                          # Environment variables (secrets)\n```\n\n## System Architecture\n\n### Frontend Architecture\n\n**Web Interface**: Single-page application (SPA) using vanilla JavaScript with a two-column layout:\n- Left panel: Configuration controls (engine selection, headless mode toggle, instruction input)\n- Right panel: Real-time execution status, results display, and generated code preview\n- Styling: Gradient purple theme with responsive design using CSS Grid\n\n**Client-Side Features**:\n- Real-time status updates during automation execution\n- JSON result formatting and display\n- Generated Playwright code preview for reusability\n- Engine and mode selection persistence in UI\n\n### Backend Architecture\n\n**Flask Application Factory Pattern**: Modular structure with blueprints, middleware, and services separation.\n\n**Engine Orchestrator** (`app/services/engine_orchestrator.py`): Manages two distinct automation engines with instance caching and lifecycle management.\n\n**Automation Engines**:\n\n1. **Browser-Use Engine** (AI-Powered - Default & Recommended):\n   - Location: `app/engines/browser_use/`\n   - Uses OpenAI's LLM to reason about browser actions\n   - Implements the `browser-use` library with Playwright backend\n   - Features: Advanced popup handling, retry mechanisms with exponential backoff, state management for complex workflows, performance monitoring, data extraction (tables, lists, metadata), screenshot/PDF generation, cookie management\n   - Thread-safe design: Creates fresh browser instances per request with proper cleanup\n   - Two implementations: `engine.py` (base) and `engine_optimized.py` (enhanced)\n\n2. **Playwright MCP Engine** (Tool-Based):\n   - Location: `app/engines/playwright_mcp/`\n   - Uses Model Context Protocol (MCP) for discrete tool calls\n   - OpenAI function calling to map natural language to browser tools\n   - Communicates with Node.js MCP server via STDIO transport (subprocess)\n   - Available tools: navigate, click, fill, snapshot, select, hover, evaluate, screenshot\n   - Node server location: `integrations/playwright_mcp_node/`\n\n**Code Generation**: Both engines include code generators that convert executed automation steps into reusable Playwright Python code.\n\n**Execution Flow**:\n1. User submits natural language instruction via REST API (`/api/execute`)\n2. Orchestrator selects appropriate engine based on request parameter\n3. Engine creates fresh browser instance on new event loop (thread safety)\n4. AI agent interprets instruction and executes browser actions\n5. Results, history, and generated code returned to client\n6. Browser instance cleaned up via finally block\n\n**Security & Middleware** (`app/middleware/security.py`):\n- API key authentication (optional, configurable via `API_KEY` env var)\n- Rate limiting: In-memory limiter (10 requests per 60 seconds by default)\n- Input validation and sanitization\n- Error message sanitization to prevent information leakage\n- CORS support with configurable allowed origins\n\n**Thread Safety Design**: Designed for Flask's multi-threaded WSGI environment. Each request creates its own asyncio event loop and browser instance, avoiding event loop affinity issues. Resources are properly cleaned up after each request.\n\n**Timeout Handling** (`app/utils/timeout.py`): Cross-platform timeout mechanism using ThreadPoolExecutor to prevent hung operations (default: 300 seconds).\n\n### API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute automation instruction\n- `GET /api/tools` - List available tools for an engine\n- `POST /api/reset` - Reset agent conversation history\n- `GET /health` - Health check endpoint\n\n### Data Storage\n\n**No Database**: The current implementation does not use a persistent database. All state is in-memory or written to local files (screenshots, PDFs, workflow states, cookies).\n\n**File-Based Outputs**:\n- Screenshots: `automation_outputs/screenshots/`\n- PDFs: `automation_outputs/pdfs/`\n- Cookies: `automation_outputs/cookies/`\n- Workflow states: `workflow_states/*.json` (for complex multi-step workflows)\n\n**Environment Configuration**: Uses `python-dotenv` to load configuration from `.env` file with explicit override to prevent system environment variable conflicts.\n\n### Authentication & Authorization\n\n**API Key Authentication**: Optional middleware-based API key validation via `X-API-Key` header. Disabled by default (no auth required), can be enabled by setting `API_KEY` environment variable.\n\n**No User Management**: The system does not implement user accounts, sessions, or role-based access control. It's designed as a single-user or team-shared automation service.\n\n## External Dependencies\n\n### Third-Party Services\n\n**OpenAI API** (Required):\n- Purpose: LLM reasoning for natural language instruction interpretation\n- Configuration: `OPENAI_API_KEY` environment variable (never hardcoded)\n- Models used: `gpt-4o-mini` (default, configurable in `config/config.ini`)\n- Usage: Both engines use OpenAI for instruction understanding and action planning\n\n### Core Python Libraries\n\n- **browser-use**: AI-powered browser automation library with LLM reasoning\n- **Playwright**: Cross-browser automation framework (Chromium, Firefox, WebKit)\n- **langchain-openai**: LangChain integration for OpenAI models\n- **Flask**: Web framework for REST API and UI serving\n- **Flask-CORS**: Cross-origin resource sharing support\n- **python-dotenv**: Environment variable management from `.env` files\n- **pytest**, **pytest-cov**: Testing framework and coverage\n- **gunicorn**: Production WSGI server\n\n### Node.js Components\n\n**Playwright MCP Server** (`integrations/playwright_mcp_node/`):\n- Purpose: Provides tool-based browser automation via Model Context Protocol\n- Package: `@playwright/mcp` (custom MCP server implementation)\n- Communication: JSON-RPC over STDIO with Python subprocess\n- Dependencies: `@modelcontextprotocol/sdk`, `playwright`, `playwright-core`\n\n### Browser Requirements\n\n**Playwright Browsers**: Automatically downloads Chromium, Firefox, and WebKit on first run. Configurable via `config/config.ini`:\n- Default browser: Chromium\n- Headless mode: Configurable per request\n- Browser validation: Skipped via `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS=1`\n\n### Configuration Files\n\n**config/config.ini**: Central configuration for OpenAI models and browser settings\n**.env**: Sensitive environment variables (API keys, secrets)\n- `OPENAI_API_KEY`: Required for AI features\n- `SESSION_SECRET`: Flask session secret\n- `CORS_ALLOWED_ORIGINS`: Comma-separated allowed origins for CORS\n\n## Testing\n\n**Test Structure** (`tests/`):\n- `unit/`: Unit tests for individual components (security, validation, utilities)\n- `integration/`: Integration tests for API endpoints and engine orchestration\n- `conftest.py`: Pytest configuration and shared fixtures\n\nRun tests: `pytest tests/`\n\n## Recent Changes\n\n**2025-10-24**: Major project restructure\n- Removed hybrid engine implementation (simplified to 2 engines: browser_use, playwright_mcp)\n- Reorganized project structure professionally:\n  - Moved `browser_use_codebase/` â†’ `app/engines/browser_use/`\n  - Moved `playwright_mcp_codebase/` â†’ `app/engines/playwright_mcp/`\n  - Moved `node/` â†’ `integrations/playwright_mcp_node/`\n- Updated all imports to reflect new package structure\n- Deleted unnecessary files (requirements.txt.bak, config.ini duplicate, check_env.py, run_windows.bat, uv.lock)\n- Created professional test suite structure\n- Browser-Use is now the default and recommended engine\n","size_bytes":10907},"playwright_mcp_codebase/client/stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        args = [\"node\", \"node/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        pass\n                except UnicodeDecodeError:\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8234},"app/__init__.py":{"content":"\"\"\"\nFlask Application Factory\n\"\"\"\nimport os\nimport logging\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.routes.api import create_api_routes\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\ndef create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \n    Returns:\n        Configured Flask app instance\n    \"\"\"\n    # Configure detailed logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S',\n        handlers=[\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n    \n    # Set browser-use and agent loggers to INFO to see detailed steps\n    logging.getLogger('browser_use').setLevel(logging.INFO)\n    logging.getLogger('Agent').setLevel(logging.INFO)\n    logging.getLogger('service').setLevel(logging.INFO)\n    logging.getLogger('tools').setLevel(logging.INFO)\n    logging.getLogger('BrowserSession').setLevel(logging.INFO)\n    \n    logger = logging.getLogger(__name__)\n    logger.info(\"ðŸš€ Starting AI Browser Automation application\")\n    \n    app = Flask(__name__)\n    app.config['SECRET_KEY'] = os.environ.get(\"SESSION_SECRET\")\n    \n    allowed_origins = os.environ.get('CORS_ALLOWED_ORIGINS', '*').split(',')\n    CORS(app, \n         resources={r\"/api/*\": {\"origins\": allowed_origins}},\n         methods=[\"GET\", \"POST\", \"OPTIONS\"],\n         allow_headers=[\"Content-Type\", \"X-API-Key\"],\n         supports_credentials=True)\n    \n    logger.info(f\"ðŸ”’ CORS configured with origins: {allowed_origins}\")\n    logger.info(\"ðŸ“¦ Initializing Engine Orchestrator\")\n    orchestrator = EngineOrchestrator()\n    \n    logger.info(\"ðŸ”— Registering API routes\")\n    api_routes = create_api_routes(orchestrator)\n    app.register_blueprint(api_routes)\n    \n    # Add cache control headers to prevent browser caching issues\n    @app.after_request\n    def add_cache_control_headers(response):\n        \"\"\"Add Cache-Control headers to all responses to prevent caching\"\"\"\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, public, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        return response\n    \n    logger.info(\"âœ… Application initialization complete\")\n    \n    return app\n","size_bytes":2572},"node/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"app/middleware/__init__.py":{"content":"\"\"\"Middleware package\"\"\"\n","size_bytes":25},"check_env.py":{"content":"\"\"\"\nEnvironment Check Script\nRun this script to verify your .env file is set up correctly\n\"\"\"\nimport os\nfrom dotenv import load_dotenv, dotenv_values\n\nprint(\"=\" * 60)\nprint(\"Environment Configuration Check\")\nprint(\"=\" * 60)\n\n# Check if .env file exists\nif os.path.exists('.env'):\n    print(\"âœ… .env file found\")\nelse:\n    print(\"âŒ .env file NOT found\")\n    print(\"   Please create a .env file in the project root directory\")\n    print(\"   You can copy .env.example and rename it to .env\")\n    exit(1)\n\n# Check what's in the .env file (before loading into environment)\nprint(\"\\nðŸ“„ Checking .env file contents...\")\nenv_values = dotenv_values('.env')\nif 'OPENAI_API_KEY' in env_values:\n    env_key = env_values['OPENAI_API_KEY']\n    masked_env = env_key[:10] + \"...\" + env_key[-4:] if len(env_key) > 14 else \"***\"\n    print(f\"   .env file contains OPENAI_API_KEY: {masked_env}\")\nelse:\n    print(\"   âš ï¸  .env file does NOT contain OPENAI_API_KEY\")\n\n# Check if there's a system environment variable (before loading .env)\nprint(\"\\nðŸ” Checking system environment variables...\")\nsystem_key = os.environ.get('OPENAI_API_KEY')\nif system_key:\n    masked_sys = system_key[:10] + \"...\" + system_key[-4:] if len(system_key) > 14 else \"***\"\n    print(f\"   âš ï¸  WARNING: System has OPENAI_API_KEY set: {masked_sys}\")\n    print(\"   This might conflict with your .env file!\")\n    print(\"\\n   To remove the system environment variable:\")\n    print(\"   - Close all Command Prompt/PowerShell windows\")\n    print(\"   - Open a fresh terminal and run this script again\")\n    print(\"   - Or in current session, run: set OPENAI_API_KEY=\")\nelse:\n    print(\"   âœ… No system OPENAI_API_KEY found (good!)\")\n\n# Load .env file with override\nprint(\"\\nðŸ”„ Loading .env file...\")\nload_dotenv(override=True)\n\n# Check for OPENAI_API_KEY after loading\nprint(\"\\nâœ… Final environment check:\")\napi_key = os.environ.get('OPENAI_API_KEY')\nif api_key:\n    # Mask the key for security\n    masked_key = api_key[:10] + \"...\" + api_key[-4:] if len(api_key) > 14 else \"***\"\n    print(f\"   OPENAI_API_KEY is set: {masked_key}\")\n    \n    # Check if it matches the .env file\n    if 'OPENAI_API_KEY' in env_values and api_key == env_values['OPENAI_API_KEY']:\n        print(\"   âœ… Matches .env file - Perfect!\")\n    elif system_key and api_key == env_values['OPENAI_API_KEY']:\n        print(\"   âœ… Using .env file (system variable was overridden)\")\n    else:\n        print(\"   âš ï¸  Using system environment variable\")\nelse:\n    print(\"   âŒ OPENAI_API_KEY is NOT set\")\n    print(\"   Please add OPENAI_API_KEY=your-key-here to your .env file\")\n    exit(1)\n\n# Check for SESSION_SECRET\nsession_secret = os.environ.get('SESSION_SECRET')\nif session_secret:\n    print(f\"   âœ… SESSION_SECRET is set\")\nelse:\n    print(\"   âš ï¸  SESSION_SECRET is not set (optional but recommended)\")\n\nprint(\"=\" * 60)\nprint(\"âœ… All required environment variables are configured!\")\nprint(\"You can now run: python main.py\")\nprint(\"=\" * 60)\n","size_bytes":2985},"app/routes/__init__.py":{"content":"\"\"\"\nFlask Routes Module\n\"\"\"\nfrom app.routes.api import create_api_routes\n\n__all__ = ['create_api_routes']\n","size_bytes":106},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\nfrom app import create_app\n\n# Force unbuffered output for better logging\nif hasattr(sys.stdout, 'reconfigure'):\n    sys.stdout.reconfigure(line_buffering=True)  # type: ignore\nos.environ['PYTHONUNBUFFERED'] = '1'\n\n# Load .env file and override any existing environment variables\nload_dotenv(override=True)\n\napp = create_app()\n\nif __name__ == '__main__':\n    # IMPORTANT: Do not hardcode API keys in source files. Read from environment.\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    \n    print(\"=\"*80)\n    print(\"ðŸš€ AI BROWSER AUTOMATION - STARTING UP\")\n    print(\"=\"*80)\n    \n    if not api_key:\n        print(\"\\nâš ï¸  WARNING: OPENAI_API_KEY environment variable is not set.\")\n        print(\"   The application will start but AI features will not work.\")\n        print(\"   Please set the OPENAI_API_KEY in your Replit Secrets.\\n\")\n    else:\n        print(f\"âœ… API Key found: {api_key[:20]}...{api_key[-4:]}\")\n    \n    sys.stdout.flush()\n\n    print(\"\\nðŸŒ Starting Flask web server on port 5000...\")\n    print(\"=\"*80)\n    print(\"\\nðŸ’¡ TIP: Keep this console window open to see automation logs\\n\")\n    sys.stdout.flush()\n\n    # Start the web app with debug mode for better console output\n    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)\n","size_bytes":1393},"node/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"playwright_mcp_codebase/__init__.py":{"content":"\"\"\"\nPlaywright MCP Codebase\nTool-based browser automation using Playwright's Model Context Protocol\n\"\"\"\nfrom playwright_mcp_codebase.client.stdio_client import MCPStdioClient\nfrom playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Playwright MCP engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        Tuple of (mcp_client, browser_agent)\n    \"\"\"\n    mcp_client = MCPStdioClient(headless=headless)\n    browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n__all__ = ['MCPStdioClient', 'BrowserAgent', 'create_engine']\n","size_bytes":700},"app/utils/__init__.py":{"content":"\"\"\"Utilities package\"\"\"\n","size_bytes":24},"playwright_mcp_codebase/agent/__init__.py":{"content":"\"\"\"\nPlaywright MCP Agent Module\n\"\"\"\nfrom playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n\n__all__ = ['BrowserAgent']\n","size_bytes":138},"WINDOWS_SETUP.md":{"content":"# Windows Setup Guide\n\n## Quick Start for Windows\n\n### Step 1: Create a `.env` file\n\n**IMPORTANT**: The file MUST be named `.env` exactly (no `.txt` extension!)\n\n1. Open Notepad or any text editor\n2. Copy this template and paste it:\n   ```\n   OPENAI_API_KEY=your-openai-api-key-here\n   SESSION_SECRET=my-secret-key-123\n   CORS_ALLOWED_ORIGINS=*\n   ```\n3. Replace `your-openai-api-key-here` with your actual OpenAI API key\n4. Click \"File\" â†’ \"Save As\"\n5. **Important**: In the \"Save as type\" dropdown, select \"All Files (*.*)\"\n6. Name the file exactly: `.env` (with the dot at the beginning)\n7. Save it in the project root directory (same folder as `main.py`)\n\n**Common Mistake**: Windows often hides file extensions. If your file shows as `.env.txt`, you need to:\n- Open File Explorer\n- Click \"View\" â†’ Check \"File name extensions\"\n- Rename the file to remove the `.txt` part\n\n### Step 2: Verify Your Setup\n\n**Run this command to check if your .env file is configured correctly:**\n\n```bash\npython check_env.py\n```\n\nIf you see all green checkmarks (âœ…), you're good to go!\n\nIf you see red X marks (âŒ), follow the error messages to fix the issues.\n\n### Step 3: Install Python Dependencies\n\nOpen Command Prompt or PowerShell in the project directory and run:\n\n```bash\npip install -r requirements.txt\n```\n\n### Step 4: Run the Application\n\n```bash\npython main.py\n```\n\nThe application will:\n- Load your `.env` file automatically\n- Start the web server on http://localhost:5782\n- Open your browser to that address\n\n## Troubleshooting\n\n### Error: \"OPENAI_API_KEY environment variable is not set\"\n\n**Solution**: Make sure you created the `.env` file (not `.env.txt`) in the project root directory with your actual API key.\n\n### Error: \"No module named 'dotenv'\"\n\n**Solution**: Install python-dotenv:\n```bash\npip install python-dotenv\n```\n\n### Browser doesn't open automatically\n\n**Solution**: Manually open your browser and go to:\n```\nhttp://localhost:5782\n```\n\n## Getting Your OpenAI API Key\n\n1. Go to https://platform.openai.com/\n2. Sign in or create an account\n3. Navigate to API Keys section\n4. Click \"Create new secret key\"\n5. Copy the key (it starts with `sk-`)\n6. Paste it into your `.env` file\n\n## Security Note\n\n**IMPORTANT**: Never commit your `.env` file to Git! It's already listed in `.gitignore` to prevent accidental commits.\n","size_bytes":2337},"tests/test_engine_orchestrator.py":{"content":"\"\"\"\nTests for Engine Orchestrator\n\"\"\"\nimport unittest\nfrom unittest.mock import Mock, patch, MagicMock\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n\nclass TestEngineOrchestrator(unittest.TestCase):\n    \"\"\"Test cases for EngineOrchestrator\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.orchestrator = EngineOrchestrator()\n    \n    def test_initialization(self):\n        \"\"\"Test orchestrator initializes with empty caches\"\"\"\n        self.assertEqual(self.orchestrator.playwright_engines, {})\n        self.assertEqual(self.orchestrator.browser_use_engines, {})\n        self.assertEqual(self.orchestrator.hybrid_engines, {})\n    \n    @patch('app.services.engine_orchestrator.browser_use_codebase')\n    def test_browser_use_engine_caching(self, mock_browser_use):\n        \"\"\"Test that Browser-Use engines are cached per headless mode\"\"\"\n        mock_engine = Mock()\n        mock_browser_use.create_engine.return_value = mock_engine\n        \n        # First call should create engine\n        engine1 = self.orchestrator.get_browser_use_engine(headless=True)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 1)\n        \n        # Second call with same headless should return cached engine\n        engine2 = self.orchestrator.get_browser_use_engine(headless=True)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 1)\n        self.assertIs(engine1, engine2)\n        \n        # Call with different headless should create new engine\n        engine3 = self.orchestrator.get_browser_use_engine(headless=False)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 2)\n        self.assertIsNot(engine1, engine3)\n    \n    @patch('app.services.engine_orchestrator.hybrid_engine')\n    def test_hybrid_engine_caching(self, mock_hybrid):\n        \"\"\"Test that Hybrid engines are cached per headless mode\"\"\"\n        mock_engine = Mock()\n        mock_hybrid.create_engine.return_value = mock_engine\n        \n        # First call should create engine\n        engine1 = self.orchestrator.get_hybrid_engine(headless=True)\n        self.assertEqual(mock_hybrid.create_engine.call_count, 1)\n        \n        # Second call should return cached engine\n        engine2 = self.orchestrator.get_hybrid_engine(headless=True)\n        self.assertEqual(mock_hybrid.create_engine.call_count, 1)\n        self.assertIs(engine1, engine2)\n    \n    def test_execute_instruction_invalid_engine(self):\n        \"\"\"Test that invalid engine type raises ValueError\"\"\"\n        with self.assertRaises(ValueError) as context:\n            self.orchestrator.execute_instruction(\n                \"test instruction\",\n                \"invalid_engine\",\n                headless=True\n            )\n        self.assertIn(\"Unknown engine type\", str(context.exception))\n    \n    @patch('app.services.engine_orchestrator.browser_use_codebase')\n    def test_execute_instruction_browser_use(self, mock_browser_use):\n        \"\"\"Test executing instruction with Browser-Use engine\"\"\"\n        mock_engine = Mock()\n        mock_engine.execute_instruction_sync.return_value = {\n            'success': True,\n            'message': 'Task completed',\n            'iterations': 5\n        }\n        mock_browser_use.create_engine.return_value = mock_engine\n        \n        result = self.orchestrator.execute_instruction(\n            \"Go to google.com\",\n            \"browser_use\",\n            headless=True\n        )\n        \n        self.assertTrue(result['success'])\n        self.assertEqual(result['engine'], 'browser_use')\n        self.assertTrue(result['headless'])\n        mock_engine.execute_instruction_sync.assert_called_once_with(\"Go to google.com\")\n\n\nif __name__ == '__main__':\n    unittest.main()\n","size_bytes":3734},"WINDOWS_TROUBLESHOOTING.md":{"content":"# Windows Troubleshooting Guide\n\n## Problem: API Key from Wrong Source\n\n### Symptom\nWhen you run `python main.py`, it prints an API key, but it's not the one from your `.env` file.\n\n### Cause\nYou likely set `OPENAI_API_KEY` as a **system environment variable** on Windows at some point (maybe when testing earlier). Windows system environment variables take priority over `.env` files.\n\n### Solution: Clear the System Environment Variable\n\n**Option 1: Temporary Fix (Current Terminal Only)**\n```cmd\nset OPENAI_API_KEY=\n```\nThen close and reopen your terminal, and run the app again.\n\n**Option 2: Permanent Fix (Remove from System)**\n\n1. Press `Windows Key + R`\n2. Type `sysdm.cpl` and press Enter\n3. Click \"Advanced\" tab\n4. Click \"Environment Variables\" button\n5. Look in both sections:\n   - \"User variables for [your username]\"\n   - \"System variables\"\n6. Find `OPENAI_API_KEY` if it exists\n7. Select it and click \"Delete\"\n8. Click OK on all windows\n9. **Close ALL Command Prompt/PowerShell windows**\n10. Open a fresh terminal\n\n**Option 3: Just Use the .env File (Current Fix)**\n\nGood news! I've updated the code to use `load_dotenv(override=True)`, which means your `.env` file will now **override** any system environment variables. Just make sure you have the correct API key in your `.env` file.\n\n### Verify Your Setup\n\nRun this diagnostic script:\n```bash\npython check_env.py\n```\n\nThis will show you:\n- âœ… What's in your `.env` file\n- âš ï¸  If you have a system environment variable set\n- âœ… Which one is actually being used\n\n## Problem: Still Getting \"API Key Not Set\" Error\n\n### Check These Things:\n\n1. **File is named correctly**\n   - Must be `.env` (not `.env.txt` or `env`)\n   - Run: `dir .env` in the project folder\n   - You should see: `.env`\n\n2. **File is in the right location**\n   - Must be in the same folder as `main.py`\n   - Run: `dir` and verify both `.env` and `main.py` are listed\n\n3. **File has correct content**\n   - Run: `type .env` to see contents\n   - Should show: `OPENAI_API_KEY=sk-...`\n   - Make sure there are NO spaces around the `=` sign\n   - Make sure there are NO quotes around the key\n\n4. **Dependencies are installed**\n   - Run: `pip install python-dotenv`\n   - Then: `pip install -r requirements.txt`\n\n## Common Mistakes\n\n### âŒ WRONG: .env.txt\nWindows often adds `.txt` extension automatically when you save in Notepad.\n\n**Fix**: In Notepad, choose \"All Files (*.*)\" when saving, not \"Text Documents (*.txt)\"\n\n### âŒ WRONG: Quotes around the key\n```\nOPENAI_API_KEY=\"sk-your-key-here\"\n```\n\n**Fix**: Remove the quotes:\n```\nOPENAI_API_KEY=sk-your-key-here\n```\n\n### âŒ WRONG: Spaces around equals\n```\nOPENAI_API_KEY = sk-your-key-here\n```\n\n**Fix**: Remove spaces:\n```\nOPENAI_API_KEY=sk-your-key-here\n```\n\n### âŒ WRONG: Missing the `sk-` prefix\nYour OpenAI API key should start with `sk-` or `sk-proj-`\n\n## Still Not Working?\n\nRun the diagnostic and send me the output:\n```bash\npython check_env.py\n```\n\nThis will help me see exactly what's wrong!\n","size_bytes":2987},"browser_use_codebase/state_manager.py":{"content":"\"\"\"\nState Management for Complex Multi-Step Workflows\nPreserves context and state across automation steps\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass WorkflowState:\n    \"\"\"\n    Manages state for complex multi-step automation workflows\n    Preserves context, variables, and execution history\n    \"\"\"\n    \n    def __init__(self, workflow_id: Optional[str] = None, persist_to_disk: bool = False):\n        \"\"\"\n        Initialize workflow state manager\n        \n        Args:\n            workflow_id: Unique identifier for this workflow\n            persist_to_disk: Save state to disk for recovery\n        \"\"\"\n        self.workflow_id = workflow_id or f\"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.persist_to_disk = persist_to_disk\n        \n        self.state: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.execution_history: List[Dict[str, Any]] = []\n        self.checkpoints: List[Dict[str, Any]] = []\n        \n        self.metadata = {\n            \"workflow_id\": self.workflow_id,\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"step_count\": 0\n        }\n        \n        if self.persist_to_disk:\n            self.state_dir = Path(\"workflow_states\")\n            self.state_dir.mkdir(exist_ok=True)\n            self.state_file = self.state_dir / f\"{self.workflow_id}.json\"\n        \n        logger.info(f\"ðŸ”„ Workflow state initialized: {self.workflow_id}\")\n    \n    def set_variable(self, key: str, value: Any):\n        \"\"\"\n        Set a workflow variable\n        \n        Args:\n            key: Variable name\n            value: Variable value\n        \"\"\"\n        self.variables[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ“ Variable set: {key} = {value}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_variable(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a workflow variable\n        \n        Args:\n            key: Variable name\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Variable value or default\n        \"\"\"\n        return self.variables.get(key, default)\n    \n    def set_state(self, key: str, value: Any):\n        \"\"\"\n        Set a state value\n        \n        Args:\n            key: State key\n            value: State value\n        \"\"\"\n        self.state[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ’¾ State set: {key}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_state(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a state value\n        \n        Args:\n            key: State key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            State value or default\n        \"\"\"\n        return self.state.get(key, default)\n    \n    def add_step(self, step_name: str, step_data: Dict[str, Any], success: bool = True):\n        \"\"\"\n        Record a workflow step\n        \n        Args:\n            step_name: Name of the step\n            step_data: Data associated with the step\n            success: Whether the step succeeded\n        \"\"\"\n        step_record = {\n            \"step_number\": self.metadata[\"step_count\"] + 1,\n            \"step_name\": step_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"success\": success,\n            \"data\": step_data\n        }\n        \n        self.execution_history.append(step_record)\n        self.metadata[\"step_count\"] += 1\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"âœ… Step {self.metadata['step_count']} recorded: {step_name} (success: {success})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def create_checkpoint(self, checkpoint_name: str):\n        \"\"\"\n        Create a checkpoint of current state\n        \n        Args:\n            checkpoint_name: Name for this checkpoint\n        \"\"\"\n        checkpoint = {\n            \"name\": checkpoint_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"state\": self.state.copy(),\n            \"variables\": self.variables.copy(),\n            \"step_count\": self.metadata[\"step_count\"]\n        }\n        \n        self.checkpoints.append(checkpoint)\n        logger.info(f\"ðŸ”– Checkpoint created: {checkpoint_name} (at step {self.metadata['step_count']})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def restore_checkpoint(self, checkpoint_name: str) -> bool:\n        \"\"\"\n        Restore state from a checkpoint\n        \n        Args:\n            checkpoint_name: Name of checkpoint to restore\n            \n        Returns:\n            True if restored successfully, False if checkpoint not found\n        \"\"\"\n        for checkpoint in reversed(self.checkpoints):\n            if checkpoint[\"name\"] == checkpoint_name:\n                self.state = checkpoint[\"state\"].copy()\n                self.variables = checkpoint[\"variables\"].copy()\n                \n                logger.info(f\"â™»ï¸  Restored checkpoint: {checkpoint_name} (from step {checkpoint['step_count']})\")\n                \n                if self.persist_to_disk:\n                    self._save_to_disk()\n                \n                return True\n        \n        logger.warning(f\"âš ï¸  Checkpoint not found: {checkpoint_name}\")\n        return False\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of the workflow state\n        \n        Returns:\n            Dictionary with state summary\n        \"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"metadata\": self.metadata,\n            \"total_steps\": self.metadata[\"step_count\"],\n            \"total_checkpoints\": len(self.checkpoints),\n            \"variable_count\": len(self.variables),\n            \"state_keys\": list(self.state.keys()),\n            \"success_rate\": self._calculate_success_rate()\n        }\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate success rate of executed steps\"\"\"\n        if not self.execution_history:\n            return 100.0\n        \n        successful = sum(1 for step in self.execution_history if step[\"success\"])\n        return (successful / len(self.execution_history)) * 100\n    \n    def _save_to_disk(self):\n        \"\"\"Save state to disk\"\"\"\n        try:\n            state_data = {\n                \"workflow_id\": self.workflow_id,\n                \"metadata\": self.metadata,\n                \"state\": self.state,\n                \"variables\": self.variables,\n                \"execution_history\": self.execution_history,\n                \"checkpoints\": self.checkpoints\n            }\n            \n            with open(self.state_file, 'w') as f:\n                json.dump(state_data, f, indent=2)\n            \n            logger.debug(f\"ðŸ’¾ State saved to: {self.state_file}\")\n        except Exception as e:\n            logger.error(f\"âŒ Failed to save state: {str(e)}\")\n    \n    @classmethod\n    def load_from_disk(cls, workflow_id: str) -> Optional['WorkflowState']:\n        \"\"\"\n        Load workflow state from disk\n        \n        Args:\n            workflow_id: Workflow ID to load\n            \n        Returns:\n            WorkflowState instance or None if not found\n        \"\"\"\n        state_file = Path(\"workflow_states\") / f\"{workflow_id}.json\"\n        \n        if not state_file.exists():\n            logger.warning(f\"âš ï¸  Workflow state not found: {workflow_id}\")\n            return None\n        \n        try:\n            with open(state_file, 'r') as f:\n                state_data = json.load(f)\n            \n            instance = cls(workflow_id=workflow_id, persist_to_disk=True)\n            instance.metadata = state_data[\"metadata\"]\n            instance.state = state_data[\"state\"]\n            instance.variables = state_data[\"variables\"]\n            instance.execution_history = state_data[\"execution_history\"]\n            instance.checkpoints = state_data[\"checkpoints\"]\n            \n            logger.info(f\"ðŸ“‚ Workflow state loaded: {workflow_id}\")\n            return instance\n            \n        except Exception as e:\n            logger.error(f\"âŒ Failed to load state: {str(e)}\")\n            return None\n    \n    def reset(self):\n        \"\"\"Reset workflow state\"\"\"\n        self.state.clear()\n        self.variables.clear()\n        self.execution_history.clear()\n        self.checkpoints.clear()\n        self.metadata[\"step_count\"] = 0\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"ðŸ”„ Workflow state reset: {self.workflow_id}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n","size_bytes":9020},"browser_use_codebase/data_extractor.py":{"content":"\"\"\"\nAdvanced Data Extraction Capabilities\nStructured data scraping, table extraction, and content parsing\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass DataExtractor:\n    \"\"\"\n    Advanced data extraction for web automation\n    Handles tables, lists, structured data, and custom selectors\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize data extractor\"\"\"\n        logger.info(\"ðŸ“Š Data extractor initialized\")\n    \n    async def extract_table(self, page, selector: str = \"table\", \n                          include_headers: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Extract data from HTML table\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for table\n            include_headers: Extract header row\n            \n        Returns:\n            Dictionary with table data\n        \"\"\"\n        try:\n            table_data = await page.evaluate(f\"\"\"(selector) => {{\n                const table = document.querySelector(selector);\n                if (!table) return null;\n                \n                const rows = Array.from(table.querySelectorAll('tr'));\n                const data = [];\n                \n                rows.forEach((row, index) => {{\n                    const cells = Array.from(row.querySelectorAll('td, th'));\n                    const rowData = cells.map(cell => cell.textContent.trim());\n                    if (rowData.length > 0) {{\n                        data.push(rowData);\n                    }}\n                }});\n                \n                return data;\n            }}\"\"\", selector)\n            \n            if not table_data:\n                return {\"success\": False, \"error\": \"Table not found\"}\n            \n            result = {\n                \"success\": True,\n                \"rows\": table_data,\n                \"row_count\": len(table_data),\n                \"column_count\": len(table_data[0]) if table_data else 0\n            }\n            \n            if include_headers and table_data:\n                result[\"headers\"] = table_data[0]\n                result[\"data\"] = table_data[1:]\n            \n            logger.info(f\"ðŸ“Š Table extracted: {result['row_count']} rows, {result['column_count']} columns\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Table extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_list(self, page, selector: str, item_selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract items from a list\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for list container\n            item_selector: Optional selector for individual items\n            \n        Returns:\n            Dictionary with list items\n        \"\"\"\n        try:\n            if item_selector:\n                query = f\"{selector} {item_selector}\"\n            else:\n                query = f\"{selector} li\"\n            \n            items = await page.evaluate(f\"\"\"(query) => {{\n                const elements = document.querySelectorAll(query);\n                return Array.from(elements).map(el => el.textContent.trim());\n            }}\"\"\", query)\n            \n            logger.info(f\"ðŸ“‹ List extracted: {len(items)} items\")\n            \n            return {\n                \"success\": True,\n                \"items\": items,\n                \"item_count\": len(items)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ List extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_structured_data(self, page, schema: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data using a schema\n        \n        Args:\n            page: Playwright page object\n            schema: Dictionary mapping field names to CSS selectors\n            \n        Returns:\n            Dictionary with extracted data\n        \"\"\"\n        try:\n            extracted_data = {}\n            \n            for field_name, selector in schema.items():\n                try:\n                    value = await page.evaluate(f\"\"\"(selector) => {{\n                        const element = document.querySelector(selector);\n                        return element ? element.textContent.trim() : null;\n                    }}\"\"\", selector)\n                    \n                    extracted_data[field_name] = value\n                except:\n                    extracted_data[field_name] = None\n            \n            logger.info(f\"ðŸ“¦ Structured data extracted: {len(extracted_data)} fields\")\n            \n            return {\n                \"success\": True,\n                \"data\": extracted_data,\n                \"field_count\": len(extracted_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Structured data extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_all_links(self, page, base_url: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract all links from page\n        \n        Args:\n            page: Playwright page object\n            base_url: Optional base URL for relative links\n            \n        Returns:\n            Dictionary with links\n        \"\"\"\n        try:\n            links = await page.evaluate(\"\"\"() => {\n                const anchors = document.querySelectorAll('a[href]');\n                return Array.from(anchors).map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    rel_href: a.getAttribute('href')\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ”— Links extracted: {len(links)} links\")\n            \n            return {\n                \"success\": True,\n                \"links\": links,\n                \"link_count\": len(links),\n                \"page_url\": page.url\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Link extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_images(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract all images from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with image data\n        \"\"\"\n        try:\n            images = await page.evaluate(\"\"\"() => {\n                const imgs = document.querySelectorAll('img');\n                return Array.from(imgs).map(img => ({\n                    src: img.src,\n                    alt: img.alt,\n                    width: img.width,\n                    height: img.height\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ–¼ï¸  Images extracted: {len(images)} images\")\n            \n            return {\n                \"success\": True,\n                \"images\": images,\n                \"image_count\": len(images)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Image extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_metadata(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract page metadata (title, description, etc.)\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with metadata\n        \"\"\"\n        try:\n            metadata = await page.evaluate(\"\"\"() => {\n                const getMeta = (name) => {\n                    const element = document.querySelector(`meta[name=\"${name}\"], meta[property=\"${name}\"]`);\n                    return element ? element.content : null;\n                };\n                \n                return {\n                    title: document.title,\n                    description: getMeta('description') || getMeta('og:description'),\n                    keywords: getMeta('keywords'),\n                    author: getMeta('author'),\n                    og_title: getMeta('og:title'),\n                    og_image: getMeta('og:image'),\n                    canonical: document.querySelector('link[rel=\"canonical\"]')?.href\n                };\n            }\"\"\")\n            \n            metadata[\"url\"] = page.url\n            \n            logger.info(f\"â„¹ï¸  Metadata extracted from: {page.url}\")\n            \n            return {\n                \"success\": True,\n                \"metadata\": metadata\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Metadata extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_text_content(self, page, selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract text content from page or specific element\n        \n        Args:\n            page: Playwright page object\n            selector: Optional CSS selector for specific element\n            \n        Returns:\n            Dictionary with text content\n        \"\"\"\n        try:\n            if selector:\n                text = await page.evaluate(f\"\"\"(selector) => {{\n                    const element = document.querySelector(selector);\n                    return element ? element.textContent.trim() : null;\n                }}\"\"\", selector)\n            else:\n                text = await page.evaluate(\"\"\"() => {\n                    return document.body.textContent.trim();\n                }\"\"\")\n            \n            logger.info(f\"ðŸ“ Text content extracted: {len(text)} characters\")\n            \n            return {\n                \"success\": True,\n                \"text\": text,\n                \"length\": len(text) if text else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Text extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n","size_bytes":10037},"browser_use_codebase/engine_optimized.py":{"content":"\"\"\"\nOptimized Browser-Use Engine\nAI-powered browser automation with advanced features and optimizations\n\nNew Features:\n- Advanced browser capabilities (screenshots, PDFs, cookies, sessions)\n- Enhanced popup handling with configurable timeouts\n- Smart retry mechanism with exponential backoff\n- State management for complex workflows\n- Data extraction capabilities\n- Performance monitoring and metrics\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\n\nfrom browser_use_codebase.advanced_features import AdvancedBrowserFeatures\nfrom browser_use_codebase.retry_mechanism import RetryConfig, RetryMechanism\nfrom browser_use_codebase.state_manager import WorkflowState\nfrom browser_use_codebase.data_extractor import DataExtractor\nfrom browser_use_codebase.performance_monitor import PerformanceMonitor\n\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedBrowserUseEngine:\n    \"\"\"\n    Optimized browser automation engine with advanced capabilities\n    \n    Features:\n    - Screenshot capture and PDF generation\n    - Cookie and session management\n    - Smart retry with exponential backoff\n    - Workflow state persistence\n    - Data extraction (tables, lists, metadata)\n    - Performance monitoring\n    - Enhanced popup handling\n    \"\"\"\n    \n    def __init__(self, headless: bool = False, enable_advanced_features: bool = True):\n        \"\"\"\n        Initialize Optimized Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n            enable_advanced_features: Enable advanced capabilities\n        \"\"\"\n        self.headless = headless\n        self.enable_advanced_features = enable_advanced_features\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n        \n        if enable_advanced_features:\n            output_dir = config.get('advanced_features', 'output_directory', fallback='automation_outputs')\n            self.enable_screenshots = config.getboolean('advanced_features', 'enable_screenshots', fallback=True)\n            self.enable_pdf_generation = config.getboolean('advanced_features', 'enable_pdf_generation', fallback=True)\n            self.enable_cookie_management = config.getboolean('advanced_features', 'enable_cookie_management', fallback=True)\n            self.enable_state_persistence = config.getboolean('advanced_features', 'enable_state_persistence', fallback=True)\n            \n            self.advanced_features = AdvancedBrowserFeatures(output_dir=output_dir)\n            \n            max_retries = int(config.get('retry', 'max_retries', fallback='3'))\n            initial_delay = float(config.get('retry', 'initial_delay', fallback='1.0'))\n            max_delay = float(config.get('retry', 'max_delay', fallback='30.0'))\n            backoff_factor = float(config.get('retry', 'backoff_factor', fallback='2.0'))\n            \n            retry_config = RetryConfig(\n                max_retries=max_retries,\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                backoff_factor=backoff_factor\n            )\n            self.retry_mechanism = RetryMechanism(retry_config)\n            \n            track_metrics = config.getboolean('performance', 'track_detailed_metrics', fallback=True)\n            self.performance_monitor = PerformanceMonitor(track_detailed_metrics=track_metrics)\n            \n            self.data_extractor = DataExtractor()\n            self.workflow_state = None\n            \n            logger.info(\"ðŸš€ Advanced features enabled: Screenshots, PDFs, Cookies, Retry, Performance Tracking\")\n        else:\n            logger.info(\"â„¹ï¸  Running in basic mode (advanced features disabled)\")\n    \n    async def execute_instruction(self, instruction: str, \n                                  workflow_id: Optional[str] = None,\n                                  save_screenshot: bool = False,\n                                  save_pdf: bool = False) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction with advanced features\n        \n        Args:\n            instruction: User's natural language instruction\n            workflow_id: Optional workflow ID for state management\n            save_screenshot: Capture screenshot after completion\n            save_pdf: Generate PDF after completion\n            \n        Returns:\n            Dictionary with execution results and advanced metrics\n        \"\"\"\n        op_id = None\n        if self.enable_advanced_features:\n            op_id = self.performance_monitor.start_operation(\"execute_instruction\")\n            \n            if workflow_id:\n                self.workflow_state = WorkflowState(workflow_id=workflow_id, persist_to_disk=True)\n        \n        try:\n            logger.info(\"ðŸ¤– Initializing Browser-Use Agent\")\n            logger.info(f\"ðŸ“‹ Task: {instruction}\")\n            logger.info(f\"ðŸ”¢ Max steps: {self.max_steps}\")\n            \n            # Enhanced system instructions with intelligent stopping mechanism\n            # Based on browser-use PR #61 for 10X efficiency improvement\n            system_instructions = f\"\"\"\nCRITICAL INSTRUCTIONS - KEEP RESPONSES BRIEF:\n1. Follow the user's instruction LITERALLY - do only what is explicitly asked\n2. STOP IMMEDIATELY once the stated task is complete\n3. Do NOT extract, save, or compile data unless explicitly requested\n4. Do NOT perform additional \"helpful\" actions beyond the instruction\n5. If asked to \"search\", stop when search results appear\n6. If asked to \"navigate\", stop when the page loads\n7. If asked to \"click\", stop after clicking\n8. Only do extra work (extract, save, analyze) if the instruction explicitly asks for it\n9. IMPORTANT: Keep all your reasoning and output SHORT and DIRECT to avoid timeouts\n\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\nDo not continue working after achieving your goal!\n\nPOPUP WINDOW HANDLING:\n- When a button opens a NEW WINDOW or POPUP (like \"Sign in with Google\", \"Continue with X\", etc.):\n  * The browser will automatically switch to the new window\n  * Continue your task in the NEW WINDOW without mentioning the window switch\n  * All subsequent actions should be performed in the NEW WINDOW\n- DO NOT try to switch windows manually - it happens automatically\n- DO NOT mention window switches in your output - just continue the task seamlessly\n            \"\"\"\n            \n            logger.info(\"âš™ï¸  Configuring agent with optimizations\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"â–¶ï¸  Starting agent execution...\")\n            \n            if self.enable_advanced_features:\n                @self.retry_mechanism.async_retry\n                async def run_with_retry():\n                    return await agent.run(max_steps=self.max_steps)\n                \n                history = await run_with_retry()\n            else:\n                history = await agent.run(max_steps=self.max_steps)\n            \n            logger.info(f\"â¹ï¸  Agent execution completed\")\n            \n            logger.info(\"ðŸ“Š Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n                \n                if self.enable_advanced_features and self.workflow_state:\n                    self.workflow_state.add_step(\n                        step_name=f\"browser_action_{step_num}\",\n                        step_data={\"action\": action},\n                        success=True\n                    )\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"ðŸŽ­ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            if len(steps) == 0:\n                logger.error(f\"âŒ Task failed - no steps were executed successfully\")\n                result = {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            else:\n                logger.info(f\"âœ… Task completed successfully!\")\n                logger.info(f\"ðŸ“ˆ Total steps executed: {len(steps)}\")\n                if final_result:\n                    logger.info(f\"ðŸŽ¯ Final result: {str(final_result)[:200]}\")\n                \n                result = {\n                    \"success\": True,\n                    \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result\n                }\n                \n                # Add Playwright code if generated\n                if playwright_code:\n                    result[\"playwright_code\"] = playwright_code\n            \n            if self.enable_advanced_features:\n                if op_id:\n                    self.performance_monitor.end_operation(op_id, success=result[\"success\"])\n                \n                result[\"performance_metrics\"] = self.performance_monitor.get_summary()\n                \n                if self.workflow_state:\n                    result[\"workflow_state\"] = self.workflow_state.get_summary()\n                \n                result[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Browser-Use execution failed: {str(e)}\", exc_info=True)\n            \n            if self.enable_advanced_features and op_id:\n                self.performance_monitor.end_operation(op_id, success=False)\n            \n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            **kwargs: Additional arguments for execute_instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction, **kwargs))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance monitoring summary\"\"\"\n        if self.enable_advanced_features:\n            return self.performance_monitor.get_summary()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def get_retry_stats(self) -> Dict[str, Any]:\n        \"\"\"Get retry mechanism statistics\"\"\"\n        if self.enable_advanced_features:\n            return self.retry_mechanism.get_stats()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics and statistics\"\"\"\n        if self.enable_advanced_features:\n            self.performance_monitor.reset()\n            self.retry_mechanism.reset_stats()\n            logger.info(\"ðŸ”„ All metrics reset\")\n","size_bytes":13966},"browser_use_codebase/performance_monitor.py":{"content":"\"\"\"\nPerformance Monitoring and Metrics Tracking\nTracks automation performance, timing, and resource usage\n\"\"\"\nimport time\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\nclass PerformanceMonitor:\n    \"\"\"\n    Monitor and track performance metrics for browser automation\n    Tracks timing, success rates, and resource usage\n    \"\"\"\n    \n    def __init__(self, track_detailed_metrics: bool = True):\n        \"\"\"\n        Initialize performance monitor\n        \n        Args:\n            track_detailed_metrics: Track detailed per-operation metrics\n        \"\"\"\n        self.track_detailed_metrics = track_detailed_metrics\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        \n        self.operation_metrics: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            \"count\": 0,\n            \"success_count\": 0,\n            \"fail_count\": 0,\n            \"total_duration\": 0.0,\n            \"min_duration\": float('inf'),\n            \"max_duration\": 0.0\n        })\n        \n        self.timing_stack: List[Dict[str, Any]] = []\n        \n        logger.info(\"ðŸ“Š Performance monitor initialized\")\n    \n    def start_operation(self, operation_name: str) -> str:\n        \"\"\"\n        Start tracking an operation\n        \n        Args:\n            operation_name: Name of the operation\n            \n        Returns:\n            Operation ID for stopping later\n        \"\"\"\n        operation_id = f\"{operation_name}_{len(self.timing_stack)}\"\n        \n        timing_info = {\n            \"operation_id\": operation_id,\n            \"operation_name\": operation_name,\n            \"start_time\": time.time(),\n            \"start_timestamp\": datetime.now().isoformat()\n        }\n        \n        self.timing_stack.append(timing_info)\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"â±ï¸  Started: {operation_name}\")\n        \n        return operation_id\n    \n    def end_operation(self, operation_id: str, success: bool = True, metadata: Optional[Dict] = None):\n        \"\"\"\n        End tracking an operation\n        \n        Args:\n            operation_id: ID returned from start_operation\n            success: Whether operation succeeded\n            metadata: Optional metadata about the operation\n        \"\"\"\n        if not self.timing_stack:\n            logger.warning(\"âš ï¸  No operation to end\")\n            return\n        \n        timing_info = self.timing_stack.pop()\n        \n        if timing_info[\"operation_id\"] != operation_id:\n            logger.warning(f\"âš ï¸  Operation ID mismatch: expected {timing_info['operation_id']}, got {operation_id}\")\n        \n        duration = time.time() - timing_info[\"start_time\"]\n        operation_name = timing_info[\"operation_name\"]\n        \n        self.metrics[\"total_operations\"] += 1\n        self.metrics[\"total_duration\"] += duration\n        \n        if success:\n            self.metrics[\"successful_operations\"] += 1\n        else:\n            self.metrics[\"failed_operations\"] += 1\n        \n        op_metrics = self.operation_metrics[operation_name]\n        op_metrics[\"count\"] += 1\n        op_metrics[\"total_duration\"] += duration\n        op_metrics[\"min_duration\"] = min(op_metrics[\"min_duration\"], duration)\n        op_metrics[\"max_duration\"] = max(op_metrics[\"max_duration\"], duration)\n        \n        if success:\n            op_metrics[\"success_count\"] += 1\n        else:\n            op_metrics[\"fail_count\"] += 1\n        \n        if self.track_detailed_metrics:\n            status = \"âœ…\" if success else \"âŒ\"\n            logger.info(f\"{status} {operation_name} completed in {duration:.2f}s\")\n    \n    def record_metric(self, metric_name: str, value: Any):\n        \"\"\"\n        Record a custom metric\n        \n        Args:\n            metric_name: Name of the metric\n            value: Metric value\n        \"\"\"\n        if \"custom_metrics\" not in self.metrics:\n            self.metrics[\"custom_metrics\"] = {}\n        \n        self.metrics[\"custom_metrics\"][metric_name] = value\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"ðŸ“Š Metric recorded: {metric_name} = {value}\")\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get performance summary\n        \n        Returns:\n            Dictionary with performance metrics\n        \"\"\"\n        total_ops = self.metrics[\"total_operations\"]\n        \n        summary = {\n            \"overview\": {\n                \"total_operations\": total_ops,\n                \"successful_operations\": self.metrics[\"successful_operations\"],\n                \"failed_operations\": self.metrics[\"failed_operations\"],\n                \"success_rate\": (self.metrics[\"successful_operations\"] / max(total_ops, 1)) * 100,\n                \"total_duration\": self.metrics[\"total_duration\"],\n                \"average_duration\": self.metrics[\"total_duration\"] / max(total_ops, 1),\n                \"start_time\": self.metrics[\"start_time\"],\n                \"current_time\": datetime.now().isoformat()\n            },\n            \"operation_breakdown\": {}\n        }\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            count = op_metrics[\"count\"]\n            summary[\"operation_breakdown\"][op_name] = {\n                \"count\": count,\n                \"success_count\": op_metrics[\"success_count\"],\n                \"fail_count\": op_metrics[\"fail_count\"],\n                \"success_rate\": (op_metrics[\"success_count\"] / max(count, 1)) * 100,\n                \"total_duration\": op_metrics[\"total_duration\"],\n                \"average_duration\": op_metrics[\"total_duration\"] / max(count, 1),\n                \"min_duration\": op_metrics[\"min_duration\"] if op_metrics[\"min_duration\"] != float('inf') else 0,\n                \"max_duration\": op_metrics[\"max_duration\"]\n            }\n        \n        if \"custom_metrics\" in self.metrics:\n            summary[\"custom_metrics\"] = self.metrics[\"custom_metrics\"]\n        \n        return summary\n    \n    def get_top_slowest_operations(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get the slowest operations\n        \n        Args:\n            limit: Number of operations to return\n            \n        Returns:\n            List of slowest operations with metrics\n        \"\"\"\n        operations = []\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            if op_metrics[\"count\"] > 0:\n                avg_duration = op_metrics[\"total_duration\"] / op_metrics[\"count\"]\n                operations.append({\n                    \"operation\": op_name,\n                    \"average_duration\": avg_duration,\n                    \"max_duration\": op_metrics[\"max_duration\"],\n                    \"count\": op_metrics[\"count\"]\n                })\n        \n        operations.sort(key=lambda x: x[\"average_duration\"], reverse=True)\n        return operations[:limit]\n    \n    def reset(self):\n        \"\"\"Reset all metrics\"\"\"\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        self.operation_metrics.clear()\n        self.timing_stack.clear()\n        \n        logger.info(\"ðŸ”„ Performance metrics reset\")\n    \n    def log_summary(self):\n        \"\"\"Log a formatted summary of metrics\"\"\"\n        summary = self.get_summary()\n        \n        logger.info(\"=\" * 80)\n        logger.info(\"ðŸ“Š PERFORMANCE SUMMARY\")\n        logger.info(\"=\" * 80)\n        logger.info(f\"Total Operations: {summary['overview']['total_operations']}\")\n        logger.info(f\"Success Rate: {summary['overview']['success_rate']:.1f}%\")\n        logger.info(f\"Total Duration: {summary['overview']['total_duration']:.2f}s\")\n        logger.info(f\"Average Duration: {summary['overview']['average_duration']:.2f}s\")\n        \n        if summary['operation_breakdown']:\n            logger.info(\"\\nðŸ“‹ Operation Breakdown:\")\n            for op_name, metrics in summary['operation_breakdown'].items():\n                logger.info(f\"  â€¢ {op_name}: {metrics['count']} ops, \"\n                          f\"avg {metrics['average_duration']:.2f}s, \"\n                          f\"success {metrics['success_rate']:.1f}%\")\n        \n        logger.info(\"=\" * 80)\n","size_bytes":8538},"browser_use_codebase/advanced_features.py":{"content":"\"\"\"\nAdvanced Browser Automation Features\nProvides screenshot capture, PDF generation, cookie management, and more\n\"\"\"\nimport os\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nfrom browser_use import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass AdvancedBrowserFeatures:\n    \"\"\"\n    Advanced capabilities for browser automation\n    Handles screenshots, PDFs, cookies, sessions, and more\n    \"\"\"\n    \n    def __init__(self, output_dir: str = \"automation_outputs\"):\n        \"\"\"\n        Initialize advanced browser features\n        \n        Args:\n            output_dir: Directory to save screenshots, PDFs, etc.\n        \"\"\"\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(exist_ok=True)\n        \n        self.screenshots_dir = self.output_dir / \"screenshots\"\n        self.pdfs_dir = self.output_dir / \"pdfs\"\n        self.cookies_dir = self.output_dir / \"cookies\"\n        \n        self.screenshots_dir.mkdir(exist_ok=True)\n        self.pdfs_dir.mkdir(exist_ok=True)\n        self.cookies_dir.mkdir(exist_ok=True)\n        \n        logger.info(f\"ðŸ“ Advanced features initialized with output dir: {self.output_dir}\")\n    \n    async def capture_screenshot(self, page, name: Optional[str] = None, full_page: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Capture screenshot of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for screenshot\n            full_page: Capture full scrollable page\n            \n        Returns:\n            Dictionary with screenshot path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.png\" if name else f\"screenshot_{timestamp}.png\"\n            filepath = self.screenshots_dir / filename\n            \n            await page.screenshot(path=str(filepath), full_page=full_page)\n            \n            logger.info(f\"ðŸ“¸ Screenshot saved: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"full_page\": full_page,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Screenshot capture failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def generate_pdf(self, page, name: Optional[str] = None, \n                          landscape: bool = False, \n                          print_background: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Generate PDF of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for PDF\n            landscape: Use landscape orientation\n            print_background: Include background graphics\n            \n        Returns:\n            Dictionary with PDF path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.pdf\" if name else f\"page_{timestamp}.pdf\"\n            filepath = self.pdfs_dir / filename\n            \n            await page.pdf(\n                path=str(filepath),\n                format='A4',\n                landscape=landscape,\n                print_background=print_background,\n                margin={'top': '20px', 'right': '20px', 'bottom': '20px', 'left': '20px'}\n            )\n            \n            logger.info(f\"ðŸ“„ PDF generated: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"landscape\": landscape,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ PDF generation failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def save_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Save browser cookies for session persistence\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name for this session\n            \n        Returns:\n            Dictionary with save status and path\n        \"\"\"\n        try:\n            cookies = await context.cookies()\n            \n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            with open(filepath, 'w') as f:\n                json.dump(cookies, f, indent=2)\n            \n            logger.info(f\"ðŸª Cookies saved: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie save failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def load_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Load previously saved cookies to restore session\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name of session to restore\n            \n        Returns:\n            Dictionary with load status\n        \"\"\"\n        try:\n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"error\": f\"Session '{session_name}' not found\"\n                }\n            \n            with open(filepath, 'r') as f:\n                cookies = json.load(f)\n            \n            await context.add_cookies(cookies)\n            \n            logger.info(f\"ðŸª Cookies loaded: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie load failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_local_storage(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract localStorage data from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with localStorage contents\n        \"\"\"\n        try:\n            storage_data = await page.evaluate(\"\"\"() => {\n                let data = {};\n                for (let i = 0; i < localStorage.length; i++) {\n                    let key = localStorage.key(i);\n                    data[key] = localStorage.getItem(key);\n                }\n                return data;\n            }\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage extracted: {len(storage_data)} items\")\n            \n            return {\n                \"success\": True,\n                \"data\": storage_data,\n                \"item_count\": len(storage_data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage extraction failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def set_local_storage(self, page, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set localStorage data on page\n        \n        Args:\n            page: Playwright page object\n            data: Dictionary of key-value pairs to set\n            \n        Returns:\n            Dictionary with operation status\n        \"\"\"\n        try:\n            for key, value in data.items():\n                await page.evaluate(f\"\"\"() => {{\n                    localStorage.setItem('{key}', '{value}');\n                }}\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage set: {len(data)} items\")\n            \n            return {\n                \"success\": True,\n                \"item_count\": len(data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage set failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    def list_sessions(self) -> List[str]:\n        \"\"\"\n        List all saved cookie sessions\n        \n        Returns:\n            List of session names\n        \"\"\"\n        sessions = []\n        for file in self.cookies_dir.glob(\"*_cookies.json\"):\n            session_name = file.stem.replace(\"_cookies\", \"\")\n            sessions.append(session_name)\n        \n        return sessions\n    \n    def cleanup_old_files(self, days: int = 7):\n        \"\"\"\n        Clean up old screenshots and PDFs\n        \n        Args:\n            days: Delete files older than this many days\n        \"\"\"\n        from datetime import timedelta\n        cutoff = datetime.now() - timedelta(days=days)\n        \n        deleted_count = 0\n        for directory in [self.screenshots_dir, self.pdfs_dir]:\n            for file in directory.glob(\"*\"):\n                if file.stat().st_mtime < cutoff.timestamp():\n                    file.unlink()\n                    deleted_count += 1\n        \n        logger.info(f\"ðŸ—‘ï¸  Cleaned up {deleted_count} old files\")\n        return deleted_count\n","size_bytes":9610},"docs/BROWSER_USE_OPTIMIZATIONS.md":{"content":"# Browser-Use Engine Optimizations\n\n## Overview\n\nThe browser-use engine has been significantly optimized with advanced features for handling both basic and complex browser automation tasks. This document outlines all the enhancements and how to use them.\n\n## New Features\n\n### 1. Advanced Browser Capabilities (`advanced_features.py`)\n\n**Features:**\n- **Screenshot Capture**: Full-page and viewport screenshots with custom naming\n- **PDF Generation**: Convert pages to PDF with customizable settings\n- **Cookie Management**: Save and restore browser sessions\n- **LocalStorage Management**: Read and write localStorage data\n- **Session Persistence**: Maintain authentication across automation runs\n\n**Usage:**\n```python\nfrom browser_use_codebase.advanced_features import AdvancedBrowserFeatures\n\nfeatures = AdvancedBrowserFeatures(output_dir=\"automation_outputs\")\n\n# Capture screenshot\nawait features.capture_screenshot(page, name=\"login_page\", full_page=True)\n\n# Generate PDF\nawait features.generate_pdf(page, name=\"report\", landscape=False)\n\n# Save cookies for session persistence\nawait features.save_cookies(context, session_name=\"user_session\")\n\n# Restore cookies\nawait features.load_cookies(context, session_name=\"user_session\")\n```\n\n### 2. Enhanced Popup Handling (`popup_handler.py`)\n\n**Improvements:**\n- Configurable timeouts for popup operations\n- Detailed logging and tracking of all popups\n- Popup history and statistics\n- Multi-popup orchestration\n- Automatic or manual popup switching\n\n**Configuration (config.ini):**\n```ini\n[popup]\ntimeout = 10000          # Timeout in milliseconds\nauto_switch = true       # Auto-switch to new popups\nlog_verbose = true       # Enable detailed logging\n```\n\n**Features:**\n- Tracks total popups opened during session\n- Records popup URLs and timestamps\n- Provides statistics via `get_popup_stats()`\n- Waits for popups with `wait_for_popup(timeout)`\n\n### 3. Smart Retry Mechanism (`retry_mechanism.py`)\n\n**Features:**\n- Exponential backoff for failed operations\n- Configurable retry attempts and delays\n- Separate retry configs for different operation types\n- Retry statistics and success rate tracking\n- Support for both sync and async operations\n\n**Configuration (config.ini):**\n```ini\n[retry]\nmax_retries = 3          # Maximum retry attempts\ninitial_delay = 1.0      # Initial delay in seconds\nmax_delay = 30.0         # Maximum delay between retries\nbackoff_factor = 2.0     # Exponential backoff multiplier\n```\n\n**Usage:**\n```python\nfrom browser_use_codebase.retry_mechanism import create_retry_mechanism\n\nretry = create_retry_mechanism(max_retries=3, initial_delay=1.0)\n\n# Decorate sync functions\n@retry.retry\ndef unreliable_operation():\n    # Operation that might fail\n    pass\n\n# Decorate async functions\n@retry.async_retry\nasync def async_unreliable_operation():\n    # Async operation that might fail\n    pass\n```\n\n### 4. Workflow State Management (`state_manager.py`)\n\n**Features:**\n- Preserve context across multi-step workflows\n- Variable storage and retrieval\n- Execution history tracking\n- Checkpoint creation and restoration\n- Optional disk persistence for recovery\n\n**Usage:**\n```python\nfrom browser_use_codebase.state_manager import WorkflowState\n\n# Create workflow state\nstate = WorkflowState(workflow_id=\"data_collection\", persist_to_disk=True)\n\n# Store variables\nstate.set_variable(\"user_email\", \"user@example.com\")\nstate.set_state(\"current_page\", \"login\")\n\n# Record steps\nstate.add_step(\"login\", {\"success\": True, \"url\": \"https://example.com\"})\n\n# Create checkpoints\nstate.create_checkpoint(\"after_login\")\n\n# Restore if needed\nstate.restore_checkpoint(\"after_login\")\n\n# Get summary\nsummary = state.get_summary()\n```\n\n### 5. Data Extraction Capabilities (`data_extractor.py`)\n\n**Features:**\n- Table data extraction with headers\n- List extraction with custom selectors\n- Structured data extraction using schemas\n- Link and image extraction\n- Page metadata extraction\n- Text content extraction\n\n**Usage:**\n```python\nfrom browser_use_codebase.data_extractor import DataExtractor\n\nextractor = DataExtractor()\n\n# Extract table data\ntable_data = await extractor.extract_table(page, selector=\"table\", include_headers=True)\n\n# Extract structured data\nschema = {\n    \"title\": \"h1.product-title\",\n    \"price\": \"span.price\",\n    \"description\": \"div.description\"\n}\ndata = await extractor.extract_structured_data(page, schema)\n\n# Extract all links\nlinks = await extractor.extract_all_links(page)\n\n# Extract page metadata\nmetadata = await extractor.extract_metadata(page)\n```\n\n### 6. Performance Monitoring (`performance_monitor.py`)\n\n**Features:**\n- Operation timing and duration tracking\n- Success rate calculation\n- Per-operation metrics and breakdown\n- Custom metric recording\n- Detailed performance summaries\n\n**Configuration (config.ini):**\n```ini\n[performance]\ntrack_detailed_metrics = true    # Track detailed per-operation metrics\nlog_summary = true               # Log summary after completion\n```\n\n**Usage:**\n```python\nfrom browser_use_codebase.performance_monitor import PerformanceMonitor\n\nmonitor = PerformanceMonitor(track_detailed_metrics=True)\n\n# Track operation\nop_id = monitor.start_operation(\"page_navigation\")\n# ... perform operation ...\nmonitor.end_operation(op_id, success=True)\n\n# Get summary\nsummary = monitor.get_summary()\n\n# Get slowest operations\nslowest = monitor.get_top_slowest_operations(limit=5)\n\n# Log formatted summary\nmonitor.log_summary()\n```\n\n### 7. Optimized Engine (`engine_optimized.py`)\n\nThe new `OptimizedBrowserUseEngine` integrates all advanced features:\n\n**Features:**\n- All advanced capabilities enabled by default\n- Performance monitoring built-in\n- Retry mechanism integrated\n- Workflow state management\n- Metrics and statistics\n\n**Usage:**\n```python\nfrom browser_use_codebase.engine_optimized import OptimizedBrowserUseEngine\n\n# Create optimized engine\nengine = OptimizedBrowserUseEngine(\n    headless=True, \n    enable_advanced_features=True\n)\n\n# Execute with advanced features\nresult = engine.execute_instruction_sync(\n    \"Navigate to example.com and extract the page title\",\n    workflow_id=\"data_extraction\",\n    save_screenshot=True,\n    save_pdf=False\n)\n\n# Access performance metrics\nmetrics = engine.get_performance_summary()\nretry_stats = engine.get_retry_stats()\n```\n\n## Configuration\n\nAll features can be configured via `config/config.ini`:\n\n```ini\n[retry]\nmax_retries = 3\ninitial_delay = 1.0\nmax_delay = 30.0\nbackoff_factor = 2.0\n\n[popup]\ntimeout = 10000\nauto_switch = true\nlog_verbose = true\n\n[performance]\ntrack_detailed_metrics = true\nlog_summary = true\n\n[advanced_features]\nenable_screenshots = true\nenable_pdf_generation = true\nenable_cookie_management = true\nenable_state_persistence = true\noutput_directory = automation_outputs\n\n[data_extraction]\nenable_auto_extraction = false\nextract_metadata = true\n```\n\n## Migration Guide\n\n### From Basic Engine to Optimized Engine\n\n**Before:**\n```python\nfrom browser_use_codebase import create_engine\n\nengine = create_engine(headless=True)\nresult = engine.execute_instruction_sync(\"Navigate to example.com\")\n```\n\n**After:**\n```python\nfrom browser_use_codebase.engine_optimized import OptimizedBrowserUseEngine\n\nengine = OptimizedBrowserUseEngine(headless=True, enable_advanced_features=True)\nresult = engine.execute_instruction_sync(\n    \"Navigate to example.com\",\n    save_screenshot=True\n)\n\n# Access additional metrics\nprint(result[\"performance_metrics\"])\nprint(result[\"retry_stats\"])\n```\n\n## Performance Improvements\n\n1. **Retry Mechanism**: Automatic retry with exponential backoff reduces failure rate\n2. **Performance Monitoring**: Identify slow operations and optimize\n3. **State Management**: Checkpoint and resume long-running workflows\n4. **Enhanced Popup Handling**: Better timeout management and logging\n\n## Best Practices\n\n1. **Enable Advanced Features for Complex Tasks**: Use `OptimizedBrowserUseEngine` for multi-step workflows\n2. **Use State Management for Long Workflows**: Create checkpoints at key stages\n3. **Monitor Performance**: Review metrics to identify bottlenecks\n4. **Configure Retries**: Adjust retry settings based on operation reliability\n5. **Save Sessions**: Use cookie management for authenticated workflows\n6. **Extract Data Efficiently**: Use structured extraction with schemas\n\n## Troubleshooting\n\n### High Failure Rate\n- Increase `max_retries` in config\n- Adjust `initial_delay` and `backoff_factor`\n- Check performance metrics for slow operations\n\n### Popup Issues\n- Increase `popup.timeout` in config\n- Enable `log_verbose` to see detailed popup logs\n- Review popup statistics via `get_popup_stats()`\n\n### Performance Issues\n- Enable `track_detailed_metrics` to identify slow operations\n- Use `get_top_slowest_operations()` to find bottlenecks\n- Consider increasing `max_steps` for complex tasks\n\n## Future Enhancements\n\nPlanned improvements:\n- [ ] Advanced visual element recognition\n- [ ] Multi-tab parallel execution\n- [ ] Browser fingerprint randomization\n- [ ] Proxy rotation support\n- [ ] Advanced authentication flow handling\n- [ ] Real-time progress streaming\n- [ ] Webhook notifications for completed tasks\n\n## API Reference\n\nSee individual module docstrings for detailed API documentation:\n- `advanced_features.py` - Advanced browser capabilities\n- `popup_handler.py` - Popup window handling\n- `retry_mechanism.py` - Retry logic and backoff\n- `state_manager.py` - Workflow state management\n- `data_extractor.py` - Data extraction utilities\n- `performance_monitor.py` - Performance tracking\n- `engine_optimized.py` - Optimized automation engine\n","size_bytes":9554},"browser_use_codebase/retry_mechanism.py":{"content":"\"\"\"\nSmart Retry Mechanism for Browser Automation\nImplements exponential backoff and intelligent retry logic\n\"\"\"\nimport time\nimport logging\nimport asyncio\nfrom typing import Callable, Any, Optional, List\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior\"\"\"\n    \n    def __init__(self, \n                 max_retries: int = 3,\n                 initial_delay: float = 1.0,\n                 max_delay: float = 30.0,\n                 backoff_factor: float = 2.0,\n                 retry_on_exceptions: Optional[List[type]] = None):\n        \"\"\"\n        Initialize retry configuration\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            initial_delay: Initial delay in seconds before first retry\n            max_delay: Maximum delay between retries\n            backoff_factor: Multiplier for exponential backoff\n            retry_on_exceptions: List of exception types to retry on (None = all)\n        \"\"\"\n        self.max_retries = max_retries\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.backoff_factor = backoff_factor\n        self.retry_on_exceptions = retry_on_exceptions or [Exception]\n\n\nclass RetryMechanism:\n    \"\"\"\n    Smart retry handler with exponential backoff\n    Handles both sync and async operations\n    \"\"\"\n    \n    def __init__(self, config: Optional[RetryConfig] = None):\n        \"\"\"\n        Initialize retry mechanism\n        \n        Args:\n            config: Retry configuration (uses defaults if None)\n        \"\"\"\n        self.config = config or RetryConfig()\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n    \n    def retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for synchronous functions with retry logic\n        \n        Args:\n            func: Function to wrap with retry logic\n            \n        Returns:\n            Wrapped function with retry capability\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return self._execute_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def async_retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for asynchronous functions with retry logic\n        \n        Args:\n            func: Async function to wrap with retry logic\n            \n        Returns:\n            Wrapped async function with retry capability\n        \"\"\"\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await self._execute_async_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def _execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute synchronous function with retry logic\n        \n        Args:\n            func: Function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    time.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All retry attempts exhausted without capturing an exception\")\n    \n    async def _execute_async_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute asynchronous function with retry logic\n        \n        Args:\n            func: Async function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Async operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Async attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    await asyncio.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} async attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All async retry attempts exhausted without capturing an exception\")\n    \n    def _should_retry(self, exception: Exception) -> bool:\n        \"\"\"\n        Determine if an exception should trigger a retry\n        \n        Args:\n            exception: The caught exception\n            \n        Returns:\n            True if should retry, False otherwise\n        \"\"\"\n        for exc_type in self.config.retry_on_exceptions:\n            if isinstance(exception, exc_type):\n                return True\n        return False\n    \n    def get_stats(self) -> dict:\n        \"\"\"\n        Get retry statistics\n        \n        Returns:\n            Dictionary with retry statistics\n        \"\"\"\n        return {\n            **self.retry_stats,\n            \"success_rate\": (\n                (self.retry_stats[\"total_attempts\"] - self.retry_stats[\"failed_operations\"]) \n                / max(self.retry_stats[\"total_attempts\"], 1) * 100\n            ),\n            \"config\": {\n                \"max_retries\": self.config.max_retries,\n                \"initial_delay\": self.config.initial_delay,\n                \"max_delay\": self.config.max_delay,\n                \"backoff_factor\": self.config.backoff_factor\n            }\n        }\n    \n    def reset_stats(self):\n        \"\"\"Reset retry statistics\"\"\"\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n        logger.info(\"ðŸ“Š Retry statistics reset\")\n\n\ndef create_retry_mechanism(max_retries: int = 3, \n                          initial_delay: float = 1.0,\n                          backoff_factor: float = 2.0) -> RetryMechanism:\n    \"\"\"\n    Factory function to create a retry mechanism with custom settings\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for exponential backoff\n        \n    Returns:\n        Configured RetryMechanism instance\n    \"\"\"\n    config = RetryConfig(\n        max_retries=max_retries,\n        initial_delay=initial_delay,\n        backoff_factor=backoff_factor\n    )\n    return RetryMechanism(config)\n","size_bytes":9108},"docs/INTEGRATION_STATUS.md":{"content":"# Browser-Use Engine Optimization Integration Status\n\n## Overview\n\nThe browser-use engine has been enhanced with new modules and features. This document clarifies which features are **fully integrated** and which are **available as utilities** pending browser-use library enhancements.\n\n## âœ… Fully Integrated Features\n\nThese features are actively used during automation execution:\n\n### 1. Performance Monitoring\n- **Status**: âœ… ACTIVE\n- **Integration**: Operations are timed during execute_instruction\n- **Configuration**: `[performance]` section in config.ini\n- **Usage**: Automatic - metrics included in result[\"performance_metrics\"]\n\n### 2. Workflow State Management\n- **Status**: âœ… ACTIVE\n- **Integration**: Steps are recorded during execution when workflow_id provided\n- **Configuration**: `[advanced_features].enable_state_persistence`\n- **Usage**: Pass workflow_id parameter to execute_instruction_sync()\n\n### 3. Smart Retry Mechanism  \n- **Status**: âœ… CONFIGURED\n- **Integration**: RetryConfig fully reads all config values (max_retries, initial_delay, max_delay, backoff_factor)\n- **Configuration**: `[retry]` section in config.ini\n- **Usage**: Available via retry_mechanism instance, can wrap operations with @retry.retry decorator\n\n### 4. Optimized Engine as Default\n- **Status**: âœ… ACTIVE\n- **Integration**: browser_use_codebase.create_engine() defaults to OptimizedBrowserUseEngine\n- **Usage**: Automatic - all new instances use optimized version\n\n## ðŸ”§ Available as Utilities (Not Auto-Integrated)\n\nThese features are implemented and available but cannot be auto-invoked during browser-use execution due to library limitations:\n\n### 1. Screenshot Capture\n- **Status**: ðŸ”§ UTILITY AVAILABLE\n- **Limitation**: browser-use library doesn't expose page object\n- **Module**: advanced_features.py\n- **Configuration**: `[advanced_features].enable_screenshots`\n- **Usage**: Can be used in custom scripts with direct Playwright access\n\n### 2. PDF Generation\n- **Status**: ðŸ”§ UTILITY AVAILABLE\n- **Limitation**: browser-use library doesn't expose page object\n- **Module**: advanced_features.py  \n- **Configuration**: `[advanced_features].enable_pdf_generation`\n- **Usage**: Can be used in custom scripts with direct Playwright access\n\n### 3. Cookie/Session Management\n- **Status**: ðŸ”§ UTILITY AVAILABLE\n- **Limitation**: browser-use library doesn't expose context object\n- **Module**: advanced_features.py\n- **Configuration**: `[advanced_features].enable_cookie_management`\n- **Usage**: Can be used in custom scripts with direct Playwright access\n\n### 4. Enhanced Popup Handler\n- **Status**: ðŸ”§ UTILITY AVAILABLE\n- **Limitation**: browser-use library manages popups internally, doesn't expose handler hooks\n- **Module**: popup_handler.py\n- **Configuration**: `[popup]` section in config.ini\n- **Usage**: Can be used in custom Playwright scripts\n\n### 5. Data Extractor\n- **Status**: ðŸ”§ UTILITY AVAILABLE\n- **Limitation**: browser-use library doesn't expose page object during execution\n- **Module**: data_extractor.py\n- **Configuration**: `[data_extraction]` settings\n- **Usage**: Can be used in custom scripts or post-automation with page access\n\n## Configuration Status\n\nAll configuration sections are properly read and applied:\n\n| Section | Status | Notes |\n|---------|--------|-------|\n| `[retry]` | âœ… Fully Applied | All 4 values read: max_retries, initial_delay, max_delay, backoff_factor |\n| `[popup]` | âš ï¸ Defined | Values defined but browser-use doesn't expose popup handler |\n| `[performance]` | âœ… Fully Applied | track_detailed_metrics controls PerformanceMonitor behavior |\n| `[advanced_features]` | âš ï¸ Partially Applied | Toggles defined, state_persistence works, others need page access |\n| `[data_extraction]` | âš ï¸ Defined | Settings available for custom scripts |\n\n## How to Use Fully Integrated Features\n\n### Performance Monitoring\n```python\nfrom browser_use_codebase import create_engine\n\nengine = create_engine(headless=True)\nresult = engine.execute_instruction_sync(\"Navigate to example.com\")\n\n# Access performance metrics\nprint(result[\"performance_metrics\"])\n# {\n#   \"overview\": {\"total_operations\": 1, \"success_rate\": 100.0, ...},\n#   \"operation_breakdown\": {...}\n# }\n```\n\n### Workflow State Management\n```python\n# Execute with workflow tracking\nresult = engine.execute_instruction_sync(\n    \"Navigate to example.com and click login\",\n    workflow_id=\"user_login_flow\"\n)\n\n# Access workflow state\nprint(result[\"workflow_state\"])\n# {\n#   \"workflow_id\": \"user_login_flow\",\n#   \"total_steps\": 5,\n#   \"success_rate\": 100.0,\n#   ...\n# }\n```\n\n### Retry Configuration\nEdit `config/config.ini`:\n```ini\n[retry]\nmax_retries = 5\ninitial_delay = 2.0\nmax_delay = 60.0\nbackoff_factor = 2.5\n```\nChanges take effect immediately on next engine instance.\n\n## How to Use Utility Features\n\nThese features require custom integration with direct Playwright access:\n\n```python\nfrom browser_use_codebase.advanced_features import AdvancedBrowserFeatures\nfrom browser_use_codebase.data_extractor import DataExtractor\nfrom playwright.async_api import async_playwright\n\nasync def custom_automation():\n    features = AdvancedBrowserFeatures()\n    extractor = DataExtractor()\n    \n    async with async_playwright() as p:\n        browser = await p.chromium.launch()\n        page = await browser.new_page()\n        \n        await page.goto(\"https://example.com\")\n        \n        # Now you can use all utility features\n        await features.capture_screenshot(page, name=\"example_page\")\n        await features.generate_pdf(page, name=\"example_page\")\n        \n        table_data = await extractor.extract_table(page)\n        metadata = await extractor.extract_metadata(page)\n        \n        await browser.close()\n```\n\n## Future Enhancement Opportunities\n\nTo fully integrate screenshot/PDF/cookie/popup features, one of these approaches is needed:\n\n1. **Modify browser-use library** to expose page/context/popup_handler objects\n2. **Create custom browser-use fork** with hooks for advanced features\n3. **Use Playwright MCP engine** instead (already has full page access)\n4. **Post-execution hooks** - add browser-use callback system for post-automation tasks\n\n## Recommendation\n\nFor users who need screenshot/PDF/cookie management:\n- Use **Playwright MCP engine** which provides full page access\n- Or use **Hybrid engine** and implement features in Playwright MCP fallback path\n- Or use utility modules in custom Playwright scripts outside browser-use\n\nFor users who want performance/state/retry features:\n- Use **OptimizedBrowserUseEngine** (default) - these features work automatically\n\n## Summary\n\n**What Works Out of the Box:**\n- âœ… Performance monitoring and metrics\n- âœ… Workflow state tracking and checkpoints  \n- âœ… Configurable retry mechanism\n- âœ… Optimized engine as default\n\n**What Needs Custom Integration:**\n- ðŸ”§ Screenshots and PDFs (requires page access)\n- ðŸ”§ Cookie/session management (requires context access)\n- ðŸ”§ Popup configuration (requires handler exposure)\n- ðŸ”§ Data extraction during automation (requires page access)\n\nAll utility modules are production-ready and fully functional - they just need to be called in contexts where Playwright objects are accessible.\n","size_bytes":7230},"docs/INTELLIGENT_STOPPING.md":{"content":"# Intelligent Stopping Mechanism\n\n## Overview\n\nThis project implements an intelligent stopping mechanism inspired by [browser-use PR #61](https://github.com/browser-use/browser-use/pull/61/files), which provides a **10X efficiency improvement** by preventing the AI agent from continuing unnecessary actions after completing its task.\n\n## How It Works\n\n### Task Validation Before Each Action\n\nBefore every action, the AI agent is reminded of its ultimate task and asked to validate whether it has been completed:\n\n```\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\nDo not continue working after achieving your goal!\n```\n\n### Benefits\n\n1. **Reduced Token Usage**: Agent stops immediately after task completion instead of performing unnecessary actions\n2. **Faster Execution**: No wasted steps means quicker task completion\n3. **Lower Costs**: Fewer LLM API calls = lower OpenAI costs\n4. **Better Accuracy**: Less chance of the agent doing unwanted \"helpful\" actions\n\n## Implementation Details\n\n### Location\n\nThe intelligent stopping mechanism is implemented in:\n- `browser_use_codebase/engine.py` - Basic engine\n- `browser_use_codebase/engine_optimized.py` - Optimized engine\n\n### How It's Applied\n\nThe task instruction is embedded directly into the system instructions using an f-string:\n\n```python\nsystem_instructions = f\"\"\"\n...\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\n...\n\"\"\"\n```\n\nThis ensures the agent constantly remembers its ultimate goal and can make intelligent decisions about when to stop.\n\n## Example Scenarios\n\n### Without Intelligent Stopping\n\nTask: \"Go to Google and search for 'AI automation'\"\n\nAgent actions:\n1. Navigate to google.com âœ…\n2. Find search box âœ…\n3. Enter \"AI automation\" âœ…\n4. Click search button âœ…\n5. Wait for results âœ…\n6. Scroll down to see more results âŒ (unnecessary)\n7. Click on first result âŒ (unnecessary)\n8. Read the page âŒ (unnecessary)\n\n**Total steps: 8** (5 necessary + 3 unnecessary)\n\n### With Intelligent Stopping\n\nTask: \"Go to Google and search for 'AI automation'\"\n\nAgent actions:\n1. Navigate to google.com âœ…\n2. Find search box âœ…\n3. Enter \"AI automation\" âœ…\n4. Click search button âœ…\n5. Wait for results âœ…\n6. **Check: \"Have I searched for 'AI automation' on Google?\" â†’ YES â†’ STOP**\n\n**Total steps: 5** (all necessary)\n\n**Efficiency gain: 37.5% fewer steps in this example**\n\n## Best Practices\n\n### Write Clear, Specific Instructions\n\nThe intelligent stopping mechanism works best with precise task descriptions:\n\nâœ… **Good Examples:**\n- \"Navigate to github.com and find the browser-use repository\"\n- \"Search for 'Python tutorials' on YouTube\"\n- \"Click the login button on the homepage\"\n\nâŒ **Poor Examples:**\n- \"Find information about Python\" (too vague)\n- \"Help me with my research\" (no clear completion criteria)\n- \"Look around the website\" (no defined goal)\n\n### Trust the Agent\n\nWith intelligent stopping enabled:\n- The agent will stop as soon as the task is complete\n- You don't need to add \"and then stop\" to your instructions\n- The agent will not perform extra \"helpful\" actions unless explicitly requested\n\n### Combining with Max Steps\n\nThe intelligent stopping mechanism works alongside the `max_steps` limit:\n- **Intelligent stopping**: Agent decides task is complete and stops early\n- **Max steps (default: 25)**: Safety limit to prevent infinite loops\n\nMost tasks will complete via intelligent stopping before hitting the max steps limit.\n\n## Configuration\n\nThe intelligent stopping mechanism is **always enabled** by default in both engines. No configuration required.\n\nIf you want to adjust the maximum steps limit, edit `config/config.ini`:\n\n```ini\n[agent]\nmax_steps = 25  # Increase for complex tasks, decrease for simple ones\n```\n\n## Performance Metrics\n\nBased on browser-use PR #61, the intelligent stopping mechanism provides:\n- **10X efficiency improvement** in ideal scenarios\n- **30-50% reduction** in average steps for typical tasks\n- **Significant cost savings** on API usage\n\n## References\n\n- [Browser-use PR #61: Fix the task validation in agent service](https://github.com/browser-use/browser-use/pull/61/files)\n- Original implementation by [@Shahar-Y](https://github.com/Shahar-Y)\n","size_bytes":4658},".local/state/replit/agent/progress_tracker.md":{"content":"[x] 1. Install the required packages\n[x] 2. Restart the workflow to see if the project is working\n[x] 3. Verify the project is working using the feedback tool\n[x] 4. Inform user the import is completed and they can start building\n[x] 5. Implement intelligent stopping mechanism from browser-use PR #61\n[x] 6. Implement Playwright code generation from browser-use automation","size_bytes":373},"PLAYWRIGHT_CODE_GENERATION_QUICKSTART.md":{"content":"# Playwright Code Generation - Quick Start Guide\n\n## What Is This?\n\nThis feature automatically converts browser-use AI automation into clean, ready-to-run Playwright Python code. Think of it as \"AI writes the automation, you get the code.\"\n\n## Why Use It?\n\n- ðŸ”„ **Turn AI exploration into production code** - Use AI once, run code forever\n- ðŸ’° **Save money** - AI automation is expensive, Playwright code is cheap\n- ðŸ“ **Get maintainable tests** - Code is reviewable, versionable, and debuggable\n- ðŸ“š **Learn Playwright** - See how AI solves problems in standard Playwright syntax\n- âš¡ **Faster execution** - Playwright code runs faster than AI decision-making\n\n## How To Use It\n\n### Method 1: API (Automatic)\n\n```python\nimport requests\n\n# Run automation\nresponse = requests.post('http://localhost:5000/api/automation/execute',\n    headers={'X-API-Key': 'your-key'},\n    json={\n        'instruction': 'Go to Google and search for Playwright',\n        'engine': 'browser_use'\n    }\n)\n\n# Get Playwright code automatically\nresult = response.json()\nplaywright_code = result.get('playwright_code')\n\n# Save it\nwith open('my_script.py', 'w') as f:\n    f.write(playwright_code)\n```\n\n### Method 2: Run Demo\n\n```bash\npython examples/generate_playwright_code_demo.py\n```\n\nThis will:\n1. Run a browser automation task\n2. Generate Playwright code\n3. Save to `generated_playwright_script.py`\n4. Show you the code\n\n### Method 3: Programmatic\n\n```python\nfrom browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\n\n# After running browser-use automation\nhistory = await agent.run()\n\n# Generate code\ncode = generate_playwright_code_from_history(\n    history,\n    output_file=\"automation.py\"\n)\n```\n\n## Example\n\n**Input (Natural Language):**\n```\n\"Go to Google, search for 'Python tutorials', and click the first result\"\n```\n\n**Output (Playwright Code):**\n```python\nimport asyncio\nfrom playwright.async_api import async_playwright\n\n# Locators extracted from automation\nSEARCH_BOX = r\"input[name='q']\"\nSEARCH_BUTTON = r\"button[type='submit']\"\nFIRST_RESULT = r\"div.g:first-child a\"\n\nasync def main():\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=False)\n        page = await browser.new_page()\n        \n        # Step 1: Navigate to Google\n        await page.goto(\"https://www.google.com\")\n        \n        # Step 2: Fill search query\n        await page.locator(SEARCH_BOX).fill(\"Python tutorials\")\n        \n        # Step 3: Submit search\n        await page.locator(SEARCH_BUTTON).click()\n        \n        # Step 4: Click first result\n        await page.locator(FIRST_RESULT).click()\n        \n        # Pause to review results\n        await page.wait_for_timeout(3000)\n        \n        await browser.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Running Generated Code\n\n```bash\n# Install Playwright\npip install playwright\n\n# Install browsers\nplaywright install chromium\n\n# Run your script\npython automation.py\n```\n\n## Use Cases\n\n### 1. Create Test Suite\n\n```python\n# Use AI to explore feature\nhistory = await agent.run(\"Sign up with new user and verify welcome email\")\n\n# Get test code\ntest_code = generate_playwright_code_from_history(\n    history,\n    output_file=\"tests/test_signup.py\"\n)\n\n# Now you have a regression test!\n```\n\n### 2. Document Workflows\n\n```python\n# Let AI document a complex workflow\nhistory = await agent.run(\"Complete checkout with PayPal payment\")\n\n# Get documented code\ndocs_code = generate_playwright_code_from_history(\n    history,\n    output_file=\"docs/checkout_workflow.py\"\n)\n```\n\n### 3. Learn Playwright\n\n```python\n# Watch AI solve a problem\nhistory = await agent.run(\"Fill out contact form and submit\")\n\n# Study how it's done\ncode = generate_playwright_code_from_history(history)\nprint(code)\n```\n\n## Important Notes\n\n### âœ… What Converts Well\n- Navigation (clicking links, typing URLs)\n- Form filling\n- Button clicks\n- Basic waits\n\n### âš ï¸ May Need Review\n- Complex AI reasoning\n- Dynamic content\n- Conditional flows\n- Data extraction\n\n**Always review generated code before using in production!**\n\n## Full Documentation\n\nSee [docs/PLAYWRIGHT_CODE_GENERATION.md](docs/PLAYWRIGHT_CODE_GENERATION.md) for complete documentation.\n\n## Quick Tips\n\n1. **Use specific instructions** - \"Click login button\" is better than \"login somehow\"\n2. **Review the code** - AI does its best, but you should verify selectors\n3. **Commit to git** - Track your automation evolution\n4. **Enhance manually** - Generated code is a starting point, add assertions and error handling\n\n## Support\n\nQuestions? Check:\n- [Full Documentation](docs/PLAYWRIGHT_CODE_GENERATION.md)\n- [Example Scripts](examples/)\n- [Playwright Docs](https://playwright.dev/python/)\n","size_bytes":4754},"browser_use_codebase/playwright_code_generator.py":{"content":"\"\"\"\nPlaywright Code Generator for Browser-Use\nConverts browser-use automation history into reusable Playwright code\n\nUsage:\n    history = await agent.run(...)\n    generator = PlaywrightCodeGenerator(history)\n    code = generator.generate_python_code()\n    print(code)\n\"\"\"\n\nimport re\nimport json\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass PlaywrightAction:\n    \"\"\"Represents a single Playwright action\"\"\"\n    action_type: str\n    selector: Optional[str] = None\n    value: Optional[str] = None\n    url: Optional[str] = None\n    comment: Optional[str] = None\n    raw_action: Optional[str] = None\n\n\nclass Locator(BaseModel):\n    \"\"\"Represents a reusable locator\"\"\"\n    name: str\n    selector: str\n    action_examples: List[str] = []\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"\n    Generates Playwright Python code from browser-use agent history\n    \n    Features:\n    - Extracts actions from AgentHistoryList\n    - Generates clean, maintainable Playwright code\n    - Creates reusable locators\n    - Includes proper async/await patterns\n    - Adds comments for clarity\n    \"\"\"\n    \n    def __init__(self, history=None, task_description: str = \"Automated browser task\"):\n        \"\"\"\n        Initialize code generator\n        \n        Args:\n            history: AgentHistoryList from browser-use agent.run()\n            task_description: Description of what the automation does\n        \"\"\"\n        self.history = history\n        self.task_description = task_description\n        self.actions: List[PlaywrightAction] = []\n        self.locators: Dict[str, Locator] = {}\n        \n    def parse_history(self) -> List[PlaywrightAction]:\n        \"\"\"\n        Parse browser-use history and extract Playwright actions\n        \n        Returns:\n            List of PlaywrightAction objects\n        \"\"\"\n        if not self.history:\n            return []\n        \n        actions = []\n        \n        # Try to get model_actions if available\n        if hasattr(self.history, 'model_actions'):\n            try:\n                model_actions = self.history.model_actions()\n                for action in model_actions:\n                    pw_action = self._convert_model_action(action)\n                    if pw_action:\n                        actions.append(pw_action)\n            except Exception as e:\n                print(f\"Note: Could not extract model_actions: {e}\")\n        \n        # Fallback: parse from history.history\n        if not actions and hasattr(self.history, 'history'):\n            for item in self.history.history:\n                pw_action = self._parse_history_item(item)\n                if pw_action:\n                    actions.append(pw_action)\n        \n        self.actions = actions\n        return actions\n    \n    def _convert_model_action(self, action: dict) -> Optional[PlaywrightAction]:\n        \"\"\"Convert browser-use model action to Playwright action\"\"\"\n        action_name = action.get('name', '').lower()\n        params = action.get('params', {}) or {}\n        \n        # Navigate action\n        if 'navigate' in action_name or 'goto' in action_name:\n            url = params.get('url') or params.get('target')\n            if url:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url,\n                    comment=f\"Navigate to {url}\",\n                    raw_action=str(action)\n                )\n        \n        # Click action\n        elif 'click' in action_name:\n            selector = self._extract_selector(params)\n            if selector:\n                return PlaywrightAction(\n                    action_type='click',\n                    selector=selector,\n                    comment=f\"Click {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Type/Input action\n        elif 'type' in action_name or 'input' in action_name or 'fill' in action_name:\n            selector = self._extract_selector(params)\n            value = params.get('text') or params.get('value') or params.get('input')\n            if selector and value:\n                return PlaywrightAction(\n                    action_type='fill',\n                    selector=selector,\n                    value=value,\n                    comment=f\"Fill '{value}' into {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Wait action\n        elif 'wait' in action_name:\n            timeout = params.get('timeout') or params.get('duration', 1000)\n            return PlaywrightAction(\n                action_type='wait',\n                value=str(timeout),\n                comment=f\"Wait {timeout}ms\",\n                raw_action=str(action)\n            )\n        \n        # Generic action - store for analysis\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Action: {action_name} - {params}\",\n            raw_action=str(action)\n        )\n    \n    def _parse_history_item(self, item) -> Optional[PlaywrightAction]:\n        \"\"\"Parse individual history item\"\"\"\n        model_output = str(getattr(item, 'model_output', ''))\n        \n        if not model_output or model_output == 'None':\n            return None\n        \n        # Simple heuristic parsing\n        model_lower = model_output.lower()\n        \n        # Navigation\n        if 'goto' in model_lower or 'navigate' in model_lower:\n            # Try to extract URL\n            url_match = re.search(r'https?://[^\\s\\'\"]+', model_output)\n            if url_match:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url_match.group(0),\n                    raw_action=model_output\n                )\n        \n        # Click\n        elif 'click' in model_lower:\n            return PlaywrightAction(\n                action_type='click',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Type/Fill\n        elif any(word in model_lower for word in ['type', 'fill', 'input', 'enter']):\n            return PlaywrightAction(\n                action_type='fill',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Store as comment for manual review\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Step: {model_output[:150]}\",\n            raw_action=model_output\n        )\n    \n    def _extract_selector(self, params: dict) -> Optional[str]:\n        \"\"\"Extract selector from action parameters\"\"\"\n        keys_to_check = [\n            'selector', 'index_selector', 'css', 'xpath', \n            'aria', 'text', 'query', 'target', 'element'\n        ]\n        \n        for key in keys_to_check:\n            value = params.get(key)\n            if value and str(value).strip():\n                return str(value).strip()\n        \n        return None\n    \n    def _normalize_locator_name(self, selector: str) -> str:\n        \"\"\"Create a valid Python variable name from selector\"\"\"\n        # Remove special characters\n        name = re.sub(r'[^0-9a-zA-Z_]+', '_', selector).strip('_')\n        # Remove multiple underscores\n        name = re.sub(r'__+', '_', name)\n        # Truncate and ensure it's not empty\n        name = (name[:50] or \"locator\").lower()\n        # Ensure it doesn't start with a number\n        if name[0].isdigit():\n            name = f\"loc_{name}\"\n        return name\n    \n    def extract_locators(self) -> Dict[str, Locator]:\n        \"\"\"Extract reusable locators from actions\"\"\"\n        seen: Dict[str, Locator] = {}\n        \n        for action in self.actions:\n            if not action.selector:\n                continue\n            \n            sel = action.selector.strip()\n            name_base = self._normalize_locator_name(sel)\n            name = name_base\n            idx = 1\n            \n            # Handle duplicates\n            while name in seen:\n                idx += 1\n                name = f\"{name_base}_{idx}\"\n            \n            seen[name] = Locator(\n                name=name,\n                selector=sel,\n                action_examples=[f\"{action.action_type}({action.comment or sel})\"]\n            )\n        \n        self.locators = seen\n        return seen\n    \n    def generate_python_code(self, \n                           use_locators: bool = True,\n                           include_comments: bool = True,\n                           async_style: bool = True) -> str:\n        \"\"\"\n        Generate complete Playwright Python code\n        \n        Args:\n            use_locators: Extract selectors into constants\n            include_comments: Add explanatory comments\n            async_style: Use async/await (recommended)\n            \n        Returns:\n            Complete Python script as string\n        \"\"\"\n        if not self.actions:\n            self.parse_history()\n        \n        if use_locators:\n            self.extract_locators()\n        \n        code_lines = []\n        \n        # Header\n        code_lines.append('\"\"\"')\n        code_lines.append(f'{self.task_description}')\n        code_lines.append('')\n        code_lines.append('Generated from browser-use automation')\n        code_lines.append('To run: python script.py')\n        code_lines.append('\"\"\"')\n        code_lines.append('')\n        \n        # Imports\n        if async_style:\n            code_lines.append('import asyncio')\n        code_lines.append('from playwright.async_api import async_playwright' if async_style else 'from playwright.sync_api import sync_playwright')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Locators section\n        if use_locators and self.locators:\n            code_lines.append('# Locators extracted from automation')\n            for name, locator in self.locators.items():\n                examples = ', '.join(locator.action_examples)[:100]\n                code_lines.append(f'{name.upper()} = r\"{locator.selector}\"  # {examples}')\n            code_lines.append('')\n            code_lines.append('')\n        \n        # Main function\n        if async_style:\n            code_lines.append('async def main():')\n        else:\n            code_lines.append('def main():')\n        \n        code_lines.append('    \"\"\"Main automation function\"\"\"')\n        \n        # Browser setup\n        if async_style:\n            code_lines.append('    async with async_playwright() as p:')\n            code_lines.append('        browser = await p.chromium.launch(headless=False)')\n            code_lines.append('        page = await browser.new_page()')\n            code_lines.append('')\n        else:\n            code_lines.append('    with sync_playwright() as p:')\n            code_lines.append('        browser = p.chromium.launch(headless=False)')\n            code_lines.append('        page = browser.new_page()')\n            code_lines.append('')\n        \n        # Generate actions\n        indent = '        '\n        \n        if include_comments:\n            code_lines.append(f'{indent}# Automation steps')\n        \n        for i, action in enumerate(self.actions, 1):\n            if include_comments and action.comment:\n                code_lines.append(f'{indent}# Step {i}: {action.comment}')\n            \n            if action.action_type == 'navigate' and action.url:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.goto(\"{action.url}\")')\n            \n            elif action.action_type == 'click' and action.selector:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).click()')\n            \n            elif action.action_type == 'fill' and action.selector and action.value:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).fill(\"{action.value}\")')\n            \n            elif action.action_type == 'wait' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout({action.value})')\n            \n            elif action.action_type == 'comment':\n                code_lines.append(f'{indent}# {action.comment}')\n            \n            code_lines.append('')\n        \n        # Pause before closing (optional)\n        if include_comments:\n            code_lines.append(f'{indent}# Pause to review results')\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout(3000)')\n        code_lines.append('')\n        \n        # Cleanup\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}browser.close()')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Runner\n        code_lines.append('if __name__ == \"__main__\":')\n        if async_style:\n            code_lines.append('    asyncio.run(main())')\n        else:\n            code_lines.append('    main()')\n        \n        return '\\n'.join(code_lines)\n    \n    def _get_locator_or_selector(self, selector: str, use_locators: bool) -> str:\n        \"\"\"Get locator constant name or raw selector\"\"\"\n        if not use_locators:\n            return f'\"{selector}\"'\n        \n        # Find matching locator\n        for name, locator in self.locators.items():\n            if locator.selector == selector:\n                return name.upper()\n        \n        # Fallback to raw selector\n        return f'\"{selector}\"'\n    \n    def save_to_file(self, filename: str, **kwargs) -> str:\n        \"\"\"\n        Generate code and save to file\n        \n        Args:\n            filename: Output filename\n            **kwargs: Arguments passed to generate_python_code()\n            \n        Returns:\n            Generated code\n        \"\"\"\n        code = self.generate_python_code(**kwargs)\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(code)\n        \n        return code\n\n\n# Convenience function\ndef generate_playwright_code_from_history(history, \n                                         task_description: str = \"Automated task\",\n                                         output_file: Optional[str] = None) -> str:\n    \"\"\"\n    Quick function to generate Playwright code from browser-use history\n    \n    Args:\n        history: AgentHistoryList from browser-use\n        task_description: What the automation does\n        output_file: Optional file to save code to\n        \n    Returns:\n        Generated Playwright Python code\n        \n    Example:\n        history = await agent.run()\n        code = generate_playwright_code_from_history(history, output_file=\"automation.py\")\n        print(code)\n    \"\"\"\n    generator = PlaywrightCodeGenerator(history, task_description)\n    \n    if output_file:\n        return generator.save_to_file(output_file)\n    \n    return generator.generate_python_code()\n","size_bytes":15060},"docs/PLAYWRIGHT_CODE_GENERATION.md":{"content":"# Playwright Code Generation from Browser-Use\n\n## Overview\n\nThis feature automatically converts browser-use AI automation into clean, maintainable Playwright Python code. This is incredibly useful for:\n\n- **Creating Test Scripts**: Convert one-off automation into regression tests\n- **Documentation**: See exactly what the AI did in standard Playwright code\n- **Code Review**: Make AI automation reviewable and maintainable\n- **Hybrid Approach**: Use AI to explore, then convert to deterministic code\n- **Learning**: Understand how to write Playwright code by seeing examples\n\n## How It Works\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Browser-Use    â”‚  AI performs automation\nâ”‚  Automation     â”‚  using natural language\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Agent History   â”‚  Records all actions:\nâ”‚  (Steps Taken)  â”‚  - Navigate to URL\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  - Click button\n         â”‚           - Fill form\n         â–¼           - etc.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Playwright     â”‚  Converts to clean\nâ”‚ Code Generator  â”‚  Playwright code\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Python Script  â”‚  Ready-to-run\nâ”‚  (.py file)     â”‚  Playwright automation\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Quick Start\n\n### Option 1: Automatic Generation (Via API)\n\nWhen you run browser-use automation through the API, Playwright code is automatically generated:\n\n```python\nimport requests\n\nresponse = requests.post('http://localhost:5000/api/automation/execute', \n    headers={'X-API-Key': 'your-key'},\n    json={\n        'instruction': 'Go to Google and search for Playwright',\n        'engine': 'browser_use'\n    }\n)\n\nresult = response.json()\n\n# Access the generated Playwright code\nplaywright_code = result.get('playwright_code')\n\nif playwright_code:\n    # Save to file\n    with open('generated_script.py', 'w') as f:\n        f.write(playwright_code)\n    print(\"âœ… Playwright script saved!\")\n```\n\n### Option 2: Programmatic Generation\n\n```python\nimport asyncio\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\nfrom browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\n\nasync def main():\n    # Run browser automation\n    agent = Agent(\n        task=\"Search for Python tutorials on YouTube\",\n        llm=ChatOpenAI(model=\"gpt-4o-mini\")\n    )\n    \n    history = await agent.run()\n    \n    # Generate Playwright code\n    playwright_code = generate_playwright_code_from_history(\n        history,\n        task_description=\"YouTube Python tutorial search\",\n        output_file=\"youtube_search.py\"\n    )\n    \n    print(playwright_code)\n\nasyncio.run(main())\n```\n\n### Option 3: Using the Demo Script\n\n```bash\npython examples/generate_playwright_code_demo.py\n```\n\n## Generated Code Structure\n\nThe generated Playwright code includes:\n\n### 1. **Complete Setup**\n```python\nimport asyncio\nfrom playwright.async_api import async_playwright\n\nasync def main():\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=False)\n        page = await browser.new_page()\n        # ... automation steps\n        await browser.close()\n```\n\n### 2. **Extracted Locators** (Optional)\n```python\n# Locators extracted from automation\nSEARCH_BOX = r\"input[name='q']\"  # fill('Playwright')\nSEARCH_BUTTON = r\"button[type='submit']\"  # click()\n```\n\n### 3. **Clean Action Steps**\n```python\n# Step 1: Navigate to Google\nawait page.goto(\"https://www.google.com\")\n\n# Step 2: Fill search query\nawait page.locator(SEARCH_BOX).fill(\"Playwright\")\n\n# Step 3: Submit search\nawait page.locator(SEARCH_BUTTON).click()\n```\n\n### 4. **Proper Cleanup**\n```python\n# Pause to review results\nawait page.wait_for_timeout(3000)\n\nawait browser.close()\n```\n\n## API Reference\n\n### PlaywrightCodeGenerator Class\n\n```python\nfrom browser_use_codebase.playwright_code_generator import PlaywrightCodeGenerator\n\ngenerator = PlaywrightCodeGenerator(\n    history=agent_history,\n    task_description=\"What the automation does\"\n)\n\n# Generate code\ncode = generator.generate_python_code(\n    use_locators=True,        # Extract selectors as constants\n    include_comments=True,     # Add explanatory comments\n    async_style=True          # Use async/await (recommended)\n)\n\n# Save to file\ngenerator.save_to_file(\"my_script.py\")\n```\n\n### Convenience Function\n\n```python\nfrom browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\n\ncode = generate_playwright_code_from_history(\n    history,\n    task_description=\"My automation task\",\n    output_file=\"output.py\"  # Optional: auto-save\n)\n```\n\n## Supported Actions\n\nThe generator converts these browser-use actions to Playwright:\n\n| Browser-Use Action | Playwright Code |\n|-------------------|-----------------|\n| Navigate to URL | `await page.goto(url)` |\n| Click element | `await page.locator(selector).click()` |\n| Fill text input | `await page.locator(selector).fill(text)` |\n| Wait | `await page.wait_for_timeout(ms)` |\n| Generic actions | Converted to comments for manual review |\n\n## Configuration Options\n\n### use_locators (bool)\nExtract repeated selectors into named constants:\n\n```python\n# use_locators=True\nSEARCH_BOX = r\"input[name='q']\"\nawait page.locator(SEARCH_BOX).fill(\"query\")\n\n# use_locators=False\nawait page.locator(\"input[name='q']\").fill(\"query\")\n```\n\n**Recommendation**: Use `True` for maintainability\n\n### include_comments (bool)\nAdd explanatory comments:\n\n```python\n# include_comments=True\n# Step 1: Navigate to homepage\nawait page.goto(\"https://example.com\")\n\n# include_comments=False\nawait page.goto(\"https://example.com\")\n```\n\n**Recommendation**: Use `True` for clarity\n\n### async_style (bool)\nUse async/await or sync API:\n\n```python\n# async_style=True (recommended)\nasync def main():\n    async with async_playwright() as p:\n        await page.goto(url)\n\n# async_style=False\ndef main():\n    with sync_playwright() as p:\n        page.goto(url)\n```\n\n**Recommendation**: Use `True` (async is more powerful)\n\n## Example Use Cases\n\n### 1. Create Regression Tests\n\n```python\n# Run AI automation once\nhistory = await agent.run(\"Login to dashboard and verify user count\")\n\n# Generate test\ncode = generate_playwright_code_from_history(\n    history,\n    task_description=\"Dashboard login test\",\n    output_file=\"tests/test_dashboard_login.py\"\n)\n\n# Now you have a repeatable test!\n```\n\n### 2. Document Complex Workflows\n\n```python\n# AI explores a complex workflow\nhistory = await agent.run(\"Complete checkout process with test payment\")\n\n# Generate documentation\ncode = generate_playwright_code_from_history(\n    history,\n    task_description=\"Checkout process - detailed steps\",\n    output_file=\"docs/checkout_workflow.py\"\n)\n```\n\n### 3. Learn Playwright\n\n```python\n# Watch AI solve a problem\nhistory = await agent.run(\"Fill out the contact form and submit\")\n\n# See how it's done in Playwright\ncode = generate_playwright_code_from_history(history)\nprint(code)  # Study the generated code\n```\n\n### 4. Hybrid AI + Deterministic Approach\n\n```python\n# Phase 1: Use AI to discover the workflow\nai_history = await agent.run(\"Find and download the monthly report\")\n\n# Phase 2: Convert to deterministic Playwright code\nreliable_code = generate_playwright_code_from_history(\n    ai_history,\n    output_file=\"monthly_report_download.py\"\n)\n\n# Phase 3: Use Playwright code in production (faster, cheaper, predictable)\n```\n\n## Running Generated Scripts\n\n### Prerequisites\n\n```bash\n# Install Playwright\npip install playwright\n\n# Install browser binaries\nplaywright install chromium\n```\n\n### Execute\n\n```bash\npython generated_script.py\n```\n\n## Limitations\n\n### What Gets Converted Well\n- âœ… Navigation (goto)\n- âœ… Clicks\n- âœ… Text input (fill)\n- âœ… Basic waits\n- âœ… Simple selectors\n\n### What Needs Manual Review\n- âš ï¸ Complex AI reasoning steps\n- âš ï¸ Dynamic selectors\n- âš ï¸ Conditional logic\n- âš ï¸ Data extraction\n- âš ï¸ File uploads/downloads\n\n**Tip**: Check generated code for `# Action:` comments - these may need manual conversion.\n\n## Best Practices\n\n### 1. Review Generated Code\n\nAlways review before running in production:\n- Check selectors are specific enough\n- Verify waits are appropriate\n- Add error handling if needed\n\n### 2. Use Descriptive Task Descriptions\n\n```python\n# âœ… Good\ngenerate_playwright_code_from_history(\n    history,\n    task_description=\"Login to admin panel and verify dashboard loads\"\n)\n\n# âŒ Poor\ngenerate_playwright_code_from_history(\n    history,\n    task_description=\"Do stuff\"\n)\n```\n\n### 3. Combine with Manual Playwright Code\n\nGenerated code is a starting point:\n\n```python\n# Generated code provides the structure\nawait page.goto(\"https://example.com\")\nawait page.locator(LOGIN_BUTTON).click()\n\n# Add your enhancements\nawait page.wait_for_load_state('networkidle')\nscreenshot = await page.screenshot()\nassert page.url == expected_url\n```\n\n### 4. Version Control\n\nCommit generated scripts to track automation evolution:\n```bash\ngit add automation_scripts/\ngit commit -m \"Add Playwright script for user signup flow\"\n```\n\n## Troubleshooting\n\n### \"No actions found in history\"\n\nThe AI may have failed to complete the task. Check:\n```python\nif history.is_done():\n    code = generate_playwright_code_from_history(history)\nelse:\n    print(\"Task incomplete, review history manually\")\n```\n\n### \"Selectors not working\"\n\nBrowser-use may use dynamic selectors. Options:\n1. Use more specific selectors manually\n2. Use Playwright codegen to find better selectors\n3. Add `data-testid` attributes to your app\n\n### \"Generated code has comments instead of actions\"\n\nSome AI actions don't map cleanly to Playwright. Review the comments and implement manually.\n\n## Integration with CI/CD\n\n```yaml\n# .github/workflows/test.yml\nname: Test\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-python@v2\n      - run: pip install playwright\n      - run: playwright install chromium\n      - run: python generated_test.py\n```\n\n## Future Enhancements\n\nPlanned features:\n- [ ] TypeScript code generation\n- [ ] Support for assertions\n- [ ] Data-driven test generation\n- [ ] Mobile/tablet viewport support\n- [ ] Network request mocking\n- [ ] Screenshot comparison\n\n## References\n\n- [Playwright Python Documentation](https://playwright.dev/python/)\n- [Browser-Use Library](https://github.com/browser-use/browser-use)\n- [Playwright Best Practices](https://playwright.dev/python/docs/best-practices)\n","size_bytes":10759},"examples/generate_playwright_code_demo.py":{"content":"\"\"\"\nDemo: Generate Playwright Code from Browser-Use Automation\n\nThis script shows how to use browser-use to perform automation,\nthen automatically generate reusable Playwright code from it.\n\nUsage:\n    python examples/generate_playwright_code_demo.py\n\"\"\"\n\nimport asyncio\nimport os\nimport sys\nfrom pathlib import Path\n\n# Add parent directory to path\nsys.path.insert(0, str(Path(__file__).parent.parent))\n\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\nfrom browser_use_codebase.playwright_code_generator import generate_playwright_code_from_history\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\nasync def demo_code_generation():\n    \"\"\"\n    Demonstrate converting browser-use automation to Playwright code\n    \"\"\"\n    \n    # Check for API key\n    api_key = os.environ.get('OPENAI_API_KEY')\n    if not api_key:\n        print(\"âŒ Error: OPENAI_API_KEY environment variable not set\")\n        print(\"Please set your OpenAI API key to run this demo\")\n        return\n    \n    print(\"=\"*80)\n    print(\"ðŸŽ­ Browser-Use to Playwright Code Generator Demo\")\n    print(\"=\"*80)\n    print()\n    \n    # Example task\n    task = \"Go to Google and search for 'Playwright testing'\"\n    print(f\"ðŸ“‹ Task: {task}\")\n    print()\n    \n    # Create browser-use agent\n    llm = ChatOpenAI(\n        model=\"gpt-4o-mini\",\n        api_key=api_key,\n        timeout=60\n    )\n    \n    agent = Agent(\n        task=task,\n        llm=llm\n    )\n    \n    print(\"ðŸ¤– Running browser automation...\")\n    print(\"   (This will open a browser window)\")\n    print()\n    \n    try:\n        # Run automation and capture history\n        history = await agent.run(max_steps=10)\n        \n        print(\"âœ… Automation complete!\")\n        print(f\"   Steps taken: {len(history.history)}\")\n        print(f\"   Task completed: {history.is_done()}\")\n        print()\n        \n        # Generate Playwright code\n        print(\"ðŸ”„ Converting to Playwright code...\")\n        print()\n        \n        playwright_code = generate_playwright_code_from_history(\n            history,\n            task_description=f\"Automation: {task}\",\n            output_file=\"generated_playwright_script.py\"\n        )\n        \n        print(\"âœ… Playwright code generated!\")\n        print()\n        print(\"=\"*80)\n        print(\"ðŸ“„ Generated Code:\")\n        print(\"=\"*80)\n        print()\n        print(playwright_code)\n        print()\n        print(\"=\"*80)\n        print(\"ðŸ’¾ Code saved to: generated_playwright_script.py\")\n        print()\n        print(\"To run the generated script:\")\n        print(\"  1. Install playwright: pip install playwright\")\n        print(\"  2. Install browsers: playwright install chromium\")\n        print(\"  3. Run: python generated_playwright_script.py\")\n        print(\"=\"*80)\n        \n    except Exception as e:\n        print(f\"âŒ Error during automation: {e}\")\n        import traceback\n        traceback.print_exc()\n\n\nif __name__ == \"__main__\":\n    print()\n    print(\"This demo will:\")\n    print(\"  1. Run a browser automation task using browser-use\")\n    print(\"  2. Extract the automation steps\")\n    print(\"  3. Generate equivalent Playwright Python code\")\n    print(\"  4. Save the code to a file\")\n    print()\n    input(\"Press Enter to continue...\")\n    print()\n    \n    asyncio.run(demo_code_generation())\n","size_bytes":3293},"app/engines/browser_use/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom app.engines.browser_use.engine import BrowserUseEngine\nfrom app.engines.browser_use.engine_optimized import OptimizedBrowserUseEngine\n\n\ndef create_engine(headless: bool = False, use_optimized: bool = True):\n    \"\"\"\n    Factory function to create a Browser-Use engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        use_optimized: Use optimized engine with advanced features (default: True)\n        \n    Returns:\n        BrowserUseEngine or OptimizedBrowserUseEngine instance\n    \"\"\"\n    if use_optimized:\n        return OptimizedBrowserUseEngine(headless=headless, enable_advanced_features=True)\n    else:\n        return BrowserUseEngine(headless=headless)\n\n\n__all__ = ['BrowserUseEngine', 'OptimizedBrowserUseEngine', 'create_engine']\n","size_bytes":876},"app/engines/browser_use/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"app/engines/playwright_mcp/agent/conversation_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom pathlib import Path\nfrom typing import List, Dict, Any\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,\n                    tools=tools,\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name\n                        tool_args = json.loads(tool_call.function.arguments)\n                        \n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    final_response = message.content or \"Task completed\"\n                    \n                    # Generate Playwright code from MCP steps\n                    playwright_code = None\n                    try:\n                        from app.engines.playwright_mcp.mcp_code_generator import generate_playwright_code_from_mcp_steps\n                        playwright_code = generate_playwright_code_from_mcp_steps(\n                            steps,\n                            task_description=instruction\n                        )\n                    except Exception as e:\n                        # Code generation is optional, don't fail the task\n                        pass\n                    \n                    result = {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n                    if playwright_code:\n                        result[\"playwright_code\"] = playwright_code\n                    \n                    return result\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        # Generate Playwright code even if max iterations reached\n        playwright_code = None\n        try:\n            from app.engines.playwright_mcp.mcp_code_generator import generate_playwright_code_from_mcp_steps\n            playwright_code = generate_playwright_code_from_mcp_steps(\n                steps,\n                task_description=instruction\n            )\n        except Exception:\n            pass\n        \n        result = {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n        \n        if playwright_code:\n            result[\"playwright_code\"] = playwright_code\n        \n        return result\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":7466},"app/engines/playwright_mcp/mcp_code_generator.py":{"content":"\"\"\"\nPlaywright Code Generator for MCP Tool Calls\nConverts Playwright MCP tool calls into reusable Playwright Python code\n\nUsage:\n    steps = [{\"tool\": \"browser_navigate_to\", \"arguments\": {\"url\": \"...\"}, ...}]\n    generator = MCPCodeGenerator(steps, task_description=\"My task\")\n    code = generator.generate_python_code()\n\"\"\"\n\nimport re\nfrom typing import List, Dict, Optional, Any\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass PlaywrightAction:\n    \"\"\"Represents a single Playwright action\"\"\"\n    action_type: str\n    selector: Optional[str] = None\n    value: Optional[str] = None\n    url: Optional[str] = None\n    comment: Optional[str] = None\n    ref: Optional[str] = None\n\n\nclass MCPCodeGenerator:\n    \"\"\"\n    Generates Playwright Python code from MCP tool call steps\n    \n    Converts tool calls like:\n    - browser_navigate_to â†’ page.goto()\n    - browser_click â†’ page.locator().click()\n    - browser_fill â†’ page.locator().fill()\n    - browser_snapshot â†’ page content inspection\n    \"\"\"\n    \n    def __init__(self, steps: List[Dict[str, Any]], task_description: str = \"MCP Automation\"):\n        \"\"\"\n        Initialize code generator\n        \n        Args:\n            steps: List of MCP tool call steps from agent execution\n            task_description: Description of what the automation does\n        \"\"\"\n        self.steps = steps\n        self.task_description = task_description\n        self.actions: List[PlaywrightAction] = []\n        self.locators: Dict[str, str] = {}\n        \n    def parse_steps(self) -> List[PlaywrightAction]:\n        \"\"\"\n        Parse MCP tool call steps and convert to Playwright actions\n        \n        Returns:\n            List of PlaywrightAction objects\n        \"\"\"\n        actions = []\n        \n        for step in self.steps:\n            tool_name = step.get('tool', '')\n            arguments = step.get('arguments', {})\n            success = step.get('success', False)\n            \n            if not success:\n                # Include failed steps as comments for debugging\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment=f\"Failed: {tool_name} - {step.get('error', 'Unknown error')}\"\n                ))\n                continue\n            \n            # Convert MCP tool calls to Playwright actions\n            if 'navigate' in tool_name.lower():\n                url = arguments.get('url', '')\n                if url:\n                    actions.append(PlaywrightAction(\n                        action_type='navigate',\n                        url=url,\n                        comment=f\"Navigate to {url}\"\n                    ))\n            \n            elif 'click' in tool_name.lower():\n                ref = arguments.get('ref')\n                selector = arguments.get('selector')\n                \n                if ref:\n                    # MCP uses element references like \"e1\", \"e2\"\n                    actions.append(PlaywrightAction(\n                        action_type='click',\n                        ref=ref,\n                        comment=f\"Click element [ref={ref}]\"\n                    ))\n                elif selector:\n                    actions.append(PlaywrightAction(\n                        action_type='click',\n                        selector=selector,\n                        comment=f\"Click {selector}\"\n                    ))\n                else:\n                    actions.append(PlaywrightAction(\n                        action_type='comment',\n                        comment=f\"Click action (selector not captured)\"\n                    ))\n            \n            elif 'fill' in tool_name.lower() or 'type' in tool_name.lower():\n                ref = arguments.get('ref')\n                selector = arguments.get('selector')\n                value = arguments.get('value') or arguments.get('text', '')\n                \n                if (ref or selector) and value:\n                    actions.append(PlaywrightAction(\n                        action_type='fill',\n                        selector=selector,\n                        ref=ref,\n                        value=value,\n                        comment=f\"Fill '{value}' into {selector or f'[ref={ref}]'}\"\n                    ))\n                else:\n                    actions.append(PlaywrightAction(\n                        action_type='comment',\n                        comment=f\"Fill action: {value}\"\n                    ))\n            \n            elif 'snapshot' in tool_name.lower():\n                # Snapshot is used for page inspection, convert to wait\n                actions.append(PlaywrightAction(\n                    action_type='wait',\n                    value='1000',\n                    comment='Wait for page state (snapshot taken)'\n                ))\n            \n            elif 'press' in tool_name.lower():\n                key = arguments.get('key', '')\n                actions.append(PlaywrightAction(\n                    action_type='press',\n                    value=key,\n                    comment=f\"Press key: {key}\"\n                ))\n            \n            elif 'scroll' in tool_name.lower():\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment='Scroll action (implement page.evaluate for scrolling)'\n                ))\n            \n            else:\n                # Generic tool call - add as comment\n                actions.append(PlaywrightAction(\n                    action_type='comment',\n                    comment=f\"Tool: {tool_name} - {arguments}\"\n                ))\n        \n        self.actions = actions\n        return actions\n    \n    def extract_locators(self) -> Dict[str, str]:\n        \"\"\"\n        Extract reusable locators from actions\n        \n        Returns:\n            Dictionary mapping locator names to selectors\n        \"\"\"\n        seen_selectors = {}\n        counter = 1\n        \n        for action in self.actions:\n            if action.selector:\n                sel = action.selector.strip()\n                if sel and sel not in seen_selectors:\n                    # Create a meaningful locator name\n                    name = self._create_locator_name(sel, action.action_type, counter)\n                    seen_selectors[sel] = name\n                    counter += 1\n        \n        self.locators = seen_selectors\n        return seen_selectors\n    \n    def _create_locator_name(self, selector: str, action_type: str, counter: int) -> str:\n        \"\"\"Create a valid Python variable name from selector\"\"\"\n        # Extract meaningful parts\n        if 'button' in selector.lower():\n            base = 'button'\n        elif 'input' in selector.lower():\n            base = 'input'\n        elif 'text' in selector.lower():\n            base = 'link'\n        elif selector.startswith('#'):\n            base = selector[1:].split('[')[0]\n        elif selector.startswith('.'):\n            base = selector[1:].split('[')[0]\n        else:\n            base = action_type\n        \n        # Clean and format\n        name = re.sub(r'[^0-9a-zA-Z_]+', '_', base).strip('_')\n        name = re.sub(r'__+', '_', name)\n        name = (name[:30] or f\"element_{counter}\").lower()\n        \n        if name[0].isdigit():\n            name = f\"loc_{name}\"\n        \n        return name.upper()\n    \n    def generate_python_code(self,\n                            use_locators: bool = True,\n                            include_comments: bool = True,\n                            async_style: bool = True) -> str:\n        \"\"\"\n        Generate complete Playwright Python code\n        \n        Args:\n            use_locators: Extract selectors into constants\n            include_comments: Add explanatory comments\n            async_style: Use async/await (recommended)\n            \n        Returns:\n            Complete Python script as string\n        \"\"\"\n        if not self.actions:\n            self.parse_steps()\n        \n        if use_locators:\n            self.extract_locators()\n        \n        code_lines = []\n        \n        # Header\n        code_lines.append('\"\"\"')\n        code_lines.append(f'{self.task_description}')\n        code_lines.append('')\n        code_lines.append('Generated from Playwright MCP automation')\n        code_lines.append('To run: python script.py')\n        code_lines.append('\"\"\"')\n        code_lines.append('')\n        \n        # Imports\n        if async_style:\n            code_lines.append('import asyncio')\n        code_lines.append('from playwright.async_api import async_playwright' if async_style else 'from playwright.sync_api import sync_playwright')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Locators section\n        if use_locators and self.locators:\n            code_lines.append('# Locators extracted from MCP automation')\n            for selector, name in self.locators.items():\n                code_lines.append(f'{name} = r\"{selector}\"')\n            code_lines.append('')\n            code_lines.append('')\n        \n        # Main function\n        if async_style:\n            code_lines.append('async def main():')\n        else:\n            code_lines.append('def main():')\n        \n        code_lines.append('    \"\"\"Main automation function\"\"\"')\n        \n        # Browser setup\n        if async_style:\n            code_lines.append('    async with async_playwright() as p:')\n            code_lines.append('        browser = await p.chromium.launch(headless=False)')\n            code_lines.append('        page = await browser.new_page()')\n            code_lines.append('')\n        else:\n            code_lines.append('    with sync_playwright() as p:')\n            code_lines.append('        browser = p.chromium.launch(headless=False)')\n            code_lines.append('        page = browser.new_page()')\n            code_lines.append('')\n        \n        # Generate actions\n        indent = '        '\n        \n        if include_comments:\n            code_lines.append(f'{indent}# Automation steps')\n        \n        for i, action in enumerate(self.actions, 1):\n            if include_comments and action.comment:\n                code_lines.append(f'{indent}# Step {i}: {action.comment}')\n            \n            if action.action_type == 'navigate' and action.url:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.goto(\"{action.url}\")')\n            \n            elif action.action_type == 'click':\n                if action.selector:\n                    selector = self._get_locator_or_selector(action.selector, use_locators)\n                    code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).click()')\n                elif action.ref:\n                    code_lines.append(f'{indent}# Click element by reference (convert to specific selector)')\n                    code_lines.append(f'{indent}# Original ref: {action.ref}')\n            \n            elif action.action_type == 'fill':\n                if action.selector:\n                    selector = self._get_locator_or_selector(action.selector, use_locators)\n                    code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).fill(\"{action.value}\")')\n                elif action.ref:\n                    code_lines.append(f'{indent}# Fill element by reference (convert to specific selector)')\n                    code_lines.append(f'{indent}# Value: {action.value}, ref: {action.ref}')\n            \n            elif action.action_type == 'press' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.keyboard.press(\"{action.value}\")')\n            \n            elif action.action_type == 'wait' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout({action.value})')\n            \n            elif action.action_type == 'comment':\n                code_lines.append(f'{indent}# {action.comment}')\n            \n            code_lines.append('')\n        \n        # Pause before closing\n        if include_comments:\n            code_lines.append(f'{indent}# Pause to review results')\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout(3000)')\n        code_lines.append('')\n        \n        # Cleanup\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}browser.close()')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Runner\n        code_lines.append('if __name__ == \"__main__\":')\n        if async_style:\n            code_lines.append('    asyncio.run(main())')\n        else:\n            code_lines.append('    main()')\n        \n        return '\\n'.join(code_lines)\n    \n    def _get_locator_or_selector(self, selector: str, use_locators: bool) -> str:\n        \"\"\"Get locator constant name or raw selector\"\"\"\n        if not use_locators or selector not in self.locators:\n            return f'\"{selector}\"'\n        \n        return self.locators[selector]\n    \n    def save_to_file(self, filename: str, **kwargs) -> str:\n        \"\"\"\n        Generate code and save to file\n        \n        Args:\n            filename: Output filename\n            **kwargs: Arguments passed to generate_python_code()\n            \n        Returns:\n            Generated code\n        \"\"\"\n        code = self.generate_python_code(**kwargs)\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(code)\n        \n        return code\n\n\ndef generate_playwright_code_from_mcp_steps(\n    steps: List[Dict[str, Any]],\n    task_description: str = \"MCP Automation\",\n    output_file: Optional[str] = None\n) -> str:\n    \"\"\"\n    Quick function to generate Playwright code from MCP steps\n    \n    Args:\n        steps: List of MCP tool call steps\n        task_description: What the automation does\n        output_file: Optional file to save code to\n        \n    Returns:\n        Generated Playwright Python code\n        \n    Example:\n        result = agent.execute_instruction(\"Go to Google\")\n        code = generate_playwright_code_from_mcp_steps(\n            result['steps'],\n            task_description=\"Google navigation\",\n            output_file=\"google_nav.py\"\n        )\n    \"\"\"\n    generator = MCPCodeGenerator(steps, task_description)\n    \n    if output_file:\n        return generator.save_to_file(output_file)\n    \n    return generator.generate_python_code()\n","size_bytes":14429},"tests/unit/test_security.py":{"content":"\"\"\"\nUnit tests for security middleware\n\"\"\"\nimport pytest\nfrom app.middleware.security import (\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\n\n\ndef test_validate_engine_type():\n    \"\"\"Test engine type validation\"\"\"\n    # Valid engines\n    assert validate_engine_type('browser_use')[0] is True\n    assert validate_engine_type('playwright_mcp')[0] is True\n    \n    # Invalid engine\n    is_valid, error = validate_engine_type('invalid_engine')\n    assert is_valid is False\n    assert 'invalid_engine' in error.lower()\n\n\ndef test_validate_instruction():\n    \"\"\"Test instruction validation\"\"\"\n    # Valid instruction\n    assert validate_instruction('Navigate to Google')[0] is True\n    \n    # Empty instruction\n    assert validate_instruction('')[0] is False\n    assert validate_instruction('   ')[0] is False\n    \n    # Too long instruction\n    long_instruction = 'a' * 5001\n    is_valid, error = validate_instruction(long_instruction)\n    assert is_valid is False\n    assert 'too long' in error.lower()\n\n\ndef test_sanitize_error_message():\n    \"\"\"Test error message sanitization\"\"\"\n    # OpenAI error\n    error = Exception(\"OpenAI API key invalid\")\n    sanitized = sanitize_error_message(error)\n    assert 'api key' not in sanitized.lower()\n    assert 'service error' in sanitized.lower()\n    \n    # Timeout error\n    error = Exception(\"Operation timeout after 300 seconds\")\n    sanitized = sanitize_error_message(error)\n    assert 'timeout' in sanitized.lower()\n","size_bytes":1494},"app/engines/browser_use/data_extractor.py":{"content":"\"\"\"\nAdvanced Data Extraction Capabilities\nStructured data scraping, table extraction, and content parsing\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass DataExtractor:\n    \"\"\"\n    Advanced data extraction for web automation\n    Handles tables, lists, structured data, and custom selectors\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize data extractor\"\"\"\n        logger.info(\"ðŸ“Š Data extractor initialized\")\n    \n    async def extract_table(self, page, selector: str = \"table\", \n                          include_headers: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Extract data from HTML table\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for table\n            include_headers: Extract header row\n            \n        Returns:\n            Dictionary with table data\n        \"\"\"\n        try:\n            table_data = await page.evaluate(f\"\"\"(selector) => {{\n                const table = document.querySelector(selector);\n                if (!table) return null;\n                \n                const rows = Array.from(table.querySelectorAll('tr'));\n                const data = [];\n                \n                rows.forEach((row, index) => {{\n                    const cells = Array.from(row.querySelectorAll('td, th'));\n                    const rowData = cells.map(cell => cell.textContent.trim());\n                    if (rowData.length > 0) {{\n                        data.push(rowData);\n                    }}\n                }});\n                \n                return data;\n            }}\"\"\", selector)\n            \n            if not table_data:\n                return {\"success\": False, \"error\": \"Table not found\"}\n            \n            result = {\n                \"success\": True,\n                \"rows\": table_data,\n                \"row_count\": len(table_data),\n                \"column_count\": len(table_data[0]) if table_data else 0\n            }\n            \n            if include_headers and table_data:\n                result[\"headers\"] = table_data[0]\n                result[\"data\"] = table_data[1:]\n            \n            logger.info(f\"ðŸ“Š Table extracted: {result['row_count']} rows, {result['column_count']} columns\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Table extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_list(self, page, selector: str, item_selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract items from a list\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for list container\n            item_selector: Optional selector for individual items\n            \n        Returns:\n            Dictionary with list items\n        \"\"\"\n        try:\n            if item_selector:\n                query = f\"{selector} {item_selector}\"\n            else:\n                query = f\"{selector} li\"\n            \n            items = await page.evaluate(f\"\"\"(query) => {{\n                const elements = document.querySelectorAll(query);\n                return Array.from(elements).map(el => el.textContent.trim());\n            }}\"\"\", query)\n            \n            logger.info(f\"ðŸ“‹ List extracted: {len(items)} items\")\n            \n            return {\n                \"success\": True,\n                \"items\": items,\n                \"item_count\": len(items)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ List extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_structured_data(self, page, schema: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data using a schema\n        \n        Args:\n            page: Playwright page object\n            schema: Dictionary mapping field names to CSS selectors\n            \n        Returns:\n            Dictionary with extracted data\n        \"\"\"\n        try:\n            extracted_data = {}\n            \n            for field_name, selector in schema.items():\n                try:\n                    value = await page.evaluate(f\"\"\"(selector) => {{\n                        const element = document.querySelector(selector);\n                        return element ? element.textContent.trim() : null;\n                    }}\"\"\", selector)\n                    \n                    extracted_data[field_name] = value\n                except:\n                    extracted_data[field_name] = None\n            \n            logger.info(f\"ðŸ“¦ Structured data extracted: {len(extracted_data)} fields\")\n            \n            return {\n                \"success\": True,\n                \"data\": extracted_data,\n                \"field_count\": len(extracted_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Structured data extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_all_links(self, page, base_url: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract all links from page\n        \n        Args:\n            page: Playwright page object\n            base_url: Optional base URL for relative links\n            \n        Returns:\n            Dictionary with links\n        \"\"\"\n        try:\n            links = await page.evaluate(\"\"\"() => {\n                const anchors = document.querySelectorAll('a[href]');\n                return Array.from(anchors).map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    rel_href: a.getAttribute('href')\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ”— Links extracted: {len(links)} links\")\n            \n            return {\n                \"success\": True,\n                \"links\": links,\n                \"link_count\": len(links),\n                \"page_url\": page.url\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Link extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_images(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract all images from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with image data\n        \"\"\"\n        try:\n            images = await page.evaluate(\"\"\"() => {\n                const imgs = document.querySelectorAll('img');\n                return Array.from(imgs).map(img => ({\n                    src: img.src,\n                    alt: img.alt,\n                    width: img.width,\n                    height: img.height\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ–¼ï¸  Images extracted: {len(images)} images\")\n            \n            return {\n                \"success\": True,\n                \"images\": images,\n                \"image_count\": len(images)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Image extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_metadata(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract page metadata (title, description, etc.)\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with metadata\n        \"\"\"\n        try:\n            metadata = await page.evaluate(\"\"\"() => {\n                const getMeta = (name) => {\n                    const element = document.querySelector(`meta[name=\"${name}\"], meta[property=\"${name}\"]`);\n                    return element ? element.content : null;\n                };\n                \n                return {\n                    title: document.title,\n                    description: getMeta('description') || getMeta('og:description'),\n                    keywords: getMeta('keywords'),\n                    author: getMeta('author'),\n                    og_title: getMeta('og:title'),\n                    og_image: getMeta('og:image'),\n                    canonical: document.querySelector('link[rel=\"canonical\"]')?.href\n                };\n            }\"\"\")\n            \n            metadata[\"url\"] = page.url\n            \n            logger.info(f\"â„¹ï¸  Metadata extracted from: {page.url}\")\n            \n            return {\n                \"success\": True,\n                \"metadata\": metadata\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Metadata extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_text_content(self, page, selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract text content from page or specific element\n        \n        Args:\n            page: Playwright page object\n            selector: Optional CSS selector for specific element\n            \n        Returns:\n            Dictionary with text content\n        \"\"\"\n        try:\n            if selector:\n                text = await page.evaluate(f\"\"\"(selector) => {{\n                    const element = document.querySelector(selector);\n                    return element ? element.textContent.trim() : null;\n                }}\"\"\", selector)\n            else:\n                text = await page.evaluate(\"\"\"() => {\n                    return document.body.textContent.trim();\n                }\"\"\")\n            \n            logger.info(f\"ðŸ“ Text content extracted: {len(text)} characters\")\n            \n            return {\n                \"success\": True,\n                \"text\": text,\n                \"length\": len(text) if text else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Text extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n","size_bytes":10037},"app/engines/browser_use/retry_mechanism.py":{"content":"\"\"\"\nSmart Retry Mechanism for Browser Automation\nImplements exponential backoff and intelligent retry logic\n\"\"\"\nimport time\nimport logging\nimport asyncio\nfrom typing import Callable, Any, Optional, List\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior\"\"\"\n    \n    def __init__(self, \n                 max_retries: int = 3,\n                 initial_delay: float = 1.0,\n                 max_delay: float = 30.0,\n                 backoff_factor: float = 2.0,\n                 retry_on_exceptions: Optional[List[type]] = None):\n        \"\"\"\n        Initialize retry configuration\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            initial_delay: Initial delay in seconds before first retry\n            max_delay: Maximum delay between retries\n            backoff_factor: Multiplier for exponential backoff\n            retry_on_exceptions: List of exception types to retry on (None = all)\n        \"\"\"\n        self.max_retries = max_retries\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.backoff_factor = backoff_factor\n        self.retry_on_exceptions = retry_on_exceptions or [Exception]\n\n\nclass RetryMechanism:\n    \"\"\"\n    Smart retry handler with exponential backoff\n    Handles both sync and async operations\n    \"\"\"\n    \n    def __init__(self, config: Optional[RetryConfig] = None):\n        \"\"\"\n        Initialize retry mechanism\n        \n        Args:\n            config: Retry configuration (uses defaults if None)\n        \"\"\"\n        self.config = config or RetryConfig()\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n    \n    def retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for synchronous functions with retry logic\n        \n        Args:\n            func: Function to wrap with retry logic\n            \n        Returns:\n            Wrapped function with retry capability\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return self._execute_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def async_retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for asynchronous functions with retry logic\n        \n        Args:\n            func: Async function to wrap with retry logic\n            \n        Returns:\n            Wrapped async function with retry capability\n        \"\"\"\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await self._execute_async_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def _execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute synchronous function with retry logic\n        \n        Args:\n            func: Function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    time.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All retry attempts exhausted without capturing an exception\")\n    \n    async def _execute_async_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute asynchronous function with retry logic\n        \n        Args:\n            func: Async function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Async operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Async attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    await asyncio.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} async attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All async retry attempts exhausted without capturing an exception\")\n    \n    def _should_retry(self, exception: Exception) -> bool:\n        \"\"\"\n        Determine if an exception should trigger a retry\n        \n        Args:\n            exception: The caught exception\n            \n        Returns:\n            True if should retry, False otherwise\n        \"\"\"\n        for exc_type in self.config.retry_on_exceptions:\n            if isinstance(exception, exc_type):\n                return True\n        return False\n    \n    def get_stats(self) -> dict:\n        \"\"\"\n        Get retry statistics\n        \n        Returns:\n            Dictionary with retry statistics\n        \"\"\"\n        return {\n            **self.retry_stats,\n            \"success_rate\": (\n                (self.retry_stats[\"total_attempts\"] - self.retry_stats[\"failed_operations\"]) \n                / max(self.retry_stats[\"total_attempts\"], 1) * 100\n            ),\n            \"config\": {\n                \"max_retries\": self.config.max_retries,\n                \"initial_delay\": self.config.initial_delay,\n                \"max_delay\": self.config.max_delay,\n                \"backoff_factor\": self.config.backoff_factor\n            }\n        }\n    \n    def reset_stats(self):\n        \"\"\"Reset retry statistics\"\"\"\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n        logger.info(\"ðŸ“Š Retry statistics reset\")\n\n\ndef create_retry_mechanism(max_retries: int = 3, \n                          initial_delay: float = 1.0,\n                          backoff_factor: float = 2.0) -> RetryMechanism:\n    \"\"\"\n    Factory function to create a retry mechanism with custom settings\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for exponential backoff\n        \n    Returns:\n        Configured RetryMechanism instance\n    \"\"\"\n    config = RetryConfig(\n        max_retries=max_retries,\n        initial_delay=initial_delay,\n        backoff_factor=backoff_factor\n    )\n    return RetryMechanism(config)\n","size_bytes":9108},"app/engines/playwright_mcp/agent/__init__.py":{"content":"\"\"\"\nPlaywright MCP Agent Module\n\"\"\"\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\n\n__all__ = ['BrowserAgent']\n","size_bytes":141},"app/engines/browser_use/engine.py":{"content":"\"\"\"\nBrowser-Use Engine\nAI-powered browser automation using browser-use library\n\nThread Safety Notes:\n- This engine creates a fresh Browser instance per request\n- Each request runs on its own event loop to ensure thread safety\n- Browser instances are NOT cached to prevent asyncio loop affinity issues\n- Memory is cleaned up after each request via finally block\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List\nfrom dotenv import load_dotenv\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BrowserUseEngine:\n    \"\"\"\n    Browser automation engine using browser-use library\n    \n    Thread Safety: This engine is designed for Flask's multi-threaded environment.\n    Each request creates its own event loop and browser instance, which are\n    properly cleaned up after execution.\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        \n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n    \n    async def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        try:\n            logger.info(\"ðŸ¤– Initializing Browser-Use Agent\")\n            logger.info(f\"ðŸ“‹ Task: {instruction}\")\n            logger.info(f\"ðŸ”¢ Max steps: {self.max_steps}\")\n            \n            # Custom system message to ensure literal execution and popup handling\n            # Includes intelligent stopping mechanism (inspired by browser-use PR #61)\n            system_instructions = f\"\"\"\nCRITICAL INSTRUCTIONS - KEEP RESPONSES BRIEF:\n1. Follow the user's instruction LITERALLY - do only what is explicitly asked\n2. STOP IMMEDIATELY once the stated task is complete\n3. Do NOT extract, save, or compile data unless explicitly requested\n4. Do NOT perform additional \"helpful\" actions beyond the instruction\n5. If asked to \"search\", stop when search results appear\n6. If asked to \"navigate\", stop when the page loads\n7. If asked to \"click\", stop after clicking\n8. Only do extra work (extract, save, analyze) if the instruction explicitly asks for it\n9. IMPORTANT: Keep all your reasoning and output SHORT and DIRECT to avoid timeouts\n\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\nDo not continue working after achieving your goal!\n\nPOPUP WINDOW HANDLING:\n- When a button opens a NEW WINDOW or POPUP (like \"Sign in with Google\", \"Continue with X\", etc.):\n  * The browser will automatically switch to the new window\n  * Continue your task in the NEW WINDOW without mentioning the window switch\n  * All subsequent actions should be performed in the NEW WINDOW\n  * Example: If user says \"click sign in with Google, then enter email\", you click the button and the new Google window opens automatically - just proceed to enter the email in that new window\n- DO NOT try to switch windows manually - it happens automatically\n- DO NOT mention window switches in your output - just continue the task seamlessly\n            \"\"\"\n            \n            logger.info(\"âš™ï¸  Configuring agent with literal execution instructions\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"â–¶ï¸  Starting agent execution...\")\n            history = await agent.run(max_steps=self.max_steps)\n            logger.info(f\"â¹ï¸  Agent execution completed\")\n            \n            logger.info(\"ðŸ“Š Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from app.engines.browser_use.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"ðŸŽ­ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            # Check if task actually succeeded - if 0 steps executed, it likely failed\n            if len(steps) == 0:\n                logger.error(f\"âŒ Task failed - no steps were executed successfully\")\n                return {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps. This usually means the browser could not launch.\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            \n            logger.info(f\"âœ… Task completed successfully!\")\n            logger.info(f\"ðŸ“ˆ Total steps executed: {len(steps)}\")\n            if final_result:\n                logger.info(f\"ðŸŽ¯ Final result: {str(final_result)[:200]}\")\n            \n            result = {\n                \"success\": True,\n                \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                \"steps\": steps,\n                \"iterations\": len(steps),\n                \"final_result\": final_result\n            }\n            \n            # Add Playwright code if generated\n            if playwright_code:\n                result[\"playwright_code\"] = playwright_code\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Browser-Use execution failed: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        Each call creates a new event loop to ensure thread safety\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n","size_bytes":8951},"app/engines/browser_use/advanced_features.py":{"content":"\"\"\"\nAdvanced Browser Automation Features\nProvides screenshot capture, PDF generation, cookie management, and more\n\"\"\"\nimport os\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nfrom browser_use import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass AdvancedBrowserFeatures:\n    \"\"\"\n    Advanced capabilities for browser automation\n    Handles screenshots, PDFs, cookies, sessions, and more\n    \"\"\"\n    \n    def __init__(self, output_dir: str = \"automation_outputs\"):\n        \"\"\"\n        Initialize advanced browser features\n        \n        Args:\n            output_dir: Directory to save screenshots, PDFs, etc.\n        \"\"\"\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(exist_ok=True)\n        \n        self.screenshots_dir = self.output_dir / \"screenshots\"\n        self.pdfs_dir = self.output_dir / \"pdfs\"\n        self.cookies_dir = self.output_dir / \"cookies\"\n        \n        self.screenshots_dir.mkdir(exist_ok=True)\n        self.pdfs_dir.mkdir(exist_ok=True)\n        self.cookies_dir.mkdir(exist_ok=True)\n        \n        logger.info(f\"ðŸ“ Advanced features initialized with output dir: {self.output_dir}\")\n    \n    async def capture_screenshot(self, page, name: Optional[str] = None, full_page: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Capture screenshot of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for screenshot\n            full_page: Capture full scrollable page\n            \n        Returns:\n            Dictionary with screenshot path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.png\" if name else f\"screenshot_{timestamp}.png\"\n            filepath = self.screenshots_dir / filename\n            \n            await page.screenshot(path=str(filepath), full_page=full_page)\n            \n            logger.info(f\"ðŸ“¸ Screenshot saved: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"full_page\": full_page,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Screenshot capture failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def generate_pdf(self, page, name: Optional[str] = None, \n                          landscape: bool = False, \n                          print_background: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Generate PDF of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for PDF\n            landscape: Use landscape orientation\n            print_background: Include background graphics\n            \n        Returns:\n            Dictionary with PDF path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.pdf\" if name else f\"page_{timestamp}.pdf\"\n            filepath = self.pdfs_dir / filename\n            \n            await page.pdf(\n                path=str(filepath),\n                format='A4',\n                landscape=landscape,\n                print_background=print_background,\n                margin={'top': '20px', 'right': '20px', 'bottom': '20px', 'left': '20px'}\n            )\n            \n            logger.info(f\"ðŸ“„ PDF generated: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"landscape\": landscape,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ PDF generation failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def save_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Save browser cookies for session persistence\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name for this session\n            \n        Returns:\n            Dictionary with save status and path\n        \"\"\"\n        try:\n            cookies = await context.cookies()\n            \n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            with open(filepath, 'w') as f:\n                json.dump(cookies, f, indent=2)\n            \n            logger.info(f\"ðŸª Cookies saved: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie save failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def load_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Load previously saved cookies to restore session\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name of session to restore\n            \n        Returns:\n            Dictionary with load status\n        \"\"\"\n        try:\n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"error\": f\"Session '{session_name}' not found\"\n                }\n            \n            with open(filepath, 'r') as f:\n                cookies = json.load(f)\n            \n            await context.add_cookies(cookies)\n            \n            logger.info(f\"ðŸª Cookies loaded: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie load failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_local_storage(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract localStorage data from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with localStorage contents\n        \"\"\"\n        try:\n            storage_data = await page.evaluate(\"\"\"() => {\n                let data = {};\n                for (let i = 0; i < localStorage.length; i++) {\n                    let key = localStorage.key(i);\n                    data[key] = localStorage.getItem(key);\n                }\n                return data;\n            }\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage extracted: {len(storage_data)} items\")\n            \n            return {\n                \"success\": True,\n                \"data\": storage_data,\n                \"item_count\": len(storage_data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage extraction failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def set_local_storage(self, page, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set localStorage data on page\n        \n        Args:\n            page: Playwright page object\n            data: Dictionary of key-value pairs to set\n            \n        Returns:\n            Dictionary with operation status\n        \"\"\"\n        try:\n            for key, value in data.items():\n                await page.evaluate(f\"\"\"() => {{\n                    localStorage.setItem('{key}', '{value}');\n                }}\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage set: {len(data)} items\")\n            \n            return {\n                \"success\": True,\n                \"item_count\": len(data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage set failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    def list_sessions(self) -> List[str]:\n        \"\"\"\n        List all saved cookie sessions\n        \n        Returns:\n            List of session names\n        \"\"\"\n        sessions = []\n        for file in self.cookies_dir.glob(\"*_cookies.json\"):\n            session_name = file.stem.replace(\"_cookies\", \"\")\n            sessions.append(session_name)\n        \n        return sessions\n    \n    def cleanup_old_files(self, days: int = 7):\n        \"\"\"\n        Clean up old screenshots and PDFs\n        \n        Args:\n            days: Delete files older than this many days\n        \"\"\"\n        from datetime import timedelta\n        cutoff = datetime.now() - timedelta(days=days)\n        \n        deleted_count = 0\n        for directory in [self.screenshots_dir, self.pdfs_dir]:\n            for file in directory.glob(\"*\"):\n                if file.stat().st_mtime < cutoff.timestamp():\n                    file.unlink()\n                    deleted_count += 1\n        \n        logger.info(f\"ðŸ—‘ï¸  Cleaned up {deleted_count} old files\")\n        return deleted_count\n","size_bytes":9610},"integrations/playwright_mcp_node/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"tests/conftest.py":{"content":"\"\"\"\nPytest configuration and fixtures for tests\n\"\"\"\nimport pytest\nimport sys\nfrom pathlib import Path\n\n# Add project root to Python path\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))\n\n\n@pytest.fixture\ndef sample_instruction():\n    \"\"\"Sample instruction for testing\"\"\"\n    return \"Navigate to example.com\"\n\n\n@pytest.fixture\ndef mock_openai_key(monkeypatch):\n    \"\"\"Mock OpenAI API key for tests\"\"\"\n    monkeypatch.setenv(\"OPENAI_API_KEY\", \"test-key-123\")\n","size_bytes":490},"app/engines/playwright_mcp/client/__init__.py":{"content":"\"\"\"\nPlaywright MCP Client Module\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\n\n__all__ = ['MCPStdioClient']\n","size_bytes":141},"app/engines/playwright_mcp/client/stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        args = [\"node\", \"integrations/playwright_mcp_node/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        pass\n                except UnicodeDecodeError:\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8262},"app/engines/playwright_mcp/config/__init__.py":{"content":"\"\"\"\nPlaywright MCP Configuration Module\n\"\"\"\n","size_bytes":44},"tests/integration/test_api.py":{"content":"\"\"\"\nIntegration tests for API endpoints\n\"\"\"\nimport pytest\n\n\ndef test_health_endpoint():\n    \"\"\"Test the health check endpoint\"\"\"\n    from app import create_app\n    \n    app = create_app()\n    client = app.test_client()\n    \n    response = client.get('/health')\n    assert response.status_code == 200\n    \n    data = response.get_json()\n    assert data['status'] == 'healthy'\n    assert 'browser_use' in data['engines']\n    assert 'playwright_mcp' in data['engines']\n\n\ndef test_execute_endpoint_validation():\n    \"\"\"Test execute endpoint input validation\"\"\"\n    from app import create_app\n    \n    app = create_app()\n    client = app.test_client()\n    \n    # Empty instruction should fail\n    response = client.post('/api/execute', json={'instruction': ''})\n    assert response.status_code == 400\n    \n    # Invalid engine should fail\n    response = client.post('/api/execute', json={\n        'instruction': 'test',\n        'engine': 'invalid_engine'\n    })\n    assert response.status_code == 400\n","size_bytes":996},"app/engines/playwright_mcp/__init__.py":{"content":"\"\"\"\nPlaywright MCP Codebase\nTool-based browser automation using Playwright's Model Context Protocol\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Playwright MCP engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        Tuple of (mcp_client, browser_agent)\n    \"\"\"\n    mcp_client = MCPStdioClient(headless=headless)\n    browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n__all__ = ['MCPStdioClient', 'BrowserAgent', 'create_engine']\n","size_bytes":706},"app/engines/browser_use/playwright_code_generator.py":{"content":"\"\"\"\nPlaywright Code Generator for Browser-Use\nConverts browser-use automation history into reusable Playwright code\n\nUsage:\n    history = await agent.run(...)\n    generator = PlaywrightCodeGenerator(history)\n    code = generator.generate_python_code()\n    print(code)\n\"\"\"\n\nimport re\nimport json\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass PlaywrightAction:\n    \"\"\"Represents a single Playwright action\"\"\"\n    action_type: str\n    selector: Optional[str] = None\n    value: Optional[str] = None\n    url: Optional[str] = None\n    comment: Optional[str] = None\n    raw_action: Optional[str] = None\n\n\nclass Locator(BaseModel):\n    \"\"\"Represents a reusable locator\"\"\"\n    name: str\n    selector: str\n    action_examples: List[str] = []\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"\n    Generates Playwright Python code from browser-use agent history\n    \n    Features:\n    - Extracts actions from AgentHistoryList\n    - Generates clean, maintainable Playwright code\n    - Creates reusable locators\n    - Includes proper async/await patterns\n    - Adds comments for clarity\n    \"\"\"\n    \n    def __init__(self, history=None, task_description: str = \"Automated browser task\"):\n        \"\"\"\n        Initialize code generator\n        \n        Args:\n            history: AgentHistoryList from browser-use agent.run()\n            task_description: Description of what the automation does\n        \"\"\"\n        self.history = history\n        self.task_description = task_description\n        self.actions: List[PlaywrightAction] = []\n        self.locators: Dict[str, Locator] = {}\n        \n    def parse_history(self) -> List[PlaywrightAction]:\n        \"\"\"\n        Parse browser-use history and extract Playwright actions\n        \n        Returns:\n            List of PlaywrightAction objects\n        \"\"\"\n        if not self.history:\n            return []\n        \n        actions = []\n        \n        # Try to get model_actions if available\n        if hasattr(self.history, 'model_actions'):\n            try:\n                model_actions = self.history.model_actions()\n                for action in model_actions:\n                    pw_action = self._convert_model_action(action)\n                    if pw_action:\n                        actions.append(pw_action)\n            except Exception as e:\n                print(f\"Note: Could not extract model_actions: {e}\")\n        \n        # Fallback: parse from history.history\n        if not actions and hasattr(self.history, 'history'):\n            for item in self.history.history:\n                pw_action = self._parse_history_item(item)\n                if pw_action:\n                    actions.append(pw_action)\n        \n        self.actions = actions\n        return actions\n    \n    def _convert_model_action(self, action: dict) -> Optional[PlaywrightAction]:\n        \"\"\"Convert browser-use model action to Playwright action\"\"\"\n        action_name = action.get('name', '').lower()\n        params = action.get('params', {}) or {}\n        \n        # Navigate action\n        if 'navigate' in action_name or 'goto' in action_name:\n            url = params.get('url') or params.get('target')\n            if url:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url,\n                    comment=f\"Navigate to {url}\",\n                    raw_action=str(action)\n                )\n        \n        # Click action\n        elif 'click' in action_name:\n            selector = self._extract_selector(params)\n            if selector:\n                return PlaywrightAction(\n                    action_type='click',\n                    selector=selector,\n                    comment=f\"Click {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Type/Input action\n        elif 'type' in action_name or 'input' in action_name or 'fill' in action_name:\n            selector = self._extract_selector(params)\n            value = params.get('text') or params.get('value') or params.get('input')\n            if selector and value:\n                return PlaywrightAction(\n                    action_type='fill',\n                    selector=selector,\n                    value=value,\n                    comment=f\"Fill '{value}' into {selector}\",\n                    raw_action=str(action)\n                )\n        \n        # Wait action\n        elif 'wait' in action_name:\n            timeout = params.get('timeout') or params.get('duration', 1000)\n            return PlaywrightAction(\n                action_type='wait',\n                value=str(timeout),\n                comment=f\"Wait {timeout}ms\",\n                raw_action=str(action)\n            )\n        \n        # Generic action - store for analysis\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Action: {action_name} - {params}\",\n            raw_action=str(action)\n        )\n    \n    def _parse_history_item(self, item) -> Optional[PlaywrightAction]:\n        \"\"\"Parse individual history item\"\"\"\n        model_output = str(getattr(item, 'model_output', ''))\n        \n        if not model_output or model_output == 'None':\n            return None\n        \n        # Simple heuristic parsing\n        model_lower = model_output.lower()\n        \n        # Navigation\n        if 'goto' in model_lower or 'navigate' in model_lower:\n            # Try to extract URL\n            url_match = re.search(r'https?://[^\\s\\'\"]+', model_output)\n            if url_match:\n                return PlaywrightAction(\n                    action_type='navigate',\n                    url=url_match.group(0),\n                    raw_action=model_output\n                )\n        \n        # Click\n        elif 'click' in model_lower:\n            return PlaywrightAction(\n                action_type='click',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Type/Fill\n        elif any(word in model_lower for word in ['type', 'fill', 'input', 'enter']):\n            return PlaywrightAction(\n                action_type='fill',\n                comment=f\"Extracted from: {model_output[:100]}\",\n                raw_action=model_output\n            )\n        \n        # Store as comment for manual review\n        return PlaywrightAction(\n            action_type='comment',\n            comment=f\"Step: {model_output[:150]}\",\n            raw_action=model_output\n        )\n    \n    def _extract_selector(self, params: dict) -> Optional[str]:\n        \"\"\"Extract selector from action parameters\"\"\"\n        keys_to_check = [\n            'selector', 'index_selector', 'css', 'xpath', \n            'aria', 'text', 'query', 'target', 'element'\n        ]\n        \n        for key in keys_to_check:\n            value = params.get(key)\n            if value and str(value).strip():\n                return str(value).strip()\n        \n        return None\n    \n    def _normalize_locator_name(self, selector: str) -> str:\n        \"\"\"Create a valid Python variable name from selector\"\"\"\n        # Remove special characters\n        name = re.sub(r'[^0-9a-zA-Z_]+', '_', selector).strip('_')\n        # Remove multiple underscores\n        name = re.sub(r'__+', '_', name)\n        # Truncate and ensure it's not empty\n        name = (name[:50] or \"locator\").lower()\n        # Ensure it doesn't start with a number\n        if name[0].isdigit():\n            name = f\"loc_{name}\"\n        return name\n    \n    def extract_locators(self) -> Dict[str, Locator]:\n        \"\"\"Extract reusable locators from actions\"\"\"\n        seen: Dict[str, Locator] = {}\n        \n        for action in self.actions:\n            if not action.selector:\n                continue\n            \n            sel = action.selector.strip()\n            name_base = self._normalize_locator_name(sel)\n            name = name_base\n            idx = 1\n            \n            # Handle duplicates\n            while name in seen:\n                idx += 1\n                name = f\"{name_base}_{idx}\"\n            \n            seen[name] = Locator(\n                name=name,\n                selector=sel,\n                action_examples=[f\"{action.action_type}({action.comment or sel})\"]\n            )\n        \n        self.locators = seen\n        return seen\n    \n    def generate_python_code(self, \n                           use_locators: bool = True,\n                           include_comments: bool = True,\n                           async_style: bool = True) -> str:\n        \"\"\"\n        Generate complete Playwright Python code\n        \n        Args:\n            use_locators: Extract selectors into constants\n            include_comments: Add explanatory comments\n            async_style: Use async/await (recommended)\n            \n        Returns:\n            Complete Python script as string\n        \"\"\"\n        if not self.actions:\n            self.parse_history()\n        \n        if use_locators:\n            self.extract_locators()\n        \n        code_lines = []\n        \n        # Header\n        code_lines.append('\"\"\"')\n        code_lines.append(f'{self.task_description}')\n        code_lines.append('')\n        code_lines.append('Generated from browser-use automation')\n        code_lines.append('To run: python script.py')\n        code_lines.append('\"\"\"')\n        code_lines.append('')\n        \n        # Imports\n        if async_style:\n            code_lines.append('import asyncio')\n        code_lines.append('from playwright.async_api import async_playwright' if async_style else 'from playwright.sync_api import sync_playwright')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Locators section\n        if use_locators and self.locators:\n            code_lines.append('# Locators extracted from automation')\n            for name, locator in self.locators.items():\n                examples = ', '.join(locator.action_examples)[:100]\n                code_lines.append(f'{name.upper()} = r\"{locator.selector}\"  # {examples}')\n            code_lines.append('')\n            code_lines.append('')\n        \n        # Main function\n        if async_style:\n            code_lines.append('async def main():')\n        else:\n            code_lines.append('def main():')\n        \n        code_lines.append('    \"\"\"Main automation function\"\"\"')\n        \n        # Browser setup\n        if async_style:\n            code_lines.append('    async with async_playwright() as p:')\n            code_lines.append('        browser = await p.chromium.launch(headless=False)')\n            code_lines.append('        page = await browser.new_page()')\n            code_lines.append('')\n        else:\n            code_lines.append('    with sync_playwright() as p:')\n            code_lines.append('        browser = p.chromium.launch(headless=False)')\n            code_lines.append('        page = browser.new_page()')\n            code_lines.append('')\n        \n        # Generate actions\n        indent = '        '\n        \n        if include_comments:\n            code_lines.append(f'{indent}# Automation steps')\n        \n        for i, action in enumerate(self.actions, 1):\n            if include_comments and action.comment:\n                code_lines.append(f'{indent}# Step {i}: {action.comment}')\n            \n            if action.action_type == 'navigate' and action.url:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.goto(\"{action.url}\")')\n            \n            elif action.action_type == 'click' and action.selector:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).click()')\n            \n            elif action.action_type == 'fill' and action.selector and action.value:\n                selector = self._get_locator_or_selector(action.selector, use_locators)\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.locator({selector}).fill(\"{action.value}\")')\n            \n            elif action.action_type == 'wait' and action.value:\n                code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout({action.value})')\n            \n            elif action.action_type == 'comment':\n                code_lines.append(f'{indent}# {action.comment}')\n            \n            code_lines.append('')\n        \n        # Pause before closing (optional)\n        if include_comments:\n            code_lines.append(f'{indent}# Pause to review results')\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}page.wait_for_timeout(3000)')\n        code_lines.append('')\n        \n        # Cleanup\n        code_lines.append(f'{indent}{\"await \" if async_style else \"\"}browser.close()')\n        code_lines.append('')\n        code_lines.append('')\n        \n        # Runner\n        code_lines.append('if __name__ == \"__main__\":')\n        if async_style:\n            code_lines.append('    asyncio.run(main())')\n        else:\n            code_lines.append('    main()')\n        \n        return '\\n'.join(code_lines)\n    \n    def _get_locator_or_selector(self, selector: str, use_locators: bool) -> str:\n        \"\"\"Get locator constant name or raw selector\"\"\"\n        if not use_locators:\n            return f'\"{selector}\"'\n        \n        # Find matching locator\n        for name, locator in self.locators.items():\n            if locator.selector == selector:\n                return name.upper()\n        \n        # Fallback to raw selector\n        return f'\"{selector}\"'\n    \n    def save_to_file(self, filename: str, **kwargs) -> str:\n        \"\"\"\n        Generate code and save to file\n        \n        Args:\n            filename: Output filename\n            **kwargs: Arguments passed to generate_python_code()\n            \n        Returns:\n            Generated code\n        \"\"\"\n        code = self.generate_python_code(**kwargs)\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(code)\n        \n        return code\n\n\n# Convenience function\ndef generate_playwright_code_from_history(history, \n                                         task_description: str = \"Automated task\",\n                                         output_file: Optional[str] = None) -> str:\n    \"\"\"\n    Quick function to generate Playwright code from browser-use history\n    \n    Args:\n        history: AgentHistoryList from browser-use\n        task_description: What the automation does\n        output_file: Optional file to save code to\n        \n    Returns:\n        Generated Playwright Python code\n        \n    Example:\n        history = await agent.run()\n        code = generate_playwright_code_from_history(history, output_file=\"automation.py\")\n        print(code)\n    \"\"\"\n    generator = PlaywrightCodeGenerator(history, task_description)\n    \n    if output_file:\n        return generator.save_to_file(output_file)\n    \n    return generator.generate_python_code()\n","size_bytes":15060},"integrations/playwright_mcp_node/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"app/engines/browser_use/performance_monitor.py":{"content":"\"\"\"\nPerformance Monitoring and Metrics Tracking\nTracks automation performance, timing, and resource usage\n\"\"\"\nimport time\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\nclass PerformanceMonitor:\n    \"\"\"\n    Monitor and track performance metrics for browser automation\n    Tracks timing, success rates, and resource usage\n    \"\"\"\n    \n    def __init__(self, track_detailed_metrics: bool = True):\n        \"\"\"\n        Initialize performance monitor\n        \n        Args:\n            track_detailed_metrics: Track detailed per-operation metrics\n        \"\"\"\n        self.track_detailed_metrics = track_detailed_metrics\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        \n        self.operation_metrics: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            \"count\": 0,\n            \"success_count\": 0,\n            \"fail_count\": 0,\n            \"total_duration\": 0.0,\n            \"min_duration\": float('inf'),\n            \"max_duration\": 0.0\n        })\n        \n        self.timing_stack: List[Dict[str, Any]] = []\n        \n        logger.info(\"ðŸ“Š Performance monitor initialized\")\n    \n    def start_operation(self, operation_name: str) -> str:\n        \"\"\"\n        Start tracking an operation\n        \n        Args:\n            operation_name: Name of the operation\n            \n        Returns:\n            Operation ID for stopping later\n        \"\"\"\n        operation_id = f\"{operation_name}_{len(self.timing_stack)}\"\n        \n        timing_info = {\n            \"operation_id\": operation_id,\n            \"operation_name\": operation_name,\n            \"start_time\": time.time(),\n            \"start_timestamp\": datetime.now().isoformat()\n        }\n        \n        self.timing_stack.append(timing_info)\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"â±ï¸  Started: {operation_name}\")\n        \n        return operation_id\n    \n    def end_operation(self, operation_id: str, success: bool = True, metadata: Optional[Dict] = None):\n        \"\"\"\n        End tracking an operation\n        \n        Args:\n            operation_id: ID returned from start_operation\n            success: Whether operation succeeded\n            metadata: Optional metadata about the operation\n        \"\"\"\n        if not self.timing_stack:\n            logger.warning(\"âš ï¸  No operation to end\")\n            return\n        \n        timing_info = self.timing_stack.pop()\n        \n        if timing_info[\"operation_id\"] != operation_id:\n            logger.warning(f\"âš ï¸  Operation ID mismatch: expected {timing_info['operation_id']}, got {operation_id}\")\n        \n        duration = time.time() - timing_info[\"start_time\"]\n        operation_name = timing_info[\"operation_name\"]\n        \n        self.metrics[\"total_operations\"] += 1\n        self.metrics[\"total_duration\"] += duration\n        \n        if success:\n            self.metrics[\"successful_operations\"] += 1\n        else:\n            self.metrics[\"failed_operations\"] += 1\n        \n        op_metrics = self.operation_metrics[operation_name]\n        op_metrics[\"count\"] += 1\n        op_metrics[\"total_duration\"] += duration\n        op_metrics[\"min_duration\"] = min(op_metrics[\"min_duration\"], duration)\n        op_metrics[\"max_duration\"] = max(op_metrics[\"max_duration\"], duration)\n        \n        if success:\n            op_metrics[\"success_count\"] += 1\n        else:\n            op_metrics[\"fail_count\"] += 1\n        \n        if self.track_detailed_metrics:\n            status = \"âœ…\" if success else \"âŒ\"\n            logger.info(f\"{status} {operation_name} completed in {duration:.2f}s\")\n    \n    def record_metric(self, metric_name: str, value: Any):\n        \"\"\"\n        Record a custom metric\n        \n        Args:\n            metric_name: Name of the metric\n            value: Metric value\n        \"\"\"\n        if \"custom_metrics\" not in self.metrics:\n            self.metrics[\"custom_metrics\"] = {}\n        \n        self.metrics[\"custom_metrics\"][metric_name] = value\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"ðŸ“Š Metric recorded: {metric_name} = {value}\")\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get performance summary\n        \n        Returns:\n            Dictionary with performance metrics\n        \"\"\"\n        total_ops = self.metrics[\"total_operations\"]\n        \n        summary = {\n            \"overview\": {\n                \"total_operations\": total_ops,\n                \"successful_operations\": self.metrics[\"successful_operations\"],\n                \"failed_operations\": self.metrics[\"failed_operations\"],\n                \"success_rate\": (self.metrics[\"successful_operations\"] / max(total_ops, 1)) * 100,\n                \"total_duration\": self.metrics[\"total_duration\"],\n                \"average_duration\": self.metrics[\"total_duration\"] / max(total_ops, 1),\n                \"start_time\": self.metrics[\"start_time\"],\n                \"current_time\": datetime.now().isoformat()\n            },\n            \"operation_breakdown\": {}\n        }\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            count = op_metrics[\"count\"]\n            summary[\"operation_breakdown\"][op_name] = {\n                \"count\": count,\n                \"success_count\": op_metrics[\"success_count\"],\n                \"fail_count\": op_metrics[\"fail_count\"],\n                \"success_rate\": (op_metrics[\"success_count\"] / max(count, 1)) * 100,\n                \"total_duration\": op_metrics[\"total_duration\"],\n                \"average_duration\": op_metrics[\"total_duration\"] / max(count, 1),\n                \"min_duration\": op_metrics[\"min_duration\"] if op_metrics[\"min_duration\"] != float('inf') else 0,\n                \"max_duration\": op_metrics[\"max_duration\"]\n            }\n        \n        if \"custom_metrics\" in self.metrics:\n            summary[\"custom_metrics\"] = self.metrics[\"custom_metrics\"]\n        \n        return summary\n    \n    def get_top_slowest_operations(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get the slowest operations\n        \n        Args:\n            limit: Number of operations to return\n            \n        Returns:\n            List of slowest operations with metrics\n        \"\"\"\n        operations = []\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            if op_metrics[\"count\"] > 0:\n                avg_duration = op_metrics[\"total_duration\"] / op_metrics[\"count\"]\n                operations.append({\n                    \"operation\": op_name,\n                    \"average_duration\": avg_duration,\n                    \"max_duration\": op_metrics[\"max_duration\"],\n                    \"count\": op_metrics[\"count\"]\n                })\n        \n        operations.sort(key=lambda x: x[\"average_duration\"], reverse=True)\n        return operations[:limit]\n    \n    def reset(self):\n        \"\"\"Reset all metrics\"\"\"\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        self.operation_metrics.clear()\n        self.timing_stack.clear()\n        \n        logger.info(\"ðŸ”„ Performance metrics reset\")\n    \n    def log_summary(self):\n        \"\"\"Log a formatted summary of metrics\"\"\"\n        summary = self.get_summary()\n        \n        logger.info(\"=\" * 80)\n        logger.info(\"ðŸ“Š PERFORMANCE SUMMARY\")\n        logger.info(\"=\" * 80)\n        logger.info(f\"Total Operations: {summary['overview']['total_operations']}\")\n        logger.info(f\"Success Rate: {summary['overview']['success_rate']:.1f}%\")\n        logger.info(f\"Total Duration: {summary['overview']['total_duration']:.2f}s\")\n        logger.info(f\"Average Duration: {summary['overview']['average_duration']:.2f}s\")\n        \n        if summary['operation_breakdown']:\n            logger.info(\"\\nðŸ“‹ Operation Breakdown:\")\n            for op_name, metrics in summary['operation_breakdown'].items():\n                logger.info(f\"  â€¢ {op_name}: {metrics['count']} ops, \"\n                          f\"avg {metrics['average_duration']:.2f}s, \"\n                          f\"success {metrics['success_rate']:.1f}%\")\n        \n        logger.info(\"=\" * 80)\n","size_bytes":8538},"app/engines/browser_use/state_manager.py":{"content":"\"\"\"\nState Management for Complex Multi-Step Workflows\nPreserves context and state across automation steps\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass WorkflowState:\n    \"\"\"\n    Manages state for complex multi-step automation workflows\n    Preserves context, variables, and execution history\n    \"\"\"\n    \n    def __init__(self, workflow_id: Optional[str] = None, persist_to_disk: bool = False):\n        \"\"\"\n        Initialize workflow state manager\n        \n        Args:\n            workflow_id: Unique identifier for this workflow\n            persist_to_disk: Save state to disk for recovery\n        \"\"\"\n        self.workflow_id = workflow_id or f\"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.persist_to_disk = persist_to_disk\n        \n        self.state: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.execution_history: List[Dict[str, Any]] = []\n        self.checkpoints: List[Dict[str, Any]] = []\n        \n        self.metadata = {\n            \"workflow_id\": self.workflow_id,\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"step_count\": 0\n        }\n        \n        if self.persist_to_disk:\n            self.state_dir = Path(\"workflow_states\")\n            self.state_dir.mkdir(exist_ok=True)\n            self.state_file = self.state_dir / f\"{self.workflow_id}.json\"\n        \n        logger.info(f\"ðŸ”„ Workflow state initialized: {self.workflow_id}\")\n    \n    def set_variable(self, key: str, value: Any):\n        \"\"\"\n        Set a workflow variable\n        \n        Args:\n            key: Variable name\n            value: Variable value\n        \"\"\"\n        self.variables[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ“ Variable set: {key} = {value}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_variable(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a workflow variable\n        \n        Args:\n            key: Variable name\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Variable value or default\n        \"\"\"\n        return self.variables.get(key, default)\n    \n    def set_state(self, key: str, value: Any):\n        \"\"\"\n        Set a state value\n        \n        Args:\n            key: State key\n            value: State value\n        \"\"\"\n        self.state[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ’¾ State set: {key}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_state(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a state value\n        \n        Args:\n            key: State key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            State value or default\n        \"\"\"\n        return self.state.get(key, default)\n    \n    def add_step(self, step_name: str, step_data: Dict[str, Any], success: bool = True):\n        \"\"\"\n        Record a workflow step\n        \n        Args:\n            step_name: Name of the step\n            step_data: Data associated with the step\n            success: Whether the step succeeded\n        \"\"\"\n        step_record = {\n            \"step_number\": self.metadata[\"step_count\"] + 1,\n            \"step_name\": step_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"success\": success,\n            \"data\": step_data\n        }\n        \n        self.execution_history.append(step_record)\n        self.metadata[\"step_count\"] += 1\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"âœ… Step {self.metadata['step_count']} recorded: {step_name} (success: {success})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def create_checkpoint(self, checkpoint_name: str):\n        \"\"\"\n        Create a checkpoint of current state\n        \n        Args:\n            checkpoint_name: Name for this checkpoint\n        \"\"\"\n        checkpoint = {\n            \"name\": checkpoint_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"state\": self.state.copy(),\n            \"variables\": self.variables.copy(),\n            \"step_count\": self.metadata[\"step_count\"]\n        }\n        \n        self.checkpoints.append(checkpoint)\n        logger.info(f\"ðŸ”– Checkpoint created: {checkpoint_name} (at step {self.metadata['step_count']})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def restore_checkpoint(self, checkpoint_name: str) -> bool:\n        \"\"\"\n        Restore state from a checkpoint\n        \n        Args:\n            checkpoint_name: Name of checkpoint to restore\n            \n        Returns:\n            True if restored successfully, False if checkpoint not found\n        \"\"\"\n        for checkpoint in reversed(self.checkpoints):\n            if checkpoint[\"name\"] == checkpoint_name:\n                self.state = checkpoint[\"state\"].copy()\n                self.variables = checkpoint[\"variables\"].copy()\n                \n                logger.info(f\"â™»ï¸  Restored checkpoint: {checkpoint_name} (from step {checkpoint['step_count']})\")\n                \n                if self.persist_to_disk:\n                    self._save_to_disk()\n                \n                return True\n        \n        logger.warning(f\"âš ï¸  Checkpoint not found: {checkpoint_name}\")\n        return False\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of the workflow state\n        \n        Returns:\n            Dictionary with state summary\n        \"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"metadata\": self.metadata,\n            \"total_steps\": self.metadata[\"step_count\"],\n            \"total_checkpoints\": len(self.checkpoints),\n            \"variable_count\": len(self.variables),\n            \"state_keys\": list(self.state.keys()),\n            \"success_rate\": self._calculate_success_rate()\n        }\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate success rate of executed steps\"\"\"\n        if not self.execution_history:\n            return 100.0\n        \n        successful = sum(1 for step in self.execution_history if step[\"success\"])\n        return (successful / len(self.execution_history)) * 100\n    \n    def _save_to_disk(self):\n        \"\"\"Save state to disk\"\"\"\n        try:\n            state_data = {\n                \"workflow_id\": self.workflow_id,\n                \"metadata\": self.metadata,\n                \"state\": self.state,\n                \"variables\": self.variables,\n                \"execution_history\": self.execution_history,\n                \"checkpoints\": self.checkpoints\n            }\n            \n            with open(self.state_file, 'w') as f:\n                json.dump(state_data, f, indent=2)\n            \n            logger.debug(f\"ðŸ’¾ State saved to: {self.state_file}\")\n        except Exception as e:\n            logger.error(f\"âŒ Failed to save state: {str(e)}\")\n    \n    @classmethod\n    def load_from_disk(cls, workflow_id: str) -> Optional['WorkflowState']:\n        \"\"\"\n        Load workflow state from disk\n        \n        Args:\n            workflow_id: Workflow ID to load\n            \n        Returns:\n            WorkflowState instance or None if not found\n        \"\"\"\n        state_file = Path(\"workflow_states\") / f\"{workflow_id}.json\"\n        \n        if not state_file.exists():\n            logger.warning(f\"âš ï¸  Workflow state not found: {workflow_id}\")\n            return None\n        \n        try:\n            with open(state_file, 'r') as f:\n                state_data = json.load(f)\n            \n            instance = cls(workflow_id=workflow_id, persist_to_disk=True)\n            instance.metadata = state_data[\"metadata\"]\n            instance.state = state_data[\"state\"]\n            instance.variables = state_data[\"variables\"]\n            instance.execution_history = state_data[\"execution_history\"]\n            instance.checkpoints = state_data[\"checkpoints\"]\n            \n            logger.info(f\"ðŸ“‚ Workflow state loaded: {workflow_id}\")\n            return instance\n            \n        except Exception as e:\n            logger.error(f\"âŒ Failed to load state: {str(e)}\")\n            return None\n    \n    def reset(self):\n        \"\"\"Reset workflow state\"\"\"\n        self.state.clear()\n        self.variables.clear()\n        self.execution_history.clear()\n        self.checkpoints.clear()\n        self.metadata[\"step_count\"] = 0\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"ðŸ”„ Workflow state reset: {self.workflow_id}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n","size_bytes":9020},"app/engines/browser_use/popup_handler.py":{"content":"\"\"\"\nEnhanced Popup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows with advanced features\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Enhanced popup window handler with advanced detection and management\n    Features:\n    - Automatic popup detection and switching\n    - Configurable timeouts\n    - Detailed logging and tracking\n    - Multi-popup orchestration\n    - Popup priority rules\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext, popup_timeout: int = 10000, \n                 auto_switch: bool = True, log_verbose: bool = True):\n        \"\"\"\n        Initialize the enhanced popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n            popup_timeout: Timeout in milliseconds for popup operations (default: 10000ms)\n            auto_switch: Automatically switch to new popups (default: True)\n            log_verbose: Enable detailed logging (default: True)\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        self.popup_timeout = popup_timeout\n        self.auto_switch = auto_switch\n        self.log_verbose = log_verbose\n        \n        self.popup_history: List[Dict[str, Any]] = []\n        self.popup_count = 0\n        \n        context.on(\"page\", self._on_new_page)\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ” Enhanced popup handler initialized (timeout: {popup_timeout}ms, auto_switch: {auto_switch})\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Enhanced event handler for new pages/windows with tracking\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        self.popup_count += 1\n        popup_info = {\n            \"popup_number\": self.popup_count,\n            \"url\": page.url or \"about:blank\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"auto_switched\": self.auto_switch\n        }\n        \n        self.popup_history.append(popup_info)\n        self.new_pages.append(page)\n        self.popup_detected = True\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ†• Popup #{self.popup_count} detected: {popup_info['url']}\")\n            logger.info(f\"ðŸ“Š Total popups opened: {self.popup_count}\")\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page with enhanced timeout handling\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages and self.auto_switch:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=self.popup_timeout)\n                \n                if self.log_verbose:\n                    logger.info(f\"âœ… Switched to popup window: {latest_page.url}\")\n                \n                return latest_page\n            except Exception as e:\n                logger.warning(f\"âš ï¸ Popup not ready within {self.popup_timeout}ms: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    async def wait_for_popup(self, timeout: Optional[int] = None) -> Optional[Page]:\n        \"\"\"\n        Wait for a popup to appear\n        \n        Args:\n            timeout: Optional custom timeout in milliseconds\n            \n        Returns:\n            New popup page or None if timeout\n        \"\"\"\n        wait_timeout = timeout or self.popup_timeout\n        start_time = datetime.now()\n        \n        while (datetime.now() - start_time).total_seconds() * 1000 < wait_timeout:\n            if self.new_pages:\n                new_page = self.new_pages[-1]\n                if self.log_verbose:\n                    logger.info(f\"âœ… Popup appeared: {new_page.url}\")\n                return new_page\n            await asyncio.sleep(0.1)\n        \n        logger.warning(f\"â±ï¸  No popup appeared within {wait_timeout}ms\")\n        return None\n    \n    def get_popup_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about popup handling\n        \n        Returns:\n            Dictionary with popup statistics\n        \"\"\"\n        return {\n            \"total_popups\": self.popup_count,\n            \"active_popups\": len(self.new_pages),\n            \"popup_history\": self.popup_history,\n            \"auto_switch_enabled\": self.auto_switch,\n            \"timeout_ms\": self.popup_timeout\n        }\n    \n    def reset(self):\n        \"\"\"Reset the handler state with enhanced logging\"\"\"\n        previous_count = self.popup_count\n        self.new_pages.clear()\n        self.popup_detected = False\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ”„ Popup handler reset (processed {previous_count} popups this session)\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":5279},"integrations/playwright_mcp_node/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"app/engines/browser_use/engine_optimized.py":{"content":"\"\"\"\nOptimized Browser-Use Engine\nAI-powered browser automation with advanced features and optimizations\n\nNew Features:\n- Advanced browser capabilities (screenshots, PDFs, cookies, sessions)\n- Enhanced popup handling with configurable timeouts\n- Smart retry mechanism with exponential backoff\n- State management for complex workflows\n- Data extraction capabilities\n- Performance monitoring and metrics\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\n\nfrom app.engines.browser_use.advanced_features import AdvancedBrowserFeatures\nfrom app.engines.browser_use.retry_mechanism import RetryConfig, RetryMechanism\nfrom app.engines.browser_use.state_manager import WorkflowState\nfrom app.engines.browser_use.data_extractor import DataExtractor\nfrom app.engines.browser_use.performance_monitor import PerformanceMonitor\n\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedBrowserUseEngine:\n    \"\"\"\n    Optimized browser automation engine with advanced capabilities\n    \n    Features:\n    - Screenshot capture and PDF generation\n    - Cookie and session management\n    - Smart retry with exponential backoff\n    - Workflow state persistence\n    - Data extraction (tables, lists, metadata)\n    - Performance monitoring\n    - Enhanced popup handling\n    \"\"\"\n    \n    def __init__(self, headless: bool = False, enable_advanced_features: bool = True):\n        \"\"\"\n        Initialize Optimized Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n            enable_advanced_features: Enable advanced capabilities\n        \"\"\"\n        self.headless = headless\n        self.enable_advanced_features = enable_advanced_features\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n        \n        if enable_advanced_features:\n            output_dir = config.get('advanced_features', 'output_directory', fallback='automation_outputs')\n            self.enable_screenshots = config.getboolean('advanced_features', 'enable_screenshots', fallback=True)\n            self.enable_pdf_generation = config.getboolean('advanced_features', 'enable_pdf_generation', fallback=True)\n            self.enable_cookie_management = config.getboolean('advanced_features', 'enable_cookie_management', fallback=True)\n            self.enable_state_persistence = config.getboolean('advanced_features', 'enable_state_persistence', fallback=True)\n            \n            self.advanced_features = AdvancedBrowserFeatures(output_dir=output_dir)\n            \n            max_retries = int(config.get('retry', 'max_retries', fallback='3'))\n            initial_delay = float(config.get('retry', 'initial_delay', fallback='1.0'))\n            max_delay = float(config.get('retry', 'max_delay', fallback='30.0'))\n            backoff_factor = float(config.get('retry', 'backoff_factor', fallback='2.0'))\n            \n            retry_config = RetryConfig(\n                max_retries=max_retries,\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                backoff_factor=backoff_factor\n            )\n            self.retry_mechanism = RetryMechanism(retry_config)\n            \n            track_metrics = config.getboolean('performance', 'track_detailed_metrics', fallback=True)\n            self.performance_monitor = PerformanceMonitor(track_detailed_metrics=track_metrics)\n            \n            self.data_extractor = DataExtractor()\n            self.workflow_state = None\n            \n            logger.info(\"ðŸš€ Advanced features enabled: Screenshots, PDFs, Cookies, Retry, Performance Tracking\")\n        else:\n            logger.info(\"â„¹ï¸  Running in basic mode (advanced features disabled)\")\n    \n    async def execute_instruction(self, instruction: str, \n                                  workflow_id: Optional[str] = None,\n                                  save_screenshot: bool = False,\n                                  save_pdf: bool = False) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction with advanced features\n        \n        Args:\n            instruction: User's natural language instruction\n            workflow_id: Optional workflow ID for state management\n            save_screenshot: Capture screenshot after completion\n            save_pdf: Generate PDF after completion\n            \n        Returns:\n            Dictionary with execution results and advanced metrics\n        \"\"\"\n        op_id = None\n        if self.enable_advanced_features:\n            op_id = self.performance_monitor.start_operation(\"execute_instruction\")\n            \n            if workflow_id:\n                self.workflow_state = WorkflowState(workflow_id=workflow_id, persist_to_disk=True)\n        \n        try:\n            logger.info(\"ðŸ¤– Initializing Browser-Use Agent\")\n            logger.info(f\"ðŸ“‹ Task: {instruction}\")\n            logger.info(f\"ðŸ”¢ Max steps: {self.max_steps}\")\n            \n            # Enhanced system instructions with intelligent stopping mechanism\n            # Based on browser-use PR #61 for 10X efficiency improvement\n            system_instructions = f\"\"\"\nCRITICAL INSTRUCTIONS - KEEP RESPONSES BRIEF:\n1. Follow the user's instruction LITERALLY - do only what is explicitly asked\n2. STOP IMMEDIATELY once the stated task is complete\n3. Do NOT extract, save, or compile data unless explicitly requested\n4. Do NOT perform additional \"helpful\" actions beyond the instruction\n5. If asked to \"search\", stop when search results appear\n6. If asked to \"navigate\", stop when the page loads\n7. If asked to \"click\", stop after clicking\n8. Only do extra work (extract, save, analyze) if the instruction explicitly asks for it\n9. IMPORTANT: Keep all your reasoning and output SHORT and DIRECT to avoid timeouts\n\nINTELLIGENT TASK COMPLETION (10X EFFICIENCY):\nYour ultimate task is: \"{instruction}\"\nBefore EVERY action, ask yourself: \"Have I achieved my ultimate task?\"\n- If YES: STOP IMMEDIATELY and use the done action to complete the task\n- If NO: Continue with the next necessary action only\nDo not continue working after achieving your goal!\n\nPOPUP WINDOW HANDLING:\n- When a button opens a NEW WINDOW or POPUP (like \"Sign in with Google\", \"Continue with X\", etc.):\n  * The browser will automatically switch to the new window\n  * Continue your task in the NEW WINDOW without mentioning the window switch\n  * All subsequent actions should be performed in the NEW WINDOW\n- DO NOT try to switch windows manually - it happens automatically\n- DO NOT mention window switches in your output - just continue the task seamlessly\n            \"\"\"\n            \n            logger.info(\"âš™ï¸  Configuring agent with optimizations\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"â–¶ï¸  Starting agent execution...\")\n            \n            if self.enable_advanced_features:\n                @self.retry_mechanism.async_retry\n                async def run_with_retry():\n                    return await agent.run(max_steps=self.max_steps)\n                \n                history = await run_with_retry()\n            else:\n                history = await agent.run(max_steps=self.max_steps)\n            \n            logger.info(f\"â¹ï¸  Agent execution completed\")\n            \n            logger.info(\"ðŸ“Š Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n                \n                if self.enable_advanced_features and self.workflow_state:\n                    self.workflow_state.add_step(\n                        step_name=f\"browser_action_{step_num}\",\n                        step_data={\"action\": action},\n                        success=True\n                    )\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Generate Playwright code from automation (optional feature)\n            playwright_code = None\n            try:\n                from app.engines.browser_use.playwright_code_generator import generate_playwright_code_from_history\n                playwright_code = generate_playwright_code_from_history(\n                    history,\n                    task_description=instruction\n                )\n                logger.info(\"ðŸŽ­ Playwright code generated successfully\")\n            except Exception as e:\n                logger.debug(f\"Could not generate Playwright code: {e}\")\n            \n            if len(steps) == 0:\n                logger.error(f\"âŒ Task failed - no steps were executed successfully\")\n                result = {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            else:\n                logger.info(f\"âœ… Task completed successfully!\")\n                logger.info(f\"ðŸ“ˆ Total steps executed: {len(steps)}\")\n                if final_result:\n                    logger.info(f\"ðŸŽ¯ Final result: {str(final_result)[:200]}\")\n                \n                result = {\n                    \"success\": True,\n                    \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result\n                }\n                \n                # Add Playwright code if generated\n                if playwright_code:\n                    result[\"playwright_code\"] = playwright_code\n            \n            if self.enable_advanced_features:\n                if op_id:\n                    self.performance_monitor.end_operation(op_id, success=result[\"success\"])\n                \n                result[\"performance_metrics\"] = self.performance_monitor.get_summary()\n                \n                if self.workflow_state:\n                    result[\"workflow_state\"] = self.workflow_state.get_summary()\n                \n                result[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Browser-Use execution failed: {str(e)}\", exc_info=True)\n            \n            if self.enable_advanced_features and op_id:\n                self.performance_monitor.end_operation(op_id, success=False)\n            \n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            **kwargs: Additional arguments for execute_instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction, **kwargs))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance monitoring summary\"\"\"\n        if self.enable_advanced_features:\n            return self.performance_monitor.get_summary()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def get_retry_stats(self) -> Dict[str, Any]:\n        \"\"\"Get retry mechanism statistics\"\"\"\n        if self.enable_advanced_features:\n            return self.retry_mechanism.get_stats()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics and statistics\"\"\"\n        if self.enable_advanced_features:\n            self.performance_monitor.reset()\n            self.retry_mechanism.reset_stats()\n            logger.info(\"ðŸ”„ All metrics reset\")\n","size_bytes":13984},"tests/integration/__init__.py":{"content":"","size_bytes":0},"tests/unit/__init__.py":{"content":"","size_bytes":0}},"version":2}