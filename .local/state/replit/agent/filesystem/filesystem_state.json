{"file_contents":{"cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"replit.md":{"content":"# AI Browser Automation Agent\n\n## Project Overview\n\nThis is a **Python web application** that combines OpenAI GPT-5 with Playwright MCP (Model Context Protocol) to create an intelligent browser automation agent. Users can input natural language instructions, and the AI agent will autonomously perform browser actions to complete the task.\n\n**Project Type:** Flask Web Application + AI Agent\n**Created:** October 20, 2025\n\n## Key Features\n\n- Natural language browser automation powered by OpenAI GPT-5\n- Intelligent task interpretation and execution using AI function calling\n- Real-time browser control via Playwright MCP\n- Beautiful, responsive web interface\n- Step-by-step execution tracking with detailed results\n- Supports navigation, clicking, form filling, and page analysis\n\n## Architecture\n\n### Components\n\n1. **Flask Web App** (`app/web_app.py`)\n   - Web server providing REST API and user interface\n   - Endpoints for instruction execution, tools listing, and health checks\n   - Lazy initialization of MCP client for efficiency\n\n2. **MCP STDIO Client** (`app/mcp_stdio_client.py`)\n   - Communicates with Playwright MCP server via subprocess\n   - Uses JSON-RPC over STDIO transport for stateful sessions\n   - Manages browser lifecycle and tool invocations\n\n3. **Browser Agent** (`app/browser_agent.py`)\n   - OpenAI GPT-5 powered intelligent agent\n   - Interprets natural language instructions\n   - Uses function calling to execute browser automation tools\n   - Iterative execution with feedback loops\n\n4. **Playwright MCP Server** (`cli.js`)\n   - Node.js-based browser automation server\n   - Launched as subprocess by the Python client\n   - Provides structured browser interaction tools\n\n### Technology Stack\n\n**Backend:**\n- Python 3.11\n- Flask (web framework)\n- OpenAI Python SDK (GPT-5 API)\n- Requests (HTTP client)\n\n**Browser Automation:**\n- Playwright MCP Server (Node.js)\n- Model Context Protocol (STDIO transport)\n- Chromium browser (headless mode)\n\n**Frontend:**\n- HTML5 + CSS3\n- Vanilla JavaScript (no frameworks)\n- Responsive design with gradient UI\n\n## Project Structure\n\n```\n.\n├── app/\n│   ├── __init__.py\n│   ├── web_app.py              # Flask application\n│   ├── mcp_stdio_client.py     # MCP client (STDIO transport)\n│   ├── mcp_client.py           # HTTP client (legacy, not used)\n│   ├── browser_agent.py        # OpenAI agent\n│   ├── templates/\n│   │   └── index.html          # Web interface\n│   └── static/\n│       ├── css/style.css       # Stylesheet\n│       └── js/app.js           # Frontend JavaScript\n├── main.py                     # Application entry point\n├── cli.js                      # Playwright MCP server\n├── package.json                # Node.js dependencies for MCP\n├── pyproject.toml              # Python dependencies\n└── replit.md                   # This file\n\n```\n\n## How It Works\n\n1. **User Input:** User enters a natural language instruction (e.g., \"Go to google.com and search for 'AI'\")\n2. **AI Processing:** OpenAI GPT-5 interprets the instruction and breaks it into browser automation steps\n3. **Tool Execution:** The agent calls Playwright MCP tools (navigate, click, fill, etc.) via function calling\n4. **Feedback Loop:** After each action, the agent receives page state and decides next steps\n5. **Results Display:** All steps and results are shown in real-time on the web interface\n\n## Environment Variables\n\n- `OPENAI_API_KEY` - OpenAI API key for GPT-5 access (required)\n\n## Usage\n\n### Starting the Application\n\nThe application runs automatically on Replit. The Flask server starts on port 5000 and launches the Playwright MCP server as a subprocess.\n\n### Example Instructions\n\n- \"Go to example.com\"\n- \"Navigate to github.com and find trending repositories\"  \n- \"Open google.com and search for 'Playwright MCP'\"\n- \"Visit example.com and get the page title\"\n\n### API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute an instruction\n- `GET /api/tools` - List available browser tools\n- `POST /api/reset` - Reset agent conversation\n- `GET /health` - Health check endpoint\n\n## Available Browser Tools\n\nThe Playwright MCP server provides these tools:\n\n- `browser_navigate` - Navigate to a URL\n- `browser_click` - Click an element on the page\n- `browser_fill` - Fill form fields with text\n- `browser_snapshot` - Get page accessibility tree\n- `browser_close` - Close the browser\n- And many more...\n\n## Technical Notes\n\n### Transport Protocol\n\nThis project uses **STDIO transport** instead of HTTP transport because:\n- HTTP transport in Playwright MCP is stateless (each request is independent)\n- STDIO maintains session state across multiple tool calls\n- Subprocess communication ensures reliable browser context preservation\n\n### AI Agent Design\n\nThe browser agent uses OpenAI's function calling feature:\n1. System prompt defines the agent's role and capabilities\n2. Available tools are formatted as OpenAI function schemas\n3. GPT-5 decides which tools to call based on the instruction\n4. Agent executes tools and provides results back to GPT-5\n5. Process repeats until task is complete (max 10 iterations)\n\n### Error Handling\n\n- Graceful degradation when MCP server is unavailable\n- Tool execution errors are captured and reported to the AI\n- User-friendly error messages in the web interface\n- Health check endpoint for monitoring\n\n## Development Notes\n\n- The MCP client spawns a new Playwright subprocess for each web session\n- Browser runs in headless mode for server environments\n- Lazy initialization prevents unnecessary resource usage\n- CORS and security headers should be added for production use\n\n## Deployment\n\nConfigured for Replit Autoscale deployment:\n- Deployment target: `autoscale` (stateless web application)\n- Run command: `python main.py`\n- Port: 5000 (exposed via web interface)\n\n## Known Limitations\n\n1. **Single User:** One browser session per application instance\n2. **No Persistence:** Browser state is lost when the app restarts\n3. **Resource Intensive:** Running browsers requires significant memory\n4. **Rate Limits:** Subject to OpenAI API rate limits and costs\n\n## Future Enhancements\n\n- Multi-user support with session management\n- Persistent browser profiles and cookies\n- Screenshot and PDF generation capabilities\n- Integration with more AI providers\n- Advanced debugging and logging features\n- Browser extension support for non-headless mode\n\n## Credits\n\n- Built on Replit platform\n- Uses Microsoft Playwright MCP Server\n- Powered by OpenAI GPT-5\n- Created as a demonstration of AI-powered browser automation\n","size_bytes":6638},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask>=3.1.2\",\n    \"openai>=2.6.0\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":236},"SETUP.md":{"content":"# Setup Guide - AI Browser Automation Agent\n\n## Complete setup instructions for running this project on Windows\n\n---\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed on your Windows machine:\n\n### 1. Python 3.11 or higher\n- Download from: https://www.python.org/downloads/\n- During installation, **check the box \"Add Python to PATH\"**\n- Verify installation:\n  ```cmd\n  python --version\n  ```\n\n### 2. Node.js 18 or higher\n- Download from: https://nodejs.org/\n- Use the LTS (Long Term Support) version\n- Verify installation:\n  ```cmd\n  node --version\n  npm --version\n  ```\n\n### 3. Git (optional, for cloning)\n- Download from: https://git-scm.com/download/win\n\n---\n\n## Step 1: Download the Project\n\n### Option A: Download from Replit\n1. In Replit, click the three dots menu (⋮) at the top\n2. Select \"Download as zip\"\n3. Extract the zip file to your desired location (e.g., `C:\\Projects\\ai-browser-agent`)\n\n### Option B: Clone from Git (if available)\n```cmd\ngit clone <repository-url>\ncd ai-browser-agent\n```\n\n---\n\n## Step 2: Install Python Dependencies\n\nOpen **Command Prompt** or **PowerShell** in the project directory:\n\n```cmd\ncd C:\\Projects\\ai-browser-agent\n```\n\nInstall Python packages:\n\n```cmd\npip install flask openai requests sseclient-py\n```\n\n---\n\n## Step 3: Install Node.js Dependencies\n\nIn the same directory, install the Playwright MCP server dependencies:\n\n```cmd\nnpm install\n```\n\nThis will install:\n- `@modelcontextprotocol/sdk`\n- `playwright`\n- `@playwright/test`\n- Other required packages\n\n---\n\n## Step 4: Install Playwright Browsers\n\nPlaywright needs to download browser binaries (Chromium):\n\n```cmd\nnpx playwright install chromium\n```\n\n---\n\n## Step 5: Set Up OpenAI API Key\n\nYou need an OpenAI API key to use the GPT-5 model.\n\n### Get your API key:\n1. Go to https://platform.openai.com/api-keys\n2. Sign in or create an account\n3. Click \"Create new secret key\"\n4. Copy the key (starts with `sk-`)\n\n### Set the environment variable:\n\n**Option A: Temporary (for current session only)**\n```cmd\nset OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n**Option B: Permanent (recommended)**\n1. Open **System Properties** (search \"environment variables\" in Windows)\n2. Click \"Environment Variables\"\n3. Under \"User variables\", click \"New\"\n4. Variable name: `OPENAI_API_KEY`\n5. Variable value: `sk-your-actual-api-key-here`\n6. Click OK\n\n**Option C: Create a .env file** (if you modify the code to use python-dotenv)\n```\nOPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n---\n\n## Step 6: Run the Application\n\nStart the Flask web server:\n\n```cmd\npython main.py\n```\n\nYou should see output like:\n```\n * Serving Flask app 'app.web_app'\n * Debug mode: off\n * Running on http://127.0.0.1:5000\n```\n\n---\n\n## Step 7: Access the Web Interface\n\nOpen your web browser and go to:\n\n```\nhttp://localhost:5000\n```\n\nYou should see the AI Browser Automation Agent interface!\n\n---\n\n## Testing the Application\n\nTry these example instructions:\n\n1. **Simple navigation:**\n   ```\n   Go to example.com\n   ```\n\n2. **Search task:**\n   ```\n   Navigate to google.com and search for 'Playwright MCP'\n   ```\n\n3. **Page interaction:**\n   ```\n   Open github.com and find trending repositories\n   ```\n\n---\n\n## Troubleshooting\n\n### Issue: \"Python is not recognized\"\n- Make sure Python is added to your PATH during installation\n- Restart Command Prompt after installing Python\n- Try using `py` instead of `python`\n\n### Issue: \"npm is not recognized\"\n- Make sure Node.js is installed correctly\n- Restart Command Prompt after installing Node.js\n- Check if Node.js is in PATH: `where node`\n\n### Issue: \"OPENAI_API_KEY not set\"\n- Make sure you set the environment variable\n- Restart Command Prompt after setting permanent variables\n- Verify it's set: `echo %OPENAI_API_KEY%`\n\n### Issue: \"Port 5000 already in use\"\n- Another application is using port 5000\n- Edit `main.py` and change the port:\n  ```python\n  app.run(host='0.0.0.0', port=8000)\n  ```\n- Then access at: `http://localhost:8000`\n\n### Issue: Browser automation fails\n- Make sure Playwright browsers are installed: `npx playwright install chromium`\n- Check if antivirus is blocking browser execution\n- Try running as Administrator\n\n### Issue: \"Module not found\" errors\n- Make sure all Python packages are installed: `pip install flask openai requests sseclient-py`\n- Make sure Node.js packages are installed: `npm install`\n\n---\n\n## Project Structure\n\n```\nai-browser-agent/\n├── app/                      # Python application\n│   ├── __init__.py\n│   ├── web_app.py           # Flask web server\n│   ├── mcp_stdio_client.py  # MCP client (subprocess)\n│   ├── browser_agent.py     # OpenAI agent\n│   ├── templates/\n│   │   └── index.html       # Web UI\n│   └── static/\n│       ├── css/style.css\n│       └── js/app.js\n├── main.py                  # Application entry point\n├── cli.js                   # Playwright MCP server (Node.js)\n├── package.json             # Node.js dependencies\n├── pyproject.toml           # Python project config\n└── SETUP.md                 # This file\n```\n\n---\n\n## How It Works\n\n1. **Flask Server**: Runs on port 5000, serves the web interface\n2. **User Input**: You enter a natural language instruction in the browser\n3. **OpenAI Processing**: GPT-5 interprets your instruction\n4. **MCP Communication**: Python spawns Node.js subprocess running Playwright MCP\n5. **Browser Automation**: Playwright executes browser actions (navigate, click, fill, etc.)\n6. **Results**: Actions and results are displayed in real-time\n\n---\n\n## API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute an instruction\n- `GET /api/tools` - List available browser tools\n- `POST /api/reset` - Reset agent conversation\n- `GET /health` - Health check\n\n---\n\n## Stopping the Application\n\nPress `Ctrl + C` in the Command Prompt window to stop the server.\n\n---\n\n## Notes for Windows Users\n\n1. **Firewall**: Windows may ask for firewall permission - allow it\n2. **Antivirus**: Some antivirus software may block browser automation - add exception if needed\n3. **PowerShell**: If using PowerShell, use `$env:OPENAI_API_KEY=\"sk-...\"` to set variables\n4. **Paths**: Use backslashes (`\\`) for Windows paths, or forward slashes (`/`) work too\n5. **Long Paths**: If you encounter path length issues, enable long paths in Windows\n\n---\n\n## Production Deployment\n\nThis setup is for **development/testing only**. For production:\n\n1. **Use a production WSGI server** (not Flask development server):\n   ```cmd\n   pip install gunicorn\n   gunicorn --bind 0.0.0.0:5000 app.web_app:app\n   ```\n   Note: Gunicorn doesn't work natively on Windows. Use `waitress` instead:\n   ```cmd\n   pip install waitress\n   waitress-serve --host=0.0.0.0 --port=5000 app.web_app:app\n   ```\n\n2. **Use environment variables** for all secrets (never hardcode API keys)\n\n3. **Add security headers** and CORS configuration\n\n4. **Consider deploying to a cloud platform** (Replit, Heroku, AWS, Azure, etc.)\n\n---\n\n## Cost Considerations\n\n- **OpenAI API**: You'll be charged based on GPT-5 usage (tokens processed)\n- Each instruction execution calls OpenAI multiple times (typically 2-5 calls)\n- Monitor your usage at: https://platform.openai.com/usage\n\n---\n\n## Support\n\nIf you encounter issues:\n1. Check the console output for error messages\n2. Verify all prerequisites are installed correctly\n3. Make sure your OpenAI API key is valid and has credits\n4. Check that port 5000 is not blocked by firewall\n\n---\n\n## License\n\nSee LICENSE file for details.\n\n---\n\n**Enjoy automating with AI!** 🤖\n","size_bytes":7614},"app/web_app.py":{"content":"\"\"\"\nFlask Web Application for Browser Automation\nProvides web interface for users to input instructions\n\"\"\"\nfrom flask import Flask, render_template, request, jsonify\nfrom app.mcp_stdio_client import MCPStdioClient\nfrom app.browser_agent import BrowserAgent\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(24)\n\n# Initialize MCP client and agent (using STDIO transport)\nmcp_client = None\nbrowser_agent = None\n\ndef get_mcp_client():\n    \"\"\"Lazy initialization of MCP client\"\"\"\n    global mcp_client, browser_agent\n    if mcp_client is None:\n        mcp_client = MCPStdioClient(headless=True, browser=\"chromium\")\n        browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n@app.route('/')\ndef index():\n    \"\"\"Render main page\"\"\"\n    return render_template('index.html')\n\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_instruction():\n    \"\"\"Execute a browser automation instruction\"\"\"\n    try:\n        data = request.get_json()\n        instruction = data.get('instruction', '').strip()\n        \n        if not instruction:\n            return jsonify({\n                'success': False,\n                'error': 'Please provide an instruction'\n            }), 400\n        \n        # Get or create MCP client\n        _, agent = get_mcp_client()\n        \n        # Execute the instruction\n        result = agent.execute_instruction(instruction)\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/api/tools', methods=['GET'])\ndef get_tools():\n    \"\"\"Get available browser tools\"\"\"\n    try:\n        client, _ = get_mcp_client()\n        \n        if not client.initialized:\n            client.initialize()\n        \n        tools = client.list_tools()\n        \n        return jsonify({\n            'success': True,\n            'tools': tools\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/api/reset', methods=['POST'])\ndef reset_agent():\n    \"\"\"Reset the browser agent\"\"\"\n    try:\n        _, agent = get_mcp_client()\n        agent.reset_conversation()\n        \n        return jsonify({\n            'success': True,\n            'message': 'Agent reset successfully'\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    try:\n        # Check if MCP server is accessible\n        client, _ = get_mcp_client()\n        \n        if not client.initialized:\n            client.initialize()\n        \n        return jsonify({\n            'status': 'healthy',\n            'mcp_connected': True,\n            'transport': 'STDIO'\n        })\n    except Exception as e:\n        return jsonify({\n            'status': 'unhealthy',\n            'mcp_connected': False,\n            'error': str(e)\n        }), 503\n\n\nif __name__ == '__main__':\n    # Bind to 0.0.0.0:5000 for Replit\n    app.run(host='0.0.0.0', port=5000, debug=True)\n","size_bytes":3204},"app/__init__.py":{"content":"# Flask app package\n","size_bytes":20},"app/mcp_stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport subprocess\nimport threading\nimport queue\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = True, browser: str = \"chromium\"):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode\n            browser: Browser to use (chromium, firefox, webkit)\n        \"\"\"\n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        \n        # Start MCP server process\n        args = [\"node\", \"cli.js\", \"--headless\" if headless else \"\", f\"--browser={browser}\"]\n        args = [arg for arg in args if arg]  # Remove empty strings\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            bufsize=1\n        )\n        \n        # Start reader thread\n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        # Give the process a moment to start\n        time.sleep(1)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                line = self.process.stdout.readline()\n                if not line:\n                    break\n                    \n                line = line.strip()\n                if not line:\n                    continue\n                \n                try:\n                    response = json.loads(line)\n                    if \"id\" in response:\n                        # This is a response to a request\n                        req_id = response[\"id\"]\n                        if req_id in self.pending_requests:\n                            self.pending_requests[req_id].put(response)\n                    else:\n                        # This is a notification\n                        self.response_queue.put(response)\n                except json.JSONDecodeError:\n                    # Not JSON, might be log output - ignore\n                    pass\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        # Create queue for this request\n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            # Send request\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            # Wait for response\n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            # Clean up\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=60)  # Longer timeout for tool calls\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":7361},"app/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 16px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\nheader {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 40px;\n    text-align: center;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.subtitle {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.main-content {\n    padding: 40px;\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 40px;\n}\n\n@media (max-width: 768px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n}\n\n.instruction-panel,\n.results-panel {\n    background: #f8f9fa;\n    padding: 30px;\n    border-radius: 12px;\n}\n\n.instruction-panel h2,\n.results-panel h2 {\n    font-size: 1.5rem;\n    margin-bottom: 20px;\n    color: #667eea;\n}\n\n.help-text {\n    color: #666;\n    margin-bottom: 10px;\n}\n\n.examples {\n    list-style: none;\n    margin-bottom: 20px;\n    padding-left: 0;\n}\n\n.examples li {\n    background: white;\n    padding: 10px 15px;\n    margin-bottom: 8px;\n    border-radius: 6px;\n    border-left: 3px solid #667eea;\n    font-size: 0.9rem;\n    color: #555;\n}\n\n#instruction-input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    margin-bottom: 20px;\n    transition: border-color 0.3s;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n}\n\n.button-group {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 12px 30px;\n    border: none;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    flex: 1;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #d0d0d0;\n}\n\n.spinner {\n    width: 16px;\n    height: 16px;\n    border: 2px solid #ffffff;\n    border-top: 2px solid transparent;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.status {\n    padding: 15px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    font-weight: 600;\n    display: none;\n}\n\n.status.success {\n    background: #d4edda;\n    color: #155724;\n    border: 1px solid #c3e6cb;\n    display: block;\n}\n\n.status.error {\n    background: #f8d7da;\n    color: #721c24;\n    border: 1px solid #f5c6cb;\n    display: block;\n}\n\n.status.processing {\n    background: #d1ecf1;\n    color: #0c5460;\n    border: 1px solid #bee5eb;\n    display: block;\n}\n\n.results-container {\n    max-height: 600px;\n    overflow-y: auto;\n}\n\n.step {\n    background: white;\n    padding: 20px;\n    margin-bottom: 15px;\n    border-radius: 8px;\n    border-left: 4px solid #667eea;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    background: #667eea;\n    color: white;\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status {\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d4edda;\n    color: #155724;\n}\n\n.step-status.error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #764ba2;\n    margin-bottom: 8px;\n}\n\n.step-args {\n    background: #f8f9fa;\n    padding: 10px;\n    border-radius: 6px;\n    font-size: 0.9rem;\n    font-family: monospace;\n    margin-top: 8px;\n    overflow-x: auto;\n}\n\n.final-message {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 8px;\n    margin-top: 20px;\n    font-size: 1.1rem;\n}\n\nfooter {\n    background: #f8f9fa;\n    padding: 20px;\n    text-align: center;\n    color: #666;\n    border-top: 1px solid #e0e0e0;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f1f1;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #667eea;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #764ba2;\n}\n","size_bytes":4892},"app/browser_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport os\nimport json\nfrom typing import List, Dict, Any\nfrom openai import OpenAI\nfrom app.mcp_client import MCPClient\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: MCPClient):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        self.mcp_client = mcp_client\n        # the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        self.client = OpenAI(api_key=os.environ.get(\"OPENAI_API_KEY\"))\n        self.model = \"gpt-5\"\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Initialize MCP connection and get available tools\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        # Start conversation\n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                # Call OpenAI with function calling\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,  # type: ignore\n                    tools=tools,  # type: ignore\n                    tool_choice=\"auto\",\n                    max_completion_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                # Check if assistant wants to call tools\n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name  # type: ignore\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                        \n                        # Execute the tool\n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            # Extract useful information from result\n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            # Add tool result to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            # Add error to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    # Assistant has finished\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6196},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nfrom app.web_app import app\n\nif __name__ == '__main__':\n    # Run Flask on port 5000, bound to all interfaces for Replit\n    app.run(host='0.0.0.0', port=5000, debug=False)\n","size_bytes":244},"app/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ instruction }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `Completed in ${data.iterations} iteration(s)`);\n            displayResults(data);\n        } else {\n            showStatus('error', `Error: ${data.error || 'Unknown error'}`);\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to execute: ${error.message}`);\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history.')) {\n        return;\n    }\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', 'Agent reset successfully');\n            resultsDiv.innerHTML = '';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to reset: ${error.message}`);\n    }\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.className = 'final-message';\n        messageEl.textContent = data.message;\n        resultsDiv.appendChild(messageEl);\n    }\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? 'Success' : 'Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.style.color = '#721c24';\n        errorEl.style.marginTop = '10px';\n        errorEl.textContent = `Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            console.log('Application is healthy and connected to MCP server');\n        } else {\n            showStatus('error', 'MCP server is not accessible. Please ensure it is running.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":6388}},"version":2}