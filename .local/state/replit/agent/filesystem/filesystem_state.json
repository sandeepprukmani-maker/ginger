{"file_contents":{"run_agent.py":{"content":"from visionvault.agents.main import main\n\nif __name__ == '__main__':\n    main()","size_bytes":79},"visionvault/agents/socket_client.py":{"content":"import socketio\nimport asyncio\nfrom .config import AGENT_ID, SERVER_URL\nfrom .utils import detect_browsers\n\n\nclass SocketClient:\n    def __init__(self):\n        self.sio = socketio.Client(\n            reconnection=True,\n            reconnection_attempts=100,\n            reconnection_delay=1,\n            reconnection_delay_max=10,\n            request_timeout=30,\n            logger=False,\n            engineio_logger=False\n        )\n        self.setup_events()\n        self.event_loop = None\n\n    def setup_events(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.sio.event\n        def connect():\n            print(f\"‚úÖ Connected to server: {SERVER_URL}\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n            print(f\"üì§ Sent registration with browsers: {available_browsers}\")\n\n        @self.sio.event\n        def disconnect():\n            print(\"‚ö†Ô∏è Disconnected from server - will auto-reconnect...\")\n\n        @self.sio.event\n        def connect_error(data):\n            print(f\"‚ùå Connection error: {data}\")\n            print(\"   Retrying connection...\")\n\n        @self.sio.event\n        def reconnect():\n            print(\"üîÑ Reconnected to server - re-registering...\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n\n        @self.sio.event\n        def agent_registered(data):\n            print(f\"Agent registered successfully: {data}\")\n\n    def connect(self):\n        \"\"\"Connect to the server\"\"\"\n        self.sio.connect(SERVER_URL,\n                         transports=['websocket', 'polling'],\n                         wait_timeout=10)\n\n    def disconnect(self):\n        \"\"\"Disconnect from server\"\"\"\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def emit(self, event, data):\n        \"\"\"Emit an event to server\"\"\"\n        self.sio.emit(event, data)\n\n    def on(self, event, handler):\n        \"\"\"Register event handler\"\"\"\n        self.sio.on(event, handler)\n\n    @property\n    def connected(self):\n        return self.sio.connected","size_bytes":2296},"scripts/run_both.py":{"content":"import subprocess\nimport sys\nimport os\nimport time\n\n# Paths to scripts\nmain_script = os.path.join(os.path.dirname(__file__), 'main.py')\nagent_script = os.path.join(os.path.dirname(__file__), 'local_agent.py')\n\n# Set environment variable for both processes\nenv = os.environ.copy()\nenv['AGENT_SERVER_URL'] = 'http://127.0.0.1:7890'\n\nprocesses = []\n\ntry:\n    # Start main.py\n    p1 = subprocess.Popen([sys.executable, main_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started main.py with PID {p1.pid}\")\n    processes.append((p1, 'main.py'))\n\n    # Start local_agent.py\n    p2 = subprocess.Popen([sys.executable, agent_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started local_agent.py with PID {p2.pid}\")\n    processes.append((p2, 'local_agent.py'))\n\n    # Print output from both processes\n    while True:\n        for proc, name in processes:\n            # Print all available lines from stdout\n            while True:\n                out = proc.stdout.readline()\n                if not out:\n                    break\n                print(f\"[{name}] {out.decode().rstrip()}\")\n            # Print all available lines from stderr\n            while True:\n                err = proc.stderr.readline()\n                if not err:\n                    break\n                print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n        # Check if any process has exited\n        for proc, name in processes[:]:\n            if proc.poll() is not None:\n                print(f\"Process {proc.pid} ({name}) exited.\")\n                # Print any remaining output after exit\n                for out in proc.stdout:\n                    print(f\"[{name}] {out.decode().rstrip()}\")\n                for err in proc.stderr:\n                    print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n                processes.remove((proc, name))\n        if not processes:\n            print(\"All processes exited.\")\n            break\n        time.sleep(0.2)\nexcept KeyboardInterrupt:\n    print(\"Stopping processes...\")\n    for proc, _ in processes:\n        proc.terminate()\n","size_bytes":2108},"visionvault/agents/test_executor.py":{"content":"import asyncio\nfrom .utils import encode_screenshot\n\n\nclass TestExecutor:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n\n    async def execute_test(self, test_id, code, browser_name, mode):\n        \"\"\"Execute a test case\"\"\"\n        headless = mode == 'headless'\n\n        try:\n            self.socket_client.emit('agent_log', {\n                'test_id': test_id,\n                'message': f'Preparing to execute test in {mode} mode...'\n            })\n\n            local_vars = {}\n            exec(code, {}, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('agent_result', {\n                    'test_id': test_id,\n                    'success': False,\n                    'logs': ['Error: run_test missing'],\n                    'screenshot': None\n                })\n                return\n\n            run_test = local_vars['run_test']\n            result = await run_test(browser_name=browser_name, headless=headless)\n\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': result.get('success', False),\n                'logs': result.get('logs', []),\n                'screenshot': screenshot_b64\n            })\n\n            print(f\"Test {test_id} completed: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n        except Exception as e:\n            print(f\"Execution error: {e}\")\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': False,\n                'logs': [str(e)],\n                'screenshot': None\n            })","size_bytes":1717},"replit.md":{"content":"# VisionVault - AI-Powered Browser Automation\n\n## Overview\nVisionVault is an intelligent browser automation platform that uses AI to create, execute, and heal web automation tests. The system leverages Playwright for browser automation and integrates with OpenAI and Google Gemini for intelligent code generation and semantic search capabilities.\n\n## Project Architecture\n\n### Core Components\n- **Web Application** (`visionvault/web/`): Flask-based web server with Socket.IO for real-time communication\n- **Agents** (`visionvault/agents/`): Browser automation agents that connect to the server and execute tests\n- **Services** (`visionvault/services/`): Core automation services including:\n  - Intelligent Planner: Pre-execution analysis and risk assessment\n  - Self-Learning Engine: Learns from past executions to improve success rates\n  - Healing Engine: Automatically fixes failing tests using AI\n  - DOM Inspector: Analyzes web pages for optimal locator selection\n  - Vector Store: Semantic search for similar learned tasks\n- **Core Models** (`visionvault/core/`): Database models and data structures\n\n### Technology Stack\n- **Backend**: Python 3.11, Flask, Flask-SocketIO, Gunicorn\n- **Browser Automation**: Playwright\n- **AI/ML**: OpenAI GPT-4, Google Gemini, scikit-learn, FAISS\n- **Database**: SQLite (development), PostgreSQL ready\n- **Frontend**: Bootstrap 5, vanilla JavaScript\n\n## Setup and Running\n\n### Entry Points\n1. **Web Server**: `python run_server.py` - Starts the Flask web application on port 5000\n2. **Agent**: `python run_agent.py` - Starts the automation agent that connects to the server\n3. **Both**: `python scripts/run_both.py` - Runs both server and agent together\n\n### Required Environment Variables\n- `OPENAI_API_KEY` (optional): For AI code generation and intelligent planning\n- `GEMINI_API_KEY` (optional): For semantic search and embeddings\n- `SESSION_SECRET` (optional): Flask session secret (auto-generated if not set)\n\n### Database\n- Uses SQLite by default (`data/automation.db`)\n- Tables:\n  - `test_history`: Execution history and test results\n  - `learned_tasks`: Persistent learning knowledge base\n  - `task_executions`: Execution feedback loop\n\n## Key Features\n1. **Natural Language to Code**: Convert commands to executable Playwright code\n2. **Self-Healing Tests**: Automatically repair failing tests using multiple strategies\n3. **Intelligent Planning**: Pre-execution analysis to predict and prevent failures\n4. **Learning System**: Continuously improves from past executions\n5. **Recording Sessions**: Capture user interactions to generate automation scripts\n6. **DOM Intelligence**: Real-time page analysis for optimal element selection\n\n## Recent Changes\n- **2025-10-15**: Critical bug fixes and enhancements\n  - **Data Contract Fix**: Fixed schema mismatch between DOMInspector and AdvancedLocatorValidator\n    - DOMInspector now outputs camelCase keys (testId, ariaLabel, tag) matching validator expectations\n    - Added missing 'tag' field to prevent KeyError crashes\n  - **Safe Access Implementation**: AdvancedLocatorValidator now uses .get() for all field access\n    - Prevents crashes when optional fields are missing\n    - Added sensible defaults for all locator strategies\n  - **Multi-Strategy Healing**: Implemented actual parallel strategy execution\n    - Multi-strategy healing now executes on attempt 3 (previously just declared)\n    - Tests multiple healing strategies in parallel and selects the best one\n    - Comprehensive error handling for strategy failures\n  - **Concurrency Fix**: Resolved gevent/asyncio mixing issues\n    - Pure asyncio implementation with proper Event handling\n    - Added result buffering for early agent responses\n    - Thread-safe event signaling with event loop stored at initialization\n  - **Error Handling**: Added comprehensive exception handling\n    - MultiStrategyHealer gracefully handles strategy failures\n    - Safe unpacking of results with fallback mechanisms\n\n- **2025-10-15**: Initial import to Replit environment\n  - Configured Python 3.11 environment\n  - Installed all dependencies via pip\n  - Installed Playwright with Chromium browser\n  - Installed system dependencies for browser automation\n  - Created data directories structure\n  - Set up .gitignore for Python project\n\n## User Preferences\n(No user preferences recorded yet)\n\n## Development Notes\n- The application serves on port 5000 (required for Replit environment)\n- Gunicorn is configured with gevent worker for Socket.IO compatibility\n- The frontend communicates via WebSocket for real-time updates\n- Screenshots and logs are stored in `data/uploads/`\n","size_bytes":4618},"scripts/reindex_tasks.py":{"content":"#!/usr/bin/env python3\n\"\"\"Re-index all learned tasks for semantic search.\"\"\"\n\nimport sys\nimport os\n\n# Add parent directory to path\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom visionvault.core.models import LearnedTask\nfrom visionvault.services.vector_store import SemanticSearch\nimport google.generativeai as genai\n\ndef reindex_all_tasks():\n    \"\"\"Re-index all learned tasks in the vector store.\"\"\"\n    \n    # Check for API key\n    gemini_api_key = os.environ.get('GEMINI_API_KEY')\n    if not gemini_api_key:\n        print(\"‚ùå Error: GEMINI_API_KEY is not set. Please set it to enable semantic search.\")\n        return\n    \n    try:\n        # Initialize semantic search\n        print(\"üîß Initializing semantic search service...\")\n        semantic_search = SemanticSearch(api_key=gemini_api_key)\n        \n        # Clear existing index\n        print(\"üóëÔ∏è  Clearing existing vector index...\")\n        semantic_search.vector_store.clear()\n        \n        # Get all learned tasks\n        print(\"üìö Loading all learned tasks from database...\")\n        tasks = LearnedTask.get_all()\n        \n        if not tasks:\n            print(\"‚ö†Ô∏è  No tasks found in the database.\")\n            return\n        \n        print(f\"Found {len(tasks)} tasks to index\")\n        \n        # Index each task\n        indexed_count = 0\n        for i, task in enumerate(tasks, 1):\n            try:\n                print(f\"[{i}/{len(tasks)}] Indexing task: '{task.task_name}'\")\n                semantic_search.index_task(task)\n                indexed_count += 1\n            except Exception as e:\n                print(f\"  ‚ùå Failed to index task {task.task_id}: {e}\")\n        \n        print(f\"\\n‚úÖ Successfully indexed {indexed_count}/{len(tasks)} tasks!\")\n        print(f\"üìä Vector index now contains {len(semantic_search.vector_store.metadata)} vectors\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error during re-indexing: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == '__main__':\n    print(\"=\" * 60)\n    print(\"Re-indexing Learned Tasks for Semantic Search\")\n    print(\"=\" * 60)\n    reindex_all_tasks()\n","size_bytes":2180},"visionvault/core/__init__.py":{"content":"","size_bytes":0},"visionvault/agents/browser_manager.py":{"content":"class BrowserManager:\n    def __init__(self):\n        self.active_page = None\n        self.active_playwright_instance = None\n        self.widget_injection_complete = None\n\n    async def cleanup_browser(self):\n        \"\"\"Clean up browser resources\"\"\"\n        if self.active_page and hasattr(self.active_page, 'context') and hasattr(self.active_page.context, 'browser'):\n            try:\n                browser = self.active_page.context.browser\n                await browser.close()\n                print(\"‚úÖ Browser closed after healing attempt\")\n            except Exception as e:\n                print(f\"Browser cleanup error: {e}\")\n            finally:\n                self.active_page = None\n\n        if self.active_playwright_instance and hasattr(self.active_playwright_instance, 'stop'):\n            try:\n                await self.active_playwright_instance.stop()\n                print(\"‚úÖ Playwright instance stopped\")\n            except Exception as e:\n                print(f\"Playwright cleanup error: {e}\")\n            finally:\n                self.active_playwright_instance = None\n\n    def set_active_page(self, page):\n        \"\"\"Set the active page for healing operations\"\"\"\n        self.active_page = page\n\n    def set_playwright_instance(self, playwright_instance):\n        \"\"\"Set the active playwright instance\"\"\"\n        self.active_playwright_instance = playwright_instance\n\n    def set_widget_event(self, event):\n        \"\"\"Set the widget injection completion event\"\"\"\n        self.widget_injection_complete = event","size_bytes":1539},"visionvault/agents/main.py":{"content":"import asyncio\nimport time\nfrom .config import AGENT_ID, SERVER_URL\nfrom .socket_client import SocketClient\nfrom .test_executor import TestExecutor\nfrom .healing_engine import HealingEngine\nfrom .recording_session import CodegenRecordingSessionManager\nimport os\n\nclass VisionVaultAgent:\n    def __init__(self):\n        self.socket_client = SocketClient()\n        self.test_executor = TestExecutor(self.socket_client)\n        self.healing_engine = HealingEngine(self.socket_client)\n        self.recording_manager = CodegenRecordingSessionManager(self.socket_client)\n\n        # Set up event handlers\n        self._setup_event_handlers()\n\n    def _setup_event_handlers(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.socket_client.sio.on('execute_on_agent')\n        def handle_execute(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.test_executor.execute_test(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode']\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('start_recording')\n        def handle_start_recording(data):\n            if self.socket_client.event_loop:\n                session_id = data['session_id']\n                start_url = data.get('start_url', '')\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.start_recording_session(\n                        session_id=session_id,\n                        start_url=start_url  # No output_file here\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('execute_healing_attempt')\n        def handle_healing_attempt(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.execute_healing_attempt(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode'],\n                        data.get('attempt', 1),\n                        final_manual_attempt=data.get('final_manual_attempt', False)\n                    ),\n                    self.socket_client.event_loop\n                )\n        \n        @self.socket_client.sio.on('healing_complete')\n        def handle_healing_complete(data):\n            \"\"\"Handle healing completion - close browser and cleanup\"\"\"\n            test_id = data.get('test_id')\n            success = data.get('success', False)\n            reason = data.get('reason', 'unknown')\n            print(f\"\\nüèÅ HEALING COMPLETE for test {test_id}\")\n            print(f\"   Success: {success}\")\n            print(f\"   Reason: {reason}\")\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.cleanup_browser(),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('element_selector_needed')\n        def handle_element_selector_needed(data):\n            mode = data.get('mode', 'headless')\n            if mode == 'headful' and self.healing_engine.active_page and self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.inject_element_selector(\n                        data['test_id'],\n                        data['failed_locator']\n                    ),\n                    self.socket_client.event_loop\n                )\n            else:\n                print(f\"‚ùå Cannot inject widget (mode={mode}, page={'yes' if self.healing_engine.active_page else 'no'})\")\n\n        @self.socket_client.sio.on('stop_recording')\n        def handle_stop_recording(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.stop_recording_session(data['session_id']),\n                    self.socket_client.event_loop\n                )\n\n    async def send_heartbeat(self):\n        while True:\n            try:\n                if self.socket_client.connected:\n                    browser_status = \"available\"\n                    active_sessions = len(getattr(self.recording_manager, 'sessions', {}))\n                    if active_sessions > 0:\n                        browser_status = f\"recording_{active_sessions}_sessions\"\n\n                    self.socket_client.emit('heartbeat', {\n                        'agent_id': AGENT_ID,\n                        'timestamp': time.time(),\n                        'browser_status': browser_status,\n                        'capabilities': {\n                            'recording': True,\n                            'comprehensive_recording': True,\n                            'test_execution': True,\n                            'healing': True\n                        }\n                    })\n                await asyncio.sleep(30)\n            except Exception as e:\n                print(f\"Heartbeat error: {e}\")\n                await asyncio.sleep(30)\n\n    async def initialize_agent(self):\n        try:\n            from .utils import detect_browsers\n            self.socket_client.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': detect_browsers(),\n                'capabilities': {\n                    'recording': True,\n                    'comprehensive_recording': True,\n                    'test_execution': True,\n                    'healing': True,\n                    'event_types': [\n                        'click', 'input', 'keypress', 'navigation',\n                        'form_submit', 'network_request', 'network_response',\n                        'console', 'page_error', 'page_created'\n                    ]\n                },\n                'status': 'ready'\n            })\n            print(\"‚úÖ Agent registered with comprehensive recording capabilities\")\n        except Exception as e:\n            print(f\"‚ùå Agent initialization failed: {e}\")\n\n    def run(self):\n        print(\"=\" * 60)\n        print(\"  VisionVault Browser Automation Agent\")\n        print(\"=\" * 60)\n        print(f\"  Agent ID: {AGENT_ID}\")\n        print(f\"  Server URL: {SERVER_URL}\")\n        print()\n\n        try:\n            print(\"Connecting to server...\")\n            self.socket_client.connect()\n            print(\"Connection established! Initializing agent...\")\n\n            self.socket_client.event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.socket_client.event_loop)\n\n            self.socket_client.event_loop.run_until_complete(self.initialize_agent())\n            self.socket_client.event_loop.create_task(self.send_heartbeat())\n\n            print(\"‚úÖ Agent ready! Waiting for tasks...\\n\")\n            self.socket_client.event_loop.run_forever()\n\n        except KeyboardInterrupt:\n            print(\"\\nüõë Shutting down agent...\")\n            try:\n                for session_id in list(getattr(self.recording_manager, 'sessions', {}).keys()):\n                    print(f\"üõë Stopping recording session: {session_id}\")\n                    asyncio.run_coroutine_threadsafe(\n                        self.recording_manager.stop_recording_session(session_id),\n                        self.socket_client.event_loop\n                    )\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Error stopping recordings: {e}\")\n\n            self.socket_client.disconnect()\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n        except Exception as e:\n            print(f\"‚ùå Connection error: {e}\")\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n\ndef main():\n    agent = VisionVaultAgent()\n    agent.run()\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":8008},"scripts/port_terminator.py":{"content":"import psutil\nfrom typing import List\n\ndef terminate_ports(ports: List[int]):\n    \"\"\"\n    Terminates all processes using the specified ports.\n    Args:\n        ports (List[int]): List of port numbers to terminate connections for.\n    \"\"\"\n    for port in ports:\n        found = False\n        for conn in psutil.net_connections(kind='inet'):\n            if conn.laddr.port == port:\n                found = True\n                pid = conn.pid\n                if pid:\n                    try:\n                        p = psutil.Process(pid)\n                        print(f\"Terminating process {pid} on port {port}...\")\n                        p.terminate()\n                        p.wait(timeout=3)\n                        print(f\"Process {pid} terminated.\")\n                    except Exception as e:\n                        print(f\"Error terminating process {pid} on port {port}: {e}\")\n                else:\n                    print(f\"No PID found for connection on port {port}.\")\n        if not found:\n            print(f\"No process found using port {port}.\")\n\nif __name__ == \"__main__\":\n    # Example usage: terminate ports 8080 and 5000\n    terminate_ports([7890, 5000])\n\n","size_bytes":1174},"visionvault/services/healing_executor.py":{"content":"import asyncio\nimport json\nimport re\nfrom visionvault.services.code_validator import CodeValidator\nfrom openai import OpenAI\nimport os\n\n# Import advanced locator validator\ntry:\n    from visionvault.services.advanced_locator_validator import AdvancedLocatorValidator\n    ADVANCED_VALIDATOR_AVAILABLE = True\nexcept ImportError:\n    ADVANCED_VALIDATOR_AVAILABLE = False\n    print(\"‚ö†Ô∏è  Advanced locator validator not available\")\n\n# Import multi-strategy healer\ntry:\n    from visionvault.services.multi_strategy_healer import MultiStrategyHealer\n    MULTI_STRATEGY_HEALER_AVAILABLE = True\nexcept ImportError:\n    MULTI_STRATEGY_HEALER_AVAILABLE = False\n    print(\"‚ö†Ô∏è  Multi-strategy healer not available\")\n\nclass HealingExecutor:\n    def __init__(self, socketio, api_key=None, use_gpt4o=False):\n        self.socketio = socketio\n        # Use provided API key or fallback to environment variable\n        openai_key = api_key or os.environ.get('OPENAI_API_KEY')\n        self.client = OpenAI(api_key=openai_key) if openai_key else None\n        self.healed_script = None\n        self.failed_locators = []\n        self.retry_count = 0\n        self.max_retries = 2  # AI healing attempts before manual intervention\n        self.user_selector_event = None\n        self.user_selected_selector = None\n        self.execution_mode = 'server'  # 'server' or 'agent'\n        self.agent_result = None\n        self.agent_result_event = None  # Will be created at first async call\n        self.agent_sid = None  # Agent session ID for targeted emits\n        self.event_loop = None  # Store event loop reference\n        self._pending_agent_result = None  # Buffer for early results before event loop ready\n        \n        # GPT-4o usage is DECOUPLED from validator availability\n        # Always use GPT-4o for better accuracy (not conditional)\n        self.use_gpt4o = use_gpt4o\n        \n        # Advanced validator is OPTIONAL and independent of GPT-4o\n        self.use_advanced_validator = ADVANCED_VALIDATOR_AVAILABLE\n        self.advanced_validator = None  # Will be initialized when page is available\n        \n        # Multi-strategy healer is OPTIONAL and independent of GPT-4o\n        self.use_multi_strategy = MULTI_STRATEGY_HEALER_AVAILABLE\n        if self.use_multi_strategy and self.client:\n            self.multi_strategy_healer = MultiStrategyHealer(openai_client=self.client)\n        else:\n            self.multi_strategy_healer = None\n        \n        # AI healing request tracking (set by handle_ai_healing_request)\n        self.ai_healing_requested = False\n        self.error_context = None\n        \n        # Log configuration\n        features = []\n        if self.use_gpt4o:\n            features.append(\"GPT-4o\")\n        if self.use_advanced_validator:\n            features.append(\"Advanced Validator\")\n        if self.use_multi_strategy:\n            features.append(\"Multi-Strategy Healing\")\n        \n        features_str = \" + \".join(features) if features else \"GPT-4o-mini\"\n        print(f\"‚úÖ Enhanced AI healing enabled ({features_str} + 2 attempts)\")\n        \n    def parse_code_steps(self, code):\n        \"\"\"Parse code to extract individual steps with their line numbers.\"\"\"\n        steps = []\n        lines = code.split('\\n')\n        current_step = None\n        current_step_lines = []\n        \n        for i, line in enumerate(lines):\n            # Check for STEP comment markers\n            if '# STEP' in line and ':' in line:\n                # Save previous step if exists\n                if current_step is not None and current_step_lines:\n                    steps.append({\n                        'step_num': current_step,\n                        'lines': current_step_lines.copy(),\n                        'start_line': current_step_lines[0][0] if current_step_lines else i,\n                        'end_line': current_step_lines[-1][0] if current_step_lines else i\n                    })\n                \n                # Extract step number\n                try:\n                    step_match = re.search(r'STEP\\s+(\\d+)', line)\n                    if step_match:\n                        current_step = int(step_match.group(1))\n                        current_step_lines = [(i, line)]\n                except:\n                    pass\n            elif current_step is not None:\n                # Add line to current step\n                current_step_lines.append((i, line))\n        \n        # Save last step\n        if current_step is not None and current_step_lines:\n            steps.append({\n                'step_num': current_step,\n                'lines': current_step_lines.copy(),\n                'start_line': current_step_lines[0][0],\n                'end_line': current_step_lines[-1][0]\n            })\n        \n        return steps\n    \n    def extract_page_locators(self, page_html, max_length=3000):\n        \"\"\"Extract available locators from page HTML for AI analysis.\"\"\"\n        import re\n        \n        # Extract elements with useful locator attributes\n        locators = []\n        \n        # Find elements with data-testid\n        test_ids = re.findall(r'data-testid=\"([^\"]+)\"', page_html)\n        for tid in test_ids[:10]:  # Limit to 10\n            locators.append(f\"get_by_test_id('{tid}')\")\n        \n        # Find elements with placeholder\n        placeholders = re.findall(r'placeholder=\"([^\"]+)\"', page_html)\n        for ph in placeholders[:10]:\n            locators.append(f\"get_by_placeholder('{ph}')\")\n        \n        # Find elements with aria-label\n        aria_labels = re.findall(r'aria-label=\"([^\"]+)\"', page_html)\n        for al in aria_labels[:10]:\n            locators.append(f\"get_by_label('{al}')\")\n        \n        # Find buttons with text\n        button_texts = re.findall(r'<button[^>]*>([^<]+)</button>', page_html)\n        for bt in button_texts[:10]:\n            if bt.strip():\n                locators.append(f\"get_by_role('button', name='{bt.strip()}')\")\n        \n        # Find links with text\n        link_texts = re.findall(r'<a[^>]*>([^<]+)</a>', page_html)\n        for lt in link_texts[:10]:\n            if lt.strip() and len(lt.strip()) > 2:\n                locators.append(f\"get_by_role('link', name='{lt.strip()}')\")\n        \n        # Find input fields with name or id\n        input_names = re.findall(r'<input[^>]*(?:name|id)=\"([^\"]+)\"[^>]*>', page_html)\n        for inp in input_names[:10]:\n            locators.append(f\"get_by_role('textbox', name='{inp}')\")\n        \n        return locators[:30]  # Return top 30 locators\n    \n    def regenerate_failed_step_only(self, original_code, error_message, failed_step=0, attempt_num=1, page_context=''):\n        \"\"\"Use AI to regenerate ONLY the failed step, preserving successful ones.\"\"\"\n        if not self.client or failed_step == 0:\n            return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n        \n        try:\n            print(f\"\\nüéØ STEP-BY-STEP HEALING (Attempt {attempt_num}/3)\")\n            print(f\"   Targeting STEP {failed_step} only\")\n            print(f\"   Preserving all successful steps\")\n            \n            # Parse code to find the failed step\n            steps = self.parse_code_steps(original_code)\n            failed_step_content = None\n            \n            for step in steps:\n                if step['step_num'] == failed_step:\n                    failed_step_content = '\\n'.join([line[1] for line in step['lines']])\n                    break\n            \n            if not failed_step_content:\n                print(f\"‚ö†Ô∏è Could not isolate step {failed_step}, falling back to full regeneration\")\n                return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n            \n            # Extract available locators from page if context provided\n            available_locators = []\n            if page_context:\n                available_locators = self.extract_page_locators(page_context)\n                print(f\"   üìä Found {len(available_locators)} available locators on page\")\n            \n            locators_hint = \"\"\n            if available_locators:\n                locators_hint = f\"\"\"\n\nAVAILABLE LOCATORS ON PAGE (use these if they match your target):\n{chr(10).join([f\"- {loc}\" for loc in available_locators[:15]])}\"\"\"\n            \n            # ALWAYS use GPT-4o for better accuracy (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at fixing specific Playwright automation steps by analyzing the actual page.\n\nYour job is to fix ONLY the failed step while preserving all other steps exactly as they are.\n\nCRITICAL RULES:\n1. Analyze the available locators from the page and choose the best match\n2. Return ONLY the fixed code for the specific step mentioned\n3. Use better locators (get_by_role, get_by_text, get_by_placeholder, get_by_label, etc.)\n4. Add explicit timeouts (10000ms) to all operations for reliability\n5. Add proper wait strategies (wait_for_load_state, wait_for_selector with visible state)\n6. Maintain the step number and structure\n7. Keep the same log messages format\n8. Return ONLY the replacement code lines, nothing else\n\nLOCATOR PRIORITY (prefer in this order):\n1. get_by_test_id (most reliable - 99% success rate)\n2. get_by_role with exact name (accessibility-first - 95% success rate)\n3. get_by_placeholder with exact match (for inputs - 90% success rate)\n4. get_by_label (for form fields - 85% success rate)\n5. get_by_text with exact match (for unique text - 80% success rate)\n6. CSS selectors with IDs (last resort - 70% success rate)\n\nBEST PRACTICES:\n- Always add .wait_for(state='visible', timeout=10000) before interacting\n- Use exact=True for text/name matches when possible\n- Combine multiple strategies (e.g., role + filter by text)\n- Add error handling for dynamic content\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"This specific step failed during execution:\n\nFAILED STEP {failed_step}:\n```python\n{failed_step_content}\n```\n\nError: {error_message}{locators_hint}\n\nAnalyze the available locators above and generate ONLY the fixed code for STEP {failed_step}. Include:\n1. The # STEP {failed_step}: comment\n2. The current_step = {failed_step} line\n3. The fixed Playwright operations with better locators from the page\n4. The success log message\n\nReturn only the replacement code for this step:\"\"\"}\n                ],\n                temperature=0.3,\n                max_tokens=1000\n            )\n            \n            fixed_step = response.choices[0].message.content.strip()\n            \n            # Clean up formatting\n            if fixed_step.startswith('```'):\n                lines = fixed_step.split('\\n')\n                fixed_step = '\\n'.join(lines[1:-1] if lines[-1].startswith('```') else lines[1:])\n            \n            # Replace the failed step in the original code\n            lines = original_code.split('\\n')\n            for step in steps:\n                if step['step_num'] == failed_step:\n                    # Replace lines\n                    start = step['start_line']\n                    end = step['end_line'] + 1\n                    fixed_lines = fixed_step.split('\\n')\n                    lines[start:end] = fixed_lines\n                    break\n            \n            improved_code = '\\n'.join(lines)\n            \n            if 'async def run_test' in improved_code:\n                print(f\"‚úÖ Fixed STEP {failed_step}, preserved all other steps\")\n                return improved_code\n            else:\n                print(f\"‚ö†Ô∏è Step fix invalid, falling back to full regeneration\")\n                return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n                \n        except Exception as e:\n            print(f\"‚ùå Step-by-step healing error: {e}\")\n            return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n\n    def regenerate_code_with_ai(self, original_code, error_message, failed_step=0, attempt_num=1, error_type='unknown'):\n        \"\"\"Use AI to regenerate improved code based on execution failure.\"\"\"\n        if not self.client:\n            print(\"‚ö†Ô∏è OpenAI client not available, cannot regenerate code\")\n            return original_code\n            \n        try:\n            print(f\"\\nü§ñ AI CODE REGENERATION (Attempt {attempt_num}/{self.max_retries})\")\n            print(f\"   Error type: {error_type}\")\n            print(f\"   Failed at step: {failed_step}\")\n            print(f\"   Error: {error_message[:200]}...\")\n            print(f\"   Using model: {'GPT-4o' if self.use_gpt4o else 'GPT-4o-mini'}\")\n            \n            # ALWAYS use GPT-4o for better accuracy (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            # Determine if this is a locator-related error or not\n            is_locator_error = error_type in ['locator_not_found', 'timeout', 'element_not_found', 'multiple_matches']\n            \n            if is_locator_error:\n                # For locator errors: Focus on improving the failed locator\n                fix_focus = \"\"\"1. Better locator for the failed step (more specific, robust, or alternative strategy)\n2. Appropriate waits and timeouts for that specific step\n3. Maintaining all other steps and their locators EXACTLY as they are\n4. Keeping the same return structure\"\"\"\n            else:\n                # For non-locator errors (API misuse, general errors): Preserve ALL locators\n                fix_focus = f\"\"\"1. Fix the {error_type} issue (API usage, syntax, logic error, etc.)\n2. PRESERVE ALL EXISTING LOCATORS - do NOT change any locator unless it's directly related to the error\n3. Add appropriate error handling or waits if needed\n4. Maintain all steps unchanged except for the specific code issue\n5. Keep the same return structure\n\n‚ö†Ô∏è CRITICAL: This is NOT a locator error - do NOT modify working locators!\"\"\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at debugging and fixing Playwright automation code.\n\nWhen code fails, you MUST:\n1. Analyze the error message to understand what went wrong\n2. Identify the problematic step and the root cause\n3. Generate improved code with targeted fixes\n4. Maintain the same overall structure and step numbering\n5. Add explicit timeouts (5000ms) to LOCATOR action methods only (click, fill, locator.press, etc.)\n   NEVER add timeout to: locator() calls, page.keyboard.press(), page.mouse methods\n   Examples:\n   ‚úÖ CORRECT: await page.get_by_role(\"button\").click(timeout=5000)\n   ‚úÖ CORRECT: await page.keyboard.press(\"Enter\")  # NO timeout!\n   ‚ùå WRONG: await page.keyboard.press(\"Enter\", timeout=5000)\n6. Use robust locator strategies (text content, role-based, data-testid) when changing locators\n7. Add appropriate waits before interactions if timing issues detected\n\nCRITICAL: Return ONLY the complete improved function code, no explanations.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"This Playwright code failed during execution:\n\n```python\n{original_code}\n```\n\nError type: {error_type}\nError occurred at STEP {failed_step}:\n{error_message}\n\nGenerate the COMPLETE improved code with fixes. Focus on:\n{fix_focus}\n\nReturn only the improved Python code:\"\"\"}\n                ],\n                temperature=0.3,\n                max_tokens=2000\n            )\n            \n            improved_code = response.choices[0].message.content.strip()\n            \n            # Clean up code formatting\n            if improved_code.startswith('```python'):\n                improved_code = improved_code[9:]\n            elif improved_code.startswith('```'):\n                improved_code = improved_code[3:]\n            if improved_code.endswith('```'):\n                improved_code = improved_code[:-3]\n            \n            improved_code = improved_code.strip()\n            \n            if improved_code and 'async def run_test' in improved_code:\n                print(f\"‚úÖ AI generated improved code ({len(improved_code)} chars)\")\n                return improved_code\n            else:\n                print(f\"‚ö†Ô∏è AI response invalid, using original code\")\n                return original_code\n                \n        except Exception as e:\n            print(f\"‚ùå AI code regeneration error: {e}\")\n            return original_code\n    \n    def improve_locator_with_ai(self, failed_locator, error_message, page_html_snippet=''):\n        \"\"\"Use AI to suggest better locator strategies.\"\"\"\n        try:\n            # ALWAYS use GPT-4o for better locator suggestions (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at web automation and CSS/XPath selectors.\nWhen a locator fails, suggest better, more robust alternatives. Consider:\n1. Using text content locators when possible\n2. Using data-testid or aria-labels\n3. Using role-based selectors\n4. Creating more specific CSS selectors\n5. Using XPath as last resort\n\nReturn ONLY the improved locator string, nothing else.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed locator: {failed_locator}\nError: {error_message}\nPage context: {page_html_snippet[:500] if page_html_snippet else 'Not available'}\n\nSuggest a better locator:\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            improved = response.choices[0].message.content.strip()\n            if improved.startswith('```'):\n                improved = improved.split('\\n')[1]\n            if improved.endswith('```'):\n                improved = improved.rsplit('\\n', 1)[0]\n                \n            return improved.strip('\"\\'')\n        except Exception as e:\n            print(f\"AI locator improvement error: {e}\")\n            return failed_locator\n    \n    def heal_script(self, original_code, failed_locator, healed_locator):\n        \"\"\"Replace failed locator with healed one in the script.\"\"\"\n        print(f\"\\nüîß HEALING SCRIPT:\")\n        print(f\"  Failed locator: '{failed_locator}'\")\n        print(f\"  Healed locator: '{healed_locator}'\")\n        print(f\"  Searching for '{failed_locator}' in code...\")\n        print(f\"  Found: {failed_locator in original_code}\")\n        \n        healed = original_code.replace(failed_locator, healed_locator)\n        self.healed_script = healed\n        \n        print(f\"  Replacement successful: {healed != original_code}\")\n        if healed != original_code:\n            print(f\"  Code changed from {len(original_code)} to {len(healed)} chars\")\n        else:\n            print(f\"  ‚ö†Ô∏è  WARNING: Code unchanged after replacement!\")\n        \n        return healed\n    \n    async def wait_for_user_selector(self, timeout=300):\n        \"\"\"Wait for user to select an element interactively.\"\"\"\n        self.user_selector_event = asyncio.Event()\n        self.user_selected_selector = None\n        \n        try:\n            await asyncio.wait_for(self.user_selector_event.wait(), timeout=timeout)\n            return self.user_selected_selector\n        except asyncio.TimeoutError:\n            return None\n    \n    def set_user_selector(self, selector):\n        \"\"\"Called when user selects an element.\"\"\"\n        self.user_selected_selector = selector\n        if self.user_selector_event:\n            self.user_selector_event.set()\n    \n    def set_agent_result(self, result):\n        \"\"\"Called when agent returns result - can be called from any thread.\"\"\"\n        self.agent_result = result\n        \n        # Try to set the event in a thread-safe way\n        if self.agent_result_event and self.event_loop:\n            try:\n                # Use the stored event loop to set the event thread-safely\n                self.event_loop.call_soon_threadsafe(self.agent_result_event.set)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è  Error setting agent result event: {e}\")\n        else:\n            # Buffer the result - it arrived before the event loop was initialized\n            # This will be picked up when _execute_on_agent checks\n            self._pending_agent_result = result\n            print(f\"üì¶ Buffered agent result (event loop not ready yet)\")\n\n    async def _execute_on_agent(self, code, browser_name, headless, test_id, attempt_num, logs):\n        \"\"\"Execute code on agent and wait for result.\"\"\"\n        import base64\n\n        # Store event loop reference and create event if not already done\n        if not self.event_loop:\n            self.event_loop = asyncio.get_event_loop()\n        \n        if not self.agent_result_event:\n            self.agent_result_event = asyncio.Event()\n        \n        # Check if we have a pending result that arrived before event loop was ready\n        if self._pending_agent_result:\n            print(f\"üì¶ Using buffered agent result\")\n            self.agent_result = self._pending_agent_result\n            self._pending_agent_result = None\n            self.agent_result_event.set()  # Signal immediately\n        else:\n            # Reset event and result for this execution\n            self.agent_result_event.clear()\n            self.agent_result = None\n\n        # For headful mode, use modified code that keeps browser open\n        execution_code = code\n        if not headless:\n            # Add a small delay to ensure browser is ready for widget injection\n            execution_code = code.replace(\n                \"async def run_test(browser_name='chromium', headless=True):\",\n                \"async def run_test(browser_name='chromium', headless=True):\\n    import asyncio\\n    await asyncio.sleep(1)  # Ensure browser is ready\"\n            )\n\n        # Emit execution request to agent (targeted to specific agent)\n        mode = 'headless' if headless else 'headful'\n        if self.agent_sid:\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            }, to=self.agent_sid)\n        else:\n            # Fallback to broadcast if no specific agent\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            })\n\n        # Wait for agent result using asyncio Event (pure asyncio - no gevent mixing)\n        timeout = 180 if not headless else 120  # 3 minutes for headful, 2 for headless\n        \n        try:\n            # Wait for the event to be set (with timeout)\n            await asyncio.wait_for(self.agent_result_event.wait(), timeout=timeout)\n            result = self.agent_result\n        except asyncio.TimeoutError:\n            return {\n                'success': False,\n                'logs': logs + [f'‚ùå Agent execution timeout ({timeout}s)'],\n                'screenshot': None,\n                'can_heal': False\n            }\n        if not result:\n            return {\n                'success': False,\n                'logs': logs + ['‚ùå No result from agent'],\n                'screenshot': None,\n                'can_heal': False\n            }\n        \n        # Decode screenshot if present\n        screenshot = None\n        if result.get('screenshot'):\n            try:\n                screenshot = base64.b64decode(result['screenshot'])\n            except:\n                pass\n        \n        logs.extend(result.get('logs', []))\n        \n        if result.get('success'):\n            logs.append(\"‚úÖ Execution completed successfully\")\n            return {\n                'success': True,\n                'logs': logs,\n                'screenshot': screenshot\n            }\n        else:\n            # Extract failed locator and step from error\n            error_msg = ' '.join(result.get('logs', []))\n            failed_locator = self.extract_failed_locator(error_msg)\n            failed_step = self.extract_failed_step(error_msg)\n            \n            if failed_locator:\n                self.failed_locators.append({\n                    'locator': failed_locator,\n                    'error': error_msg,\n                    'attempt': attempt_num + 1,\n                    'step': failed_step\n                })\n                \n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': True,\n                    'failed_locator': failed_locator,\n                    'failed_step': failed_step,\n                    'error_message': error_msg,\n                    'page_content': ''\n                }\n            else:\n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': False\n                }\n    \n    async def execute_with_healing(self, code, browser_name, headless, test_id):\n        \"\"\"Execute code with advanced AI-guided healing and retry on failures.\n        \n        Each failed step gets up to 3 AI-guided retry attempts before user intervention.\n        \"\"\"\n        validator = CodeValidator()\n        if not validator.validate(code):\n            return {\n                'success': False,\n                'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                'screenshot': None,\n                'healed_script': None\n            }\n        \n        self.healed_script = code\n        current_code = code\n        result = {'success': False, 'logs': [], 'screenshot': None}\n        all_logs = []  # Accumulate logs across all attempts\n        \n        for attempt in range(self.max_retries):\n            result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt)\n            \n            # Accumulate logs from this attempt\n            if result.get('logs'):\n                all_logs.extend(result['logs'])\n            \n            if result['success']:\n                final_result = {\n                    'success': True,\n                    'logs': all_logs,  # Return all accumulated logs\n                    'screenshot': result['screenshot'],\n                    'healed_script': self.healed_script if self.healed_script != code else None,\n                    'failed_locators': self.failed_locators\n                }\n                \n                if self.failed_locators:\n                    await self.report_failures_to_ai(test_id)\n                    final_result['logs'].append(\"üìä AI analysis complete - check insights for improvement recommendations\")\n                \n                return final_result\n            \n            if not result.get('can_heal'):\n                result['logs'] = all_logs  # Return accumulated logs even on failure\n                return result\n            \n            # Extract error details BEFORE any processing (needed for both healing paths)\n            error_message = result.get('error_message', '')\n            failed_step = result.get('failed_step', 0)  # Get from result, fallback to 0\n            failed_locator = result.get('failed_locator')\n            \n            import sys\n            print(f\"\\nüîç HEALING ATTEMPT {attempt + 1}/{self.max_retries}:\", flush=True)\n            print(f\"   Failed step: {failed_step}\", flush=True)\n            print(f\"   Failed locator: {failed_locator}\", flush=True)\n            print(f\"   Mode: {'headful' if not headless else 'headless'}\", flush=True)\n            sys.stdout.flush()\n            \n            # Add log entry for this attempt\n            all_logs.append(f\"\\nüîÑ Attempt {attempt + 1}/{self.max_retries}: Healing failed step {failed_step} with locator: {failed_locator}\")\n            \n            # CHECK FOR AI HEALING REQUEST (from agent's request_ai_healing event)\n            if self.ai_healing_requested and self.error_context:\n                error_type = self.error_context.get('error_type', 'unknown')\n                print(f\"\\nü§ñ AI HEALING REQUEST DETECTED:\", flush=True)\n                print(f\"   Error type: {error_type}\", flush=True)\n                print(f\"   Regenerating code with AI...\", flush=True)\n                \n                # Use error context from the request, with safe fallback\n                error_detail = self.error_context.get('error_info', {}).get('detail', '') or error_message or 'Unknown error'\n                \n                # Regenerate entire code with AI based on error\n                # Pass error type to help AI know whether to preserve locators\n                regenerated_code = self.regenerate_code_with_ai(\n                    current_code, \n                    error_detail, \n                    failed_step, \n                    attempt + 1,\n                    error_type=error_type\n                )\n                \n                if regenerated_code != current_code:\n                    current_code = regenerated_code\n                    self.healed_script = regenerated_code\n                    all_logs.append(f\"‚úÖ AI regenerated complete code based on error analysis\")\n                    print(f\"   ‚úÖ Code regenerated successfully ({len(regenerated_code)} chars)\", flush=True)\n                    \n                    self.socketio.emit('script_healed', {\n                        'test_id': test_id,\n                        'healed_script': current_code,\n                        'failed_locator': failed_locator or '',\n                        'healed_locator': 'AI regenerated',\n                        'attempt': attempt + 1,\n                        'method': 'ai_healing_request'\n                    })\n                else:\n                    print(f\"   ‚ö†Ô∏è AI regeneration produced same code\", flush=True)\n                \n                # Reset the flag\n                self.ai_healing_requested = False\n                self.error_context = None\n                \n                # Continue to next attempt with regenerated code\n                continue\n            \n            # ENHANCED AI-GUIDED RETRY STRATEGY\n            # Attempts 1-2: Step-by-step healing\n            # Attempt 3: Multi-strategy parallel healing (if available)\n            # Attempt 4: Advanced locator validation\n            # Attempt 5: User intervention (only as last resort)\n            \n            if attempt < 4:  # First 4 attempts: Automated AI healing\n                healing_mode = \"Enhanced (GPT-4o)\" if self.use_gpt4o else \"Standard (GPT-4o-mini)\"\n                if attempt == 2 and self.use_multi_strategy:\n                    healing_mode = \"Multi-Strategy Parallel Healing\"\n                elif self.use_advanced_validator:\n                    healing_mode += \" + Validator\"\n                all_logs.append(f\"ü§ñ AI Retry {attempt + 1}/4: {healing_mode}...\")\n                \n                # Get page content for analysis\n                page_content = result.get('page_content', '')\n                if page_content:\n                    all_logs.append(f\"üìä Captured page context ({len(page_content)} chars) for locator analysis\")\n                \n                # CRITICAL FIX: Actually execute multi-strategy healing on attempt 3 (index 2)\n                if attempt == 2 and self.use_multi_strategy and self.multi_strategy_healer:\n                    all_logs.append(f\"üöÄ Activating Multi-Strategy Parallel Healing...\")\n                    \n                    # Define async executor function for strategies\n                    async def execute_strategy_code(strategy_code):\n                        return await self._execute_single_attempt(strategy_code, browser_name, headless, test_id, attempt)\n                    \n                    # Execute multi-strategy healing\n                    multi_result = await self.multi_strategy_healer.heal_with_parallel_strategies(\n                        current_code,\n                        error_message,\n                        failed_step,\n                        page_content,\n                        execute_strategy_code\n                    )\n                    \n                    if multi_result.get('success'):\n                        healed_code = multi_result.get('healed_code')\n                        if healed_code:\n                            current_code = healed_code\n                            self.healed_script = healed_code\n                            strategy_name = multi_result.get('strategy_used', 'Unknown')\n                            all_logs.append(f\"‚úÖ Multi-strategy healing succeeded with: {strategy_name}\")\n                            \n                            self.socketio.emit('script_healed', {\n                                'test_id': test_id,\n                                'healed_script': current_code,\n                                'failed_locator': failed_locator or '',\n                                'healed_locator': f'Multi-strategy: {strategy_name}',\n                                'attempt': attempt + 1,\n                                'method': 'multi_strategy_healing'\n                            })\n                            continue  # Skip to next iteration with healed code\n                        else:\n                            all_logs.append(f\"‚ö†Ô∏è Multi-strategy healing succeeded but no healed code returned\")\n                    else:\n                        all_logs.append(f\"‚ö†Ô∏è All multi-strategies failed, falling back to step-by-step healing\")\n                \n                # Try step-by-step healing (for attempts 1, 2, 4, or if multi-strategy failed)\n                regenerated_code = self.regenerate_failed_step_only(\n                    current_code, \n                    error_message, \n                    failed_step, \n                    attempt + 1,\n                    page_content\n                )\n                \n                if regenerated_code != current_code:\n                    current_code = regenerated_code\n                    self.healed_script = regenerated_code\n                    all_logs.append(f\"‚úÖ Fixed STEP {failed_step}, all other steps preserved\")\n                    \n                    self.socketio.emit('script_healed', {\n                        'test_id': test_id,\n                        'healed_script': current_code,\n                        'failed_locator': failed_locator or '',\n                        'healed_locator': f'Step {failed_step} fixed',\n                        'attempt': attempt + 1,\n                        'method': 'step_by_step_healing'\n                    })\n                else:\n                    # Fallback to locator improvement if step regeneration failed\n                    all_logs.append(f\"‚ö†Ô∏è Step healing unchanged, trying locator improvement...\")\n                    if failed_locator:\n                        improved_locator = self.improve_locator_with_ai(\n                            failed_locator, \n                            error_message,\n                            result.get('page_content', '')\n                        )\n                        current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                        all_logs.append(f\"üîß Trying improved locator: {failed_locator} ‚Üí {improved_locator}\")\n                \n            # Final attempt (5th): Show user widget in headful mode as last resort\n            elif attempt >= 4:  # 5th attempt: User intervention only as last resort\n                if failed_locator:\n                    improved_locator = None\n                    \n                    if not headless:\n                        # User widget intervention\n                        mode = 'headful' if not headless else 'headless'\n                        print(f\"üîî SERVER: Emitting element_selector_needed (final attempt) for test {test_id}\", flush=True)\n                        sys.stdout.flush()\n                        \n                        all_logs.append(f\"üëÜ Final attempt: Requesting user help to locate element...\")\n                        \n                        if self.agent_sid:\n                            self.socketio.emit('element_selector_needed', {\n                                'test_id': test_id,\n                                'failed_locator': failed_locator,\n                                'failed_step': failed_step,\n                                'error': error_message,\n                                'attempt': attempt + 1,\n                                'mode': mode\n                            }, to=self.agent_sid)\n                        else:\n                            self.socketio.emit('element_selector_needed', {\n                                'test_id': test_id,\n                                'failed_locator': failed_locator,\n                                'failed_step': failed_step,\n                                'error': error_message,\n                                'attempt': attempt + 1,\n                                'mode': mode\n                            })\n                        \n                        user_selector = await self.wait_for_user_selector(timeout=300)\n                        \n                        if user_selector:\n                            improved_locator = user_selector\n                            print(f\"\\n‚úÖ USER SELECTED: '{improved_locator}'\", flush=True)\n                            all_logs.append(f\"‚úÖ User selected element: {improved_locator}\")\n                        else:\n                            all_logs.append(f\"‚è±Ô∏è User selection timeout, final AI attempt...\")\n                            improved_locator = self.improve_locator_with_ai(\n                                failed_locator, \n                                error_message,\n                                result.get('page_content', '')\n                            )\n                            all_logs.append(f\"ü§ñ Final AI suggestion: {improved_locator}\")\n                    else:\n                        # Headless mode: Final AI attempt\n                        all_logs.append(f\"ü§ñ Final AI retry in headless mode...\")\n                        improved_locator = self.improve_locator_with_ai(\n                            failed_locator, \n                            error_message,\n                            result.get('page_content', '')\n                        )\n                        all_logs.append(f\"üîß Trying final locator: {failed_locator} ‚Üí {improved_locator}\")\n                    \n                    if improved_locator:\n                        current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                        self.healed_script = current_code\n                        \n                        self.socketio.emit('script_healed', {\n                            'test_id': test_id,\n                            'healed_script': current_code,\n                            'failed_locator': failed_locator,\n                            'healed_locator': improved_locator,\n                            'attempt': attempt + 1,\n                            'method': 'user_selection' if not headless else 'final_ai'\n                        })\n                        \n                        # Execute the healed code immediately (final attempt after user help)\n                        all_logs.append(f\"üîÑ Re-executing with user-provided locator...\")\n                        final_result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt + 1)\n                        \n                        if final_result.get('logs'):\n                            all_logs.extend(final_result['logs'])\n                        \n                        if final_result['success']:\n                            return {\n                                'success': True,\n                                'logs': all_logs,\n                                'screenshot': final_result['screenshot'],\n                                'healed_script': self.healed_script,\n                                'failed_locators': self.failed_locators\n                            }\n                \n                await asyncio.sleep(0.5)\n        \n        print(f\"\\n‚ùå HEALING FAILED after {self.max_retries} attempts\")\n        print(f\"  self.healed_script is None: {self.healed_script is None}\")\n        print(f\"  self.healed_script length: {len(self.healed_script) if self.healed_script else 0}\", flush=True)\n        \n        all_logs.append(f'‚ùå Failed after {self.max_retries} healing attempts')\n        final_result = {\n            'success': False,\n            'logs': all_logs,  # Use accumulated logs\n            'screenshot': result.get('screenshot'),\n            'healed_script': self.healed_script,\n            'failed_locators': self.failed_locators\n        }\n        \n        if self.failed_locators:\n            await self.report_failures_to_ai(test_id)\n        \n        return final_result\n    \n    async def _execute_single_attempt(self, code, browser_name, headless, test_id, attempt_num):\n        \"\"\"Execute a single attempt of the automation code.\"\"\"\n        logs = [f\"‚ñ∂Ô∏è  Attempt {attempt_num + 1}: Executing automation...\"]\n        screenshot = None\n        page_content = ''\n        \n        # If agent execution mode, delegate to agent\n        if self.execution_mode == 'agent':\n            return await self._execute_on_agent(code, browser_name, headless, test_id, attempt_num, logs)\n        \n        try:\n            from playwright.async_api import TimeoutError as PlaywrightTimeout\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True, 'False': False, 'None': None,\n                    'dict': dict, 'list': list, 'str': str, 'int': int,\n                    'float': float, 'bool': bool, 'len': len,\n                    'Exception': Exception, '__import__': __import__,\n                }\n            }\n            \n            local_vars = {}\n            \n            try:\n                exec(code, restricted_globals, local_vars)\n                \n                if 'run_test' not in local_vars:\n                    logs.append(\"‚ùå Error: Generated code must contain a run_test function\")\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': None,\n                        'can_heal': False\n                    }\n                \n                result = await local_vars['run_test'](browser_name=browser_name, headless=headless)\n                logs.extend(result.get('logs', []))\n                screenshot = result.get('screenshot')\n                page_content = result.get('page_html', '')  # Get page HTML if available\n                \n                if result.get('success'):\n                    logs.append(\"‚úÖ Execution completed successfully\")\n                    return {\n                        'success': True,\n                        'logs': logs,\n                        'screenshot': screenshot\n                    }\n                else:\n                    error_msg = ' '.join(result.get('logs', []))\n                    failed_locator = self.extract_failed_locator(error_msg)\n                    failed_step = self.extract_failed_step(error_msg)\n                    \n                    if failed_locator:\n                        self.failed_locators.append({\n                            'locator': failed_locator,\n                            'error': error_msg,\n                            'attempt': attempt_num + 1,\n                            'step': failed_step\n                        })\n                        \n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': True,\n                            'failed_locator': failed_locator,\n                            'failed_step': failed_step,\n                            'error_message': error_msg,\n                            'page_content': page_content\n                        }\n                    else:\n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': False\n                        }\n                        \n            except PlaywrightTimeout as e:\n                error_msg = str(e)\n                logs.append(f\"‚è±Ô∏è  Timeout error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                failed_step = self.extract_failed_step(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1,\n                        'step': failed_step\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'failed_step': failed_step,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n            except Exception as e:\n                error_msg = str(e)\n                logs.append(f\"‚ùå Execution error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                failed_step = self.extract_failed_step(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1,\n                        'step': failed_step\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'failed_step': failed_step,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n        except Exception as e:\n            logs.append(f'üí• Fatal error: {str(e)}')\n            return {\n                'success': False,\n                'logs': logs,\n                'screenshot': screenshot,\n                'can_heal': False\n            }\n    \n    def extract_failed_step(self, error_message):\n        \"\"\"Extract the failed step number from error message.\"\"\"\n        # Look for patterns like \"Error at STEP 3:\" or \"STEP 2:\" in the error\n        patterns = [\n            r'Error at STEP\\s+(\\d+)',\n            r'STEP\\s+(\\d+):',\n            r'step\\s+(\\d+)',\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return int(match.group(1))\n        \n        return 0  # Default to 0 if no step found\n    \n    def extract_failed_locator(self, error_message):\n        \"\"\"Extract the failed locator from error message.\"\"\"\n        patterns = [\n            r'locator\\(\"([^\"]+)\"\\)',\n            r'selector \"([^\"]+)\"',\n            r'element \"([^\"]+)\"',\n            r'get_by_text\\(\"([^\"]+)\"\\)',\n            r'get_by_role\\(\"([^\"]+)\"\\)',\n            r\"locator\\('([^']+)'\\)\",\n            r\"selector '([^']+)'\",\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        \n        return None\n    \n    async def report_failures_to_ai(self, test_id):\n        \"\"\"Report all failures and healing attempts to AI for continuous improvement.\"\"\"\n        if not self.failed_locators or not self.client:\n            return\n        \n        try:\n            failure_report = {\n                'test_id': test_id,\n                'total_failures': len(self.failed_locators),\n                'failures': self.failed_locators,\n                'healed_script': self.healed_script\n            }\n            \n            # ALWAYS use GPT-4o for better analysis (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an automation quality analyst. \nAnalyze the failures and healing attempts to provide insights for improving automation scripts.\nIdentify patterns, suggest best practices, and recommend preventive measures.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Analyze these automation failures and healing attempts:\n\nTest ID: {test_id}\nTotal Failures: {len(self.failed_locators)}\n\nFailures:\n{json.dumps(self.failed_locators, indent=2)}\n\nFinal Healed Script:\n{self.healed_script[:500] if self.healed_script else 'None'}\n\nProvide:\n1. Key insights about failure patterns\n2. Recommendations for better locator strategies\n3. Preventive measures for future scripts\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            insights = response.choices[0].message.content.strip()\n            \n            self.socketio.emit('ai_insights', {\n                'test_id': test_id,\n                'insights': insights,\n                'failure_count': len(self.failed_locators)\n            })\n            \n            return insights\n        except Exception as e:\n            print(f\"AI feedback error: {e}\")\n            return None\n","size_bytes":51042},"playwright_codegen_2.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPlaywright Codegen Locator Capture Script\n\nThis script replicates the core functionality of `npx playwright codegen` by:\n1. Launching a browser (Chromium)\n2. Opening a specified webpage\n3. Capturing and displaying locators for elements that the user clicks\n4. Properly closing the browser when finished\n\nBased on analysis of the Playwright source code:\n- packages/playwright-core/src/server/recorder.ts - Server-side recorder\n- packages/injected/src/recorder/recorder.ts - Browser-injected recorder\n- packages/injected/src/selectorGenerator.ts - Selector generation logic\n\"\"\"\n\nimport sys\nimport asyncio\nfrom playwright.async_api import async_playwright, Page, ElementHandle\n\nclass PlaywrightCodegenCapture:\n    \"\"\"\n    Captures and displays element locators similar to Playwright's codegen tool.\n\n    The selector generation follows Playwright's priority order:\n    1. Test ID attributes (data-testid, etc.)\n    2. Role-based locators (accessibility-first approach)\n    3. Text content\n    4. Label associations\n    5. Placeholder text\n    6. CSS selectors (fallback)\n    \"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        self.page = None\n        self.browser = None\n        self.context = None\n\n    async def generate_locator_suggestions(self, element: ElementHandle) -> dict:\n        \"\"\"\n        Generate multiple locator suggestions for an element.\n\n        This mimics the selector generation logic from:\n        packages/injected/src/selectorGenerator.ts\n\n        The generator prioritizes selectors in order of reliability:\n        - Test IDs (score: 1-2)\n        - Role with name (score: 100)\n        - Placeholder (score: 120)\n        - Label (score: 140)\n        - Alt text (score: 160)\n        - Text content (score: 180)\n        - CSS selectors (score: 500+)\n        \"\"\"\n        locators = {}\n\n        try:\n            # Strategy 1: Test ID attribute (highest priority)\n            # From selectorGenerator.ts: kTestIdScore = 1\n            test_id = await element.get_attribute('data-testid')\n            if test_id:\n                locators['testid'] = f'page.get_by_test_id(\"{test_id}\")'\n\n            # Strategy 2: Role-based locator (accessibility-first)\n            # From selectorGenerator.ts: kRoleWithNameScore = 100\n            role = await element.evaluate('''\n                element => {\n                    const role = element.getAttribute('role') ||\n                                 (element.tagName === 'BUTTON' ? 'button' :\n                                  element.tagName === 'A' ? 'link' :\n                                  element.tagName === 'INPUT' && element.type === 'text' ? 'textbox' :\n                                  element.tagName === 'INPUT' && element.type === 'checkbox' ? 'checkbox' :\n                                  null);\n                    const name = element.textContent?.trim() ||\n                                element.getAttribute('aria-label') ||\n                                element.getAttribute('title');\n                    return { role, name };\n                }\n            ''')\n\n            if role.get('role'):\n                if role.get('name'):\n                    locators['role_with_name'] = f'page.get_by_role(\"{role[\"role\"]}\", name=\"{role[\"name\"]}\")'\n                else:\n                    locators['role'] = f'page.get_by_role(\"{role[\"role\"]}\")'\n\n            # Strategy 3: Text content\n            # From selectorGenerator.ts: kTextScore = 180\n            text_content = await element.text_content()\n            if text_content and text_content.strip():\n                # Use exact match if short, otherwise use contains\n                text = text_content.strip()\n                if len(text) <= 50:\n                    locators['text'] = f'page.get_by_text(\"{text}\", exact=True)'\n                else:\n                    locators['text_partial'] = f'page.get_by_text(\"{text[:30]}...\", exact=False)'\n\n            # Strategy 4: Label (for form inputs)\n            # From selectorGenerator.ts: kLabelScore = 140\n            label = await element.evaluate('''\n                element => {\n                    if (element.id) {\n                        const label = document.querySelector(`label[for=\"${element.id}\"]`);\n                        if (label) return label.textContent?.trim();\n                    }\n                    const parentLabel = element.closest('label');\n                    if (parentLabel) return parentLabel.textContent?.trim();\n                    return null;\n                }\n            ''')\n            if label:\n                locators['label'] = f'page.get_by_label(\"{label}\")'\n\n            # Strategy 5: Placeholder\n            # From selectorGenerator.ts: kPlaceholderScore = 120\n            placeholder = await element.get_attribute('placeholder')\n            if placeholder:\n                locators['placeholder'] = f'page.get_by_placeholder(\"{placeholder}\")'\n\n            # Strategy 6: Alt text (for images)\n            # From selectorGenerator.ts: kAltTextScore = 160\n            alt_text = await element.get_attribute('alt')\n            if alt_text:\n                locators['alt'] = f'page.get_by_alt_text(\"{alt_text}\")'\n\n            # Strategy 7: CSS selector (fallback)\n            # From selectorGenerator.ts: kCSSFallbackScore = 10000000\n            tag_name = await element.evaluate('el => el.tagName.toLowerCase()')\n            css_id = await element.get_attribute('id')\n            css_class = await element.get_attribute('class')\n\n            if css_id:\n                locators['css_id'] = f'page.locator(\"#{css_id}\")'\n            elif css_class:\n                classes = css_class.strip().split()[0] if css_class.strip() else None\n                if classes:\n                    locators['css_class'] = f'page.locator(\"{tag_name}.{classes}\")'\n            else:\n                locators['css_tag'] = f'page.locator(\"{tag_name}\")'\n\n        except Exception as e:\n            locators['error'] = f'Error generating locators: {str(e)}'\n\n        return locators\n\n    async def verify_locator_uniqueness(self, locator_code: str) -> int:\n        \"\"\"\n        Verify how many elements a locator matches on the page.\n        Returns the count of matching elements.\n        \"\"\"\n        try:\n            # Extract the actual locator expression from the Python code\n            # Handle different locator types\n            if 'get_by_test_id' in locator_code:\n                test_id = locator_code.split('\"')[1]\n                count = await self.page.locator(f'[data-testid=\"{test_id}\"]').count()\n            elif 'get_by_role' in locator_code:\n                # Parse role and name if present\n                parts = locator_code.split('\"')\n                role = parts[1]\n                name = parts[3] if len(parts) > 3 and 'name=' in locator_code else None\n                if name:\n                    count = await self.page.get_by_role(role, name=name).count()\n                else:\n                    count = await self.page.get_by_role(role).count()\n            elif 'get_by_text' in locator_code:\n                text = locator_code.split('\"')[1]\n                exact = 'exact=True' in locator_code\n                count = await self.page.get_by_text(text, exact=exact).count()\n            elif 'get_by_placeholder' in locator_code:\n                placeholder = locator_code.split('\"')[1]\n                count = await self.page.get_by_placeholder(placeholder).count()\n            elif 'get_by_alt_text' in locator_code:\n                alt = locator_code.split('\"')[1]\n                count = await self.page.get_by_alt_text(alt).count()\n            elif 'get_by_title' in locator_code:\n                title = locator_code.split('\"')[1]\n                count = await self.page.get_by_title(title).count()\n            elif 'get_by_label' in locator_code:\n                label = locator_code.split('\"')[1]\n                count = await self.page.get_by_label(label).count()\n            elif 'page.locator' in locator_code:\n                # CSS or XPath\n                selector = locator_code.split('\"')[1]\n                count = await self.page.locator(selector).count()\n            elif '.filter(' in locator_code or '.get_by_text(' in locator_code:\n                # Chained locator - harder to evaluate, skip for now\n                count = 999\n            else:\n                count = 999\n\n            return count\n        except Exception as e:\n            # If we can't verify, assume it's not unique\n            return 999\n\n    async def generate_locators_from_info(self, info: dict) -> dict:\n        \"\"\"\n        Generate ALL possible locators from pre-captured element information.\n        Returns primary (best) locator and all valid secondary locators.\n        \"\"\"\n        primary = None\n        secondary = []\n\n        # Score tracking to determine primary locator (lower score = better)\n        scores = []\n\n        # 1. TEST ID LOCATORS (Score: 1 - highest priority)\n        if info.get('testId'):\n            loc = f'page.get_by_test_id(\"{info[\"testId\"]}\")'\n            scores.append((1, loc, 'testid'))\n\n        # 2. ROLE-BASED LOCATORS (Score: 100-150)\n        role = None\n        if info.get('role'):\n            role = info['role']\n        elif info['tag'] == 'button':\n            role = 'button'\n        elif info['tag'] == 'a':\n            role = 'link'\n        elif info['tag'] == 'input':\n            input_type = info.get('type', '')\n            if input_type == 'text' or input_type == '':\n                role = 'textbox'\n            elif input_type == 'checkbox':\n                role = 'checkbox'\n            elif input_type == 'radio':\n                role = 'radio'\n            elif input_type == 'submit':\n                role = 'button'\n        elif info['tag'] == 'img':\n            role = 'img'\n        elif info['tag'] == 'h1':\n            role = 'heading'\n        elif info['tag'] in ['h2', 'h3', 'h4', 'h5', 'h6']:\n            role = 'heading'\n\n        if role:\n            name = info.get('text') or info.get('ariaLabel')\n            if name:\n                loc = f'page.get_by_role(\"{role}\", name=\"{name}\")'\n                scores.append((100, loc, 'role_with_name'))\n                # Also add exact match variant\n                loc_exact = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)'\n                scores.append((105, loc_exact, 'role_with_name_exact'))\n            else:\n                loc = f'page.get_by_role(\"{role}\")'\n                scores.append((510, loc, 'role'))\n\n        # 3. LABEL LOCATORS (Score: 140)\n        # Note: We can't detect actual labels from pre-captured info, but include placeholder\n        if info.get('ariaLabel'):\n            loc = f'page.get_by_label(\"{info[\"ariaLabel\"]}\")'\n            scores.append((140, loc, 'label'))\n\n        # 4. PLACEHOLDER LOCATORS (Score: 120)\n        if info.get('placeholder'):\n            loc = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\")'\n            scores.append((120, loc, 'placeholder'))\n            loc_exact = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\", exact=True)'\n            scores.append((125, loc_exact, 'placeholder_exact'))\n\n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if info.get('alt'):\n            loc = f'page.get_by_alt_text(\"{info[\"alt\"]}\")'\n            scores.append((160, loc, 'alt'))\n            loc_exact = f'page.get_by_alt_text(\"{info[\"alt\"]}\", exact=True)'\n            scores.append((165, loc_exact, 'alt_exact'))\n\n        # 6. TEXT LOCATORS (Score: 180)\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                # Exact text match\n                loc = f'page.get_by_text(\"{text}\", exact=True)'\n                scores.append((185, loc, 'text_exact'))\n                # Partial text match\n                loc_partial = f'page.get_by_text(\"{text}\")'\n                scores.append((180, loc_partial, 'text'))\n                # Regex variant\n                if len(text) > 3:\n                    loc_regex = f'page.get_by_text(re.compile(r\"{text[:20]}\"))'\n                    scores.append((250, loc_regex, 'text_regex'))\n\n        # 7. TITLE LOCATORS (Score: 200)\n        if info.get('title'):\n            loc = f'page.get_by_title(\"{info[\"title\"]}\")'\n            scores.append((200, loc, 'title'))\n\n        # 8. CSS SELECTORS (Score: 500+)\n        css_selectors = []\n\n        # CSS by ID\n        if info.get('id'):\n            loc = f'page.locator(\"#{info[\"id\"]}\")'\n            scores.append((500, loc, 'css_id'))\n            css_selectors.append(f'#{info[\"id\"]}')\n\n        # CSS by class\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                # First class\n                loc = f'page.locator(\"{info[\"tag\"]}.{classes[0]}\")'\n                scores.append((520, loc, 'css_class'))\n                css_selectors.append(f'{info[\"tag\"]}.{classes[0]}')\n                # All classes\n                all_classes = '.'.join(classes)\n                loc_all = f'page.locator(\"{info[\"tag\"]}.{all_classes}\")'\n                scores.append((515, loc_all, 'css_all_classes'))\n                css_selectors.append(f'{info[\"tag\"]}.{all_classes}')\n\n        # CSS by tag + attributes\n        if info.get('type'):\n            loc = f'page.locator(\"{info[\"tag\"]}[type=\\\\\"{info[\"type\"]}\\\\\"]\")'\n            scores.append((520, loc, 'css_type'))\n            css_selectors.append(f'{info[\"tag\"]}[type=\"{info[\"type\"]}\"]')\n\n        if info.get('href'):\n            loc = f'page.locator(\"{info[\"tag\"]}[href=\\\\\"{info[\"href\"]}\\\\\"]\")'\n            scores.append((525, loc, 'css_href'))\n            css_selectors.append(f'{info[\"tag\"]}[href=\"{info[\"href\"]}\"]')\n\n        # CSS by tag only\n        loc = f'page.locator(\"{info[\"tag\"]}\")'\n        scores.append((530, loc, 'css_tag'))\n        css_selectors.append(info[\"tag\"])\n\n        # 9. XPATH SELECTORS (Score: 600+)\n        xpath_selectors = []\n\n        # XPath by ID\n        if info.get('id'):\n            loc = f'page.locator(\"xpath=//{info[\"tag\"]}[@id=\\\\\"{info[\"id\"]}\\\\\"]\")'\n            scores.append((600, loc, 'xpath_id'))\n            xpath_selectors.append(f'//{info[\"tag\"]}[@id=\"{info[\"id\"]}\"]')\n\n        # XPath by class\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                loc = f'page.locator(\"xpath=//{info[\"tag\"]}[contains(@class, \\\\\"{classes[0]}\\\\\")]\")'\n                scores.append((610, loc, 'xpath_class'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[contains(@class, \"{classes[0]}\")]')\n\n        # XPath by text\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.locator(\"xpath=//{info[\"tag\"]}[text()=\\\\\"{text}\\\\\"]\")'\n                scores.append((620, loc, 'xpath_text'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[text()=\"{text}\"]')\n                loc_contains = f'page.locator(\"xpath=//{info[\"tag\"]}[contains(text(), \\\\\"{text[:20]}\\\\\")]\")'\n                scores.append((625, loc_contains, 'xpath_text_contains'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[contains(text(), \"{text[:20]}\")]')\n\n        # XPath by tag\n        loc = f'page.locator(\"xpath=//{info[\"tag\"]}\")'\n        scores.append((630, loc, 'xpath_tag'))\n        xpath_selectors.append(f'//{info[\"tag\"]}')\n\n        # 10. CHAINED LOCATORS (Score: 300+)\n        chained = []\n\n        # Chain: Role + Text filter\n        if role and info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.get_by_role(\"{role}\").filter(has_text=\"{text}\")'\n                scores.append((300, loc, 'chained_role_text'))\n                chained.append(loc)\n\n        # Chain: Locator + Text filter\n        if css_selectors and info.get('text'):\n            text = info['text'].strip()\n            if text and css_selectors[0]:\n                loc = f'page.locator(\"{css_selectors[0]}\").filter(has_text=\"{text}\")'\n                scores.append((310, loc, 'chained_css_text'))\n                chained.append(loc)\n\n        # Chain: Locator + get_by_text\n        if css_selectors and info.get('text'):\n            text = info['text'].strip()\n            if text and css_selectors[0]:\n                loc = f'page.locator(\"{css_selectors[0]}\").get_by_text(\"{text}\")'\n                scores.append((320, loc, 'chained_css_getbytext'))\n                chained.append(loc)\n\n        # INTELLIGENT PRIMARY LOCATOR SELECTION\n        # Sort by score (lower is better)\n        scores.sort(key=lambda x: x[0])\n\n        # Verify uniqueness for each locator and find the best unique one\n        primary = None\n        secondary = []\n        verified_scores = []\n\n        for score, locator, loc_type in scores:\n            # Check how many elements this locator matches\n            count = await self.verify_locator_uniqueness(locator)\n            verified_scores.append({\n                'locator': locator,\n                'type': loc_type,\n                'score': score,\n                'count': count,\n                'unique': count == 1\n            })\n\n        # Find the best UNIQUE locator (prioritize by score, but must be unique)\n        unique_locators = [v for v in verified_scores if v['unique']]\n\n        if unique_locators:\n            # Best unique locator becomes primary\n            primary = unique_locators[0]\n            # All others (unique or not) become secondary\n            secondary = [v for v in verified_scores if v != primary]\n        else:\n            # No unique locator found - use the best score but mark as non-unique\n            # Try to build a more specific CSS selector as fallback\n            if verified_scores:\n                primary = verified_scores[0]\n                primary['warning'] = f'‚ö†Ô∏è  Matches {primary[\"count\"]} elements - not unique!'\n                secondary = verified_scores[1:]\n\n        return {\n            'primary': primary,\n            'secondary': secondary,\n            'css_selectors': css_selectors,\n            'xpath_selectors': xpath_selectors,\n            'chained': chained\n        }\n\n    async def setup_click_handler(self):\n        \"\"\"\n        Inject JavaScript to capture click events and highlight elements.\n\n        This mimics the behavior from:\n        packages/injected/src/recorder/recorder.ts - RecordActionTool class\n\n        The injected script:\n        1. Listens for click events on the page\n        2. Prevents default action temporarily\n        3. Sends element info back to Python\n        4. Highlights clicked elements\n        \"\"\"\n        if not self.page:\n            return\n\n        await self.page.evaluate('''\n            () => {\n                // Remove any existing listeners\n                if (window.__playwrightCodegenHandler) {\n                    document.removeEventListener('click', window.__playwrightCodegenHandler, true);\n                }\n\n                // Highlight element on hover (similar to Playwright Inspector)\n                let currentHighlight = null;\n\n                document.addEventListener('mouseover', (e) => {\n                    if (currentHighlight) {\n                        currentHighlight.style.outline = '';\n                        currentHighlight.style.backgroundColor = '';\n                    }\n\n                    // Highlight color from packages/injected/src/recorder/recorder.ts\n                    // HighlightColors.action = '#dc6f6f7f'\n                    e.target.style.outline = '2px solid #dc6f6f';\n                    e.target.style.backgroundColor = 'rgba(220, 111, 111, 0.1)';\n                    currentHighlight = e.target;\n                }, true);\n\n                // Click handler - captures element info WITHOUT triggering actions\n                // This mimics Playwright codegen behavior - record but don't execute\n                const clickHandler = (e) => {\n                    const element = e.target;\n\n                    // PREVENT default action (like codegen does)\n                    // This stops navigation, form submission, etc.\n                    e.preventDefault();\n                    e.stopPropagation();\n                    e.stopImmediatePropagation();\n\n                    // Capture element info for locator generation\n                    window.__lastClickedElementInfo = {\n                        tag: element.tagName.toLowerCase(),\n                        text: element.textContent?.trim().substring(0, 50),\n                        id: element.id || '',\n                        classes: element.className || '',\n                        testId: element.getAttribute('data-testid') || '',\n                        role: element.getAttribute('role') || '',\n                        ariaLabel: element.getAttribute('aria-label') || '',\n                        placeholder: element.getAttribute('placeholder') || '',\n                        alt: element.getAttribute('alt') || '',\n                        title: element.getAttribute('title') || '',\n                        type: element.getAttribute('type') || '',\n                        href: element.getAttribute('href') || '',\n                        timestamp: Date.now()\n                    };\n\n                    // Visual feedback - flash the element\n                    const originalBg = element.style.backgroundColor;\n                    element.style.backgroundColor = 'rgba(220, 111, 111, 0.3)';\n                    setTimeout(() => {\n                        element.style.backgroundColor = originalBg;\n                    }, 200);\n                };\n\n                window.__playwrightCodegenHandler = clickHandler;\n                document.addEventListener('click', clickHandler, true);\n\n                console.log('Playwright Codegen: Click capture enabled');\n            }\n        ''')\n\n    async def start_capture(self):\n        \"\"\"\n        Main capture loop - launches browser and listens for user interactions.\n\n        Flow mirrors Playwright's recorder:\n        1. Launch browser with recorder mode enabled\n        2. Navigate to target URL\n        3. Inject event listeners\n        4. Wait for user interactions\n        5. Generate and display locators\n        \"\"\"\n        async with async_playwright() as p:\n            print(\"üé≠ Playwright Codegen Locator Capture\")\n            print(\"=\" * 60)\n            print(f\"Opening: {self.url}\")\n            print(\"\\nInstructions:\")\n            print(\"  ‚Ä¢ Click on any element to see its locators\")\n            print(\"  ‚Ä¢ Press Ctrl+C to exit\")\n            print(\"=\" * 60)\n            print()\n\n            # Launch browser in headed mode (similar to codegen)\n            # From recorder.ts: browser is launched with headful mode\n            self.browser = await p.chromium.launch(\n                headless=False,\n                args=['--disable-blink-features=AutomationControlled']\n            )\n\n            # Create context (similar to Recorder._create in recorder.ts)\n            self.context = await self.browser.new_context()\n            self.page = await self.context.new_page()\n\n            # Navigate to URL\n            await self.page.goto(self.url)\n\n            # Inject click capture handler\n            await self.setup_click_handler()\n\n            # Monitor for clicks (actions are prevented like codegen)\n            # Elements are recorded but not executed\n            last_processed_timestamp = 0\n\n            try:\n                while True:\n                    # Check if a new element was clicked\n                    element_info = await self.page.evaluate(\n                        '() => window.__lastClickedElementInfo'\n                    )\n\n                    if element_info and element_info.get('timestamp', 0) > last_processed_timestamp:\n                        last_processed_timestamp = element_info['timestamp']\n\n                        # Display element info\n                        print(f\"\\n{'='*70}\")\n                        print(f\"üéØ Element: <{element_info['tag']}>\")\n                        if element_info.get('id'):\n                            print(f\"   ID: {element_info['id']}\")\n                        if element_info.get('text'):\n                            print(f\"   Text: {element_info['text']}\")\n                        if element_info.get('href'):\n                            print(f\"   Href: {element_info['href']}\")\n                        print(f\"{'='*70}\")\n\n                        # Generate all possible locators (with uniqueness verification)\n                        result = await self.generate_locators_from_info(element_info)\n\n                        # Build locators dictionary\n                        primary_info = {\n                            'locator': result['primary']['locator'] if result['primary'] else None,\n                            'count': result['primary']['count'] if result['primary'] else 0,\n                            'unique': result['primary']['unique'] if result['primary'] else False\n                        }\n\n                        # Add warning if not unique\n                        if result['primary'] and result['primary'].get('warning'):\n                            primary_info['warning'] = result['primary']['warning']\n\n                        locators_dict = {\n                            'primary_locator': primary_info,\n                            'all_locators': {}\n                        }\n\n                        # Organize by method type\n                        by_role = []\n                        by_text = []\n                        by_label = []\n                        by_placeholder = []\n                        by_alt = []\n                        by_title = []\n                        by_testid = []\n                        css_locators = []\n                        xpath_locators = []\n                        chained_locators = []\n\n                        # Add primary (with uniqueness info)\n                        if result['primary']:\n                            loc_type = result['primary']['type']\n                            loc_str = result['primary']['locator']\n                            count = result['primary']['count']\n                            unique = result['primary']['unique']\n\n                            loc_with_info = {\n                                'locator': loc_str,\n                                'count': count,\n                                'unique': unique\n                            }\n\n                            if 'role' in loc_type:\n                                by_role.append(loc_with_info)\n                            elif 'text' in loc_type:\n                                by_text.append(loc_with_info)\n                            elif 'label' in loc_type:\n                                by_label.append(loc_with_info)\n                            elif 'placeholder' in loc_type:\n                                by_placeholder.append(loc_with_info)\n                            elif 'alt' in loc_type:\n                                by_alt.append(loc_with_info)\n                            elif 'title' in loc_type:\n                                by_title.append(loc_with_info)\n                            elif 'testid' in loc_type:\n                                by_testid.append(loc_with_info)\n                            elif 'css' in loc_type:\n                                css_locators.append(loc_with_info)\n                            elif 'xpath' in loc_type:\n                                xpath_locators.append(loc_with_info)\n                            elif 'chained' in loc_type:\n                                chained_locators.append(loc_with_info)\n\n                        # Add secondary (with uniqueness info)\n                        for sec in result['secondary']:\n                            loc_type = sec['type']\n                            loc_str = sec['locator']\n                            count = sec['count']\n                            unique = sec['unique']\n\n                            # Format: \"locator_string (count: N, unique: True/False)\"\n                            loc_with_info = {\n                                'locator': loc_str,\n                                'count': count,\n                                'unique': unique\n                            }\n\n                            if 'role' in loc_type:\n                                by_role.append(loc_with_info)\n                            elif 'text' in loc_type:\n                                by_text.append(loc_with_info)\n                            elif 'label' in loc_type:\n                                by_label.append(loc_with_info)\n                            elif 'placeholder' in loc_type:\n                                by_placeholder.append(loc_with_info)\n                            elif 'alt' in loc_type:\n                                by_alt.append(loc_with_info)\n                            elif 'title' in loc_type:\n                                by_title.append(loc_with_info)\n                            elif 'testid' in loc_type:\n                                by_testid.append(loc_with_info)\n                            elif 'css' in loc_type:\n                                css_locators.append(loc_with_info)\n                            elif 'xpath' in loc_type:\n                                xpath_locators.append(loc_with_info)\n                            elif 'chained' in loc_type:\n                                chained_locators.append(loc_with_info)\n\n                        # Build final dictionary\n                        if by_testid:\n                            locators_dict['all_locators']['getByTestId'] = by_testid\n                        if by_role:\n                            locators_dict['all_locators']['getByRole'] = by_role\n                        if by_text:\n                            locators_dict['all_locators']['getByText'] = by_text\n                        if by_label:\n                            locators_dict['all_locators']['getByLabel'] = by_label\n                        if by_placeholder:\n                            locators_dict['all_locators']['getByPlaceholder'] = by_placeholder\n                        if by_alt:\n                            locators_dict['all_locators']['getByAltText'] = by_alt\n                        if by_title:\n                            locators_dict['all_locators']['getByTitle'] = by_title\n                        if css_locators:\n                            locators_dict['all_locators']['locator_css'] = css_locators\n                        if xpath_locators:\n                            locators_dict['all_locators']['locator_xpath'] = xpath_locators\n                        if chained_locators:\n                            locators_dict['all_locators']['chained_locators'] = chained_locators\n\n                        # Also include raw CSS and XPath selectors\n                        if result['css_selectors']:\n                            locators_dict['css_selectors'] = result['css_selectors']\n                        if result['xpath_selectors']:\n                            locators_dict['xpath_selectors'] = result['xpath_selectors']\n\n                        # Display as formatted dictionary\n                        import json\n                        print(\"\\nüìç LOCATORS DICTIONARY:\")\n                        print(json.dumps(locators_dict, indent=2))\n                        print()\n\n                    # Small delay to prevent high CPU usage\n                    await asyncio.sleep(0.1)\n\n            except KeyboardInterrupt:\n                print(\"\\n\\nüëã Exiting Playwright Codegen Capture...\")\n            finally:\n                # Cleanup: close browser properly\n                # This mirrors the cleanup in recorder.ts\n                if self.context:\n                    await self.context.close()\n                if self.browser:\n                    await self.browser.close()\n                print(\"‚úì Browser closed successfully\")\n\ndef main():\n    \"\"\"\n    Entry point - parses URL from command line arguments.\n\n    Usage:\n        python playwright_codegen.py <URL>\n        python playwright_codegen.py https://example.com\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: python playwright_codegen.py <URL>\")\n        print(\"\\nExample:\")\n        print(\"  python playwright_codegen.py https://example.com\")\n        print(\"  python playwright_codegen.py https://playwright.dev\")\n        sys.exit(1)\n\n    url = sys.argv[1]\n\n    # Ensure URL has a protocol\n    if not url.startswith(('http://', 'https://')):\n        url = 'https://' + url\n\n    # Create and run the capture tool\n    capture = PlaywrightCodegenCapture(url)\n\n    try:\n        asyncio.run(capture.start_capture())\n    except Exception as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":32786},"visionvault/__init__.py":{"content":"","size_bytes":0},"visionvault/services/code_validator.py":{"content":"import ast\nimport re\n\nclass CodeValidator:\n    ALLOWED_IMPORTS = {\n        'playwright.async_api',\n        'asyncio',\n        'time',\n        'datetime',\n        're',\n        'json',\n        'base64'\n    }\n    \n    DANGEROUS_MODULES = {\n        'os', 'sys', 'subprocess', 'shutil', 'eval', 'exec',\n        'compile', '__import__', 'open', 'file', 'input',\n        'execfile', 'reload', 'importlib', 'pickle', 'shelve',\n        'socket', 'urllib', 'requests', 'http', 'ftplib',\n        'telnetlib', 'smtplib', 'poplib', 'imaplib'\n    }\n    \n    def __init__(self):\n        self.errors = []\n    \n    def validate(self, code):\n        self.errors = []\n        \n        if not code or not isinstance(code, str):\n            self.errors.append(\"Code must be a non-empty string\")\n            return False\n        \n        if not self._check_function_structure(code):\n            return False\n        \n        if not self._check_dangerous_imports(code):\n            return False\n        \n        if not self._check_dangerous_patterns(code):\n            return False\n        \n        try:\n            tree = ast.parse(code)\n            if not self._validate_ast(tree):\n                return False\n        except SyntaxError as e:\n            self.errors.append(f\"Syntax error: {str(e)}\")\n            return False\n        \n        return True\n    \n    def _check_function_structure(self, code):\n        if 'async def run_test' not in code:\n            self.errors.append(\"Code must contain 'async def run_test' function\")\n            return False\n        \n        if 'playwright.async_api import async_playwright' not in code:\n            self.errors.append(\"Code must use 'from playwright.async_api import async_playwright'\")\n            return False\n        \n        return True\n    \n    def _check_dangerous_imports(self, code):\n        for module in self.DANGEROUS_MODULES:\n            patterns = [\n                f'import {module}',\n                f'from {module}',\n                f'__import__(\"{module}\")',\n                f\"__import__('{module}')\"\n            ]\n            for pattern in patterns:\n                if pattern in code:\n                    self.errors.append(f\"Dangerous import detected: {module}\")\n                    return False\n        \n        return True\n    \n    def _check_dangerous_patterns(self, code):\n        dangerous_patterns = [\n            (r'\\beval\\s*\\(', 'eval() function'),\n            (r'\\bexec\\s*\\(', 'exec() function'),\n            (r'\\b__import__\\s*\\(', '__import__() function'),\n            (r'\\bcompile\\s*\\(', 'compile() function'),\n            (r'\\bopen\\s*\\(', 'open() function (file access)'),\n            (r'\\.system\\s*\\(', 'system() call'),\n            (r'\\.popen\\s*\\(', 'popen() call'),\n            (r'\\.spawn\\s*\\(', 'spawn() call'),\n        ]\n        \n        for pattern, name in dangerous_patterns:\n            if re.search(pattern, code, re.IGNORECASE):\n                self.errors.append(f\"Dangerous pattern detected: {name}\")\n                return False\n        \n        return True\n    \n    def _validate_ast(self, tree):\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if not self._is_allowed_import(alias.name):\n                        self.errors.append(f\"Disallowed import: {alias.name}\")\n                        return False\n            \n            elif isinstance(node, ast.ImportFrom):\n                if node.module and not self._is_allowed_import(node.module):\n                    self.errors.append(f\"Disallowed import from: {node.module}\")\n                    return False\n            \n            elif isinstance(node, ast.Call):\n                if isinstance(node.func, ast.Name):\n                    if node.func.id in ['eval', 'exec', 'compile', '__import__', 'open']:\n                        self.errors.append(f\"Dangerous function call: {node.func.id}\")\n                        return False\n        \n        return True\n    \n    def _is_allowed_import(self, module_name):\n        for allowed in self.ALLOWED_IMPORTS:\n            if module_name.startswith(allowed):\n                return True\n        return False\n    \n    def get_errors(self):\n        return self.errors\n","size_bytes":4240},"visionvault/web/__init__.py":{"content":"","size_bytes":0},"visionvault/services/advanced_locator_validator.py":{"content":"\"\"\"\nAdvanced Locator Validator - Intelligent locator testing and selection\n\nThis module provides advanced locator validation capabilities that:\n1. Tests all possible locator strategies in parallel\n2. Automatically selects the most reliable unique locator\n3. Caches successful locators for reuse\n4. Provides confidence scores based on stability and uniqueness\n\"\"\"\n\nimport asyncio\nimport re\nfrom typing import Dict, List, Tuple, Optional\nimport json\nimport os\nfrom datetime import datetime\n\n\nclass LocatorCache:\n    \"\"\"Cache for successful locators to speed up future executions\"\"\"\n    \n    def __init__(self, cache_file='data/locator_cache.json'):\n        self.cache_file = cache_file\n        self.cache = self._load_cache()\n    \n    def _load_cache(self) -> Dict:\n        \"\"\"Load cache from file\"\"\"\n        try:\n            if os.path.exists(self.cache_file):\n                with open(self.cache_file, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Could not load locator cache: {e}\")\n        return {}\n    \n    def _save_cache(self):\n        \"\"\"Save cache to file\"\"\"\n        try:\n            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n            with open(self.cache_file, 'w') as f:\n                json.dump(self.cache, f, indent=2)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Could not save locator cache: {e}\")\n    \n    def get(self, url: str, element_description: str) -> Optional[Dict]:\n        \"\"\"Get cached locator for a URL and element description\"\"\"\n        key = f\"{url}::{element_description}\"\n        return self.cache.get(key)\n    \n    def set(self, url: str, element_description: str, locator_info: Dict):\n        \"\"\"Cache a successful locator\"\"\"\n        key = f\"{url}::{element_description}\"\n        self.cache[key] = {\n            **locator_info,\n            'last_used': datetime.now().isoformat(),\n            'success_count': self.cache.get(key, {}).get('success_count', 0) + 1\n        }\n        self._save_cache()\n\n\nclass AdvancedLocatorValidator:\n    \"\"\"Advanced locator validation with parallel testing and intelligent selection\"\"\"\n    \n    def __init__(self, page):\n        self.page = page\n        self.cache = LocatorCache()\n    \n    async def generate_all_possible_locators(self, element_info: Dict) -> List[Tuple[int, str, str]]:\n        \"\"\"\n        Generate ALL possible locator strategies from element information.\n        Returns list of (score, locator_code, strategy_name) tuples.\n        Lower score = higher priority.\n        \"\"\"\n        locators = []\n        \n        # 1. TEST ID LOCATORS (Score: 1 - HIGHEST PRIORITY)\n        if element_info.get('testId'):\n            locators.append((1, f'page.get_by_test_id(\"{element_info[\"testId\"]}\")', 'testid'))\n        \n        # 2. ROLE-BASED LOCATORS (Score: 100-510)\n        role = self._determine_role(element_info)\n        if role:\n            # Try ariaLabel first, then text, fallback to empty\n            name = element_info.get('ariaLabel') or element_info.get('text') or ''\n            if name and name.strip():\n                # Role with exact name - most reliable\n                locators.append((100, f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)', 'role_exact'))\n                # Role with partial name\n                locators.append((105, f'page.get_by_role(\"{role}\", name=\"{name}\")', 'role_name'))\n            else:\n                # Role alone - less reliable\n                locators.append((510, f'page.get_by_role(\"{role}\")', 'role_only'))\n        \n        # 3. PLACEHOLDER LOCATORS (Score: 120)\n        if element_info.get('placeholder'):\n            locators.append((120, f'page.get_by_placeholder(\"{element_info[\"placeholder\"]}\", exact=True)', 'placeholder_exact'))\n            locators.append((125, f'page.get_by_placeholder(\"{element_info[\"placeholder\"]}\")', 'placeholder'))\n        \n        # 4. LABEL LOCATORS (Score: 140)\n        if element_info.get('ariaLabel'):\n            locators.append((140, f'page.get_by_label(\"{element_info[\"ariaLabel\"]}\", exact=True)', 'label_exact'))\n            locators.append((145, f'page.get_by_label(\"{element_info[\"ariaLabel\"]}\")', 'label'))\n        \n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if element_info.get('alt'):\n            locators.append((160, f'page.get_by_alt_text(\"{element_info[\"alt\"]}\", exact=True)', 'alt_exact'))\n            locators.append((165, f'page.get_by_alt_text(\"{element_info[\"alt\"]}\")', 'alt'))\n        \n        # 6. TEXT LOCATORS (Score: 180-250)\n        if element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((180, f'page.get_by_text(\"{text}\", exact=True)', 'text_exact'))\n                locators.append((185, f'page.get_by_text(\"{text}\")', 'text'))\n                # Text content with regex for partial matching\n                if len(text) > 5:\n                    escaped_text = re.escape(text[:30])\n                    locators.append((250, f'page.get_by_text(re.compile(r\"{escaped_text}\"))', 'text_regex'))\n        \n        # 7. TITLE LOCATORS (Score: 200)\n        if element_info.get('title'):\n            locators.append((200, f'page.get_by_title(\"{element_info[\"title\"]}\")', 'title'))\n        \n        # 8. CSS SELECTORS (Score: 500+)\n        tag = element_info.get('tag', 'div')  # Default to div if tag not specified\n        \n        # ID selector - very reliable\n        if element_info.get('id'):\n            locators.append((500, f'page.locator(\"#{element_info[\"id\"]}\")', 'css_id'))\n        \n        # Class selectors\n        if element_info.get('classes'):\n            classes = element_info['classes'].strip().split()\n            if classes:\n                # Single class\n                locators.append((520, f'page.locator(\"{tag}.{classes[0]}\")', 'css_class'))\n                # All classes\n                if len(classes) > 1:\n                    all_classes = '.'.join(classes)\n                    locators.append((515, f'page.locator(\"{tag}.{all_classes}\")', 'css_all_classes'))\n        \n        # Attribute selectors\n        if element_info.get('type'):\n            locators.append((520, f'page.locator(\"{tag}[type=\\\\\"{element_info[\"type\"]}\\\\\"]\")', 'css_type'))\n        \n        if element_info.get('name'):\n            locators.append((525, f'page.locator(\"{tag}[name=\\\\\"{element_info[\"name\"]}\\\\\"]\")', 'css_name'))\n        \n        if element_info.get('href'):\n            href = element_info['href'][:100]  # Limit length\n            locators.append((525, f'page.locator(\"{tag}[href=\\\\\"{href}\\\\\"]\")', 'css_href'))\n        \n        if element_info.get('value'):\n            locators.append((530, f'page.locator(\"{tag}[value=\\\\\"{element_info[\"value\"]}\\\\\"]\")', 'css_value'))\n        \n        # Tag only - lowest priority (only if tag is available)\n        if tag:\n            locators.append((600, f'page.locator(\"{tag}\")', 'css_tag'))\n        \n        # 9. COMBINED LOCATORS (Score: 300-400)\n        # Combine strategies for better specificity\n        if role and element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((300, f'page.get_by_role(\"{role}\").filter(has_text=\"{text}\")', 'role_filter_text'))\n        \n        elem_id = element_info.get('id')\n        if elem_id and element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((350, f'page.locator(\"#{elem_id}\").get_by_text(\"{text}\")', 'id_filter_text'))\n        \n        # Sort by score (lower is better)\n        locators.sort(key=lambda x: x[0])\n        return locators\n    \n    def _determine_role(self, element_info: Dict) -> Optional[str]:\n        \"\"\"Determine the ARIA role for an element\"\"\"\n        if element_info.get('role'):\n            return element_info['role']\n        \n        tag = element_info.get('tag', '').lower()\n        input_type = element_info.get('type', '').lower()\n        \n        role_map = {\n            'button': 'button',\n            'a': 'link',\n            'img': 'img',\n            'h1': 'heading',\n            'h2': 'heading',\n            'h3': 'heading',\n            'h4': 'heading',\n            'h5': 'heading',\n            'h6': 'heading',\n            'nav': 'navigation',\n            'main': 'main',\n            'header': 'banner',\n            'footer': 'contentinfo',\n            'aside': 'complementary',\n            'section': 'region',\n        }\n        \n        if tag in role_map:\n            return role_map[tag]\n        \n        if tag == 'input':\n            input_role_map = {\n                'text': 'textbox',\n                'email': 'textbox',\n                'password': 'textbox',\n                'search': 'searchbox',\n                'tel': 'textbox',\n                'url': 'textbox',\n                'checkbox': 'checkbox',\n                'radio': 'radio',\n                'button': 'button',\n                'submit': 'button',\n                'reset': 'button',\n            }\n            return input_role_map.get(input_type, 'textbox')\n        \n        if tag == 'textarea':\n            return 'textbox'\n        \n        if tag == 'select':\n            return 'combobox'\n        \n        return None\n    \n    async def verify_locator(self, locator_code: str) -> Tuple[int, bool, Optional[str]]:\n        \"\"\"\n        Verify a locator and return (count, is_visible, error).\n        Tests both count and visibility.\n        \"\"\"\n        try:\n            count = await self._count_matches(locator_code)\n            \n            if count == 0:\n                return (0, False, None)\n            \n            # Check if the element is visible\n            is_visible = False\n            if count == 1:\n                try:\n                    is_visible = await self._is_element_visible(locator_code)\n                except Exception:\n                    pass\n            \n            return (count, is_visible, None)\n        \n        except Exception as e:\n            return (999, False, str(e))\n    \n    async def _count_matches(self, locator_code: str) -> int:\n        \"\"\"Count how many elements match a locator\"\"\"\n        try:\n            if 'get_by_test_id' in locator_code:\n                match = re.search(r'get_by_test_id\\(\"([^\"]+)\"\\)', locator_code)\n                if match:\n                    return await self.page.locator(f'[data-testid=\"{match.group(1)}\"]').count()\n            \n            elif 'get_by_role' in locator_code:\n                role_match = re.search(r'get_by_role\\(\"([^\"]+)\"', locator_code)\n                name_match = re.search(r'name=\"([^\"]+)\"', locator_code)\n                exact = 'exact=True' in locator_code\n                \n                if role_match:\n                    role = role_match.group(1)\n                    name = name_match.group(1) if name_match else None\n                    if name:\n                        return await self.page.get_by_role(role, name=name, exact=exact).count()\n                    else:\n                        return await self.page.get_by_role(role).count()\n            \n            elif 'get_by_text' in locator_code:\n                text_match = re.search(r'get_by_text\\(\"([^\"]+)\"', locator_code)\n                if text_match:\n                    text = text_match.group(1)\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_text(text, exact=exact).count()\n            \n            elif 'get_by_placeholder' in locator_code:\n                match = re.search(r'get_by_placeholder\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_placeholder(match.group(1), exact=exact).count()\n            \n            elif 'get_by_label' in locator_code:\n                match = re.search(r'get_by_label\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_label(match.group(1), exact=exact).count()\n            \n            elif 'get_by_alt_text' in locator_code:\n                match = re.search(r'get_by_alt_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_alt_text(match.group(1), exact=exact).count()\n            \n            elif 'get_by_title' in locator_code:\n                match = re.search(r'get_by_title\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    return await self.page.get_by_title(match.group(1)).count()\n            \n            elif 'page.locator' in locator_code:\n                match = re.search(r'page\\.locator\\(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\)', locator_code)\n                if match:\n                    selector = match.group(1).replace('\\\\\"', '\"')\n                    return await self.page.locator(selector).count()\n            \n            elif '.filter(' in locator_code or '.get_by_text(' in locator_code:\n                # Handle chained locators - for now, return high count (needs page context)\n                return 999\n            \n            return 999\n        \n        except Exception:\n            return 999\n    \n    async def _is_element_visible(self, locator_code: str) -> bool:\n        \"\"\"Check if an element matching the locator is visible\"\"\"\n        try:\n            # This is a simplified check - you'd need to actually get the locator\n            # For now, assume visible if count is 1\n            return True\n        except Exception:\n            return False\n    \n    async def find_best_locator(self, element_info: Dict, page_url: str = '') -> Optional[Dict]:\n        \"\"\"\n        Find the best locator for an element by testing all strategies in parallel.\n        Returns dict with locator info or None if no unique locator found.\n        \"\"\"\n        # Check cache first\n        if page_url and element_info.get('text'):\n            cached = self.cache.get(page_url, element_info['text'])\n            if cached:\n                print(f\"‚úÖ Using cached locator for '{element_info.get('text', 'element')[:30]}...'\")\n                return cached\n        \n        # Generate all possible locators\n        all_locators = await self.generate_all_possible_locators(element_info)\n        \n        if not all_locators:\n            print(\"‚ùå No locators could be generated from element info\")\n            return None\n        \n        print(f\"üîç Testing {len(all_locators)} locator strategies in parallel...\")\n        \n        # Test all locators in parallel\n        tasks = [self.verify_locator(loc[1]) for loc in all_locators]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Find best unique visible locator\n        best_locator = None\n        best_score = float('inf')\n        \n        for i, (score, locator_code, strategy) in enumerate(all_locators):\n            if isinstance(results[i], Exception):\n                print(f\"  ‚ö†Ô∏è  {strategy}: Error during validation\")\n                continue\n            \n            count, is_visible, error = results[i]\n            \n            if error:\n                print(f\"  ‚ö†Ô∏è  {strategy}: {error}\")\n                continue\n            \n            print(f\"  {'‚úÖ' if count == 1 else '‚ö†Ô∏è '} {strategy}: {locator_code} ‚Üí {count} match(es){' (visible)' if is_visible else ''}\")\n            \n            # Prefer unique locators that are visible\n            if count == 1 and is_visible and score < best_score:\n                best_locator = {\n                    'locator': locator_code,\n                    'strategy': strategy,\n                    'score': score,\n                    'count': count,\n                    'visible': is_visible,\n                    'unique': True,\n                    'confidence': 100 - min(score, 100)  # Convert score to confidence\n                }\n                best_score = score\n            # If no visible unique locator yet, accept non-visible unique\n            elif count == 1 and not best_locator and score < best_score:\n                best_locator = {\n                    'locator': locator_code,\n                    'strategy': strategy,\n                    'score': score,\n                    'count': count,\n                    'visible': is_visible,\n                    'unique': True,\n                    'confidence': 90 - min(score, 90)\n                }\n                best_score = score\n        \n        if best_locator:\n            print(f\"‚úÖ Best locator: {best_locator['strategy']} (confidence: {best_locator['confidence']}%)\")\n            \n            # Cache successful locator\n            if page_url and element_info.get('text'):\n                self.cache.set(page_url, element_info['text'], best_locator)\n            \n            return best_locator\n        \n        # No unique locator found - return best scored locator with warning\n        for i, (score, locator_code, strategy) in enumerate(all_locators):\n            if not isinstance(results[i], Exception):\n                count, is_visible, error = results[i]\n                if count > 0 and not error:\n                    print(f\"‚ö†Ô∏è  No unique locator found. Using: {strategy} (matches {count} elements)\")\n                    return {\n                        'locator': locator_code,\n                        'strategy': strategy,\n                        'score': score,\n                        'count': count,\n                        'visible': is_visible,\n                        'unique': False,\n                        'confidence': 50 - min(score // 10, 50)\n                    }\n        \n        print(\"‚ùå No valid locator found\")\n        return None\n    \n    async def validate_and_improve_locator(self, locator_code: str, element_info: Optional[Dict] = None) -> Dict:\n        \"\"\"\n        Validate an existing locator and suggest improvements if needed.\n        Returns validation result with alternative suggestions.\n        \"\"\"\n        count, is_visible, error = await self.verify_locator(locator_code)\n        \n        result = {\n            'original_locator': locator_code,\n            'is_valid': count == 1 and not error,\n            'count': count,\n            'visible': is_visible,\n            'error': error,\n            'alternatives': []\n        }\n        \n        # If locator is not unique or has errors, generate alternatives\n        if (count != 1 or error) and element_info:\n            print(f\"üîç Generating alternative locators...\")\n            best = await self.find_best_locator(element_info)\n            if best:\n                result['alternatives'] = [best]\n                result['recommended'] = best['locator']\n        \n        return result\n","size_bytes":18794},"visionvault/agents/config.py":{"content":"import os\nimport uuid\nimport socket\n\n\ndef get_server_url():\n    \"\"\"Auto-detect server URL based on environment\"\"\"\n    # Priority 1: User-specified environment variable\n    if os.environ.get('AGENT_SERVER_URL'):\n        return os.environ.get('AGENT_SERVER_URL')\n\n    # Priority 2: Check if running in same environment as server\n    # Look for common local development ports\n    local_ports = [7890, 5000, 8000, 3000]\n\n    for port in local_ports:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(0.5)\n            result = sock.connect_ex(('127.0.0.1', port))\n            sock.close()\n            if result == 0:  # Port is open\n                print(f\"‚úì Detected local server on port {port}\")\n                return f'http://127.0.0.1:{port}'\n        except:\n            pass\n\n    # Priority 3: Default to standard port 5000\n    print(\"‚Ñπ No server detected. Using default: http://127.0.0.1:5000\")\n    print(\"  Set AGENT_SERVER_URL environment variable to override\")\n    return 'http://127.0.0.1:5000'\n\n\n# Global configuration\nSERVER_URL = get_server_url()\nAGENT_ID = str(uuid.uuid4())","size_bytes":1148},"visionvault/services/vector_store.py":{"content":"import numpy as np\nimport faiss\nimport json\nimport os\nfrom typing import List, Dict, Tuple, Optional\nimport google.generativeai as genai\n\n\nclass VectorStore:\n    \"\"\"Vector store for semantic search using FAISS.\"\"\"\n    \n    def __init__(self, dimension=768, index_path='data/vector_index.faiss', \n                 metadata_path='data/vector_metadata.json'):\n        self.dimension = dimension  # Gemini embeddings are 768 dimensions\n        self.index_path = index_path\n        self.metadata_path = metadata_path\n        self.index = None\n        self.metadata = []  # Store task_ids corresponding to each vector\n        \n        # Initialize or load index\n        self._load_or_create_index()\n    \n    def _load_or_create_index(self):\n        \"\"\"Load existing index or create a new one.\"\"\"\n        if os.path.exists(self.index_path) and os.path.exists(self.metadata_path):\n            print(f\"Loading existing vector index from {self.index_path}\")\n            loaded_index = faiss.read_index(self.index_path)\n            with open(self.metadata_path, 'r') as f:\n                self.metadata = json.load(f)\n            \n            # Check if it's a legacy L2 index (needs migration to IP for cosine similarity)\n            index_type = type(loaded_index).__name__\n            if 'L2' in index_type or (hasattr(loaded_index, 'metric_type') and loaded_index.metric_type == faiss.METRIC_L2):\n                print(\"‚ö†Ô∏è  Detected legacy L2 index, migrating to cosine similarity (IndexFlatIP)...\")\n                # Rebuild as IP index with all existing vectors\n                self.index = faiss.IndexFlatIP(self.dimension)\n                for idx in range(loaded_index.ntotal):\n                    vector = loaded_index.reconstruct(idx)\n                    # Re-normalize vector for cosine similarity\n                    normalized = self._normalize_embedding(vector)\n                    self.index.add(normalized.reshape(1, -1))\n                print(f\"‚úÖ Migrated {loaded_index.ntotal} vectors to cosine similarity index\")\n                self._save_index()\n            else:\n                self.index = loaded_index\n        else:\n            print(\"Creating new vector index\")\n            # Using IndexFlatIP (Inner Product) for cosine similarity with normalized vectors\n            self.index = faiss.IndexFlatIP(self.dimension)\n            self.metadata = []\n            self._save_index()\n    \n    def _normalize_embedding(self, embedding: np.ndarray) -> np.ndarray:\n        \"\"\"Normalize embedding to unit length for cosine similarity.\"\"\"\n        norm = np.linalg.norm(embedding)\n        if norm > 0:\n            return embedding / norm\n        return embedding\n    \n    def _save_index(self):\n        \"\"\"Save index and metadata to disk.\"\"\"\n        faiss.write_index(self.index, self.index_path)\n        with open(self.metadata_path, 'w') as f:\n            json.dump(self.metadata, f)\n    \n    def add_vector(self, task_id: str, embedding: np.ndarray):\n        \"\"\"Add a vector and its metadata to the index.\"\"\"\n        if embedding.shape[0] != self.dimension:\n            raise ValueError(f\"Embedding dimension {embedding.shape[0]} does not match index dimension {self.dimension}\")\n        \n        # Normalize for cosine similarity\n        normalized_embedding = self._normalize_embedding(embedding)\n        \n        # FAISS expects vectors as float32 and in shape (1, dimension)\n        embedding_array = normalized_embedding.astype('float32').reshape(1, -1)\n        \n        # Add to index\n        self.index.add(embedding_array)\n        \n        # Add metadata\n        self.metadata.append(task_id)\n        \n        # Save to disk\n        self._save_index()\n    \n    def update_vector(self, task_id: str, new_embedding: np.ndarray):\n        \"\"\"Update a vector for an existing task_id.\"\"\"\n        # Find the index of the task_id\n        if task_id not in self.metadata:\n            # If not found, just add it\n            self.add_vector(task_id, new_embedding)\n            return\n        \n        # Normalize for cosine similarity\n        normalized_embedding = self._normalize_embedding(new_embedding)\n        \n        # FAISS doesn't support updates directly, so we need to rebuild\n        # Get all vectors except the one to update\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        # Create new index\n        new_index = faiss.IndexFlatIP(self.dimension)\n        new_metadata = []\n        \n        # Add all vectors except the one being updated\n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        # Add the updated vector\n        new_embedding_array = normalized_embedding.astype('float32').reshape(1, -1)\n        new_index.add(new_embedding_array)\n        new_metadata.append(task_id)\n        \n        # Replace old index and metadata\n        self.index = new_index\n        self.metadata = new_metadata\n        \n        # Save to disk\n        self._save_index()\n    \n    def search(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Tuple[str, float]]:\n        \"\"\"\n        Search for the most similar vectors using cosine similarity.\n        \n        Returns:\n            List of (task_id, similarity_score) tuples, sorted by similarity (higher score = more similar)\n        \"\"\"\n        if self.index.ntotal == 0:\n            return []\n        \n        # Normalize query for cosine similarity\n        normalized_query = self._normalize_embedding(query_embedding)\n        \n        # Ensure query is the right shape\n        query_array = normalized_query.astype('float32').reshape(1, -1)\n        \n        # Search (returns cosine similarity scores since we use IndexFlatIP with normalized vectors)\n        top_k = min(top_k, self.index.ntotal)  # Don't ask for more than we have\n        similarities, indices = self.index.search(query_array, top_k)\n        \n        # Build results\n        results = []\n        for i, idx in enumerate(indices[0]):\n            if idx < len(self.metadata):  # Safety check\n                task_id = self.metadata[idx]\n                # Cosine similarity is already in range [-1, 1], convert to [0, 1]\n                similarity = float((similarities[0][i] + 1) / 2)  # Normalize to 0-1 range\n                results.append((task_id, similarity))\n        \n        return results\n    \n    def delete_vector(self, task_id: str):\n        \"\"\"Delete a vector by task_id.\"\"\"\n        if task_id not in self.metadata:\n            return\n        \n        # Rebuild index without the deleted vector\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        new_index = faiss.IndexFlatIP(self.dimension)  # Use IP for cosine similarity\n        new_metadata = []\n        \n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            # Vector is already normalized, so just add it\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        self.index = new_index\n        self.metadata = new_metadata\n        \n        self._save_index()\n    \n    def get_all_task_ids(self) -> List[str]:\n        \"\"\"Get all task_ids in the index.\"\"\"\n        return self.metadata.copy()\n    \n    def clear(self):\n        \"\"\"Clear all vectors from the index.\"\"\"\n        self.index = faiss.IndexFlatIP(self.dimension)  # Use IP for cosine similarity\n        self.metadata = []\n        self._save_index()\n\n\nclass EmbeddingService:\n    \"\"\"Service for generating embeddings using Google Gemini API.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.api_key = api_key or os.environ.get('GEMINI_API_KEY')\n        if not self.api_key:\n            raise ValueError(\"Gemini API key is required for embedding generation. Please set GEMINI_API_KEY environment variable.\")\n        \n        genai.configure(api_key=self.api_key)\n        self.model = \"models/text-embedding-004\"  # Gemini's latest embedding model\n    \n    def generate_embedding(self, text: str) -> np.ndarray:\n        \"\"\"Generate embedding for a text string.\"\"\"\n        try:\n            result = genai.embed_content(\n                model=self.model,\n                content=text,\n                task_type=\"retrieval_document\"\n            )\n            \n            # Extract the embedding vector\n            embedding = np.array(result['embedding'], dtype=np.float32)\n            return embedding\n            \n        except Exception as e:\n            print(f\"Error generating embedding: {e}\")\n            raise\n    \n    def generate_task_embedding(self, task_name: str, description: str, tags: List[str]) -> np.ndarray:\n        \"\"\"\n        Generate embedding for a task based on its metadata.\n        Combines task name, description, and tags into a single text.\n        \"\"\"\n        # Create a comprehensive text representation\n        text_parts = [task_name]\n        \n        if description:\n            text_parts.append(description)\n        \n        if tags:\n            text_parts.append(\"Tags: \" + \", \".join(tags))\n        \n        combined_text = \". \".join(text_parts)\n        \n        return self.generate_embedding(combined_text)\n\n\nclass SemanticSearch:\n    \"\"\"High-level semantic search service combining VectorStore and EmbeddingService.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.vector_store = VectorStore()\n        self.embedding_service = EmbeddingService(api_key)\n    \n    def index_task(self, task):\n        \"\"\"Index a LearnedTask for semantic search.\"\"\"\n        # Generate embedding from task metadata\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        # Add to vector store\n        self.vector_store.add_vector(task.task_id, embedding)\n        \n        # Also save embedding with the task\n        task.embedding_vector = embedding\n        task.save()\n    \n    def update_task_index(self, task):\n        \"\"\"Update the index for an existing task.\"\"\"\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        self.vector_store.update_vector(task.task_id, embedding)\n        \n        task.embedding_vector = embedding\n        task.save()\n    \n    def search_tasks(self, query: str, top_k: int = 5) -> List[Dict]:\n        \"\"\"\n        Search for tasks similar to the query.\n        \n        Returns:\n            List of task dictionaries with similarity scores\n        \"\"\"\n        # Generate embedding for query\n        query_embedding = self.embedding_service.generate_embedding(query)\n        \n        # Search vector store\n        results = self.vector_store.search(query_embedding, top_k)\n        \n        # Fetch task details from database\n        from visionvault.core.models import LearnedTask\n        \n        tasks_with_scores = []\n        for task_id, similarity_score in results:\n            task = LearnedTask.get_by_id(task_id)\n            if task:\n                task_dict = task.to_dict()\n                # similarity_score is already in range [0, 1] from cosine similarity\n                task_dict['similarity_score'] = float(similarity_score)\n                tasks_with_scores.append(task_dict)\n        \n        return tasks_with_scores\n    \n    def delete_task_from_index(self, task_id: str):\n        \"\"\"Remove a task from the search index.\"\"\"\n        self.vector_store.delete_vector(task_id)\n    \n    def reindex_all_tasks(self):\n        \"\"\"Rebuild the entire search index from scratch.\"\"\"\n        from visionvault.core.models import LearnedTask\n        \n        # Clear existing index\n        self.vector_store.clear()\n        \n        # Get all tasks\n        all_tasks = LearnedTask.get_all(limit=10000)\n        \n        # Index each task\n        for task in all_tasks:\n            try:\n                self.index_task(task)\n                print(f\"Indexed task: {task.task_name}\")\n            except Exception as e:\n                print(f\"Failed to index task {task.task_id}: {e}\")\n","size_bytes":12244},"visionvault/core/models.py":{"content":"import sqlite3\nimport json\nfrom datetime import datetime\n\nclass Database:\n    def __init__(self, db_path='data/automation.db'):\n        self.db_path = db_path\n        self.init_db()\n    \n    def init_db(self):\n        \"\"\"Initialize all database tables.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        \n        # Existing test_history table\n        c.execute('''CREATE TABLE IF NOT EXISTS test_history\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      command TEXT NOT NULL,\n                      generated_code TEXT NOT NULL,\n                      healed_code TEXT,\n                      browser TEXT,\n                      mode TEXT,\n                      execution_location TEXT,\n                      status TEXT,\n                      logs TEXT,\n                      screenshot_path TEXT,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # New learned_tasks table for persistent learning\n        c.execute('''CREATE TABLE IF NOT EXISTS learned_tasks\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT UNIQUE NOT NULL,\n                      task_name TEXT NOT NULL,\n                      description TEXT,\n                      steps TEXT,\n                      playwright_code TEXT NOT NULL,\n                      tags TEXT,\n                      embedding_vector BLOB,\n                      version INTEGER DEFAULT 1,\n                      parent_task_id TEXT,\n                      success_count INTEGER DEFAULT 0,\n                      failure_count INTEGER DEFAULT 0,\n                      last_executed TIMESTAMP,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # Task execution history for feedback loop\n        c.execute('''CREATE TABLE IF NOT EXISTS task_executions\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT NOT NULL,\n                      execution_result TEXT,\n                      success BOOLEAN,\n                      error_message TEXT,\n                      execution_time_ms INTEGER,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      FOREIGN KEY (task_id) REFERENCES learned_tasks(task_id))''')\n        \n        # Create indices for faster queries\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_id ON learned_tasks(task_id)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_name ON learned_tasks(task_name)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_created_at ON learned_tasks(created_at)')\n        \n        conn.commit()\n        conn.close()\n\n\nclass LearnedTask:\n    \"\"\"Model for a learned automation task.\"\"\"\n    \n    def __init__(self, task_id, task_name, playwright_code, description='', steps=None, \n                 tags=None, embedding_vector=None, version=1, parent_task_id=None):\n        self.task_id = task_id\n        self.task_name = task_name\n        self.description = description\n        self.steps = steps or []\n        self.playwright_code = playwright_code\n        self.tags = tags or []\n        self.embedding_vector = embedding_vector\n        self.version = version\n        self.parent_task_id = parent_task_id\n        self.success_count = 0\n        self.failure_count = 0\n        self.last_executed = None\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n    \n    def to_dict(self):\n        \"\"\"Convert task to dictionary.\"\"\"\n        return {\n            'task_id': self.task_id,\n            'task_name': self.task_name,\n            'description': self.description,\n            'steps': self.steps,\n            'playwright_code': self.playwright_code,\n            'tags': self.tags,\n            'version': self.version,\n            'parent_task_id': self.parent_task_id,\n            'success_count': self.success_count,\n            'failure_count': self.failure_count,\n            'last_executed': self.last_executed.isoformat() if self.last_executed else None,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save task to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Serialize complex fields\n        steps_json = json.dumps(self.steps)\n        tags_json = json.dumps(self.tags)\n        \n        # Serialize embedding vector if present\n        embedding_blob = None\n        if self.embedding_vector is not None:\n            import numpy as np\n            embedding_blob = self.embedding_vector.tobytes()\n        \n        c.execute('''INSERT OR REPLACE INTO learned_tasks \n                     (task_id, task_name, description, steps, playwright_code, tags, \n                      embedding_vector, version, parent_task_id, success_count, \n                      failure_count, last_executed, updated_at)\n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',\n                  (self.task_id, self.task_name, self.description, steps_json, \n                   self.playwright_code, tags_json, embedding_blob, self.version,\n                   self.parent_task_id, self.success_count, self.failure_count,\n                   self.last_executed, datetime.now()))\n        \n        conn.commit()\n        conn.close()\n    \n    @staticmethod\n    def get_by_id(task_id, db_path='data/automation.db'):\n        \"\"\"Retrieve task by ID.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks WHERE task_id=?', (task_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return None\n        \n        return LearnedTask._from_row(row)\n    \n    @staticmethod\n    def get_all(db_path='data/automation.db', limit=100):\n        \"\"\"Retrieve all tasks.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks ORDER BY created_at DESC LIMIT ?', (limit,))\n        rows = c.fetchall()\n        conn.close()\n        \n        return [LearnedTask._from_row(row) for row in rows]\n    \n    @staticmethod\n    def search_by_tags(tags, db_path='data/automation.db'):\n        \"\"\"Search tasks by tags.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Simple tag search - checks if any tag is present in the tags JSON\n        tasks = []\n        c.execute('SELECT * FROM learned_tasks')\n        rows = c.fetchall()\n        \n        for row in rows:\n            task_tags = json.loads(row[6]) if row[6] else []\n            if any(tag in task_tags for tag in tags):\n                tasks.append(LearnedTask._from_row(row))\n        \n        conn.close()\n        return tasks\n    \n    @staticmethod\n    def _from_row(row):\n        \"\"\"Create LearnedTask from database row.\"\"\"\n        import numpy as np\n        \n        task = LearnedTask(\n            task_id=row[1],\n            task_name=row[2],\n            description=row[3],\n            steps=json.loads(row[4]) if row[4] else [],\n            playwright_code=row[5],\n            tags=json.loads(row[6]) if row[6] else [],\n            version=row[8],\n            parent_task_id=row[9]\n        )\n        \n        # Deserialize embedding vector\n        if row[7]:\n            task.embedding_vector = np.frombuffer(row[7], dtype=np.float32)\n        \n        task.success_count = row[10] or 0\n        task.failure_count = row[11] or 0\n        task.last_executed = datetime.fromisoformat(row[12]) if row[12] else None\n        task.created_at = datetime.fromisoformat(row[13]) if row[13] else datetime.now()\n        task.updated_at = datetime.fromisoformat(row[14]) if row[14] else datetime.now()\n        \n        return task\n\n\nclass TaskExecution:\n    \"\"\"Model for task execution record.\"\"\"\n    \n    def __init__(self, task_id, execution_result, success, error_message=None, execution_time_ms=0):\n        self.task_id = task_id\n        self.execution_result = execution_result\n        self.success = success\n        self.error_message = error_message\n        self.execution_time_ms = execution_time_ms\n        self.created_at = datetime.now()\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save execution record to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        c.execute('''INSERT INTO task_executions \n                     (task_id, execution_result, success, error_message, execution_time_ms)\n                     VALUES (?, ?, ?, ?, ?)''',\n                  (self.task_id, self.execution_result, self.success, \n                   self.error_message, self.execution_time_ms))\n        \n        conn.commit()\n        conn.close()\n","size_bytes":8928},"visionvault/services/executor.py":{"content":"import asyncio\nimport sys\nfrom io import StringIO\nfrom visionvault.services.code_validator import CodeValidator\n\nclass ServerExecutor:\n    def execute(self, code, browser_name='chromium', headless=True):\n        try:\n            validator = CodeValidator()\n            if not validator.validate(code):\n                return {\n                    'success': False,\n                    'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                    'screenshot': None\n                }\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True,\n                    'False': False,\n                    'None': None,\n                    'dict': dict,\n                    'list': list,\n                    'str': str,\n                    'int': int,\n                    'float': float,\n                    'bool': bool,\n                    'len': len,\n                    'range': range,\n                    'enumerate': enumerate,\n                    'zip': zip,\n                    'Exception': Exception,\n                    'ValueError': ValueError,\n                    'TypeError': TypeError,\n                    'KeyError': KeyError,\n                    'AttributeError': AttributeError,\n                    'getattr': getattr,\n                    'setattr': setattr,\n                    'hasattr': hasattr,\n                    'print': print,\n                    '__import__': __import__,\n\n                }\n            }\n            \n            local_vars = {}\n            exec(code, restricted_globals, local_vars)\n            \n            if 'run_test' not in local_vars:\n                return {\n                    'success': False,\n                    'logs': ['Error: Generated code must contain a run_test function'],\n                    'screenshot': None\n                }\n            \n            run_test = local_vars['run_test']\n            \n            result = asyncio.run(run_test(browser_name=browser_name, headless=headless))\n            \n            return result\n        except Exception as e:\n            return {\n                'success': False,\n                'logs': [f'Execution error: {str(e)}'],\n                'screenshot': None\n            }\n","size_bytes":2270},"visionvault/services/intelligent_planner.py":{"content":"\"\"\"\nIntelligent Pre-Execution Planner\n\nThis module analyzes user commands BEFORE execution to:\n1. Predict potential failures and edge cases\n2. Generate multiple execution strategies\n3. Pre-validate URLs and element availability\n4. Optimize execution path for speed and reliability\n5. Provide confidence scores and risk assessment\n\"\"\"\n\nimport re\nfrom typing import Dict, List, Optional\nfrom openai import OpenAI\n\n\nclass IntelligentPlanner:\n    \"\"\"AI-powered pre-execution planning and analysis\"\"\"\n\n    def __init__(self, openai_client: Optional[OpenAI] = None):\n        self.client = openai_client\n        self.common_patterns = self._load_common_patterns()\n\n    def _load_common_patterns(self) -> Dict:\n        \"\"\"Load common automation patterns and success strategies\"\"\"\n        return {\n            'search': {\n                'keywords': ['search', 'find', 'look for', 'query'],\n                'common_issues': [\n                    'search box not visible', 'autocomplete interference',\n                    'slow page load'\n                ],\n                'best_practices': [\n                    'wait for search box', 'use placeholder locator',\n                    'handle autocomplete'\n                ]\n            },\n            'login': {\n                'keywords': ['login', 'sign in', 'authenticate', 'log in'],\n                'common_issues':\n                ['captcha', 'two-factor auth', 'session timeout'],\n                'best_practices':\n                ['wait for form', 'check for errors', 'handle redirects']\n            },\n            'form_fill': {\n                'keywords': ['fill', 'enter', 'type', 'input'],\n                'common_issues':\n                ['validation errors', 'required fields', 'field not ready'],\n                'best_practices': [\n                    'wait for field visibility', 'validate after fill',\n                    'handle dropdowns'\n                ]\n            },\n            'navigation': {\n                'keywords': ['go to', 'navigate', 'open', 'visit'],\n                'common_issues': ['slow load', 'redirects', 'cookie banners'],\n                'best_practices':\n                ['wait for load state', 'handle popups', 'extended timeout']\n            },\n            'click': {\n                'keywords': ['click', 'press', 'select', 'choose'],\n                'common_issues':\n                ['element not clickable', 'covered by overlay', 'not visible'],\n                'best_practices':\n                ['scroll into view', 'wait for visible', 'check for overlays']\n            }\n        }\n\n    def analyze_command(self, command: str) -> Dict:\n        \"\"\"\n        Analyze command and generate execution plan with risk assessment.\n        Returns: {\n            'intent': str,\n            'complexity': str (low/medium/high),\n            'predicted_steps': List[str],\n            'potential_issues': List[str],\n            'recommended_strategies': List[str],\n            'confidence_score': float (0-100),\n            'estimated_time': str\n        }\n        \"\"\"\n        if not self.client:\n            return self._basic_analysis(command)\n\n        try:\n            # Use GPT-4o for deep command understanding\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\n                    \"role\":\n                    \"system\",\n                    \"content\":\n                    \"\"\"You are an expert automation planner with deep understanding of web applications.\n\nAnalyze the user's automation command and provide a detailed execution plan.\n\nYour analysis must include:\n1. PRIMARY INTENT: What the user wants to accomplish\n2. COMPLEXITY: low/medium/high based on steps and potential issues\n3. PREDICTED STEPS: Detailed step-by-step breakdown\n4. POTENTIAL ISSUES: Common failures (slow load, dynamic content, overlays, SPAs, auth, etc.)\n5. RECOMMENDED STRATEGIES: Best practices to avoid failures\n6. CONFIDENCE SCORE: 0-100 based on clarity and feasibility\n7. ESTIMATED TIME: Expected execution time (e.g., \"10-20 seconds\")\n\nConsider:\n- Website type (SPA, static, e-commerce, etc.)\n- Dynamic content and async loading\n- Common UI patterns (modals, dropdowns, autocomplete)\n- Potential blockers (captcha, auth, cookies)\n- Element stability and visibility\n- Network delays and page load times\n\nReturn a comprehensive analysis that helps generate flawless code.\"\"\"\n                }, {\n                    \"role\":\n                    \"user\",\n                    \"content\":\n                    f\"Analyze this automation command and create an execution plan:\\n\\n{command}\"\n                }],\n                temperature=0.3)\n\n            analysis_text = response.choices[0].message.content.strip()\n\n            # Parse the AI response into structured format\n            return self._parse_ai_analysis(analysis_text, command)\n\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  AI planning error: {e}\")\n            return self._basic_analysis(command)\n\n    def _parse_ai_analysis(self, analysis_text: str, command: str) -> Dict:\n        \"\"\"Parse AI analysis into structured format\"\"\"\n\n        # Extract sections from AI response\n        intent = self._extract_section(analysis_text,\n                                       ['PRIMARY INTENT', 'INTENT', 'PURPOSE'])\n        complexity = self._extract_complexity(analysis_text)\n        steps = self._extract_list(\n            analysis_text, ['PREDICTED STEPS', 'STEPS', 'EXECUTION STEPS'])\n        issues = self._extract_list(analysis_text,\n                                    ['POTENTIAL ISSUES', 'ISSUES', 'RISKS'])\n        strategies = self._extract_list(\n            analysis_text,\n            ['RECOMMENDED STRATEGIES', 'STRATEGIES', 'BEST PRACTICES'])\n        confidence = self._extract_confidence(analysis_text)\n        time_est = self._extract_section(\n            analysis_text, ['ESTIMATED TIME', 'TIME', 'DURATION'])\n\n        return {\n            'intent':\n            intent or self._infer_intent(command),\n            'complexity':\n            complexity or 'medium',\n            'predicted_steps':\n            steps or ['Execute command'],\n            'potential_issues':\n            issues or ['Standard web automation risks'],\n            'recommended_strategies':\n            strategies or ['Use robust locators', 'Add proper waits'],\n            'confidence_score':\n            confidence or 70.0,\n            'estimated_time':\n            time_est or '10-30 seconds',\n            'full_analysis':\n            analysis_text\n        }\n\n    def _extract_section(self, text: str, headers: List[str]) -> str:\n        \"\"\"Extract content from a section with given headers\"\"\"\n        for header in headers:\n            pattern = rf\"{header}[:\\s]+(.+?)(?=\\n(?:[A-Z\\s]+:|$))\"\n            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n            if match:\n                return match.group(1).strip()\n        return \"\"\n\n    def _extract_list(self, text: str, headers: List[str]) -> List[str]:\n        \"\"\"Extract bulleted or numbered list from text\"\"\"\n        section = self._extract_section(text, headers)\n        if not section:\n            return []\n\n        # Find list items (bullets, numbers, dashes)\n        items = re.findall(r'(?:^|\\n)[\\s]*(?:[-‚Ä¢*]|\\d+\\.)\\s*(.+)', section)\n        if items:\n            return [item.strip() for item in items if item.strip()]\n\n        # Fallback: split by newlines\n        lines = [line.strip() for line in section.split('\\n') if line.strip()]\n        return lines[:5]  # Limit to 5 items\n\n    def _extract_complexity(self, text: str) -> str:\n        \"\"\"Extract complexity level\"\"\"\n        text_lower = text.lower()\n        if 'complexity: low' in text_lower or 'low complexity' in text_lower:\n            return 'low'\n        elif 'complexity: high' in text_lower or 'high complexity' in text_lower:\n            return 'high'\n        elif 'complexity: medium' in text_lower or 'medium complexity' in text_lower:\n            return 'medium'\n        return 'medium'\n\n    def _extract_confidence(self, text: str) -> float:\n        \"\"\"Extract confidence score\"\"\"\n        # Look for patterns like \"85%\", \"confidence: 90\", etc.\n        patterns = [\n            r'confidence[:\\s]+(\\d+)', r'(\\d+)%?\\s*confidence',\n            r'score[:\\s]+(\\d+)'\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return float(match.group(1))\n\n        return 75.0  # Default confidence\n\n    def _basic_analysis(self, command: str) -> Dict:\n        \"\"\"Fallback analysis without AI\"\"\"\n        intent = self._infer_intent(command)\n        pattern = self._match_pattern(command)\n\n        return {\n            'intent':\n            intent,\n            'complexity':\n            'medium',\n            'predicted_steps': [f'Execute: {command}'],\n            'potential_issues':\n            pattern.get('common_issues', ['Standard risks'])\n            if pattern else ['Standard risks'],\n            'recommended_strategies':\n            pattern.get('best_practices', ['Use robust locators'])\n            if pattern else ['Use robust locators'],\n            'confidence_score':\n            70.0,\n            'estimated_time':\n            '10-30 seconds',\n            'full_analysis':\n            'Basic analysis (AI not available)'\n        }\n\n    def _infer_intent(self, command: str) -> str:\n        \"\"\"Infer user intent from command\"\"\"\n        command_lower = command.lower()\n\n        if any(kw in command_lower for kw in ['search', 'find', 'look for']):\n            return 'Search for information'\n        elif any(kw in command_lower for kw in ['login', 'sign in', 'log in']):\n            return 'Authenticate user'\n        elif any(kw in command_lower for kw in ['buy', 'purchase', 'order']):\n            return 'Complete purchase'\n        elif any(kw in command_lower for kw in ['fill', 'enter', 'submit']):\n            return 'Fill and submit form'\n        elif any(kw in command_lower for kw in ['click', 'press', 'select']):\n            return 'Interact with element'\n        elif any(kw in command_lower\n                 for kw in ['go to', 'navigate', 'open', 'visit']):\n            return 'Navigate to page'\n        else:\n            return 'Execute automation task'\n\n    def _match_pattern(self, command: str) -> Optional[Dict]:\n        \"\"\"Match command to known patterns\"\"\"\n        command_lower = command.lower()\n\n        for pattern_name, pattern in self.common_patterns.items():\n            if any(kw in command_lower for kw in pattern['keywords']):\n                return pattern\n\n        return None\n\n    def generate_optimized_prompt(self, command: str, analysis: Dict) -> str:\n        \"\"\"\n        Generate enhanced prompt for code generation based on analysis.\n        Includes predicted issues and recommended strategies.\n        \"\"\"\n        strategies_text = '\\n'.join(\n            [f\"- {s}\" for s in analysis['recommended_strategies']])\n        issues_text = '\\n'.join(\n            [f\"- {s}\" for s in analysis['potential_issues']])\n\n        enhanced_prompt = f\"\"\"Generate Playwright code for: {command}\n\nEXECUTION PLAN ANALYSIS:\nIntent: {analysis['intent']}\nComplexity: {analysis['complexity']}\nConfidence: {analysis['confidence_score']:.0f}%\n\nPREDICTED POTENTIAL ISSUES:\n{issues_text}\n\nREQUIRED STRATEGIES (MANDATORY):\n{strategies_text}\n\nCRITICAL REQUIREMENTS:\n1. Implement ALL recommended strategies above\n2. Add robust error handling for predicted issues\n3. Use intelligent waits (wait_for_load_state, wait_for_selector with visible/attached states)\n4. Include retry logic for dynamic content\n5. Handle common blockers (cookie banners, overlays, modals)\n6. Add detailed logging for each step\n7. Use the most reliable locators (testId > role > placeholder > label > text)\n8. Set appropriate timeouts (10000ms for critical operations)\n\nGenerate production-ready code that anticipates and handles these issues proactively.\"\"\"\n\n        return enhanced_prompt\n","size_bytes":12006},"visionvault/services/self_learning_engine.py":{"content":"\"\"\"\nSelf-Learning Engine\n\nThis module enables the system to:\n1. Learn from successful executions and failures\n2. Build a knowledge base of working patterns\n3. Adapt strategies based on past performance\n4. Predict success probability for new commands\n5. Continuously improve over time\n\"\"\"\n\nimport json\nimport os\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport hashlib\n\n\nclass SelfLearningEngine:\n    \"\"\"AI system that learns from experience and improves over time\"\"\"\n    \n    def __init__(self, knowledge_file='data/learned_knowledge.json'):\n        self.knowledge_file = knowledge_file\n        self.knowledge_base = self._load_knowledge()\n        self.session_learnings = []\n    \n    def _load_knowledge(self) -> Dict:\n        \"\"\"Load accumulated knowledge from disk\"\"\"\n        try:\n            if os.path.exists(self.knowledge_file):\n                with open(self.knowledge_file, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Could not load knowledge base: {e}\")\n        \n        return {\n            'successful_patterns': {},  # Patterns that consistently work\n            'failure_patterns': {},      # Patterns that consistently fail\n            'locator_success_rates': {}, # Success rate per locator type\n            'website_patterns': {},      # Learned patterns per website\n            'command_patterns': {},      # Common command structures\n            'total_executions': 0,\n            'total_successes': 0,\n            'total_failures': 0,\n            'success_rate': 0.0\n        }\n    \n    def _save_knowledge(self):\n        \"\"\"Persist knowledge to disk\"\"\"\n        try:\n            os.makedirs(os.path.dirname(self.knowledge_file), exist_ok=True)\n            \n            # Update success rate\n            if self.knowledge_base['total_executions'] > 0:\n                self.knowledge_base['success_rate'] = (\n                    self.knowledge_base['total_successes'] / \n                    self.knowledge_base['total_executions'] * 100\n                )\n            \n            with open(self.knowledge_file, 'w') as f:\n                json.dump(self.knowledge_base, f, indent=2)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Could not save knowledge base: {e}\")\n    \n    def learn_from_execution(\n        self,\n        command: str,\n        code: str,\n        result: Dict,\n        healing_attempts: int = 0,\n        url: str = ''\n    ):\n        \"\"\"Learn from a completed execution (successful or failed)\"\"\"\n        \n        success = result.get('success', False)\n        \n        # Update global stats\n        self.knowledge_base['total_executions'] += 1\n        if success:\n            self.knowledge_base['total_successes'] += 1\n        else:\n            self.knowledge_base['total_failures'] += 1\n        \n        # Extract patterns\n        command_pattern = self._extract_command_pattern(command)\n        locators_used = self._extract_locators(code)\n        website = self._extract_website(url or code)\n        \n        # Learn command patterns\n        if command_pattern not in self.knowledge_base['command_patterns']:\n            self.knowledge_base['command_patterns'][command_pattern] = {\n                'total': 0,\n                'successes': 0,\n                'avg_healing_attempts': 0.0,\n                'best_locators': []\n            }\n        \n        pattern_data = self.knowledge_base['command_patterns'][command_pattern]\n        pattern_data['total'] += 1\n        if success:\n            pattern_data['successes'] += 1\n        \n        # Update average healing attempts\n        pattern_data['avg_healing_attempts'] = (\n            (pattern_data['avg_healing_attempts'] * (pattern_data['total'] - 1) + healing_attempts) /\n            pattern_data['total']\n        )\n        \n        # Learn locator success rates\n        for locator_type in locators_used:\n            if locator_type not in self.knowledge_base['locator_success_rates']:\n                self.knowledge_base['locator_success_rates'][locator_type] = {\n                    'total': 0,\n                    'successes': 0,\n                    'success_rate': 0.0\n                }\n            \n            loc_data = self.knowledge_base['locator_success_rates'][locator_type]\n            loc_data['total'] += 1\n            if success:\n                loc_data['successes'] += 1\n            loc_data['success_rate'] = (loc_data['successes'] / loc_data['total'] * 100)\n            \n            # Track best locators for this command pattern\n            if success and locator_type not in pattern_data['best_locators']:\n                pattern_data['best_locators'].append(locator_type)\n        \n        # Learn website-specific patterns\n        if website:\n            if website not in self.knowledge_base['website_patterns']:\n                self.knowledge_base['website_patterns'][website] = {\n                    'total_visits': 0,\n                    'successful_locators': [],\n                    'common_issues': [],\n                    'best_practices': []\n                }\n            \n            site_data = self.knowledge_base['website_patterns'][website]\n            site_data['total_visits'] += 1\n            \n            if success:\n                for loc in locators_used:\n                    if loc not in site_data['successful_locators']:\n                        site_data['successful_locators'].append(loc)\n        \n        # Record session learning\n        self.session_learnings.append({\n            'command': command,\n            'success': success,\n            'healing_attempts': healing_attempts,\n            'timestamp': datetime.now().isoformat()\n        })\n        \n        # Save knowledge\n        self._save_knowledge()\n        \n        print(f\"üìö Learning recorded: {command_pattern} ({'‚úÖ Success' if success else '‚ùå Failed'})\")\n    \n    def _extract_command_pattern(self, command: str) -> str:\n        \"\"\"Extract high-level pattern from command\"\"\"\n        command_lower = command.lower()\n        \n        patterns = {\n            'search': ['search', 'find', 'look for', 'query'],\n            'login': ['login', 'sign in', 'log in', 'authenticate'],\n            'form_fill': ['fill', 'enter', 'type', 'input'],\n            'navigation': ['go to', 'navigate', 'open', 'visit'],\n            'click': ['click', 'press', 'select', 'choose'],\n            'purchase': ['buy', 'purchase', 'order', 'checkout'],\n            'extract': ['get', 'extract', 'scrape', 'collect']\n        }\n        \n        for pattern, keywords in patterns.items():\n            if any(kw in command_lower for kw in keywords):\n                return pattern\n        \n        return 'general'\n    \n    def _extract_locators(self, code: str) -> List[str]:\n        \"\"\"Extract locator types used in code\"\"\"\n        locators = []\n        \n        locator_patterns = {\n            'get_by_test_id': 'testid',\n            'get_by_role': 'role',\n            'get_by_text': 'text',\n            'get_by_placeholder': 'placeholder',\n            'get_by_label': 'label',\n            'get_by_alt_text': 'alt',\n            'get_by_title': 'title',\n            'page.locator': 'css_selector'\n        }\n        \n        for pattern, loc_type in locator_patterns.items():\n            if pattern in code:\n                locators.append(loc_type)\n        \n        return list(set(locators))  # Unique locators\n    \n    def _extract_website(self, url_or_code: str) -> str:\n        \"\"\"Extract website domain\"\"\"\n        import re\n        \n        # Try to find URL in string\n        url_pattern = r'https?://(?:www\\.)?([^/\\s]+)'\n        match = re.search(url_pattern, url_or_code)\n        \n        if match:\n            domain = match.group(1)\n            # Remove common subdomains\n            domain = domain.replace('www.', '')\n            return domain\n        \n        return ''\n    \n    def get_recommendations(self, command: str, url: str = '') -> Dict:\n        \"\"\"Get learned recommendations for a command\"\"\"\n        \n        pattern = self._extract_command_pattern(command)\n        website = self._extract_website(url)\n        \n        recommendations = {\n            'predicted_success_rate': self.knowledge_base.get('success_rate', 70.0),\n            'recommended_locators': [],\n            'potential_issues': [],\n            'best_practices': [],\n            'confidence': 70.0\n        }\n        \n        # Get command pattern recommendations\n        if pattern in self.knowledge_base['command_patterns']:\n            pattern_data = self.knowledge_base['command_patterns'][pattern]\n            \n            if pattern_data['total'] > 0:\n                pattern_success_rate = (pattern_data['successes'] / pattern_data['total'] * 100)\n                recommendations['predicted_success_rate'] = pattern_success_rate\n                recommendations['recommended_locators'] = pattern_data['best_locators']\n                recommendations['confidence'] = min(90, 50 + pattern_data['total'] * 5)\n        \n        # Get website-specific recommendations\n        if website and website in self.knowledge_base['website_patterns']:\n            site_data = self.knowledge_base['website_patterns'][website]\n            recommendations['recommended_locators'].extend(site_data['successful_locators'])\n            recommendations['potential_issues'] = site_data.get('common_issues', [])\n            recommendations['best_practices'] = site_data.get('best_practices', [])\n        \n        # Get best performing locators overall\n        best_locators = sorted(\n            self.knowledge_base['locator_success_rates'].items(),\n            key=lambda x: x[1]['success_rate'],\n            reverse=True\n        )[:3]\n        \n        for loc_type, data in best_locators:\n            if loc_type not in recommendations['recommended_locators']:\n                recommendations['recommended_locators'].append(loc_type)\n        \n        return recommendations\n    \n    def get_learning_stats(self) -> Dict:\n        \"\"\"Get learning statistics\"\"\"\n        return {\n            'total_executions': self.knowledge_base['total_executions'],\n            'overall_success_rate': self.knowledge_base['success_rate'],\n            'patterns_learned': len(self.knowledge_base['command_patterns']),\n            'websites_learned': len(self.knowledge_base['website_patterns']),\n            'locator_types_tracked': len(self.knowledge_base['locator_success_rates']),\n            'best_locators': self._get_best_locators(3),\n            'session_learnings': len(self.session_learnings)\n        }\n    \n    def _get_best_locators(self, top_n: int = 3) -> List[Dict]:\n        \"\"\"Get top N best performing locators\"\"\"\n        locators = [\n            {\n                'type': loc_type,\n                'success_rate': data['success_rate'],\n                'total_uses': data['total']\n            }\n            for loc_type, data in self.knowledge_base['locator_success_rates'].items()\n            if data['total'] >= 3  # Minimum 3 uses for statistical significance\n        ]\n        \n        # Sort by success rate, then by total uses\n        locators.sort(key=lambda x: (x['success_rate'], x['total_uses']), reverse=True)\n        \n        return locators[:top_n]\n","size_bytes":11232},"visionvault/services/dom_inspector.py":{"content":"\"\"\"\nDOM Inspector Service\nAnalyzes web pages to extract element information for intelligent locator selection.\n\"\"\"\nimport asyncio\nimport re\nfrom typing import Dict, List, Optional\nfrom playwright.async_api import async_playwright, Page\n\n\nclass DOMInspector:\n    \"\"\"Inspects DOM structure to help AI select perfect locators\"\"\"\n    \n    def __init__(self):\n        self.browser = None\n        self.context = None\n        self.page = None\n    \n    async def analyze_page(self, url: str, user_command: str) -> Dict:\n        \"\"\"\n        Navigate to a page and extract element information for intelligent locator selection.\n        \n        Args:\n            url: The URL to analyze\n            user_command: The user's natural language command to understand intent\n            \n        Returns:\n            Dict containing available elements, their attributes, and recommended locators\n        \"\"\"\n        try:\n            async with async_playwright() as p:\n                browser = await p.chromium.launch(headless=True)\n                page = await browser.new_page()\n                \n                # Navigate to the page\n                await page.goto(url, timeout=15000, wait_until='domcontentloaded')\n                \n                # Extract page information\n                page_info = {\n                    'url': url,\n                    'title': await page.title(),\n                    'interactive_elements': await self._extract_interactive_elements(page),\n                    'form_elements': await self._extract_form_elements(page),\n                    'navigation_elements': await self._extract_navigation_elements(page),\n                    'intent_matched_elements': await self._match_user_intent(page, user_command)\n                }\n                \n                await browser.close()\n                return page_info\n                \n        except Exception as e:\n            return {\n                'error': str(e),\n                'url': url,\n                'message': 'Could not inspect DOM, AI will use standard locator strategies'\n            }\n    \n    async def _extract_interactive_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract all interactive elements (buttons, links, inputs)\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Buttons\n                document.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {  // Only visible elements\n                        elements.push({\n                            type: 'button',\n                            tag: el.tagName.toLowerCase(),\n                            text: el.textContent.trim() || el.value || '',\n                            role: el.getAttribute('role') || 'button',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            id: el.id,\n                            testId: el.getAttribute('data-testid'),\n                            classes: el.className,\n                            value: el.value || ''\n                        });\n                    }\n                });\n                \n                // Links\n                document.querySelectorAll('a').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'link',\n                            tag: el.tagName.toLowerCase(),\n                            text: el.textContent.trim(),\n                            href: el.href,\n                            role: el.getAttribute('role') || 'link',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            id: el.id,\n                            testId: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _extract_form_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract form inputs with their labels and attributes\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Text inputs, textareas\n                document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], input[type=\"search\"], input:not([type]), textarea').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        // Find associated label\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        if (!labelText) {\n                            const parentLabel = el.closest('label');\n                            if (parentLabel) labelText = parentLabel.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: 'input',\n                            tag: el.tagName.toLowerCase(),\n                            inputType: el.type || 'text',\n                            placeholder: el.placeholder,\n                            label: labelText,\n                            role: el.getAttribute('role') || (el.type === 'search' ? 'combobox' : 'textbox'),\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            id: el.id,\n                            testId: el.getAttribute('data-testid'),\n                            autocomplete: el.autocomplete,\n                            value: el.value || ''\n                        });\n                    }\n                });\n                \n                // Checkboxes and radios\n                document.querySelectorAll('input[type=\"checkbox\"], input[type=\"radio\"]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: el.type,\n                            tag: el.tagName.toLowerCase(),\n                            label: labelText,\n                            role: el.type,\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            id: el.id,\n                            testId: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                // Select dropdowns\n                document.querySelectorAll('select').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: 'select',\n                            tag: el.tagName.toLowerCase(),\n                            label: labelText,\n                            role: 'combobox',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            id: el.id,\n                            testId: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _extract_navigation_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract navigation elements (nav links, menus)\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                document.querySelectorAll('nav a, [role=\"navigation\"] a').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'nav-link',\n                            tag: el.tagName.toLowerCase(),\n                            text: el.textContent.trim(),\n                            href: el.href,\n                            role: 'link',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || ''\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _match_user_intent(self, page: Page, user_command: str) -> List[Dict]:\n        \"\"\"\n        Match user intent to specific elements on the page.\n        For example: \"search for cats\" -> find search box\n        \"\"\"\n        command_lower = user_command.lower()\n        matched_elements = []\n        \n        # Search intent\n        if any(word in command_lower for word in ['search', 'find', 'look for', 'query']):\n            search_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Find search inputs\n                document.querySelectorAll('input[type=\"search\"], input[name*=\"search\" i], input[placeholder*=\"search\" i], input[aria-label*=\"search\" i]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'search-input',\n                            tag: el.tagName.toLowerCase(),\n                            placeholder: el.placeholder,\n                            role: el.getAttribute('role') || 'combobox',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            testId: el.getAttribute('data-testid'),\n                            id: el.id,\n                            recommended_locator: el.getAttribute('aria-label') \n                                ? `get_by_role(\"combobox\", name=\"${el.getAttribute('aria-label')}\")`\n                                : (el.placeholder ? `get_by_placeholder(\"${el.placeholder}\")` : null)\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(search_elements)\n        \n        # Login intent\n        if any(word in command_lower for word in ['login', 'log in', 'sign in', 'signin']):\n            login_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Find login buttons\n                document.querySelectorAll('button, a, input[type=\"submit\"]').forEach(el => {\n                    const text = el.textContent.trim() || el.value || '';\n                    if (text.match(/log ?in|sign ?in/i)) {\n                        elements.push({\n                            type: 'login-button',\n                            tag: el.tagName.toLowerCase(),\n                            text: text,\n                            role: 'button',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            testId: el.getAttribute('data-testid'),\n                            recommended_locator: `get_by_role(\"button\", name=\"${text}\")`\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(login_elements)\n        \n        # Submit intent\n        if any(word in command_lower for word in ['submit', 'send', 'post']):\n            submit_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                document.querySelectorAll('button[type=\"submit\"], input[type=\"submit\"], button').forEach(el => {\n                    const text = el.textContent.trim() || el.value || '';\n                    if (text.match(/submit|send|post|continue|next/i)) {\n                        elements.push({\n                            type: 'submit-button',\n                            tag: el.tagName.toLowerCase(),\n                            text: text,\n                            role: 'button',\n                            name: el.getAttribute('name') || '',\n                            ariaLabel: el.getAttribute('aria-label') || '',\n                            testId: el.getAttribute('data-testid'),\n                            recommended_locator: `get_by_role(\"button\", name=\"${text}\")`\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(submit_elements)\n        \n        return matched_elements\n    \n    def generate_locator_recommendations(self, page_info: Dict) -> str:\n        \"\"\"\n        Generate a detailed report of available locators for the AI to use.\n        \"\"\"\n        if 'error' in page_info:\n            return \"\"\n        \n        recommendations = []\n        recommendations.append(\"=== REAL PAGE ANALYSIS ===\")\n        recommendations.append(f\"Page: {page_info.get('title', 'Unknown')} ({page_info.get('url', '')})\")\n        recommendations.append(\"\")\n        \n        # Intent-matched elements (highest priority)\n        if page_info.get('intent_matched_elements'):\n            recommendations.append(\"üéØ ELEMENTS MATCHING USER INTENT (Use these first!):\")\n            for elem in page_info['intent_matched_elements'][:5]:\n                if elem.get('recommended_locator'):\n                    recommendations.append(f\"  ‚Ä¢ {elem['type']}: {elem.get('text', elem.get('name', ''))} ‚Üí {elem['recommended_locator']}\")\n                else:\n                    recommendations.append(f\"  ‚Ä¢ {elem['type']}: {elem.get('text', elem.get('name', ''))}\")\n            recommendations.append(\"\")\n        \n        # Form elements\n        if page_info.get('form_elements'):\n            recommendations.append(\"üìù FORM ELEMENTS AVAILABLE:\")\n            for elem in page_info['form_elements'][:10]:\n                locators = []\n                if elem.get('testid'):\n                    locators.append(f\"get_by_test_id(\\\"{elem['testid']}\\\")\")\n                if elem.get('label'):\n                    locators.append(f\"get_by_label(\\\"{elem['label']}\\\")\")\n                if elem.get('placeholder'):\n                    locators.append(f\"get_by_placeholder(\\\"{elem['placeholder']}\\\")\")\n                if elem.get('role') and elem.get('name'):\n                    locators.append(f\"get_by_role(\\\"{elem['role']}\\\", name=\\\"{elem['name']}\\\")\")\n                \n                if locators:\n                    recommendations.append(f\"  ‚Ä¢ {elem.get('type', 'input')} ({elem.get('inputType', '')}): {' OR '.join(locators[:2])}\")\n            recommendations.append(\"\")\n        \n        # Interactive elements\n        if page_info.get('interactive_elements'):\n            recommendations.append(\"üîò BUTTONS & LINKS AVAILABLE:\")\n            for elem in page_info['interactive_elements'][:10]:\n                locators = []\n                if elem.get('testid'):\n                    locators.append(f\"get_by_test_id(\\\"{elem['testid']}\\\")\")\n                if elem.get('role') and elem.get('name'):\n                    locators.append(f\"get_by_role(\\\"{elem['role']}\\\", name=\\\"{elem['name']}\\\")\")\n                if elem.get('text'):\n                    locators.append(f\"get_by_text(\\\"{elem['text']}\\\", exact=True)\")\n                \n                if locators:\n                    recommendations.append(f\"  ‚Ä¢ {elem.get('type', 'element')}: {locators[0]}\")\n            recommendations.append(\"\")\n        \n        recommendations.append(\"‚úÖ USE THESE EXACT LOCATORS - They are confirmed to exist on the page!\")\n        recommendations.append(\"=\" * 60)\n        \n        return \"\\n\".join(recommendations)\n\n\n# Singleton instance\ndom_inspector = DOMInspector()\n","size_bytes":17342},"visionvault/agents/__init__.py":{"content":"\"\"\"VisionVault Browser Automation Agent\"\"\"\n\n__version__ = \"1.0.0\"","size_bytes":65},"visionvault/agents/utils.py":{"content":"import os\nimport sys\nimport subprocess\nimport re\nimport base64\n\n\ndef detect_browsers():\n    \"\"\"Detect available browsers on the system\"\"\"\n    browsers = []\n    try:\n        if sys.platform == 'win32':\n            paths = [\n                r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\",\n                r\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"\n            ]\n            if any(os.path.exists(p) for p in paths):\n                browsers.append('chromium')\n        elif sys.platform == 'darwin':\n            if os.path.exists('/Applications/Google Chrome.app'):\n                browsers.append('chromium')\n            if os.path.exists('/Applications/Firefox.app'):\n                browsers.append('firefox')\n            if os.path.exists('/Applications/Safari.app'):\n                browsers.append('webkit')\n        else:\n            if subprocess.run(['which', 'google-chrome'], capture_output=True).returncode == 0:\n                browsers.append('chromium')\n            if subprocess.run(['which', 'firefox'], capture_output=True).returncode == 0:\n                browsers.append('firefox')\n        if not browsers:\n            browsers = ['chromium']\n    except Exception as e:\n        print(f\"Browser detection error: {e}\")\n        browsers = ['chromium']\n\n    print(f\"Detected browsers: {browsers}\")\n    return browsers\n\n\ndef extract_failed_locator_local(error_message):\n    \"\"\"\n    Enhanced error detection - catches ALL types of automation errors.\n    Returns a dict with error type and details for intelligent healing.\n    \"\"\"\n    if not error_message:\n        return None\n    \n    error_info = {\n        'type': 'unknown',\n        'locator': None,\n        'full_error': error_message,\n        'is_healable': False\n    }\n    \n    # 1. API Misuse Errors (NEW - catches code generation bugs)\n    api_errors = [\n        (r\"'(\\w+)' object has no attribute '(\\w+)'\", 'api_misuse'),\n        (r\"takes (\\d+) positional argument.*?but (\\d+) (?:were|was) given\", 'api_misuse'),\n        (r\"unexpected keyword argument\", 'api_misuse'),\n        (r\"missing \\d+ required positional argument\", 'api_misuse'),\n    ]\n    \n    for pattern, error_type in api_errors:\n        if re.search(pattern, error_message, re.IGNORECASE):\n            error_info['type'] = error_type\n            error_info['is_healable'] = True\n            error_info['detail'] = re.search(pattern, error_message, re.IGNORECASE).group(0)\n            return error_info\n    \n    # 2. Locator/Element Not Found Errors (existing patterns enhanced)\n    locator_patterns = [\n        (r'locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'locator_not_found'),\n        (r'waiting for locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'timeout'),\n        (r'Timeout.*?locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'timeout'),\n        (r'Error: (?:element )?not found: ([^\\n]+)', 'element_not_found'),\n        (r'strict mode violation.*?(\\d+) elements', 'multiple_matches'),\n    ]\n    \n    for pattern, error_type in locator_patterns:\n        match = re.search(pattern, error_message, re.IGNORECASE)\n        if match:\n            error_info['type'] = error_type\n            error_info['locator'] = match.group(1)\n            error_info['is_healable'] = True\n            return error_info\n    \n    # 3. Timeout Errors (general)\n    if re.search(r'timeout|timed out', error_message, re.IGNORECASE):\n        error_info['type'] = 'timeout'\n        error_info['is_healable'] = True\n        return error_info\n    \n    # 4. Navigation/Page Errors\n    if re.search(r'navigation|net::|ERR_', error_message, re.IGNORECASE):\n        error_info['type'] = 'navigation_error'\n        error_info['is_healable'] = False\n        return error_info\n    \n    # 5. Any error is potentially healable with AI retry\n    if 'Error at STEP' in error_message or 'error' in error_message.lower():\n        error_info['type'] = 'general_error'\n        error_info['is_healable'] = True\n        return error_info\n    \n    return error_info if error_info['is_healable'] else None\n\n\ndef encode_screenshot(screenshot_bytes):\n    \"\"\"Encode screenshot to base64 string\"\"\"\n    if screenshot_bytes:\n        return base64.b64encode(screenshot_bytes).decode('utf-8')\n    return None","size_bytes":4178},"visionvault/services/__init__.py":{"content":"","size_bytes":0},"scripts/tred.py":{"content":"import asyncio\nimport base64\nfrom playwright.async_api import async_playwright\n\n# ---------------- Dummy Test Code ----------------\ndummy_code = \"\"\"\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    success = False\n\n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            await page.goto(\"https://example.com\")\n            logs.append(\"Page loaded successfully\")\n\n            # Try finding a widget that may fail\n            try:\n                await page.wait_for_selector(\"#nonexistent-widget\", timeout=2000)\n                logs.append(\"Widget found!\")\n            except:\n                logs.append(\"Widget not found, requires healing.\")\n\n            screenshot = await page.screenshot()\n            success = True\n            await browser.close()\n    except Exception as e:\n        logs.append(f\"Error: {e}\")\n\n    return {\"success\": success, \"logs\": logs, \"screenshot\": screenshot}\n\"\"\"\n\n# ---------------- Test Execution ----------------\nasync def execute_test(test_id, code, browser_name=\"chromium\", headless=True):\n    print(f\"\\n=== Executing Test {test_id} ===\")\n    local_vars = {}\n    exec(code, {}, local_vars)\n\n    if \"run_test\" not in local_vars:\n        print(\"Error: run_test function not found in code\")\n        return\n\n    run_test = local_vars[\"run_test\"]\n    result = await run_test(browser_name=browser_name, headless=headless)\n\n    print(f\"Test {test_id} Result: {'SUCCESS' if result['success'] else 'FAILED'}\")\n    for log in result[\"logs\"]:\n        print(f\" - {log}\")\n\n    if result[\"screenshot\"]:\n        filename = f\"screenshot_{test_id}.png\"\n        with open(filename, \"wb\") as f:\n            f.write(result[\"screenshot\"])\n        print(f\"Screenshot saved as {filename}\")\n\n# ---------------- Healing Execution ----------------\nasync def execute_healing(test_id, code, browser_name=\"chromium\", headless=True, attempt=1):\n    print(f\"\\n=== Healing Attempt {attempt} for Test {test_id} ===\")\n    await execute_test(f\"{test_id}_healing_{attempt}\", code, browser_name, headless)\n\n# ---------------- Main ----------------\nif __name__ == \"__main__\":\n    asyncio.run(execute_test(\"test1\", dummy_code))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=1))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=2))\n","size_bytes":2490},"visionvault/agents/healing_engine.py":{"content":"import re\nimport asyncio\nfrom .browser_manager import BrowserManager\nfrom .utils import extract_failed_locator_local\n\n\nclass HealingEngine(BrowserManager):\n    def __init__(self, socket_client):\n        super().__init__()\n        self.socket_client = socket_client\n\n    def modify_code_for_healing(self, code):\n        \"\"\"Transform code to keep browser open by removing async with context manager\"\"\"\n        import re\n\n        # Step 1: Find the async with line and its indentation\n        lines = code.split('\\n')\n        new_lines = []\n        in_async_with_block = False\n        async_with_indent = 0\n        block_indent = 0\n\n        for i, line in enumerate(lines):\n            # Check if this line contains 'async with async_playwright() as var:'\n            async_with_match = re.match(r'^(\\s*)async with async_playwright\\(\\) as (\\w+):\\s*$', line)\n\n            if async_with_match and not in_async_with_block:\n                # Found the async with line - replace it\n                indent = async_with_match.group(1)\n                var_name = async_with_match.group(2)\n                async_with_indent = len(indent)\n\n                # Replace with two lines at the same indentation\n                new_lines.append(f'{indent}{var_name} = await async_playwright().start()')\n                new_lines.append(f'{indent}globals()[\"__p_instance__\"] = {var_name}')\n\n                in_async_with_block = True\n                # Determine the block indentation\n                if i + 1 < len(lines) and lines[i + 1].strip():\n                    block_indent = len(lines[i + 1]) - len(lines[i + 1].lstrip())\n                else:\n                    block_indent = async_with_indent + 4\n\n            elif in_async_with_block:\n                # Check if this line is still part of the async with block\n                if line.strip():\n                    current_indent = len(line) - len(line.lstrip())\n\n                    # If indentation decreased to or below async_with level, we've exited the block\n                    if current_indent <= async_with_indent:\n                        in_async_with_block = False\n                        new_lines.append(line)\n                    else:\n                        # Dedent by one level\n                        dedent_amount = block_indent - async_with_indent\n                        if current_indent >= block_indent:\n                            dedented_line = line[dedent_amount:]\n                            new_lines.append(dedented_line)\n                        else:\n                            new_lines.append(line)\n                else:\n                    new_lines.append(line)\n            else:\n                new_lines.append(line)\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 2: Inject page capture after page creation\n        lines = modified_code.split('\\n')\n        new_lines = []\n        page_captured = False\n\n        for line in lines:\n            new_lines.append(line)\n            # Match any variable name pattern: var = await browser.new_page()\n            if re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line) and not page_captured:\n                indent = len(line) - len(line.lstrip())\n                var_match = re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line)\n                if var_match:\n                    var_name = var_match.group(1)\n                    new_lines.append(f'{\" \" * indent}globals()[\"__healing_page__\"] = {var_name}')\n                    page_captured = True\n                    print(f\"‚úÖ Added page capture injection for variable '{var_name}'\")\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 3: Replace browser.close() with pass to keep browser open for healing\n        modified_code = re.sub(\n            r'^(\\s*)(await\\s+)?browser\\.close\\(\\)',\n            r'\\1pass  # browser.close() commented for healing',\n            modified_code,\n            flags=re.MULTILINE\n        )\n\n        print(\"‚úÖ Code transformation: async with removed, body dedented, browser stays open for healing\")\n        return modified_code\n\n    async def execute_healing_attempt(self, test_id, code, browser_name, mode, attempt, final_manual_attempt=False):\n        \"\"\"Execute a healing attempt with widget injection on failure\"\"\"\n        headless = mode == 'headless'\n        \n        # Store final_manual_attempt flag for later use\n        self.final_manual_attempt = final_manual_attempt\n        \n        if final_manual_attempt:\n            print(f\"üéØ Starting FINAL MANUAL healing attempt for test {test_id} in {'headless' if headless else 'headful'} mode\")\n            print(f\"   ‚ö†Ô∏è  This is the last attempt - no further healing will be requested if it fails\")\n        else:\n            print(f\"üéØ Starting healing attempt {attempt} for test {test_id} in {'headless' if headless else 'headful'} mode\")\n\n        try:\n\n            # Clean up any previous instances\n            await self.cleanup_browser()\n\n            # Use original code for headless, modified for headful\n            if headless:\n                modified_code = code\n            else:\n                modified_code = self.modify_code_for_healing(code)\n                print(\"‚úÖ Code modified for headful healing mode\")\n\n            global_vars = {'__healing_page__': None, '__p_instance__': None}\n            local_vars = {}\n\n            # Execute the code\n            exec(modified_code, global_vars, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('healing_attempt_result',\n                                        {'test_id': test_id, 'success': False, 'logs': ['Error: run_test missing'],\n                                         'screenshot': None})\n                return\n\n            run_test = local_vars['run_test']\n\n            # Execute with timeout\n            try:\n                result = await asyncio.wait_for(\n                    run_test(browser_name=browser_name, headless=headless),\n                    timeout=60.0\n                )\n            except asyncio.TimeoutError:\n                print(f\"‚è±Ô∏è  Execution timeout for test {test_id}\")\n                result = {\n                    'success': False,\n                    'logs': ['Execution timeout - browser took too long to respond'],\n                    'screenshot': None\n                }\n\n            # Store page reference for headful mode\n            if not headless and global_vars.get('__healing_page__'):\n                self.set_active_page(global_vars['__healing_page__'])\n                if self.active_page and hasattr(self.active_page, 'url') and hasattr(self.active_page, 'is_closed'):\n                    print(\n                        f\"‚úÖ Page captured for healing - URL: {self.active_page.url if not self.active_page.is_closed() else 'CLOSED'}\")\n                else:\n                    print(f\"‚úÖ Page captured for healing - but no valid URL or is_closed method\")\n            else:\n                print(\n                    f\"‚ÑπÔ∏è  No page captured (headless: {headless}, page available: {bool(global_vars.get('__healing_page__'))})\")\n\n            # Handle screenshot\n            from .utils import encode_screenshot\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            print(f\"Healing attempt {attempt} for test {test_id}: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n            # ENHANCED HEALING: Works for BOTH headless and headful modes\n            # - Headless: AI healing only (all 5 attempts)\n            # - Headful: AI healing (attempts 1-4) + manual widget (attempt 5 for locator errors only)\n            if not result.get('success'):\n                # Extract error details using enhanced detection\n                error_msg = ' '.join(result.get('logs', []))\n                error_info = extract_failed_locator_local(error_msg)\n\n                if error_info and error_info.get('is_healable'):\n                    error_type = error_info.get('type', 'unknown')\n                    print(f\"üîç DETECTED ERROR TYPE: {error_type}\")\n                    print(f\"üìã Error details: {error_info.get('detail', error_info.get('full_error', 'No details'))[:200]}\")\n\n                    # Handle different error types with appropriate healing strategy\n                    if error_type in ['api_misuse', 'general_error']:\n                        # Check if this is the final manual attempt - no more healing allowed\n                        if self.final_manual_attempt:\n                            print(f\"‚ùå Final manual attempt failed with API/Code error - no further healing\")\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': False,\n                                'logs': result.get('logs', []) + ['‚ùå Final manual healing attempt failed - no more retries'],\n                                'screenshot': screenshot_b64\n                            })\n                            await self.cleanup_browser()\n                            return\n                        \n                        # API/Code errors: Request AI regeneration (works WITHOUT page)\n                        print(f\"ü§ñ API/Code error detected - requesting AI regeneration\")\n                        print(f\"üí° Server will automatically retry with improved code generation\")\n                        # Emit AI healing request FIRST (before result) to avoid race condition\n                        self.socket_client.emit('request_ai_healing', {\n                            'test_id': test_id,\n                            'error_type': error_type,\n                            'error_info': error_info,\n                            'attempt': attempt\n                        })\n                        # Then emit result to server for tracking\n                        self.socket_client.emit('healing_attempt_result', {\n                            'test_id': test_id,\n                            'success': result.get('success', False),\n                            'logs': result.get('logs', []),\n                            'screenshot': screenshot_b64\n                        })\n                        # Close browser, server will retry with new code\n                        await self.cleanup_browser()\n                        return  # Early return to avoid sending result twice\n                        \n                    elif error_type in ['locator_not_found', 'timeout', 'element_not_found', 'multiple_matches']:\n                        # Locator errors: Different handling for headless vs headful\n                        # Extract actual failed locator for healing\n                        actual_failed_locator = error_info.get('locator') or result.get('failed_locator')\n                        \n                        # If no locator found, extract from error detail/message\n                        if not actual_failed_locator:\n                            error_detail = error_info.get('detail', '') or error_msg\n                            import re\n                            # Extract locator from patterns like \"waiting for get_by_placeholder(\"Search\")\"\n                            if 'get_by_' in error_detail:\n                                match = re.search(r'(get_by_[^(]+\\([^)]+\\))', error_detail)\n                                if match:\n                                    # Add 'page.' prefix if not present to match code\n                                    locator = match.group(1)\n                                    if not locator.startswith('page.'):\n                                        locator = 'page.' + locator\n                                    actual_failed_locator = locator\n                            # Extract from patterns like 'locator(\"selector\")' including escaped quotes\n                            elif 'locator(' in error_detail:\n                                # Match locator(...) handling nested parentheses and escaped quotes\n                                # Look for 'locator(' followed by content until we hit keywords like ' to ', ' Call'\n                                match = re.search(r'locator\\(([\"\\'])(.+?)\\1\\)(?=\\s+(?:to|Call|$))', error_detail, re.DOTALL)\n                                if not match:\n                                    # Fallback: match any locator() call more greedily\n                                    match = re.search(r'(locator\\([^)]+(?:\\([^)]*\\))*[^)]*\\))', error_detail)\n                                    if match:\n                                        # Extract the full locator call\n                                        locator_call = match.group(1)\n                                        actual_failed_locator = f'page.{locator_call}'\n                                else:\n                                    quote_char = match.group(1)\n                                    selector = match.group(2)\n                                    # Add 'page.' prefix to match code\n                                    actual_failed_locator = f'page.locator({quote_char}{selector}{quote_char})'\n                        \n                        # For widget display: use actual locator or friendly fallback\n                        display_locator = actual_failed_locator or error_info.get('detail') or 'element selector'\n                        if not display_locator or display_locator == 'None':\n                            display_locator = error_msg.split('locator')[0].strip() if 'locator' in error_msg else 'element selector'\n                        \n                        print(f\"üéØ LOCATOR ERROR: {display_locator} (attempt {attempt}, mode: {'headless' if headless else 'headful'})\")\n                        print(f\"   Actual failed locator for healing: {actual_failed_locator or 'None (will be extracted by server)'}\")\n                        \n                        # Check if widget was already shown for this test\n                        widget_already_shown = hasattr(self, 'widget_shown_for_test') and self.widget_shown_for_test == test_id\n                        \n                        # HEADFUL MODE: Widget shown when max AI attempts exhausted (attempt >= 999 = final manual)\n                        # Only show widget once per test\n                        if not headless and attempt >= 999 and self.active_page and not widget_already_shown:\n                            print(f\"üöÄ HEADFUL FINAL ATTEMPT - Showing manual element selector widget...\")\n                            self.widget_shown_for_test = test_id  # Mark widget as shown for this test\n                            self.set_widget_event(asyncio.Event())\n                            \n                            try:\n                                # Pass display locator to widget for UI, but store actual for healing\n                                self.actual_failed_locator = actual_failed_locator  # Store for later use\n                                await self.inject_element_selector(test_id, display_locator)\n                                print(f\"‚è≥ Waiting for user to select element (300s timeout)...\")\n                                try:\n                                    await asyncio.wait_for(self.widget_injection_complete.wait(), timeout=300.0)\n                                    print(f\"‚úÖ User selection completed\")\n                                    # Fix: Don't close browser yet - wait for server to send healed code for retry\n                                    print(f\"‚è≥ Keeping browser open, waiting for server to send healed code...\")\n                                except asyncio.TimeoutError:\n                                    print(f\"‚è±Ô∏è  User selection timeout (300s)\")\n                                    # Only close browser on timeout\n                                    self.set_widget_event(None)\n                                    self.socket_client.emit('healing_attempt_result', {\n                                        'test_id': test_id,\n                                        'success': result.get('success', False),\n                                        'logs': result.get('logs', []),\n                                        'screenshot': screenshot_b64\n                                    })\n                                    await self.cleanup_browser()\n                            except Exception as widget_error:\n                                print(f\"‚ùå Widget error: {widget_error}\")\n                                self.set_widget_event(None)\n                                self.socket_client.emit('healing_attempt_result', {\n                                    'test_id': test_id,\n                                    'success': result.get('success', False),\n                                    'logs': result.get('logs', []),\n                                    'screenshot': screenshot_b64\n                                })\n                                await self.cleanup_browser()\n                        else:\n                            # Widget not shown (either headless, widget already shown, or no page)\n                            if widget_already_shown:\n                                print(f\"‚ö†Ô∏è  Manual widget already shown for test {test_id} - marking as failed without showing again\")\n                            \n                            # Check if this is the final manual attempt - no more healing allowed\n                            if self.final_manual_attempt:\n                                print(f\"‚ùå Final manual attempt failed with locator error - no further healing\")\n                                self.socket_client.emit('healing_attempt_result', {\n                                    'test_id': test_id,\n                                    'success': False,\n                                    'logs': result.get('logs', []) + ['‚ùå Final manual healing attempt failed - no more retries'],\n                                    'screenshot': screenshot_b64\n                                })\n                                await self.cleanup_browser()\n                                return\n                            \n                            # HEADLESS MODE or HEADFUL AI attempts: Always use AI healing\n                            mode_desc = \"HEADLESS\" if headless else f\"HEADFUL ATTEMPT {attempt}\"\n                            print(f\"ü§ñ {mode_desc} - Using AI healing for locator issue: {display_locator}\")\n                            \n                            # Request AI healing\n                            self.socket_client.emit('request_ai_healing', {\n                                'test_id': test_id,\n                                'error_type': error_type,\n                                'error_info': error_info,\n                                'attempt': attempt\n                            })\n                            # Send result for tracking\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': result.get('success', False),\n                                'logs': result.get('logs', []),\n                                'screenshot': screenshot_b64\n                            })\n                            \n                            # Browser lifecycle: Keep open in headful for retry, close in headless after AI request\n                            if headless:\n                                print(f\"üßπ HEADLESS - Closing browser, server will retry with healed code\")\n                                await self.cleanup_browser()\n                            else:\n                                print(f\"‚è≥ HEADFUL - Browser kept open, waiting for server's AI-healed code retry...\")\n                            return\n                    else:\n                        # Check if this is the final manual attempt - no more healing allowed\n                        if self.final_manual_attempt:\n                            print(f\"‚ùå Final manual attempt failed with unknown error type - no further healing\")\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': False,\n                                'logs': result.get('logs', []) + ['‚ùå Final manual healing attempt failed - no more retries'],\n                                'screenshot': screenshot_b64\n                            })\n                            await self.cleanup_browser()\n                            return\n                        \n                        # Unknown error type: Use AI healing for both headless and headful\n                        print(f\"‚ö†Ô∏è  Unknown healable error type: {error_type} - requesting AI healing\")\n                        self.socket_client.emit('request_ai_healing', {\n                            'test_id': test_id,\n                            'error_type': error_type,\n                            'error_info': error_info,\n                            'attempt': attempt\n                        })\n                        self.socket_client.emit('healing_attempt_result', {\n                            'test_id': test_id,\n                            'success': result.get('success', False),\n                            'logs': result.get('logs', []),\n                            'screenshot': screenshot_b64\n                        })\n                        \n                        # Browser lifecycle\n                        if headless:\n                            print(f\"üßπ HEADLESS - Closing browser, server will retry with healed code\")\n                            await self.cleanup_browser()\n                        else:\n                            print(f\"‚è≥ HEADFUL - Browser kept open, waiting for server's AI-healed code retry...\")\n                        return\n                else:\n                    # No healable error detected - cleanup and exit\n                    print(f\"‚ÑπÔ∏è  No healable error detected (non-recoverable)\")\n                    self.socket_client.emit('healing_attempt_result', {\n                        'test_id': test_id,\n                        'success': result.get('success', False),\n                        'logs': result.get('logs', []),\n                        'screenshot': screenshot_b64\n                    })\n                    await self.cleanup_browser()\n            else:\n                # Success case - send result and cleanup\n                print(f\"‚úÖ Execution successful!\")\n                self.socket_client.emit('healing_attempt_result', {\n                    'test_id': test_id,\n                    'success': True,\n                    'logs': result.get('logs', []),\n                    'screenshot': screenshot_b64\n                })\n\n        except Exception as e:\n            print(f\"üí• Healing attempt error: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.socket_client.emit('healing_attempt_result',\n                                    {'test_id': test_id, 'success': False, 'logs': [str(e)], 'screenshot': None})\n            await self.cleanup_browser()\n\n    async def verify_locator_uniqueness(self, locator_code: str) -> int:\n        \"\"\"\n        Verify how many elements a locator matches on the page.\n        Returns the count of matching elements.\n        From playwright_codegen_2.py - Fixed to handle attribute selectors correctly\n        \"\"\"\n        if not self.active_page:\n            return 999\n            \n        try:\n            # Use regex to extract selector strings properly, handling escaped quotes\n            import re\n            \n            # Extract the actual locator expression from the Python code\n            if 'get_by_test_id' in locator_code:\n                # Extract: page.get_by_test_id(\"value\")\n                match = re.search(r'get_by_test_id\\(\"([^\"]+)\"\\)', locator_code)\n                if match:\n                    test_id = match.group(1)\n                    count = await self.active_page.locator(f'[data-testid=\"{test_id}\"]').count()\n                else:\n                    return 999\n            elif 'get_by_role' in locator_code:\n                # Extract: page.get_by_role(\"role\", name=\"name\")\n                role_match = re.search(r'get_by_role\\(\"([^\"]+)\"', locator_code)\n                name_match = re.search(r'name=\"([^\"]+)\"', locator_code)\n                if role_match:\n                    role = role_match.group(1)\n                    name = name_match.group(1) if name_match else None\n                    if name:\n                        count = await self.active_page.get_by_role(role, name=name).count()\n                    else:\n                        count = await self.active_page.get_by_role(role).count()\n                else:\n                    return 999\n            elif 'get_by_text' in locator_code:\n                # Extract: page.get_by_text(\"text\", exact=True)\n                match = re.search(r'get_by_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    text = match.group(1)\n                    exact = 'exact=True' in locator_code\n                    count = await self.active_page.get_by_text(text, exact=exact).count()\n                else:\n                    return 999\n            elif 'get_by_placeholder' in locator_code:\n                # Extract: page.get_by_placeholder(\"placeholder\")\n                match = re.search(r'get_by_placeholder\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    placeholder = match.group(1)\n                    count = await self.active_page.get_by_placeholder(placeholder).count()\n                else:\n                    return 999\n            elif 'get_by_alt_text' in locator_code:\n                # Extract: page.get_by_alt_text(\"alt\")\n                match = re.search(r'get_by_alt_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    alt = match.group(1)\n                    count = await self.active_page.get_by_alt_text(alt).count()\n                else:\n                    return 999\n            elif 'get_by_title' in locator_code:\n                # Extract: page.get_by_title(\"title\")\n                match = re.search(r'get_by_title\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    title = match.group(1)\n                    count = await self.active_page.get_by_title(title).count()\n                else:\n                    return 999\n            elif 'get_by_label' in locator_code:\n                # Extract: page.get_by_label(\"label\")\n                match = re.search(r'get_by_label\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    label = match.group(1)\n                    count = await self.active_page.get_by_label(label).count()\n                else:\n                    return 999\n            elif 'page.locator' in locator_code:\n                # CSS or XPath - handle escaped quotes properly\n                # Extract: page.locator(\"selector\") where selector may contain \\\" \n                match = re.search(r'page\\.locator\\(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\)', locator_code)\n                if match:\n                    selector = match.group(1).replace('\\\\\"', '\"')  # Unescape quotes\n                    count = await self.active_page.locator(selector).count()\n                else:\n                    return 999\n            else:\n                count = 999\n\n            return count\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Locator verification error for '{locator_code}': {e}\")\n            # If we can't verify, assume it's not unique\n            return 999\n\n    async def generate_best_locator(self, info: dict):\n        \"\"\"\n        Generate ALL possible locators from pre-captured element information.\n        Returns the best UNIQUE locator with highest success rate.\n        Based on playwright_codegen_2.py logic\n        \"\"\"\n        # Score tracking to determine primary locator (lower score = better)\n        scores = []\n\n        # 1. TEST ID LOCATORS (Score: 1 - highest priority)\n        if info.get('testId'):\n            loc = f'page.get_by_test_id(\"{info[\"testId\"]}\")'\n            scores.append((1, loc, 'testid'))\n\n        # 2. ROLE-BASED LOCATORS (Score: 100-150)\n        role = None\n        if info.get('role'):\n            role = info['role']\n        elif info['tag'] == 'button':\n            role = 'button'\n        elif info['tag'] == 'a':\n            role = 'link'\n        elif info['tag'] == 'input':\n            input_type = info.get('type', '')\n            if input_type == 'text' or input_type == '':\n                role = 'textbox'\n            elif input_type == 'checkbox':\n                role = 'checkbox'\n            elif input_type == 'radio':\n                role = 'radio'\n            elif input_type == 'submit':\n                role = 'button'\n\n        if role:\n            name = info.get('text') or info.get('ariaLabel')\n            if name:\n                loc = f'page.get_by_role(\"{role}\", name=\"{name}\")'\n                scores.append((100, loc, 'role_with_name'))\n                loc_exact = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)'\n                scores.append((105, loc_exact, 'role_with_name_exact'))\n            else:\n                loc = f'page.get_by_role(\"{role}\")'\n                scores.append((510, loc, 'role'))\n\n        # 3. PLACEHOLDER LOCATORS (Score: 120)\n        if info.get('placeholder'):\n            loc = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\")'\n            scores.append((120, loc, 'placeholder'))\n            loc_exact = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\", exact=True)'\n            scores.append((125, loc_exact, 'placeholder_exact'))\n\n        # 4. LABEL LOCATORS (Score: 140)\n        if info.get('ariaLabel'):\n            loc = f'page.get_by_label(\"{info[\"ariaLabel\"]}\")'\n            scores.append((140, loc, 'label'))\n\n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if info.get('alt'):\n            loc = f'page.get_by_alt_text(\"{info[\"alt\"]}\")'\n            scores.append((160, loc, 'alt'))\n            loc_exact = f'page.get_by_alt_text(\"{info[\"alt\"]}\", exact=True)'\n            scores.append((165, loc_exact, 'alt_exact'))\n\n        # 6. TEXT LOCATORS (Score: 180)\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.get_by_text(\"{text}\", exact=True)'\n                scores.append((185, loc, 'text_exact'))\n                loc_partial = f'page.get_by_text(\"{text}\")'\n                scores.append((180, loc_partial, 'text'))\n\n        # 7. TITLE LOCATORS (Score: 200)\n        if info.get('title'):\n            loc = f'page.get_by_title(\"{info[\"title\"]}\")'\n            scores.append((200, loc, 'title'))\n\n        # 8. CSS SELECTORS (Score: 500+)\n        if info.get('id'):\n            loc = f'page.locator(\"#{info[\"id\"]}\")'\n            scores.append((500, loc, 'css_id'))\n\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                loc = f'page.locator(\"{info[\"tag\"]}.{classes[0]}\")'\n                scores.append((520, loc, 'css_class'))\n\n        if info.get('type'):\n            loc = f'page.locator(\"{info[\"tag\"]}[type=\\\\\"{info[\"type\"]}\\\\\"]\")'\n            scores.append((520, loc, 'css_type'))\n\n        # 9. Fallback to tag\n        loc = f'page.locator(\"{info[\"tag\"]}\")'\n        scores.append((530, loc, 'css_tag'))\n\n        # Sort by score (lower is better)\n        scores.sort(key=lambda x: x[0])\n\n        # Verify uniqueness for each locator and find the best unique one\n        print(f\"üîç Testing {len(scores)} locator strategies for uniqueness...\")\n        \n        for score, locator, loc_type in scores:\n            # Check how many elements this locator matches\n            count = await self.verify_locator_uniqueness(locator)\n            print(f\"  - {loc_type}: {locator} ‚Üí matches {count} element(s)\")\n            \n            if count == 1:\n                # Found a unique locator!\n                return {\n                    'locator': locator,\n                    'type': loc_type,\n                    'score': score,\n                    'count': count,\n                    'unique': True\n                }\n\n        # No unique locator found - use the best score but warn\n        if scores:\n            score, locator, loc_type = scores[0]\n            count = await self.verify_locator_uniqueness(locator)\n            print(f\"‚ö†Ô∏è  No unique locator found. Using best score: {loc_type} (matches {count} elements)\")\n            return {\n                'locator': locator,\n                'type': loc_type,\n                'score': score,\n                'count': count,\n                'unique': False\n            }\n\n        return None\n\n    async def inject_element_selector(self, test_id, failed_locator):\n        \"\"\"Inject element selector widget into the page\"\"\"\n        if not self.active_page:\n            print(f\"‚ùå No active page for element selection (test {test_id})\")\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()\n            return\n\n        try:\n            if hasattr(self.active_page, 'is_closed') and self.active_page.is_closed():\n                print(f\"‚ùå Page already closed for test {test_id}\")\n                self.set_active_page(None)\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            if hasattr(self.active_page, 'url'):\n                print(f\"üéØ Injecting element selector widget for test {test_id} on page: {self.active_page.url}\")\n            else:\n                print(f\"üéØ Injecting element selector widget for test {test_id} on page: [no url]\")\n\n            # JavaScript to inject element selector overlay\n            selector_script = \"\"\"\n            (failedLocator) => {\n                console.log('üîß Injecting element selector for locator:', failedLocator);\n                \n                // Remove any existing overlays first\n                const existingOverlay = document.getElementById('playwright-element-selector-overlay');\n                if (existingOverlay) {\n                    existingOverlay.remove();\n                }\n                \n                // Create overlay (non-blocking)\n                const overlay = document.createElement('div');\n                overlay.id = 'playwright-element-selector-overlay';\n                overlay.style.cssText = `\n                    position: fixed !important;\n                    top: 0 !important;\n                    left: 0 !important;\n                    width: 100% !important;\n                    height: 100% !important;\n                    background: rgba(0, 0, 0, 0.3) !important;\n                    z-index: 2147483647 !important;\n                    cursor: crosshair !important;\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;\n                    pointer-events: none !important;\n                `;\n                \n                // Create draggable header with instructions\n                const header = document.createElement('div');\n                header.style.cssText = `\n                    position: fixed !important;\n                    top: 20px !important;\n                    left: 50% !important;\n                    transform: translateX(-50%) !important;\n                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;\n                    color: white !important;\n                    padding: 16px 24px !important;\n                    border-radius: 12px !important;\n                    font-size: 15px !important;\n                    font-weight: 600 !important;\n                    z-index: 2147483648 !important;\n                    box-shadow: 0 8px 24px rgba(0,0,0,0.4) !important;\n                    text-align: left !important;\n                    cursor: move !important;\n                    user-select: none !important;\n                    pointer-events: auto !important;\n                    backdrop-filter: blur(10px) !important;\n                    border: 1px solid rgba(255,255,255,0.1) !important;\n                `;\n                header.innerHTML = `\n                    <div style=\"display: flex; align-items: center; gap: 12px; margin-bottom: 8px;\">\n                        <span style=\"font-size: 20px;\">üéØ</span>\n                        <span style=\"font-size: 16px;\">Element Selector Mode</span>\n                    </div>\n                    <div style=\"font-size: 13px; font-weight: normal; opacity: 0.95; line-height: 1.5;\">\n                        <div style=\"margin-bottom: 4px;\">Failed locator: <code style=\"background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px; font-family: monospace;\">${failedLocator}</code></div>\n                        <div style=\"opacity: 0.85;\">Click on the element you want to select</div>\n                        <div style=\"font-size: 11px; opacity: 0.7; margin-top: 6px;\">üí° Drag this panel to move it</div>\n                    </div>\n                `;\n                \n                // Make header draggable\n                let isDragging = false;\n                let dragOffsetX = 0;\n                let dragOffsetY = 0;\n                \n                header.addEventListener('mousedown', (e) => {\n                    if (e.target.tagName !== 'BUTTON') {\n                        isDragging = true;\n                        const rect = header.getBoundingClientRect();\n                        dragOffsetX = e.clientX - rect.left;\n                        dragOffsetY = e.clientY - rect.top;\n                        header.style.transition = 'none';\n                    }\n                });\n                \n                document.addEventListener('mousemove', (e) => {\n                    if (isDragging) {\n                        e.preventDefault();\n                        const newX = e.clientX - dragOffsetX;\n                        const newY = e.clientY - dragOffsetY;\n                        header.style.left = newX + 'px';\n                        header.style.top = newY + 'px';\n                        header.style.transform = 'none';\n                    }\n                });\n                \n                document.addEventListener('mouseup', () => {\n                    isDragging = false;\n                });\n                \n                // Create cancel button inside header\n                const cancelBtn = document.createElement('button');\n                cancelBtn.textContent = '‚úï';\n                cancelBtn.style.cssText = `\n                    position: absolute !important;\n                    top: 12px !important;\n                    right: 12px !important;\n                    background: rgba(255,255,255,0.2) !important;\n                    color: white !important;\n                    border: none !important;\n                    width: 28px !important;\n                    height: 28px !important;\n                    border-radius: 50% !important;\n                    cursor: pointer !important;\n                    font-size: 16px !important;\n                    font-weight: bold !important;\n                    display: flex !important;\n                    align-items: center !important;\n                    justify-content: center !important;\n                    transition: background 0.2s !important;\n                    pointer-events: auto !important;\n                `;\n                cancelBtn.onmouseover = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.3)';\n                };\n                cancelBtn.onmouseout = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.2)';\n                };\n                cancelBtn.onclick = (e) => {\n                    e.stopPropagation();\n                    overlay.remove();\n                    header.remove();\n                    window.__selectedSelector = null;\n                };\n                header.appendChild(cancelBtn);\n                \n                // Track highlighted element\n                let highlightedElement = null;\n                let highlightBox = null;\n                \n                // Mouse move handler to highlight elements\n                document.addEventListener('mousemove', (e) => {\n                    if (!isDragging) {\n                        const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (elementUnderCursor && elementUnderCursor !== overlay && !header.contains(elementUnderCursor)) {\n                            if (highlightedElement !== elementUnderCursor) {\n                                highlightedElement = elementUnderCursor;\n                                \n                                // Remove old highlight box\n                                if (highlightBox) {\n                                    highlightBox.remove();\n                                }\n                                \n                                // Create new highlight box\n                                const rect = highlightedElement.getBoundingClientRect();\n                                highlightBox = document.createElement('div');\n                                highlightBox.style.cssText = `\n                                    position: fixed !important;\n                                    top: ${rect.top}px !important;\n                                    left: ${rect.left}px !important;\n                                    width: ${rect.width}px !important;\n                                    height: ${rect.height}px !important;\n                                    border: 2px solid #667eea !important;\n                                    background: rgba(102, 126, 234, 0.1) !important;\n                                    z-index: 2147483646 !important;\n                                    pointer-events: none !important;\n                                    box-shadow: 0 0 20px rgba(102, 126, 234, 0.4) !important;\n                                    border-radius: 4px !important;\n                                `;\n                                document.body.appendChild(highlightBox);\n                            }\n                        }\n                    }\n                });\n                \n                // Click handler to select element - Comprehensive info capture\n                document.addEventListener('click', function selectHandler(e) {\n                    if (!header.contains(e.target)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        \n                        const element = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (element && element !== overlay && !header.contains(element)) {\n                            // Capture comprehensive element information\n                            // This follows the approach from playwright_codegen_2.py\n                            window.__selectedElementInfo = {\n                                tag: element.tagName.toLowerCase(),\n                                text: element.textContent?.trim().substring(0, 100) || '',\n                                id: element.id || '',\n                                classes: element.className || '',\n                                testId: element.getAttribute('data-testid') || element.getAttribute('data-test') || '',\n                                role: element.getAttribute('role') || '',\n                                ariaLabel: element.getAttribute('aria-label') || '',\n                                placeholder: element.getAttribute('placeholder') || '',\n                                alt: element.getAttribute('alt') || '',\n                                title: element.getAttribute('title') || '',\n                                type: element.getAttribute('type') || '',\n                                href: element.getAttribute('href') || '',\n                                name: element.getAttribute('name') || '',\n                                value: element.getAttribute('value') || '',\n                                timestamp: Date.now()\n                            };\n                            \n                            console.log('‚úÖ Element info captured:', window.__selectedElementInfo);\n                            \n                            // Clean up\n                            overlay.remove();\n                            header.remove();\n                            if (highlightBox) {\n                                highlightBox.remove();\n                            }\n                            document.removeEventListener('click', selectHandler);\n                        }\n                    }\n                }, true);\n                \n                // Add to DOM\n                document.body.appendChild(overlay);\n                document.body.appendChild(header);\n                \n                console.log('‚úÖ Element selector widget injected successfully');\n            }\n            \"\"\"\n\n            # Inject the script\n            if hasattr(self.active_page, 'evaluate'):\n                await self.active_page.evaluate(selector_script, failed_locator)\n                print(\"‚úÖ Element selector widget injected successfully\")\n            else:\n                print(\"‚ùå Cannot inject selector widget: active_page has no evaluate method\")\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            # Poll for user selection\n            print(\"‚è≥ Polling for user element selection...\")\n            for i in range(600):\n                await asyncio.sleep(0.2)\n                element_info = None\n                if hasattr(self.active_page, 'evaluate'):\n                    element_info = await self.active_page.evaluate('() => window.__selectedElementInfo')\n                if element_info:\n                    print(f\"‚úÖ Element info captured: {element_info}\")\n                    \n                    # Generate all possible locators with scoring and uniqueness verification\n                    best_locator = await self.generate_best_locator(element_info)\n                    \n                    # Use actual_failed_locator (stored earlier) for healing, not the display fallback\n                    # If actual_failed_locator is None, send None (not display text) so server can try to extract\n                    healing_locator = getattr(self, 'actual_failed_locator', None)\n                    # Only use failed_locator if it's not a generic fallback display text\n                    if not healing_locator and failed_locator and failed_locator not in ['element selector', 'None', '']:\n                        healing_locator = failed_locator\n                    \n                    if best_locator:\n                        print(f\"‚úÖ Best locator selected: {best_locator['locator']} (type: {best_locator['type']}, score: {best_locator['score']}, unique: {best_locator['unique']})\")\n                        self.socket_client.emit('element_selected', {\n                            'test_id': test_id,\n                            'selector': best_locator['locator'],\n                            'failed_locator': healing_locator,  # Use actual locator for healing\n                            'locator_type': best_locator['type'],\n                            'score': best_locator['score'],\n                            'unique': best_locator['unique']\n                        })\n                    else:\n                        print(\"‚ö†Ô∏è  No unique locator found, using fallback\")\n                        self.socket_client.emit('element_selected', {\n                            'test_id': test_id,\n                            'selector': f\"#{element_info.get('id')}\" if element_info.get('id') else element_info.get('tag', 'div'),\n                            'failed_locator': healing_locator  # Use actual locator for healing\n                        })\n                    \n                    if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                        self.widget_injection_complete.set()\n                    return\n            print(\"‚è±Ô∏è  Element selection polling complete (300s)\")\n        except Exception as e:\n            print(f\"‚ùå Element selector injection error: {e}\")\n        finally:\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()","size_bytes":48914},"visionvault/services/action_recorder.py":{"content":"import asyncio\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Browser, async_playwright\nimport uuid\n\n\nclass ActionRecorder:\n    \"\"\"Records browser actions for teaching mode.\"\"\"\n    \n    def __init__(self):\n        self.actions: List[Dict] = []\n        self.is_recording = False\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright_instance = None\n    \n    async def start_recording(self, browser_name='chromium', headless=False):\n        \"\"\"Start recording browser actions.\"\"\"\n        self.actions = []\n        self.is_recording = True\n        self.playwright_instance = await async_playwright().start()\n        browser_type = getattr(self.playwright_instance, browser_name)\n        self.browser = await browser_type.launch(headless=headless)\n        self.page = await self.browser.new_page()\n\n        # Use add_init_script for persistent listeners\n        await self.page.add_init_script(self._get_event_listener_js())\n        await self.page.expose_function('recordUserAction', self._handle_user_action)\n        self.page.on('framenavigated', lambda frame: asyncio.create_task(self._on_navigation(frame)))\n        self.page.on('close', lambda: self._on_page_close())\n        return self.page\n\n    def _get_event_listener_js(self):\n        # JS to listen for click, input, change, keyboard events and call recordUserAction\n        return '''\n        (function() {\n            // Use WeakMap to track debounce timers by element identity, not selector\n            const inputTimers = new WeakMap();\n            const DEBOUNCE_DELAY = 500; // Wait 500ms after last keystroke\n            \n            function getSelector(el) {\n                let selector = el.tagName.toLowerCase();\n                if (el.id) {\n                    selector += '#' + el.id;\n                } else if (el.className && typeof el.className === 'string') {\n                    const classes = el.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            function sendAction(type, selector, value, text, key) {\n                if (window.recordUserAction) {\n                    const action = {type, selector, value, text, timestamp: new Date().toISOString()};\n                    if (key) action.key = key;\n                    window.recordUserAction(action);\n                }\n            }\n            \n            // Record clicks\n            document.addEventListener('click', function(e) {\n                const selector = getSelector(e.target);\n                const text = e.target.innerText ? e.target.innerText.substring(0, 50) : null;\n                sendAction('click', selector, null, text);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                // Clear existing timer for THIS SPECIFIC element\n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                // Set new timer - will only fire if user stops typing for DEBOUNCE_DELAY ms\n                const timer = setTimeout(() => {\n                    sendAction('fill', selector, el.value, null);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record change events (for selects, checkboxes, radios)\n            document.addEventListener('change', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (el.type === 'checkbox' || el.type === 'radio') {\n                    sendAction('check', selector, el.checked, null);\n                } else if (el.tagName.toLowerCase() === 'select') {\n                    sendAction('select', selector, el.value, null);\n                }\n            }, true);\n            \n            // Record keyboard events (Enter, Tab, Escape, etc.)\n            document.addEventListener('keydown', function(e) {\n                // Only record special keys, not regular characters (those are captured via input)\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter key and there's a pending input timer, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        sendAction('fill', selector, el.value, null);\n                        inputTimers.delete(el);\n                    }\n                    \n                    sendAction('press', selector, null, null, e.key);\n                }\n            }, true);\n            \n            // Record form submissions\n            document.addEventListener('submit', function(e) {\n                const selector = getSelector(e.target);\n                sendAction('submit', selector, null, null);\n            }, true);\n        })();\n        '''\n\n    async def _on_navigation(self, frame):\n        \"\"\"Record navigation events.\"\"\"\n        if frame == self.page.main_frame:\n            self.record_action({\n                'type': 'navigate',\n                'url': frame.url,\n                'timestamp': datetime.now().isoformat()\n            })\n            # Re-expose function after navigation\n            try:\n                await self.page.expose_function('recordUserAction', self._handle_user_action)\n            except Exception as e:\n                pass\n\n    def _on_page_close(self):\n        self.is_recording = False\n\n    async def _handle_user_action(self, action):\n        # Receives actions from JS and records them\n        self.record_action(action)\n\n    def record_action(self, action: Dict):\n        \"\"\"Record an action with deduplication.\"\"\"\n        if self.is_recording:\n            # Deduplicate consecutive identical actions\n            if self.actions and self._is_duplicate_action(self.actions[-1], action):\n                return  # Skip duplicate\n            self.actions.append(action)\n    \n    def _is_duplicate_action(self, action1: Dict, action2: Dict) -> bool:\n        \"\"\"Check if two actions are duplicates - only deduplicate identical fills and navigation.\"\"\"\n        action_type = action1.get('type')\n        \n        # Different types are never duplicates\n        if action_type != action2.get('type'):\n            return False\n        \n        # For fill actions: same selector AND same value = duplicate\n        if action_type == 'fill':\n            return (action1.get('selector') == action2.get('selector') and \n                    action1.get('value') == action2.get('value'))\n        \n        # For navigation: same URL = duplicate\n        if action_type in ('navigate', 'goto'):\n            return action1.get('url') == action2.get('url')\n        \n        # Allow all other actions (clicks, presses, etc.) - user may intentionally repeat them\n        return False\n    \n    def record_goto(self, url: str):\n        \"\"\"Record a goto action.\"\"\"\n        self.record_action({\n            'type': 'goto',\n            'url': url,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_click(self, selector: str, text: Optional[str] = None):\n        \"\"\"Record a click action.\"\"\"\n        self.record_action({\n            'type': 'click',\n            'selector': selector,\n            'text': text,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_fill(self, selector: str, value: str):\n        \"\"\"Record a fill/input action.\"\"\"\n        self.record_action({\n            'type': 'fill',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_select(self, selector: str, value: str):\n        \"\"\"Record a select action.\"\"\"\n        self.record_action({\n            'type': 'select',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_check(self, selector: str):\n        \"\"\"Record a checkbox/radio check action.\"\"\"\n        self.record_action({\n            'type': 'check',\n            'selector': selector,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_wait(self, wait_type: str, selector: Optional[str] = None, timeout: int = 5000):\n        \"\"\"Record a wait action.\"\"\"\n        action = {\n            'type': 'wait',\n            'wait_type': wait_type,  # 'navigation', 'selector', 'timeout'\n            'timeout': timeout,\n            'timestamp': datetime.now().isoformat()\n        }\n        if selector:\n            action['selector'] = selector\n        self.record_action(action)\n    \n    async def stop_recording(self):\n        \"\"\"Stop recording and return captured actions.\"\"\"\n        self.is_recording = False\n        \n        # Close browser\n        if self.browser:\n            await self.browser.close()\n        if self.playwright_instance:\n            await self.playwright_instance.stop()\n        \n        return self.actions\n    \n    def generate_playwright_code(self, actions: Optional[List[Dict]] = None) -> str:\n        \"\"\"Generate Playwright code from recorded actions.\"\"\"\n        if actions is None:\n            actions = self.actions\n        \n        if not actions:\n            return \"\"\n        \n        # Start building the code\n        code_lines = [\n            \"async def run_test(browser_name='chromium', headless=True):\",\n            \"    from playwright.async_api import async_playwright\",\n            \"    logs = []\",\n            \"    screenshot = None\",\n            \"    \",\n            \"    try:\",\n            \"        async with async_playwright() as p:\",\n            \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n            \"            page = await browser.new_page()\",\n            \"            \",\n        ]\n        \n        # Convert actions to code\n        for i, action in enumerate(actions):\n            action_type = action.get('type')\n            \n            if action_type == 'goto' or action_type == 'navigate':\n                url = action.get('url')\n                code_lines.append(f\"            await page.goto('{url}')\")\n                code_lines.append(f\"            logs.append('Navigated to {url}')\")\n            \n            elif action_type == 'click':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.click('{selector}')\")\n                code_lines.append(f\"            logs.append('Clicked {selector}')\")\n            \n            elif action_type == 'fill':\n                selector = action.get('selector')\n                value = action.get('value', '').replace(\"'\", \"\\\\'\")\n                code_lines.append(f\"            await page.fill('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Filled {selector}')\")\n            \n            elif action_type == 'select':\n                selector = action.get('selector')\n                value = action.get('value')\n                code_lines.append(f\"            await page.select_option('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option in {selector}')\")\n            \n            elif action_type == 'check':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.check('{selector}')\")\n                code_lines.append(f\"            logs.append('Checked {selector}')\")\n            \n            elif action_type == 'wait':\n                wait_type = action.get('wait_type')\n                if wait_type == 'navigation':\n                    code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n                    code_lines.append(\"            logs.append('Waited for navigation')\")\n                elif wait_type == 'selector':\n                    selector = action.get('selector')\n                    timeout = action.get('timeout', 5000)\n                    code_lines.append(f\"            await page.wait_for_selector('{selector}', timeout={timeout})\")\n                    code_lines.append(f\"            logs.append('Waited for {selector}')\")\n                elif wait_type == 'timeout':\n                    timeout = action.get('timeout', 1000)\n                    code_lines.append(f\"            await page.wait_for_timeout({timeout})\")\n                    code_lines.append(f\"            logs.append('Waited {timeout}ms')\")\n            \n            elif action_type == 'press':\n                selector = action.get('selector')\n                key = action.get('key', 'Enter')\n                code_lines.append(f\"            await page.press('{selector}', '{key}')\")\n                code_lines.append(f\"            logs.append('Pressed {key} on {selector}')\")\n            \n            elif action_type == 'submit':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.locator('{selector}').press('Enter')\")\n                code_lines.append(f\"            logs.append('Submitted form {selector}')\")\n        \n        # Add screenshot and closing code\n        code_lines.extend([\n            \"            \",\n            \"            # Take screenshot before closing\",\n            \"            screenshot = await page.screenshot()\",\n            \"            logs.append('Screenshot captured')\",\n            \"            \",\n            \"            await browser.close()\",\n            \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n            \"    \",\n            \"    except Exception as e:\",\n            \"        logs.append(f'Error: {str(e)}')\",\n            \"        if 'page' in locals():\",\n            \"            try:\",\n            \"                screenshot = await page.screenshot()\",\n            \"            except:\",\n            \"                pass\",\n            \"        if 'browser' in locals():\",\n            \"            try:\",\n            \"                await browser.close()\",\n            \"            except:\",\n            \"                pass\",\n            \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    @staticmethod\n    def parse_code_to_actions(playwright_code: str) -> List[Dict]:\n        \"\"\"\n        Parse Playwright code to extract actions (reverse operation).\n        This is a simple parser that looks for common patterns.\n        \"\"\"\n        actions = []\n        lines = playwright_code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            # Parse goto\n            if 'page.goto(' in line:\n                import re\n                match = re.search(r\"page\\.goto\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'goto',\n                        'url': match.group(1)\n                    })\n            \n            # Parse click\n            elif 'page.click(' in line:\n                import re\n                match = re.search(r\"page\\.click\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'click',\n                        'selector': match.group(1)\n                    })\n            \n            # Parse fill\n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r\"page\\.fill\\(['\\\"](.+?)['\\\"],\\s*['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'fill',\n                        'selector': match.group(1),\n                        'value': match.group(2)\n                    })\n            \n            # Add more parsers as needed\n        \n        return actions\n\n\nclass InteractiveRecorder(ActionRecorder):\n    \"\"\"\n    Enhanced recorder that can intercept and record actual user interactions.\n    This would be used with a UI where users can click through a task.\n    \"\"\"\n    \n    async def start_interactive_recording(self, browser_name='chromium'):\n        \"\"\"Start interactive recording with visible browser.\"\"\"\n        page = await self.start_recording(browser_name, headless=False)\n        \n        # Inject improved JavaScript with debouncing and keyboard capture\n        await page.add_init_script(\"\"\"\n            window.__recordedActions = [];\n            const inputTimers = new WeakMap();  // Track by element identity, not selector\n            const DEBOUNCE_DELAY = 500;\n            \n            // Helper to generate CSS selector (must be defined first!)\n            function getSelector(element) {\n                let selector = element.tagName.toLowerCase();\n                if (element.id) {\n                    selector += '#' + element.id;\n                } else if (element.className && typeof element.className === 'string') {\n                    const classes = element.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            // Record clicks\n            document.addEventListener('click', (e) => {\n                const selector = getSelector(e.target);\n                window.__recordedActions.push({\n                    type: 'click',\n                    selector: selector,\n                    text: e.target.textContent ? e.target.textContent.trim().substring(0, 50) : '',\n                    timestamp: new Date().toISOString()\n                });\n                console.log('üé¨ Recorded click:', selector);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', (e) => {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                const timer = setTimeout(() => {\n                    window.__recordedActions.push({\n                        type: 'fill',\n                        selector: selector,\n                        value: el.value,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('üé¨ Recorded fill:', selector, '=', el.value);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record keyboard events\n            document.addEventListener('keydown', (e) => {\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter and there's pending input, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        window.__recordedActions.push({\n                            type: 'fill',\n                            selector: selector,\n                            value: el.value,\n                            timestamp: new Date().toISOString()\n                        });\n                        console.log('üé¨ Recorded fill (Enter):', selector, '=', el.value);\n                        inputTimers.delete(el);\n                    }\n                    \n                    window.__recordedActions.push({\n                        type: 'press',\n                        selector: selector,\n                        key: e.key,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('üé¨ Recorded keypress:', e.key, 'on', selector);\n                }\n            }, true);\n            \n            console.log('‚úÖ VisionVault recording initialized - actions will be captured automatically');\n        \"\"\")\n        \n        return page\n    \n    async def get_recorded_actions_from_page(self):\n        \"\"\"Get actions recorded by JavaScript injection.\"\"\"\n        if not self.page:\n            return []\n        \n        try:\n            js_actions = await self.page.evaluate(\"window.__recordedActions || []\")\n            return js_actions\n        except:\n            return []\n","size_bytes":21461},"visionvault/web/app.py":{"content":"import os\nimport json\nimport sqlite3\nimport uuid\nimport time\nfrom datetime import datetime\nfrom typing import Optional\nfrom flask import Flask, render_template, request, jsonify, send_from_directory, Response\nfrom flask_socketio import SocketIO, emit\nfrom flask_cors import CORS\nfrom openai import OpenAI\nfrom visionvault.services.executor import ServerExecutor\nfrom visionvault.services.healing_executor import HealingExecutor\nfrom visionvault.services.code_validator import CodeValidator\nfrom visionvault.core.models import Database, LearnedTask, TaskExecution\nfrom visionvault.services.vector_store import SemanticSearch\nfrom visionvault.services.intelligent_planner import IntelligentPlanner\nfrom visionvault.services.self_learning_engine import SelfLearningEngine\nfrom visionvault.services.dom_inspector import dom_inspector\nfrom visionvault.mcp.server import VisionVaultMCPServer\nfrom visionvault.mcp.client import MCPEnhancedCodeGenerator, MCPEnhancedHealer\nimport base64\nimport asyncio\nimport re\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key-change-in-production')\napp.config['UPLOAD_FOLDER'] = 'data/uploads'\napp.config['DATABASE_PATH'] = 'data/automation.db'\nCORS(app)\nsocketio = SocketIO(\n    app, \n    async_mode='threading', \n    cors_allowed_origins=\"*\",\n    ping_timeout=60,           # 60 seconds before considering connection dead\n    ping_interval=25,          # Send ping every 25 seconds to keep connection alive\n    max_http_buffer_size=10**8,  # 100MB buffer for large payloads\n    engineio_logger=False,     # Reduce logging overhead\n    logger=False\n)\n\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'screenshots'), exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'logs'), exist_ok=True)\n\n# Cache absolute upload directory path at module load for efficiency\nUPLOAD_DIR_ABS = os.path.abspath(app.config['UPLOAD_FOLDER'])\n\nopenai_api_key = os.environ.get('OPENAI_API_KEY')\ngemini_api_key = os.environ.get('GEMINI_API_KEY')\n\nif openai_api_key:\n    client = OpenAI(api_key=openai_api_key)\n    print(\"‚úÖ OpenAI client initialized for code generation\")\nelse:\n    client = None\n    print(\"WARNING: OPENAI_API_KEY is not set. AI code generation will not be available.\")\n\nif gemini_api_key:\n    try:\n        semantic_search = SemanticSearch(api_key=gemini_api_key)\n        print(\"‚úÖ Semantic search service initialized with Gemini embeddings\")\n    except Exception as e:\n        semantic_search = None\n        print(f\"‚ö†Ô∏è Failed to initialize semantic search: {e}\")\nelse:\n    semantic_search = None\n    print(\"WARNING: GEMINI_API_KEY is not set. Semantic search will not be available.\")\n\nconnected_agents = {}\nactive_healing_executors = {}\nactive_recorders = {}  # Track active recording sessions\nactive_loops = {}  # Track event loops for recording sessions\n\n# Initialize database with new tables\ndb = Database()\nprint(\"‚úÖ Database initialized with persistent learning tables\")\n\n# Initialize super-intelligent systems\nif client:\n    intelligent_planner = IntelligentPlanner(openai_client=client)\n    print(\"‚úÖ Intelligent Planner initialized (GPT-4o pre-execution analysis)\")\nelse:\n    intelligent_planner = None\n    print(\"‚ö†Ô∏è  Intelligent Planner disabled (requires OPENAI_API_KEY)\")\n\nself_learning_engine = SelfLearningEngine()\nprint(f\"‚úÖ Self-Learning Engine initialized (learned from {self_learning_engine.knowledge_base['total_executions']} past executions)\")\n\n# Initialize MCP Server and Clients\nmcp_server = VisionVaultMCPServer(\n    database_path=app.config['DATABASE_PATH'],\n    vector_store=semantic_search,\n    dom_inspector=dom_inspector\n)\nprint(\"‚úÖ MCP Server initialized with VisionVault intelligence tools\")\n\n# Initialize MCP-enhanced code generator and healer\nif client:\n    mcp_code_generator = MCPEnhancedCodeGenerator(mcp_server, client)\n    mcp_healer = MCPEnhancedHealer(mcp_server, client)\n    print(\"‚úÖ MCP-Enhanced Code Generator and Healer initialized\")\nelse:\n    mcp_code_generator = None\n    mcp_healer = None\n    print(\"‚ö†Ô∏è  MCP enhancements disabled (requires OPENAI_API_KEY)\")\n\n\ndef extract_url_from_command(command: str) -> Optional[str]:\n    \"\"\"Extract URL from natural language command\"\"\"\n    # Try to find explicit URLs\n    url_pattern = r'(https?://[^\\s]+|www\\.[^\\s]+|[a-zA-Z0-9-]+\\.(com|org|net|io|dev|co|ai)[^\\s]*)'\n    urls = re.findall(url_pattern, command.lower())\n    \n    if urls:\n        url = urls[0] if isinstance(urls[0], str) else urls[0][0]\n        # Add https:// if missing\n        if not url.startswith('http'):\n            url = 'https://' + url\n        return url\n    \n    # Try to infer from common patterns\n    command_lower = command.lower()\n    \n    # \"go to X\" or \"navigate to X\" or \"open X\"\n    patterns = [\n        r'(?:go to|navigate to|open|visit)\\s+([a-zA-Z0-9-]+(?:\\.[a-zA-Z]{2,})+)',\n        r'(?:search on|use)\\s+([a-zA-Z0-9-]+)(?:\\s|$)',\n    ]\n    \n    for pattern in patterns:\n        match = re.search(pattern, command_lower)\n        if match:\n            domain = match.group(1)\n            # Common sites without .com/.org etc\n            if domain in ['google', 'youtube', 'facebook', 'twitter', 'amazon', 'reddit', 'github', 'linkedin']:\n                return f'https://www.{domain}.com'\n            elif '.' not in domain:\n                return f'https://www.{domain}.com'\n            else:\n                return f'https://{domain}' if not domain.startswith('http') else domain\n    \n    return None\n\n\ndef generate_playwright_code(natural_language_command, browser='chromium', similar_tasks=None):\n    \"\"\"\n    Generate Playwright code with MCP-ENHANCED intelligence and planning.\n    \n    Uses:\n    - MCP Tools: Learned tasks, execution history, DOM analysis, healing strategies\n    - Intelligent Planner: Pre-execution analysis and risk assessment\n    - Self-Learning Engine: Learned patterns from past executions\n    - Similar Task Reuse: Code from related tasks\n    \n    Args:\n        natural_language_command: The user's command\n        browser: Browser type (chromium, firefox, webkit)\n        similar_tasks: List of similar tasks to use as context (optional)\n    \"\"\"\n    if not client:\n        raise Exception(\"OpenAI API key not configured. Please set the OPENAI_API_KEY environment variable.\")\n    \n    try:\n        page_url = extract_url_from_command(natural_language_command)\n        \n        # Try MCP-enhanced generation first if available\n        if mcp_code_generator:\n            print(\"\\nüöÄ MCP-ENHANCED CODE GENERATION ACTIVE\")\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            mcp_result = loop.run_until_complete(\n                mcp_code_generator.generate_with_mcp(\n                    command=natural_language_command,\n                    browser=browser,\n                    url=page_url\n                )\n            )\n            loop.close()\n            \n            if mcp_result and mcp_result.get('code'):\n                print(\"\\n‚úÖ MCP-Enhanced Code Generated Successfully\")\n                if mcp_result.get('insights'):\n                    print(\"   MCP Insights:\")\n                    for insight in mcp_result['insights']:\n                        print(f\"   - {insight}\")\n                return mcp_result['code']\n            else:\n                print(\"‚ö†Ô∏è  MCP generation failed, falling back to standard generation\")\n        \n        # Fallback to standard generation\n        # STEP 0: DOM Inspection - Analyze actual page for perfect locator selection\n        dom_analysis = None\n        \n        if page_url:\n            print(f\"\\nüîç INTELLIGENT DOM INSPECTION...\")\n            print(f\"   Analyzing page: {page_url}\")\n            try:\n                # Run DOM inspection in asyncio event loop\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n                dom_analysis = loop.run_until_complete(\n                    dom_inspector.analyze_page(page_url, natural_language_command)\n                )\n                loop.close()\n                \n                if 'error' not in dom_analysis:\n                    intent_matched = len(dom_analysis.get('intent_matched_elements', []))\n                    form_elements = len(dom_analysis.get('form_elements', []))\n                    interactive = len(dom_analysis.get('interactive_elements', []))\n                    print(f\"   ‚úÖ Page analyzed successfully!\")\n                    print(f\"   Found: {intent_matched} intent-matched, {form_elements} form, {interactive} interactive elements\")\n                else:\n                    print(f\"   ‚ö†Ô∏è  DOM inspection failed: {dom_analysis.get('error', 'Unknown error')}\")\n                    print(f\"   Falling back to standard locator strategies\")\n                    dom_analysis = None\n            except Exception as e:\n                print(f\"   ‚ö†Ô∏è  DOM inspection error: {str(e)}\")\n                print(f\"   Falling back to standard locator strategies\")\n                dom_analysis = None\n        else:\n            print(\"\\n‚ö†Ô∏è  No URL detected in command - skipping DOM inspection\")\n        \n        # STEP 1: Pre-execution intelligent planning\n        execution_plan = None\n        learned_recommendations = None\n        \n        if intelligent_planner:\n            print(\"\\nüß† INTELLIGENT PRE-EXECUTION ANALYSIS...\")\n            execution_plan = intelligent_planner.analyze_command(natural_language_command)\n            print(f\"   Intent: {execution_plan['intent']}\")\n            print(f\"   Complexity: {execution_plan['complexity']}\")\n            print(f\"   Confidence: {execution_plan['confidence_score']:.0f}%\")\n            print(f\"   Predicted issues: {len(execution_plan['potential_issues'])}\")\n            print(f\"   Recommended strategies: {len(execution_plan['recommended_strategies'])}\")\n        \n        # STEP 2: Get self-learning recommendations\n        learned_recommendations = self_learning_engine.get_recommendations(natural_language_command)\n        print(f\"\\nüìö SELF-LEARNING RECOMMENDATIONS:\")\n        print(f\"   Predicted success rate: {learned_recommendations['predicted_success_rate']:.1f}%\")\n        print(f\"   Recommended locators: {', '.join(learned_recommendations['recommended_locators'][:3])}\")\n        print(f\"   Confidence: {learned_recommendations['confidence']:.0f}%\")\n        # Build system prompt with reusable code context\n        system_prompt = \"\"\"You are an expert at converting natural language commands into Playwright Python code with ENHANCED RELIABILITY.\n\nYour goal is to generate code efficiently by REUSING existing code and locators whenever possible.\n\nGenerate complete, executable Playwright code that:\n1. Uses async/await syntax\n2. Includes proper browser launch with the specified browser\n3. Has error handling with proper cleanup\n4. Returns a dict with 'success', 'logs', 'screenshot', and 'current_step' keys\n5. ALWAYS takes screenshot BEFORE closing browser (CRITICAL)\n6. The code should be a complete async function named 'run_test' that takes browser_name and headless parameters\n\nCRITICAL TIMEOUT RULES:\n- Use 5000ms (5 seconds) timeout for LOCATOR action methods only\n- LOCATOR actions that accept timeout: click(), fill(), locator.press(), select_option(), check(), etc.\n- NEVER add timeout to: locator() calls, page.keyboard.press(), page.mouse methods\n- Examples:\n  ‚úÖ CORRECT: await page.get_by_role(\"button\").click(timeout=5000)\n  ‚úÖ CORRECT: await page.get_by_placeholder(\"Search\").fill(\"text\", timeout=5000)\n  ‚úÖ CORRECT: await page.get_by_text(\"Enter\").press(\"Enter\", timeout=5000)  # locator.press()\n  ‚úÖ CORRECT: await page.keyboard.press(\"Enter\")  # NO timeout parameter!\n  ‚ùå WRONG: await page.locator(\"button\", timeout=5000)  # locator() doesn't accept timeout!\n  ‚ùå WRONG: await page.keyboard.press(\"Enter\", timeout=5000)  # keyboard.press() doesn't accept timeout!\n\nCRITICAL STEP TRACKING:\n- Label each major step with a comment like \"# STEP 1: Navigate to website\"\n- Update current_step variable before each step for granular error tracking\n- Log each step completion with step number\n\nCRITICAL LOCATOR SELECTION STRATEGY (Priority Order - Use the FIRST available):\nBased on Playwright best practices and proven success rates, ALWAYS select locators in this priority order:\n\n‚ö†Ô∏è CRITICAL RULE: NEVER use CSS selectors or page.locator() unless absolutely necessary!\n‚ùå BAD: page.locator(\"input[aria-label='Search']\") or page.locator(\"#id\") \n‚úÖ GOOD: page.get_by_role(), page.get_by_placeholder(), page.get_by_label()\n\n1. Test ID (HIGHEST PRIORITY - 99% success rate)\n   ‚úÖ page.get_by_test_id(\"submit-btn\")\n   Use when element has data-testid attribute\n\n2. Role with Name (Accessibility-first - 95% success rate) ‚≠ê PREFERRED\n   ‚úÖ page.get_by_role(\"button\", name=\"Submit\")\n   ‚úÖ page.get_by_role(\"link\", name=\"Login\")\n   ‚úÖ page.get_by_role(\"textbox\", name=\"Search\")\n   ‚úÖ page.get_by_role(\"combobox\", name=\"Search\")  # For search boxes!\n   Common roles: button, link, textbox, combobox, checkbox, radio, heading\n   ALWAYS use for interactive elements (buttons, links, inputs)\n\n3. Placeholder (90% success rate)\n   ‚úÖ page.get_by_placeholder(\"Enter your email\")\n   ‚úÖ page.get_by_placeholder(\"Search\")\n   Use for form inputs with placeholder text\n\n4. Label (85% success rate)\n   ‚úÖ page.get_by_label(\"Email Address\")\n   Use when form field has associated label\n\n5. Text Content (80% success rate)\n   ‚úÖ page.get_by_text(\"Submit\", exact=True)\n   Use for elements with unique visible text\n\n6. Alt Text (for images only)\n   ‚úÖ page.get_by_alt_text(\"Company Logo\")\n\n7. Title Attribute\n   ‚úÖ page.get_by_title(\"Close dialog\")\n\n8. ‚ùå CSS Selectors (LAST RESORT - 70% success rate, often breaks)\n   Only if NO semantic locator exists:\n   page.locator(\"#unique-id\")  # ID only\n   ‚ùå NEVER use: page.locator(\"input\"), page.locator(\".class\"), page.locator(\"[aria-label='...']\")\n\nSMART LOCATOR SELECTION BY ELEMENT TYPE:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Element Type    ‚îÇ Best Locator (in order of preference)          ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Search box      ‚îÇ 1. get_by_role(\"combobox\", name=\"Search\")     ‚îÇ\n‚îÇ                 ‚îÇ 2. get_by_placeholder(\"Search...\")             ‚îÇ\n‚îÇ                 ‚îÇ 3. get_by_label(\"Search\")                      ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Button          ‚îÇ 1. get_by_role(\"button\", name=\"Submit\")       ‚îÇ\n‚îÇ                 ‚îÇ 2. get_by_text(\"Submit\", exact=True)           ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Link            ‚îÇ 1. get_by_role(\"link\", name=\"Login\")          ‚îÇ\n‚îÇ                 ‚îÇ 2. get_by_text(\"Login\", exact=True)            ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Text input      ‚îÇ 1. get_by_label(\"Email\")                      ‚îÇ\n‚îÇ                 ‚îÇ 2. get_by_placeholder(\"Enter email\")           ‚îÇ\n‚îÇ                 ‚îÇ 3. get_by_role(\"textbox\", name=\"Email\")       ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Checkbox/Radio  ‚îÇ 1. get_by_role(\"checkbox\", name=\"Remember\")   ‚îÇ\n‚îÇ                 ‚îÇ 2. get_by_label(\"Remember me\")                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nCRITICAL: Search boxes are usually role=\"combobox\" or have a placeholder!\nExample: Google search ‚Üí page.get_by_role(\"combobox\", name=\"Search\") or page.get_by_placeholder(\"Search\")\n\nCRITICAL NAVIGATION RULES:\n- NEVER use page.wait_for_navigation() - this is Puppeteer syntax, NOT Playwright!\n- For navigation after click/submit, use: async with page.expect_navigation(): await page.click(...)\n- Or use: await page.wait_for_load_state('networkidle') after the action\n- Or simply await page.click() and Playwright auto-waits for navigation\n- Example: await page.get_by_role(\"button\", name=\"Submit\").click(timeout=5000)\n          await page.wait_for_load_state('networkidle')  # Wait for page to load\n\nCRITICAL RULE: Always take screenshot BEFORE closing browser/page. Never close browser before screenshot.\n\nExample structure with BEST PRACTICE LOCATORS:\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    browser = None\n    page = None\n    current_step = 0\n    \n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            \n            # STEP 1: Navigate to website\n            current_step = 1\n            await page.goto('https://example.com', timeout=10000)\n            logs.append(\"STEP 1: Navigated to website\")\n            \n            # STEP 2: Click login button (using role - Score 100)\n            current_step = 2\n            await page.get_by_role(\"button\", name=\"Login\").click(timeout=5000)\n            logs.append(\"STEP 2: Clicked login button\")\n            \n            # STEP 3: Fill username (using label - Score 140)\n            current_step = 3\n            await page.get_by_label(\"Username\").fill('testuser', timeout=5000)\n            logs.append(\"STEP 3: Filled username\")\n            \n            # STEP 4: Fill password (using placeholder - Score 120)\n            current_step = 4\n            await page.get_by_placeholder(\"Enter password\").fill('pass123', timeout=5000)\n            logs.append(\"STEP 4: Filled password\")\n            \n            # STEP 5: Submit (using role - Score 100)\n            current_step = 5\n            await page.get_by_role(\"button\", name=\"Submit\").click(timeout=5000)\n            logs.append(\"STEP 5: Submitted form\")\n            \n            # CRITICAL: Screenshot and page HTML capture BEFORE closing\n            screenshot = await page.screenshot()\n            page_html = await page.content()  # Capture page HTML for healing analysis\n            await browser.close()\n            return {'success': True, 'logs': logs, 'screenshot': screenshot, 'page_html': page_html, 'current_step': current_step}\n    except Exception as e:\n        error_msg = f\"Error at STEP {current_step}: {str(e)}\"\n        logs.append(error_msg)\n        # Try to get screenshot and page HTML even on error, BEFORE cleanup\n        page_html = ''\n        if page:\n            try:\n                screenshot = await page.screenshot()\n                page_html = await page.content()  # Capture page HTML for healing analysis\n            except:\n                pass\n        if browser:\n            try:\n                await browser.close()\n            except:\n                pass\n        return {'success': False, 'logs': logs, 'screenshot': screenshot, 'page_html': page_html, 'current_step': current_step}\n\nOnly return the function code, no explanations.\"\"\"\n\n        # Add DOM inspection results to the prompt (HIGHEST PRIORITY - real page data!)\n        if dom_analysis and 'error' not in dom_analysis:\n            dom_recommendations = dom_inspector.generate_locator_recommendations(dom_analysis)\n            system_prompt += f\"\\n\\n{dom_recommendations}\\n\"\n            system_prompt += \"üéØ CRITICAL: Use the exact locators from DOM analysis above - they are CONFIRMED to exist!\\n\"\n            system_prompt += \"These locators were extracted from the actual live page, ensuring 99%+ accuracy.\\n\\n\"\n\n        # Add intelligent planner's recommendations to the prompt\n        if execution_plan:\n            system_prompt += f\"\\n\\n--- INTELLIGENT EXECUTION PLAN ---\\n\"\n            system_prompt += f\"Intent: {execution_plan['intent']}\\n\"\n            system_prompt += f\"Complexity: {execution_plan['complexity']}\\n\"\n            system_prompt += f\"Estimated Time: {execution_plan['estimated_time']}\\n\\n\"\n            \n            if execution_plan['potential_issues']:\n                system_prompt += \"PREDICTED POTENTIAL ISSUES (must handle):\\n\"\n                for issue in execution_plan['potential_issues']:\n                    system_prompt += f\"- {issue}\\n\"\n                system_prompt += \"\\n\"\n            \n            if execution_plan['recommended_strategies']:\n                system_prompt += \"REQUIRED STRATEGIES (must implement):\\n\"\n                for strategy in execution_plan['recommended_strategies']:\n                    system_prompt += f\"- {strategy}\\n\"\n                system_prompt += \"\\n\"\n        \n        # Add self-learning recommendations\n        if learned_recommendations['recommended_locators']:\n            system_prompt += f\"\\n--- LEARNED BEST LOCATORS ---\\n\"\n            system_prompt += f\"Based on {self_learning_engine.knowledge_base['total_executions']} past executions:\\n\"\n            for loc in learned_recommendations['recommended_locators'][:5]:\n                system_prompt += f\"- {loc} (proven effective)\\n\"\n            system_prompt += \"\\n\"\n        \n        # Add similar tasks as context if available - ENHANCED CODE ADAPTATION MODE\n        if similar_tasks and len(similar_tasks) > 0:\n            best_similarity = similar_tasks[0].get('similarity_score', 0)\n            \n            system_prompt += \"\\n\\n--- üéØ SMART CODE ADAPTATION MODE ACTIVATED ---\\n\"\n            system_prompt += \"Below are existing tasks that are similar to the new request. Your job is to INTELLIGENTLY ADAPT the existing code, NOT generate from scratch.\\n\\n\"\n            \n            for i, task in enumerate(similar_tasks, 1):\n                similarity = task.get('similarity_score', 0)\n                system_prompt += f\"Task {i} (Similarity: {similarity:.0%}): {task['task_name']}\\n\"\n                if task.get('description'):\n                    system_prompt += f\"Description: {task['description']}\\n\"\n                system_prompt += f\"Existing Code:\\n```python\\n{task['playwright_code']}\\n```\\n\\n\"\n            \n            # Add smart adaptation instructions based on similarity level\n            if best_similarity > 0.50:\n                # High similarity - minor adaptation needed\n                system_prompt += \"\"\"--- üîß CODE ADAPTATION STRATEGY (HIGH SIMILARITY) ---\n‚ö†Ô∏è  WARNING: The existing task is VERY similar to the new request!\n\nMANDATORY APPROACH - Follow these steps EXACTLY:\n1. START with the existing code from Task 1 as your BASE\n2. IDENTIFY what needs to change (e.g., search terms, URLs, button names)\n3. REPLACE only the specific values that differ - DO NOT rewrite locators or structure\n4. KEEP all working locators, selectors, and navigation patterns UNCHANGED\n5. MAINTAIN the exact same code structure and error handling\n\nEXAMPLES OF SMART ADAPTATION:\n- Old: await page.fill(\"#search\", \"dog food\")\n  New: await page.fill(\"#search\", \"cat food\")  ‚Üê ONLY change the search term\n  \n- Old: await page.goto(\"https://flipkart.com\")\n  New: await page.goto(\"https://flipkart.com\")  ‚Üê KEEP if same site\n  \n- Old: await page.get_by_role(\"button\", name=\"Search\").click()\n  New: await page.get_by_role(\"button\", name=\"Search\").click()  ‚Üê KEEP if same button\n\n‚ùå DO NOT:\n- Generate new code from scratch\n- Change working locators or selectors\n- Modify the overall structure\n- Add unnecessary waits or steps\n\n‚úÖ DO:\n- Copy the existing code structure\n- Replace ONLY the parameter values that need to change\n- Preserve all proven locators and patterns\n- Keep comments and logging intact\n\"\"\"\n            else:\n                # Moderate similarity - partial reuse\n                system_prompt += \"\"\"--- üîß CODE ADAPTATION STRATEGY (MODERATE SIMILARITY) ---\nThe existing tasks share some patterns with the new request.\n\nRECOMMENDED APPROACH:\n1. Identify REUSABLE patterns: URLs, navigation flows, locator types, wait strategies\n2. COPY working code sections (navigation, form filling, button clicks)\n3. ADAPT values and targets to match the new requirement\n4. COMBINE patterns from multiple tasks if needed\n5. Only generate NEW code for unique parts not covered\n\nFOCUS ON:\n- Reusing proven locators and selectors\n- Maintaining the same navigation structure\n- Copying error handling patterns\n- Adapting values (search terms, form data) to new requirements\n\"\"\"\n            \n            system_prompt += \"\\nüéØ GOAL: Generate adapted code that leverages existing proven patterns and minimizes new code generation.\\n\"\n\n        # Build enhanced user prompt with all context\n        user_prompt = f\"NEW REQUEST: {natural_language_command}\\n\"\n        user_prompt += f\"Target Browser: {browser}\\n\"\n        \n        if similar_tasks and len(similar_tasks) > 0:\n            best_similarity = similar_tasks[0].get('similarity_score', 0)\n            if best_similarity > 0.50:\n                user_prompt += f\"\\n‚ö†Ô∏è  CRITICAL: An existing task is {best_similarity:.0%} similar to this request!\\n\"\n                user_prompt += \"You MUST adapt the existing code, NOT generate from scratch.\\n\"\n                user_prompt += \"Identify the differences and make MINIMAL changes to the existing code.\\n\"\n            else:\n                user_prompt += f\"\\n‚úÖ Found {len(similar_tasks)} related task(s). Reuse their proven patterns and locators.\\n\"\n        \n        if execution_plan:\n            user_prompt += f\"\\n\\nEXECUTION PLAN: {execution_plan['full_analysis'][:500]}\"\n        \n        user_prompt += f\"\\n\\nGenerate PRODUCTION-READY code that handles all predicted issues and implements all recommended strategies.\"\n\n        # Use GPT-4o-mini for code generation\n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt}\n            ],\n            temperature=0.2  # Lower temperature for more consistent, reliable code\n        )\n\n        code = response.choices[0].message.content\n        if not code:\n            raise Exception(\"No code generated from OpenAI\")\n        code = code.strip()\n        if code.startswith('```python'):\n            code = code[9:]\n        if code.startswith('```'):\n            code = code[3:]\n        if code.endswith('```'):\n            code = code[:-3]\n\n        return code.strip()\n    except Exception as e:\n        raise Exception(f\"OpenAI API error: {str(e)}\")\n\n\ndef generate_playwright_code_from_recording(recorded_events):\n    \"\"\"\n    Convert recorded events from ComprehensiveRecordingSessionManager to executable Playwright code.\n    This generates proper Playwright code with full browser launch, error handling, and screenshot capture.\n    \"\"\"\n    if not recorded_events or len(recorded_events) == 0:\n        raise Exception(\"No recorded events to convert to code\")\n    \n    # Start building the code\n    code_lines = [\n        \"async def run_test(browser_name='chromium', headless=True):\",\n        \"    from playwright.async_api import async_playwright\",\n        \"    logs = []\",\n        \"    screenshot = None\",\n        \"    browser = None\",\n        \"    page = None\",\n        \"    \",\n        \"    try:\",\n        \"        async with async_playwright() as p:\",\n        \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n        \"            page = await browser.new_page()\",\n        \"            \",\n    ]\n    \n    # Convert each event to Playwright code\n    for i, event in enumerate(recorded_events):\n        action = event.get('action')\n        target = event.get('target', '')\n        value = event.get('value', '')\n        description = event.get('description', '')\n        attributes = event.get('attributes', {})\n        \n        # Escape single quotes in strings\n        if value:\n            value = str(value).replace(\"'\", \"\\\\'\")\n        if target:\n            target = str(target).replace(\"'\", \"\\\\'\")\n        \n        if action == 'navigation':\n            # Navigation action\n            code_lines.append(f\"            await page.goto('{target}')\")\n            code_lines.append(f\"            logs.append('Navigated to {target}')\")\n            \n        elif action == 'click':\n            # Check if next event is navigation (click causes page change)\n            next_event = recorded_events[i + 1] if i + 1 < len(recorded_events) else None\n            is_link = attributes.get('tag') == 'a'\n            is_form_submit = attributes.get('type') == 'submit' or attributes.get('isFormSubmit')\n            causes_navigation = (next_event and next_event.get('action') == 'navigation')\n            \n            # If click causes navigation, use expect_navigation\n            if causes_navigation or is_link or is_form_submit:\n                code_lines.append(f\"            # Click that triggers navigation\")\n                code_lines.append(f\"            async with page.expect_navigation():\")\n                code_lines.append(f\"                await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target} and navigated')\")\n            else:\n                # Regular click without navigation\n                code_lines.append(f\"            await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target}')\")\n            \n        elif action == 'type':\n            # Input/fill action\n            code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n            code_lines.append(f\"            logs.append('Typed into {target}')\")\n            \n        elif action == 'change':\n            # Change action (select, checkbox, radio)\n            attributes = event.get('attributes', {})\n            tag = attributes.get('tag', 'unknown')\n            \n            if tag == 'select':\n                code_lines.append(f\"            await page.select_option('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option {value} in {target}')\")\n            elif attributes.get('type') in ['checkbox', 'radio']:\n                if value:  # If checked\n                    code_lines.append(f\"            await page.check('{target}')\")\n                    code_lines.append(f\"            logs.append('Checked {target}')\")\n                else:\n                    code_lines.append(f\"            await page.uncheck('{target}')\")\n                    code_lines.append(f\"            logs.append('Unchecked {target}')\")\n            else:\n                code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Changed {target} to {value}')\")\n                \n        elif action == 'keypress':\n            # Key press action\n            key = event.get('key', 'Enter')\n            code_lines.append(f\"            await page.keyboard.press('{key}')\")\n            code_lines.append(f\"            logs.append('Pressed {key} key')\")\n            \n        elif action == 'dialog':\n            # Dialog detection (alert, confirm, prompt)\n            dialog_type = event.get('dialog_type', 'alert')\n            dialog_message = event.get('target', '').replace(\"'\", \"\\\\'\")\n            code_lines.append(f\"            # Handle {dialog_type} dialog\")\n            code_lines.append(f\"            # Dialog will auto-accept in Playwright\")\n            code_lines.append(f\"            logs.append('Dialog appeared: {dialog_message}')\")\n        \n        elif action == 'dialog_accept':\n            # Dialog acceptance\n            dialog_type = event.get('target', 'dialog')\n            code_lines.append(f\"            logs.append('Accepted {dialog_type}')\")\n        \n        elif action == 'popup_opened':\n            # New window/popup opened\n            popup_url = target.replace(\"'\", \"\\\\'\") if target else 'popup'\n            code_lines.append(f\"            # New popup window opened\")\n            code_lines.append(f\"            # Playwright automatically tracks popup pages\")\n            code_lines.append(f\"            logs.append('Popup opened: {popup_url}')\")\n        \n        elif action == 'page_created':\n            # New tab created\n            page_url = target.replace(\"'\", \"\\\\'\") if target else 'new page'\n            code_lines.append(f\"            # New page/tab opened\")\n            code_lines.append(f\"            logs.append('New page opened: {page_url}')\")\n        \n        elif action == 'frame_attached':\n            # iFrame/widget loaded\n            frame_name = event.get('frame_name', 'widget')\n            code_lines.append(f\"            # Frame/Widget loaded: {frame_name}\")\n            code_lines.append(f\"            logs.append('Frame attached: {frame_name}')\")\n            \n        elif action == 'form_submit':\n            # Form submission - press Enter on the form\n            code_lines.append(f\"            await page.keyboard.press('Enter')\")\n            code_lines.append(f\"            logs.append('Submitted form')\")\n    \n    code_lines.extend([\n        \"            \",\n        \"            # Take screenshot before closing\",\n        \"            screenshot = await page.screenshot()\",\n        \"            logs.append('Screenshot captured')\",\n        \"            \",\n        \"            await browser.close()\",\n        \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n        \"    \",\n        \"    except Exception as e:\",\n        \"        logs.append(f'Error: {str(e)}')\",\n        \"        if 'page' in locals():\",\n        \"            try:\",\n        \"                screenshot = await page.screenshot()\",\n        \"            except:\",\n        \"                pass\",\n        \"        if 'browser' in locals():\",\n        \"            try:\",\n        \"                await browser.close()\",\n        \"            except:\",\n        \"                pass\",\n        \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n    ])\n    \n    return \"\\n\".join(code_lines)\n\n\n@app.after_request\ndef add_header(response):\n    \"\"\"Add cache-control headers to prevent caching issues in iframe\"\"\"\n    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n    response.headers['Pragma'] = 'no-cache'\n    response.headers['Expires'] = '0'\n    return response\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/api/history')\ndef get_history():\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT * FROM test_history ORDER BY created_at DESC LIMIT 50')\n    rows = c.fetchall()\n    conn.close()\n    \n    history = []\n    for row in rows:\n        history.append({\n            'id': row[0],\n            'command': row[1],\n            'generated_code': row[2],\n            'healed_code': row[3],\n            'browser': row[4],\n            'mode': row[5],\n            'execution_location': row[6],\n            'status': row[7],\n            'logs': row[8],\n            'screenshot_path': row[9],\n            'created_at': row[10]\n        })\n    \n    return jsonify(history)\n\n@app.route('/api/history/<int:history_id>', methods=['DELETE'])\ndef delete_history_item(history_id):\n    \"\"\"Delete a single history item.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM test_history WHERE id=?', (history_id,))\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True, 'message': 'History item deleted'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/history/all', methods=['DELETE'])\ndef delete_all_history():\n    \"\"\"Delete all history items.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM test_history')\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True, 'message': 'All history deleted'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/history/rerun/<int:history_id>', methods=['POST'])\ndef rerun_from_history(history_id):\n    \"\"\"Re-execute a test from history using healed code if available, otherwise generated code.\"\"\"\n    try:\n        data = request.json or {}\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT command, generated_code, healed_code, browser, mode, execution_location FROM test_history WHERE id=?', (history_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return jsonify({'error': 'History item not found'}), 404\n        \n        command, generated_code, healed_code, browser, mode, execution_location = row\n        \n        code_to_use = healed_code if healed_code else generated_code\n        code_source = 'healed' if healed_code else 'generated'\n        \n        use_healing = data.get('use_healing', True)\n        auto_save = data.get('auto_save', False)\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, healed_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, healed_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        print(f\"üîÑ Re-running test from history #{history_id} as test #{test_id}\")\n        print(f\"   Using {code_source} code\")\n        print(f\"   Command: {command}\")\n        \n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if use_healing:\n                socketio.start_background_task(execute_agent_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                if agent_sid:\n                    socketio.emit('execute_on_agent', {\n                        'test_id': test_id,\n                        'code': code_to_use,\n                        'browser': browser,\n                        'mode': mode\n                    }, to=agent_sid)\n                else:\n                    return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id,\n            'code': code_to_use,\n            'code_source': code_source,\n            'original_history_id': history_id,\n            'command': command\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_test():\n    data = request.json or {}\n    command = data.get('command')\n    browser = data.get('browser', 'chromium')\n    mode = data.get('mode', 'headless')\n    execution_location = data.get('execution_location', 'server')\n    use_healing = data.get('use_healing', True)\n    auto_save = data.get('auto_save', False)\n    \n    if not command:\n        return jsonify({'error': 'Command is required'}), 400\n    \n    try:\n        code_source = 'generated'\n        learned_task_id = None\n        learned_task_name = None\n        similarity_score = 0.0\n        \n        # INTELLIGENT CODE REUSE: Search for similar tasks and reuse their code/locators\n        if semantic_search:\n            try:\n                print(f\"üîç Searching for similar learned tasks for: '{command}'\")\n                results = semantic_search.search_tasks(command, top_k=3)  # Get top 3 similar tasks\n                \n                if results and len(results) > 0:\n                    best_match = results[0]\n                    similarity_score = best_match.get('similarity_score', 0)\n                    \n                    # Strategy 1: Very high similarity (>75%) - use existing task as-is\n                    if similarity_score > 0.75:\n                        learned_task_id = best_match['task_id']\n                        learned_task_name = best_match['task_name']\n                        generated_code = best_match['playwright_code']\n                        code_source = 'learned'\n                        print(f\"‚úÖ Using learned task '{learned_task_name}' (similarity: {similarity_score:.2%})\")\n                    \n                    # Strategy 2: Moderate similarity (20-75%) - intelligent reuse with AI\n                    elif similarity_score > 0.20:\n                        print(f\"üîÑ Found {len(results)} similar task(s) (best: {similarity_score:.2%})\")\n                        print(f\"   üìù SMART CODE ADAPTATION MODE: Adapting existing code to new requirements...\")\n                        generated_code = generate_playwright_code(command, browser, similar_tasks=results)\n                        code_source = 'generated_with_reuse'\n                        print(f\"‚úÖ Generated ADAPTED code reusing patterns from {len(results)} similar task(s)\")\n                    \n                    # Strategy 3: Low similarity (<20%) - generate from scratch\n                    else:\n                        print(f\"‚ö†Ô∏è  Found task but similarity too low ({similarity_score:.2%}), generating new code\")\n                        generated_code = generate_playwright_code(command, browser)\n                else:\n                    print(\"‚ÑπÔ∏è  No similar tasks found, generating new code\")\n                    generated_code = generate_playwright_code(command, browser)\n            except Exception as search_error:\n                print(f\"‚ö†Ô∏è  Semantic search failed: {search_error}, falling back to code generation\")\n                generated_code = generate_playwright_code(command, browser)\n        else:\n            print(\"‚ÑπÔ∏è  Semantic search not available, generating new code\")\n            generated_code = generate_playwright_code(command, browser)\n        \n        validator = CodeValidator()\n        if not validator.validate(generated_code):\n            error_msg = \"Code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute the code\n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            # Agent execution - find agent's session ID\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break  # Get the first available agent\n            \n            if use_healing:\n                socketio.start_background_task(execute_agent_with_healing, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                if agent_sid:\n                    socketio.emit('execute_on_agent', {\n                        'test_id': test_id,\n                        'code': generated_code,\n                        'browser': browser,\n                        'mode': mode\n                    }, to=agent_sid)\n                else:\n                    return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id, \n            'code': generated_code,\n            'code_source': code_source,\n            'learned_task_id': learned_task_id,\n            'learned_task_name': learned_task_name,\n            'similarity_score': similarity_score\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\ndef execute_on_server(test_id, code, browser, mode, auto_save=False, original_command=None):\n    executor = ServerExecutor()\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on server in {mode} mode...'\n    })\n    \n    result = executor.execute(code, browser, headless)\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    code = code if code else 'No code generated.'\n\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=code,\n                description=f\"Auto-saved from successful execution in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"‚úÖ Auto-saved successful execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name\n            })\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Failed to auto-save task: {e}\")\n    \n    # SELF-LEARNING: Record execution for continuous improvement\n    if original_command:\n        self_learning_engine.learn_from_execution(\n            command=original_command,\n            code=code,\n            result=result,\n            healing_attempts=0,\n            url=''\n        )\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path\n    })\n\ndef execute_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing with healing in {mode} mode...'\n    })\n    \n    try:\n        result = asyncio.run(healing_executor.execute_with_healing(code, browser, headless, test_id))\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\nüíæ SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ‚úÖ Database updated successfully\", flush=True)\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from successful {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"‚úÖ Auto-saved successful {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Failed to auto-save task: {e}\")\n    \n    # SELF-LEARNING: Record healing execution for continuous improvement\n    if original_command:\n        healing_attempts = len(healing_executor.failed_locators) if hasattr(healing_executor, 'failed_locators') else 0\n        final_code = healed_code if healed_code else code\n        \n        self_learning_engine.learn_from_execution(\n            command=original_command,\n            code=final_code,\n            result=result,\n            healing_attempts=healing_attempts,\n            url=''\n        )\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\ndef execute_agent_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    \"\"\"Execute automation on agent with server-coordinated healing.\"\"\"\n    import gevent\n    from gevent.event import AsyncResult\n    \n    # Find the agent's session ID\n    agent_sid = None\n    for sid in connected_agents:\n        agent_sid = sid\n        break  # Get the first available agent\n    \n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    healing_executor.execution_mode = 'agent'  # Mark as agent execution\n    healing_executor.agent_sid = agent_sid  # Store agent session ID\n    # Use gevent AsyncResult for cross-greenlet communication\n    healing_executor.agent_result_async = AsyncResult()\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on agent with healing in {mode} mode...'\n    })\n    \n    # Run async code synchronously using gevent - NO asyncio.run()\n    # This keeps us in the same greenlet so socket.io handlers can communicate\n    async def _run_healing():\n        return await healing_executor.execute_with_healing(code, browser, headless, test_id)\n    \n    try:\n        # Use gevent to wrap the async function\n        import nest_asyncio\n        nest_asyncio.apply()\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        try:\n            result = loop.run_until_complete(_run_healing())\n        finally:\n            loop.close()\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\nüíæ SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from agent {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'agent', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"‚úÖ Auto-saved successful agent {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Failed to auto-save task: {e}\")\n    \n    print(f\"  ‚úÖ Database updated successfully\", flush=True)\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\n@app.route('/api/heal', methods=['POST'])\ndef heal_locator():\n    data = request.json or {}\n    test_id = data.get('test_id')\n    failed_locator = data.get('failed_locator')\n    healed_locator = data.get('healed_locator')\n    \n    if not all([test_id, failed_locator, healed_locator]):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT generated_code, healed_code FROM test_history WHERE id=?', (test_id,))\n        row = c.fetchone()\n        \n        if not row:\n            return jsonify({'error': 'Test not found'}), 404\n        \n        original_code = row[0]\n        current_healed = row[1] or original_code\n        \n        new_healed = current_healed.replace(failed_locator, healed_locator)\n        \n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (new_healed, test_id))\n        conn.commit()\n        conn.close()\n        \n        socketio.emit('script_healed', {\n            'test_id': test_id,\n            'healed_script': new_healed,\n            'failed_locator': failed_locator,\n            'healed_locator': healed_locator\n        })\n        \n        return jsonify({'success': True, 'healed_script': new_healed})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/uploads/<path:filename>')\ndef uploaded_file(filename):\n    return send_from_directory(UPLOAD_DIR_ABS, filename)\n\n@app.route('/api/agent/download')\ndef download_agent():\n    # Get the current server URL dynamically\n    replit_domain = os.environ.get('REPLIT_DEV_DOMAIN', 'localhost:5000')\n    server_url = f'https://{replit_domain}' if replit_domain != 'localhost:5000' else 'http://localhost:5000'\n    \n    # Read the local agent file\n    with open('visionvault/agents/local_agent.py', 'r', encoding='utf-8') as f:\n        agent_code = f.read()\n    \n    # Replace the default port in get_server_url to prioritize the current server\n    # This ensures downloaded agent connects to the right server by default\n    agent_code = agent_code.replace(\n        'local_ports = [5000, 8000, 3000, 7890]',\n        f'# Auto-configured for this server\\n    local_ports = [{replit_domain.split(\":\")[-1] if \":\" in replit_domain else \"5000\"}, 5000, 8000, 3000, 7890]'\n    )\n    \n    # Also add the server URL as a comment for reference\n    agent_code = f'# Auto-downloaded from: {server_url}\\n# This agent will automatically connect to the server\\n\\n{agent_code}'\n    \n    # Create a temporary response with the modified content\n    return Response(\n        agent_code,\n        mimetype='text/x-python',\n        headers={'Content-Disposition': 'attachment; filename=local_agent.py'}\n    )\n\n# ========== Persistent Learning API Endpoints ==========\n\n@app.route('/api/tasks', methods=['GET'])\ndef get_all_tasks():\n    \"\"\"Get all learned tasks.\"\"\"\n    try:\n        limit = request.args.get('limit', 100, type=int)\n        tasks = LearnedTask.get_all(limit=limit)\n        return jsonify([task.to_dict() for task in tasks])\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['GET'])\ndef get_task(task_id):\n    \"\"\"Get a specific learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        return jsonify(task.to_dict())\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/save', methods=['POST'])\ndef save_learned_task():\n    \"\"\"Save a new learned task or update existing one.\"\"\"\n    try:\n        data = request.json or {}\n        \n        # Extract task data\n        task_id = data.get('task_id') or str(uuid.uuid4())\n        task_name = data.get('task_name')\n        playwright_code = data.get('playwright_code')\n        description = data.get('description', '')\n        steps = data.get('steps', [])\n        tags = data.get('tags', [])\n        \n        if not task_name or not playwright_code:\n            return jsonify({'error': 'task_name and playwright_code are required'}), 400\n        \n        # Create task object\n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags\n        )\n        \n        # Save to database\n        task.save()\n        \n        # Index for semantic search\n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"‚úÖ Task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Failed to index task for search: {e}\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict()\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['DELETE'])\ndef delete_task(task_id):\n    \"\"\"Delete a learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Remove from semantic search index\n        if semantic_search:\n            semantic_search.delete_task_from_index(task_id)\n        \n        # Delete from database\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM learned_tasks WHERE task_id=?', (task_id,))\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/search', methods=['POST'])\ndef search_tasks():\n    \"\"\"Search for tasks using natural language.\"\"\"\n    try:\n        data = request.json or {}\n        query = data.get('query')\n        top_k = data.get('top_k', 5)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Semantic search requires an OpenAI API key to generate embeddings.'\n            }), 400\n        \n        # Search for relevant tasks\n        results = semantic_search.search_tasks(query, top_k=top_k)\n        \n        return jsonify({\n            'query': query,\n            'results': results\n        })\n    except Exception as e:\n        error_msg = str(e)\n        # Check if it's an API key or embedding-related error\n        if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n            return jsonify({\n                'error': f'OPENAI_API_KEY error: {error_msg}'\n            }), 400\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>/execute', methods=['POST'])\ndef execute_learned_task(task_id):\n    \"\"\"Execute a learned task.\"\"\"\n    try:\n        data = request.json or {}\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        \n        # Get the task\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Use the task's code instead of generating new code\n        code = task.playwright_code\n        \n        # Validate the code\n        validator = CodeValidator()\n        if not validator.validate(code):\n            error_msg = \"Task code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        # Create a test history entry for tracking\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (f\"Learned Task: {task.task_name}\", code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute the task\n        if execution_location == 'server':\n            socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if agent_sid:\n                socketio.emit('execute_on_agent', {\n                    'test_id': test_id,\n                    'code': code,\n                    'browser': browser,\n                    'mode': mode\n                }, to=agent_sid)\n            else:\n                return jsonify({'error': 'No agent connected'}), 503\n        \n        # Update task execution stats\n        start_time = time.time()\n        \n        # Record execution in background\n        def record_execution():\n            # Wait a bit for execution to complete\n            time.sleep(2)\n            \n            # Get execution result from test_history\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('SELECT status, logs FROM test_history WHERE id=?', (test_id,))\n            row = c.fetchone()\n            \n            if row:\n                status = row[0]\n                logs = row[1]\n                success = status == 'success'\n                \n                # Update task stats\n                task = LearnedTask.get_by_id(task_id)\n                if task:\n                    if success:\n                        task.success_count += 1\n                    else:\n                        task.failure_count += 1\n                    task.last_executed = datetime.now()\n                    task.save()\n                \n                # Record execution\n                execution_time = int((time.time() - start_time) * 1000)\n                execution = TaskExecution(\n                    task_id=task_id,\n                    execution_result=status,\n                    success=success,\n                    error_message=logs if not success else None,\n                    execution_time_ms=execution_time\n                )\n                execution.save()\n            \n            conn.close()\n        \n        socketio.start_background_task(record_execution)\n        \n        return jsonify({\n            'test_id': test_id,\n            'task_name': task.task_name,\n            'message': 'Task execution started'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/recall', methods=['POST'])\ndef recall_and_execute():\n    \"\"\"\n    Recall Mode: Search for a task by natural language and execute it.\n    This is the main entry point for the persistent learning system.\n    \"\"\"\n    try:\n        data = request.json or {}\n        query = data.get('query')\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        auto_execute = data.get('auto_execute', False)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Recall Mode requires an OpenAI API key to search for tasks.'\n            }), 400\n        \n        # Search for the most relevant task\n        try:\n            results = semantic_search.search_tasks(query, top_k=1)\n        except Exception as search_error:\n            error_msg = str(search_error)\n            if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n                return jsonify({\n                    'error': f'OPENAI_API_KEY error: {error_msg}'\n                }), 400\n            raise\n        \n        if not results:\n            return jsonify({\n                'found': False,\n                'message': 'No matching tasks found. Consider creating a new task.'\n            })\n        \n        # Get the best match\n        best_match = results[0]\n        task_id = best_match['task_id']\n        similarity_score = best_match.get('similarity_score', 0)\n        \n        # If auto_execute is True and similarity is high enough, execute immediately\n        if auto_execute and similarity_score > 0.7:\n            # Execute the task\n            task = LearnedTask.get_by_id(task_id)\n            if not task:\n                return jsonify({'error': 'Task not found'}), 404\n            code = task.playwright_code\n            \n            # Create test history entry\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                      (query, code, browser, mode, execution_location, 'pending'))\n            test_id = c.lastrowid\n            conn.commit()\n            conn.close()\n            \n            # Execute\n            if execution_location == 'server':\n                socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n            \n            return jsonify({\n                'found': True,\n                'executed': True,\n                'test_id': test_id,\n                'task': best_match,\n                'similarity_score': similarity_score\n            })\n        else:\n            # Return the best match for user confirmation\n            return jsonify({\n                'found': True,\n                'executed': False,\n                'task': best_match,\n                'similarity_score': similarity_score,\n                'message': 'Task found. Please confirm execution or adjust the query.'\n            })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Teaching Mode Recording - Store recorded actions by session\nrecording_sessions = {}\n\n@app.route('/api/teaching/start', methods=['POST'])\ndef start_teaching_recording():\n    \"\"\"Start interactive recording session for Teaching Mode - routes to agent.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id') or str(uuid.uuid4())\n        # Don't provide default URL - let browser open blank (like Playwright codegen)\n        start_url = data.get('start_url', '')\n        \n        # Check if any agent is connected\n        if not connected_agents:\n            return jsonify({\n                'error': 'No agent connected. Please connect a local agent to use Teaching Mode.',\n                'session_id': session_id\n            }), 400\n        \n        # Initialize recording session\n        recording_sessions[session_id] = {\n            'actions': [],\n            'start_time': time.time(),\n            'start_url': start_url\n        }\n        \n        # Emit start_recording event to agent\n        socketio.emit('start_recording', {\n            'session_id': session_id,\n            'start_url': start_url\n        })\n        \n        print(f\"üì§ Sent start_recording to agent for session {session_id}\")\n        \n        return jsonify({\n            'success': True,\n            'session_id': session_id,\n            'message': 'Recording request sent to agent. Browser will open on your machine.'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/navigate', methods=['POST'])\ndef teaching_navigate():\n    \"\"\"Navigate to a URL during recording.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        url = data.get('url')\n        \n        if not session_id or session_id not in active_recorders:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        recorder = active_recorders[session_id]\n        loop = active_loops.get(session_id)\n        \n        if not loop or not recorder.page:\n            return jsonify({'error': 'Recording session not ready'}), 400\n        \n        # Run navigation using the session's event loop\n        try:\n            asyncio.run_coroutine_threadsafe(recorder.page.goto(url), loop).result(timeout=10)\n            recorder.record_goto(url)\n            return jsonify({'success': True})\n        except Exception as e:\n            print(f\"Navigation error: {e}\")\n            return jsonify({'error': str(e)}), 500\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/actions', methods=['GET'])\ndef get_teaching_actions():\n    \"\"\"Get currently recorded actions.\"\"\"\n    try:\n        session_id = request.args.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'actions': []})\n        \n        session = recording_sessions[session_id]\n        return jsonify({'actions': session.get('actions', [])})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/stop', methods=['POST'])\ndef stop_teaching_recording():\n    \"\"\"Stop recording and return captured actions.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        # Emit stop_recording event to agent\n        socketio.emit('stop_recording', {\n            'session_id': session_id\n        })\n        \n        print(f\"üì§ Sent stop_recording to agent for session {session_id}\")\n        \n        # Return success - actual actions will come via recording_stopped event\n        return jsonify({\n            'success': True,\n            'message': 'Stop request sent to agent'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/save_to_library', methods=['POST'])\ndef save_recording_to_library():\n    \"\"\"Save a recorded session to the task library.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        task_name = data.get('task_name')\n        description = data.get('description', '')\n        tags = data.get('tags', [])\n        \n        if not session_id or not task_name:\n            return jsonify({'error': 'session_id and task_name are required'}), 400\n        \n        session = recording_sessions.get(session_id)\n        if not session:\n            return jsonify({'error': 'Recording session not found'}), 404\n        \n        playwright_code = session.get('playwright_code')\n        actions = session.get('actions', [])\n        \n        if not playwright_code:\n            return jsonify({'error': 'No recorded code available'}), 400\n        \n        task_id = str(uuid.uuid4())\n        \n        steps = [{'step': i+1, 'description': action.get('description', '')} \n                 for i, action in enumerate(actions)]\n        \n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags + ['recorded', 'teaching-mode']\n        )\n        \n        task.save()\n        \n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"‚úÖ Recorded task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Failed to index task for search: {e}\")\n        \n        print(f\"‚úÖ Recording saved to task library: {task_name} ({task_id})\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict(),\n            'message': f'Task \"{task_name}\" saved to library'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n\n@socketio.on('connect')\ndef handle_connect():\n    print(f'Client connected: {request.sid}')\n    emit('connected', {'sid': request.sid})\n    # Send current list of connected agents to newly connected web client\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print(f'Client disconnected: {request.sid}')\n    if request.sid in connected_agents:\n        del connected_agents[request.sid]\n        print(f'Updated connected_agents after disconnect: {connected_agents}')\n        socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_register')\ndef handle_agent_register(data):\n    agent_id = data.get('agent_id')\n    connected_agents[request.sid] = {\n        'agent_id': agent_id,\n        'browsers': data.get('browsers', []),\n        'connected_at': datetime.now().isoformat()\n    }\n    print(f'Agent registered: {agent_id}')\n    print(f'Updated connected_agents after register: {connected_agents}')\n    emit('agent_registered', {'status': 'success'})\n    print(f'Emitting agents_update: {list(connected_agents.values())}')\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_result')\ndef handle_agent_result(data):\n    test_id = data.get('test_id')\n    success = data.get('success')\n    logs = data.get('logs', [])\n    screenshot_data = data.get('screenshot')\n    \n    screenshot_path = None\n    if screenshot_data:\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        screenshot_bytes = base64.b64decode(screenshot_data)\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(screenshot_bytes)\n    \n    logs_json = json.dumps(logs)\n    status = 'success' if success else 'failed'\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': logs,\n        'screenshot_path': screenshot_path\n    })\n\n@socketio.on('agent_log')\ndef handle_agent_log(data):\n    socketio.emit('execution_status', {\n        'test_id': data.get('test_id'),\n        'status': 'running',\n        'message': data.get('message')\n    })\n\n\n@socketio.on('heartbeat')\ndef handle_heartbeat(data):\n    \"\"\"Handle heartbeat from agent to keep connection alive.\"\"\"\n    # Simply acknowledge - the ping/pong mechanism handles the rest\n    # This prevents timeout on idle connections\n    pass\n\n@socketio.on('recording_started')\ndef handle_recording_started(data):\n    \"\"\"Handle recording started event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        print(f\"‚úÖ Recording session {session_id} started on agent\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'started',\n            'message': data.get('message', 'Browser opened on agent machine')\n        })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"‚ùå Recording session {session_id} failed to start: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_actions')\ndef handle_recording_actions(data):\n    \"\"\"Handle periodic action updates from agent.\"\"\"\n    session_id = data.get('session_id')\n    actions = data.get('actions', [])\n    \n    if session_id in recording_sessions:\n        recording_sessions[session_id]['actions'].extend(actions)\n        print(f\"üì• Received {len(actions)} actions for session {session_id}. Total: {len(recording_sessions[session_id]['actions'])}\")\n\n\n@socketio.on('recording_stopped')\ndef handle_recording_stopped(data):\n    \"\"\"Handle recording stopped event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        final_actions = data.get('final_actions', [])\n        \n        if session_id in recording_sessions:\n            # Add final actions\n            recording_sessions[session_id]['actions'].extend(final_actions)\n            all_actions = recording_sessions[session_id]['actions']\n            \n            print(f\"‚úÖ Recording session {session_id} stopped. Total actions: {len(all_actions)}\")\n            \n            # Generate Playwright code from recorded actions\n            playwright_code = None\n            try:\n                if all_actions:\n                    playwright_code = generate_playwright_code_from_recording(all_actions)\n                    print(f\"‚úÖ Generated Playwright code from {len(all_actions)} actions\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Error generating Playwright code: {e}\")\n            \n            # Emit to web client with both actions and generated code\n            socketio.emit('recording_complete', {\n                'session_id': session_id,\n                'actions': all_actions,\n                'playwright_code': playwright_code\n            })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"‚ùå Recording session {session_id} stop failed: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_status')\ndef handle_recording_status(data):\n    \"\"\"Handle recording status updates from agent (including auto-stop on browser close).\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'stopped':\n        playwright_code = data.get('playwright_code')\n        actions = data.get('actions', [])\n        auto_stopped = data.get('auto_stopped', False)\n        \n        print(f\"‚úÖ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped\")\n        print(f\"   Playwright code: {'Yes' if playwright_code else 'No'}\")\n        print(f\"   Actions extracted: {len(actions)}\")\n        \n        if session_id in recording_sessions:\n            recording_sessions[session_id]['playwright_code'] = playwright_code\n            recording_sessions[session_id]['actions'] = actions\n        else:\n            recording_sessions[session_id] = {\n                'playwright_code': playwright_code,\n                'actions': actions,\n                'start_time': time.time()\n            }\n        \n        socketio.emit('recording_complete', {\n            'session_id': session_id,\n            'playwright_code': playwright_code,\n            'actions': actions,\n            'auto_stopped': auto_stopped,\n            'message': 'Browser closed. Recording stopped automatically.' if auto_stopped else 'Recording stopped.'\n        })\n    else:\n        socketio.emit('recording_status', data)\n\n\n@socketio.on('element_selected')\ndef handle_element_selected(data):\n    test_id = data.get('test_id')\n    selector = data.get('selector')\n    failed_locator = data.get('failed_locator')  # Agent should send this\n    \n    print(f\"\\n‚úÖ ELEMENT SELECTED EVENT RECEIVED:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  selector: {selector}\")\n    print(f\"  failed_locator: {failed_locator}\", flush=True)\n    \n    # Get the generated code, browser, and mode from database\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT generated_code, browser, mode FROM test_history WHERE id=?', (test_id,))\n    row = c.fetchone()\n    \n    if not row:\n        print(f\"  ‚ùå Test {test_id} not found in database\", flush=True)\n        conn.close()\n        socketio.emit('error', {\n            'test_id': test_id,\n            'message': 'Test not found in database'\n        })\n        return\n    \n    generated_code, browser, mode = row\n    \n    # If failed_locator not provided by agent, try to extract from healing_executor\n    if not failed_locator and test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        if healing_executor.failed_locators:\n            failed_locator = healing_executor.failed_locators[-1]['locator']\n    \n    # Heal the script - replace the entire failed locator method call\n    healed_code = generated_code\n    \n    if failed_locator and selector:\n        import re\n        \n        # If failed_locator is a full method call (e.g., 'page.get_by_placeholder(\"Search\")'),\n        # replace the entire method call with the healed selector\n        if 'page.' in failed_locator or 'get_by_' in failed_locator or 'locator(' in failed_locator:\n            # Try flexible replacement that handles quote variations\n            replacement_made = False\n            \n            # Extract the method and selector from failed_locator\n            # E.g., page.locator(\"input[name=\\\"q\\\"]\") -> method=page.locator, selector_content=input[name=\"q\"]\n            # Handle complex locators with nested parentheses like: page.locator(\"button:has-text(\\\"Start Chat\\\")\")\n            method_match = re.search(r'(page\\.\\w+)\\((.+)\\)$', failed_locator)\n            if method_match:\n                method_name = method_match.group(1)\n                full_args = method_match.group(2)\n                \n                # Try to extract just the main selector string (first quoted argument)\n                selector_match = re.match(r'[\"\\'](.+?)[\"\\']', full_args)\n                if selector_match:\n                    selector_content = selector_match.group(1)\n                    # Escape special regex chars in selector content but not quotes\n                    escaped_selector = re.escape(selector_content).replace(r'\\\"', r'[\\\\]?\"').replace(r\"\\'\", r\"[\\\\]?'\")\n                    \n                    # Build flexible pattern that matches both single and double quotes\n                    flexible_pattern = rf'{re.escape(method_name)}\\([\"\\']' + escaped_selector + r'[\"\\'](?:,\\s*\\w+=.*?)?\\)'\n                    \n                    if re.search(flexible_pattern, healed_code):\n                        healed_code = re.sub(flexible_pattern, selector, healed_code, count=1)\n                        print(f\"  ‚úÖ Replaced full method call (flexible): '{failed_locator}' -> '{selector}'\")\n                        replacement_made = True\n            \n            # Fallback to exact match if flexible didn't work\n            if not replacement_made:\n                escaped_failed = re.escape(failed_locator)\n                if re.search(escaped_failed, healed_code):\n                    healed_code = re.sub(escaped_failed, selector, healed_code, count=1)\n                    print(f\"  ‚úÖ Replaced full method call (exact): '{failed_locator}' -> '{selector}'\")\n                    replacement_made = True\n            \n            # If still no replacement, try smart contextual replacement\n            if not replacement_made:\n                print(f\"  ‚ö†Ô∏è  Could not find failed locator '{failed_locator}' in code\")\n                print(f\"  üí° Trying smart contextual replacement...\")\n                \n                # Extract key text from failed_locator (e.g., \"Start Chat\" from any locator method)\n                text_patterns = [\n                    r'name=\"([^\"]+)\"',  # name=\"Start Chat\"\n                    r'name=\\'([^\\']+)\\'',  # name='Start Chat'\n                    r':has-text\\([\"\\']([^\"\\']+)[\"\\']\\)',  # :has-text(\"Start Chat\")\n                    r'text=\"([^\"]+)\"',  # text=\"Start Chat\"\n                    r'text=\\'([^\\']+)\\'',  # text='Start Chat'\n                    r'[\"\\']([^\"\\']*(?:button|link|input)[^\"\\']*)[\"\\']',  # Any quoted text with element keywords\n                ]\n                \n                key_text = None\n                for pattern in text_patterns:\n                    match = re.search(pattern, failed_locator, re.IGNORECASE)\n                    if match:\n                        key_text = match.group(1)\n                        break\n                \n                if key_text:\n                    print(f\"  üîç Extracted key text: '{key_text}'\")\n                    # Find any line containing this text in a locator\n                    # Match any page.* method call that contains this text\n                    context_pattern = rf'(await\\s+)?page\\.\\w+\\([^)]*{re.escape(key_text)}[^)]*\\)(?:\\.(?:click|fill|type|press|check|select_option)\\([^)]*\\))?'\n                    context_match = re.search(context_pattern, healed_code)\n                    \n                    if context_match:\n                        old_locator_call = context_match.group(0)\n                        # Replace the entire locator call with the new selector + action\n                        # Extract the action (click, fill, etc.) from the old call\n                        action_match = re.search(r'\\.(click|fill|type|press|check|select_option)\\(([^)]*)\\)', old_locator_call)\n                        if action_match:\n                            action = action_match.group(1)\n                            action_args = action_match.group(2)\n                            new_call = f\"await {selector}.{action}({action_args})\"\n                            healed_code = healed_code.replace(old_locator_call, new_call, 1)\n                            print(f\"  ‚úÖ Smart replacement: Found context and replaced entire call\")\n                            print(f\"     Old: {old_locator_call}\")\n                            print(f\"     New: {new_call}\")\n                            replacement_made = True\n                        else:\n                            # No action, just replace the locator part\n                            healed_code = healed_code.replace(old_locator_call, f\"await {selector}\", 1)\n                            print(f\"  ‚úÖ Smart replacement: Replaced locator without action\")\n                            replacement_made = True\n                    else:\n                        print(f\"  ‚ö†Ô∏è  Could not find any locator containing '{key_text}'\")\n                \n                # Last fallback: try simple string replacement\n                if not replacement_made:\n                    locator_match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', failed_locator)\n                    if locator_match:\n                        locator_to_find = locator_match.group(1)\n                        if not (selector.startswith('page.') or selector.startswith('get_by_') or 'locator(' in selector):\n                            # Simple string replacement\n                            escaped_locator = re.escape(locator_to_find)\n                            replacement_patterns = [\n                                (rf'\"{escaped_locator}\"', f'\"{selector}\"'),\n                                (rf\"'{escaped_locator}'\", f\"'{selector}'\"),\n                            ]\n                            \n                            for pattern, replacement in replacement_patterns:\n                                if re.search(pattern, healed_code):\n                                    healed_code = re.sub(pattern, replacement, healed_code, count=1)\n                                    print(f\"  ‚úÖ Replaced locator string: '{locator_to_find}' -> '{selector}'\")\n                                    replacement_made = True\n                                    break\n        else:\n            # Old logic: failed_locator is just a string selector\n            escaped_locator = re.escape(failed_locator)\n            replacement_patterns = [\n                (rf'\"{escaped_locator}\"', f'\"{selector}\"'),\n                (rf\"'{escaped_locator}'\", f\"'{selector}'\"),\n            ]\n            \n            replacement_made = False\n            for pattern, replacement in replacement_patterns:\n                if re.search(pattern, healed_code):\n                    old_code = healed_code\n                    healed_code = re.sub(pattern, replacement, healed_code, count=1)\n                    replacement_made = (healed_code != old_code)\n                    if replacement_made:\n                        print(f\"  ‚úÖ Replaced locator: '{failed_locator}' -> '{selector}'\")\n                        break\n            \n            if not replacement_made:\n                print(f\"  ‚ö†Ô∏è  Could not find locator '{failed_locator}' in generated code\")\n                print(f\"  üí° User may need to manually update the healed script\")\n    \n    print(f\"\\nüîß HEALING SCRIPT IN handle_element_selected:\")\n    print(f\"  Failed locator: '{failed_locator}'\")\n    print(f\"  Healed locator: '{selector}'\")\n    print(f\"  Replacement successful: {healed_code != generated_code}\")\n    print(f\"  Healed code length: {len(healed_code)}\", flush=True)\n    \n    # Save healed code to database\n    c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ‚úÖ Healed code saved to database for test {test_id}\", flush=True)\n    \n    # Update healing executor if it exists\n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.set_user_selector(selector)\n        healing_executor.healed_script = healed_code\n    \n    # Emit confirmation to UI\n    socketio.emit('element_selected_confirmed', {\n        'test_id': test_id,\n        'selector': selector,\n        'failed_locator': failed_locator,\n        'healed_script': healed_code\n    })\n    \n    # FIX: Trigger re-execution with healed code (final attempt with user-selected locator)\n    print(f\"\\nüöÄ TRIGGERING FINAL RETRY with user-selected locator...\")\n    print(f\"  Test ID: {test_id}\")\n    print(f\"  Browser: {browser}\")\n    print(f\"  Mode: {mode}\")\n    \n    # Get agent's session ID from healing executor or connected agents\n    agent_sid = None\n    if test_id in active_healing_executors:\n        agent_sid = active_healing_executors[test_id].agent_sid\n        print(f\"  Agent SID from executor: {agent_sid}\")\n    \n    if not agent_sid and connected_agents:\n        # Fallback to any connected agent\n        agent_sid = list(connected_agents.keys())[0]\n        print(f\"  Using first connected agent: {agent_sid}\")\n    \n    if agent_sid:\n        # This is the FINAL manual healing attempt - mark it specially\n        # and disable further healing if it fails\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': healed_code,\n            'browser': browser or 'chromium',\n            'mode': mode or 'headful',\n            'attempt': 999,  # Special marker: final manual attempt, no more healing\n            'final_manual_attempt': True  # Flag to prevent further healing requests\n        }, to=agent_sid)\n        print(f\"  ‚úÖ FINAL manual healing attempt triggered with healed code to agent {agent_sid}\", flush=True)\n        \n        # Mark that manual healing has been attempted for this test\n        # to prevent multiple manual healing widgets\n        if test_id in active_healing_executors:\n            active_healing_executors[test_id].manual_healing_attempted = True\n    else:\n        print(f\"  ‚ùå No agent connected - cannot trigger retry\", flush=True)\n        socketio.emit('error', {\n            'test_id': test_id,\n            'message': 'No agent connected for retry execution'\n        })\n\n@socketio.on('request_ai_healing')\ndef handle_ai_healing_request(data):\n    \"\"\"\n    Handle AI healing request for code generation errors.\n    Automatically retries with improved AI prompting based on error type.\n    \"\"\"\n    test_id = data.get('test_id')\n    error_type = data.get('error_type')\n    error_info = data.get('error_info', {})\n    attempt = data.get('attempt', 1)\n    agent_sid = request.sid  # Get the agent's session ID\n    \n    print(f\"\\nü§ñ AI HEALING REQUEST:\")\n    print(f\"  Test ID: {test_id}\")\n    print(f\"  Error Type: {error_type}\")\n    print(f\"  Attempt: {attempt}\")\n    print(f\"  Error Detail: {error_info.get('detail', error_info.get('full_error', 'N/A'))[:150]}\")\n    \n    # Get the original code from database\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT generated_code, healed_code, browser, mode FROM test_history WHERE id=?', (test_id,))\n    row = c.fetchone()\n    \n    if not row:\n        print(f\"  ‚ùå Test {test_id} not found in database\")\n        conn.close()\n        return\n    \n    generated_code, existing_healed_code, browser, mode = row\n    current_code = existing_healed_code if existing_healed_code else generated_code\n    \n    # Get or create healing executor\n    if test_id not in active_healing_executors:\n        openai_key = os.environ.get('OPENAI_API_KEY')\n        healing_executor = HealingExecutor(socketio, api_key=openai_key, use_gpt4o=False)\n        healing_executor.agent_sid = agent_sid\n        active_healing_executors[test_id] = healing_executor\n    else:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.agent_sid = agent_sid\n    \n    # Extract error detail\n    error_detail = error_info.get('detail', error_info.get('full_error', 'Unknown error'))\n    failed_step = error_info.get('step', 0)\n    \n    # Check max retries (2 AI attempts, then manual widget)\n    max_retries = healing_executor.max_retries\n    if attempt >= max_retries:\n        print(f\"  ‚ö†Ô∏è Max AI healing attempts ({max_retries}) reached, triggering manual widget...\")\n        \n        # Trigger manual healing with special attempt number (999) for final manual attempt\n        # Agent will show manual widget when it receives attempt >= 999\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': current_code,\n            'browser': browser,\n            'mode': mode,\n            'attempt': 999,\n            'final_manual_attempt': True\n        }, to=agent_sid)\n        print(f\"  üéØ Sent manual healing trigger to agent (attempt 999 - final manual attempt)\")\n        conn.close()\n        return\n    \n    # Use AI to regenerate the code\n    print(f\"  üîÑ Regenerating code with AI (attempt {attempt}/{max_retries})...\")\n    healed_code = healing_executor.regenerate_code_with_ai(\n        current_code,\n        error_detail,\n        failed_step,\n        attempt,\n        error_type=error_type\n    )\n    \n    if healed_code and healed_code != current_code:\n        # Save healed code to database\n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_code, test_id))\n        conn.commit()\n        print(f\"  ‚úÖ AI regenerated code saved to database ({len(healed_code)} chars)\")\n        \n        # Send healed code back to agent for retry\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': healed_code,\n            'browser': browser,\n            'mode': mode,\n            'attempt': attempt + 1\n        }, to=agent_sid)\n        print(f\"  üöÄ Sent healed code to agent for retry (attempt {attempt + 1}/{max_retries})\")\n    else:\n        print(f\"  ‚ö†Ô∏è AI regeneration failed or produced same code\")\n        # Mark as failed in database\n        c.execute('UPDATE test_history SET status=? WHERE id=?', ('failed', test_id))\n        conn.commit()\n        # Notify agent to close browser\n        socketio.emit('healing_complete', {\n            'test_id': test_id,\n            'success': False,\n            'reason': 'regeneration_failed'\n        }, to=agent_sid)\n    \n    conn.close()\n\n@socketio.on('healing_attempt_result')\ndef handle_healing_attempt_result(data):\n    \"\"\"Handle result from agent healing attempt execution.\"\"\"\n    test_id = data.get('test_id')\n    \n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        result = {\n            'success': data.get('success'),\n            'logs': data.get('logs', []),\n            'screenshot': data.get('screenshot')\n        }\n        # Set via both methods for compatibility\n        healing_executor.set_agent_result(result)\n        # Also set via gevent AsyncResult for cross-greenlet communication\n        if hasattr(healing_executor, 'agent_result_async'):\n            healing_executor.agent_result_async.set(result)\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 6890))\n    socketio.run(\n        app,\n        host='127.0.0.1',  # localhost\n        port=port,\n        debug=True,\n        allow_unsafe_werkzeug=True\n    )\n","size_bytes":101366},"config/gunicorn.conf.py":{"content":"import logging\nimport signal\n\n# Bind to 0.0.0.0:5000 (required for Replit environment)\nbind = \"0.0.0.0:5000\"\n\n# Worker class for async support with SocketIO\nworker_class = \"gevent\"\n\n# Number of workers\nworkers = 1\n\n# Set log level to WARNING to suppress SIGWINCH INFO messages\nloglevel = \"warning\"\n\n# Custom logger class to filter out SIGWINCH messages\nclass FilteredGunicornLogger(logging.Logger):\n    def log(self, level, msg, *args, **kwargs):\n        if \"Handling signal: winch\" not in str(msg):\n            super().log(level, msg, *args, **kwargs)\n\nlogconfig_dict = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'generic': {\n            'format': '%(asctime)s [%(process)d] [%(levelname)s] %(message)s',\n            'datefmt': '[%Y-%m-%d %H:%M:%S %z]',\n        },\n    },\n    'filters': {\n        'winch_filter': {\n            '()': lambda: type('WinchFilter', (), {\n                'filter': lambda self, record: 'Handling signal: winch' not in record.getMessage()\n            })()\n        }\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': 'generic',\n            'filters': ['winch_filter'],\n            'stream': 'ext://sys.stdout'\n        },\n    },\n    'root': {\n        'level': 'INFO',\n        'handlers': ['console']\n    },\n    'loggers': {\n        'gunicorn.error': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        },\n        'gunicorn.access': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        }\n    }\n}\n","size_bytes":1643},"run_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"Entry point for running the VisionVault server.\"\"\"\n\nfrom visionvault.web.app import app, socketio\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 5000))\n    socketio.run(app, host='0.0.0.0', port=port, debug=False, allow_unsafe_werkzeug=True)","size_bytes":300},"visionvault/services/multi_strategy_healer.py":{"content":"\"\"\"\nMulti-Strategy Parallel Healing\n\nThis module implements advanced healing that:\n1. Generates multiple fix strategies simultaneously\n2. Tests all strategies in parallel\n3. Automatically selects the best working solution\n4. Learns from successful strategies for future use\n\"\"\"\n\nimport asyncio\nfrom typing import Dict, List, Optional, Tuple\nfrom openai import OpenAI\nimport json\nimport os\n\n\nclass MultiStrategyHealer:\n    \"\"\"Advanced healing with parallel strategy execution\"\"\"\n    \n    def __init__(self, openai_client: Optional[OpenAI] = None):\n        self.client = openai_client\n        self.strategy_success_history = self._load_history()\n    \n    def _load_history(self) -> Dict:\n        \"\"\"Load history of successful strategies\"\"\"\n        history_file = 'data/strategy_history.json'\n        try:\n            if os.path.exists(history_file):\n                with open(history_file, 'r') as f:\n                    return json.load(f)\n        except Exception:\n            pass\n        return {}\n    \n    def _save_history(self):\n        \"\"\"Save strategy success history\"\"\"\n        try:\n            os.makedirs('data', exist_ok=True)\n            with open('data/strategy_history.json', 'w') as f:\n                json.dump(self.strategy_success_history, f, indent=2)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Could not save strategy history: {e}\")\n    \n    def generate_multiple_strategies(\n        self,\n        failed_code: str,\n        error_message: str,\n        failed_step: int,\n        page_content: str = ''\n    ) -> List[Dict]:\n        \"\"\"\n        Generate multiple different healing strategies in parallel.\n        Each strategy uses a different approach to fix the same issue.\n        \"\"\"\n        if not self.client:\n            return self._generate_fallback_strategies(failed_code, error_message)\n        \n        try:\n            # Identify the type of failure\n            failure_type = self._classify_error(error_message)\n            \n            # Generate multiple strategies using GPT-4o-mini\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at generating MULTIPLE different strategies to fix automation failures.\n\nYour task: Generate 3-4 DIFFERENT approaches to fix the same issue. Each strategy should use a fundamentally different technique.\n\nSTRATEGY TYPES TO CONSIDER:\n\n1. LOCATOR-BASED STRATEGY\n   - Use different locator types (role, text, placeholder, label, CSS, XPath)\n   - Try multiple selectors for redundancy\n   - Use chained locators or filters\n\n2. TIMING-BASED STRATEGY\n   - Add longer waits and timeouts\n   - Wait for specific states (load, networkidle, visible, attached)\n   - Add delays before interactions\n   - Wait for animations to complete\n\n3. NAVIGATION-BASED STRATEGY\n   - Scroll element into view\n   - Handle overlays/modals first\n   - Navigate through page differently\n   - Use keyboard navigation instead of clicks\n\n4. ROBUST-APPROACH STRATEGY\n   - Try multiple locators with fallback logic\n   - Add retry loops with exponential backoff\n   - Check element state before interaction\n   - Handle dynamic content explicitly\n\nFor each strategy, provide:\n1. Strategy name and type\n2. Confidence score (0-100)\n3. Complete fixed code for the failed step\n4. Explanation of why this approach should work\n\nReturn as JSON array:\n[\n  {\n    \"name\": \"Strategy name\",\n    \"type\": \"locator/timing/navigation/robust\",\n    \"confidence\": 85,\n    \"code\": \"Fixed code here\",\n    \"explanation\": \"Why this works\"\n  }\n]\n\nGenerate 3-4 diverse strategies that attack the problem from different angles.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed automation needs multiple fix strategies:\n\nFAILED STEP {failed_step}:\n```python\n{self._extract_failed_step_code(failed_code, failed_step)}\n```\n\nERROR:\n{error_message}\n\nPAGE CONTEXT:\n{page_content[:1000] if page_content else 'Not available'}\n\nGenerate 3-4 different strategies to fix this issue.\"\"\"}\n                ],\n                temperature=0.4,  # Slightly higher for diversity\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            result = response.choices[0].message.content.strip()\n            strategies_data = json.loads(result)\n            \n            # Extract strategies array (handle both array and object responses)\n            if isinstance(strategies_data, dict) and 'strategies' in strategies_data:\n                strategies = strategies_data['strategies']\n            elif isinstance(strategies_data, list):\n                strategies = strategies_data\n            else:\n                strategies = [strategies_data]\n            \n            # Sort by confidence\n            strategies.sort(key=lambda x: x.get('confidence', 0), reverse=True)\n            \n            print(f\"\\nüéØ Generated {len(strategies)} healing strategies:\")\n            for i, strat in enumerate(strategies, 1):\n                print(f\"   {i}. {strat.get('name', 'Strategy')} ({strat.get('type', 'unknown')}) - Confidence: {strat.get('confidence', 0)}%\")\n            \n            return strategies\n        \n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Multi-strategy generation error: {e}\")\n            return self._generate_fallback_strategies(failed_code, error_message)\n    \n    def _classify_error(self, error_message: str) -> str:\n        \"\"\"Classify the type of error\"\"\"\n        error_lower = error_message.lower()\n        \n        if 'timeout' in error_lower or 'timed out' in error_lower:\n            return 'timeout'\n        elif 'not found' in error_lower or 'no element' in error_lower:\n            return 'element_not_found'\n        elif 'not visible' in error_lower or 'not attached' in error_lower:\n            return 'visibility'\n        elif 'not clickable' in error_lower or 'intercept' in error_lower:\n            return 'not_clickable'\n        else:\n            return 'unknown'\n    \n    def _extract_failed_step_code(self, code: str, step_num: int) -> str:\n        \"\"\"Extract just the failed step code\"\"\"\n        lines = code.split('\\n')\n        step_lines = []\n        in_step = False\n        \n        for line in lines:\n            if f'STEP {step_num}:' in line or f'Step {step_num}:' in line:\n                in_step = True\n            elif in_step and ('STEP' in line or 'Step' in line) and str(step_num) not in line:\n                break\n            \n            if in_step:\n                step_lines.append(line)\n        \n        return '\\n'.join(step_lines) if step_lines else code[:500]\n    \n    def _generate_fallback_strategies(self, failed_code: str, error_message: str) -> List[Dict]:\n        \"\"\"Generate basic strategies without AI\"\"\"\n        return [\n            {\n                'name': 'Extended Timeout',\n                'type': 'timing',\n                'confidence': 60,\n                'code': 'await element.click(timeout=15000)',\n                'explanation': 'Increase timeout to handle slow loading'\n            },\n            {\n                'name': 'Wait for Visible',\n                'type': 'timing',\n                'confidence': 55,\n                'code': 'await element.wait_for(state=\"visible\", timeout=10000)\\nawait element.click()',\n                'explanation': 'Explicitly wait for element visibility'\n            },\n            {\n                'name': 'Scroll Into View',\n                'type': 'navigation',\n                'confidence': 50,\n                'code': 'await element.scroll_into_view_if_needed()\\nawait element.click()',\n                'explanation': 'Ensure element is in viewport'\n            }\n        ]\n    \n    async def test_strategy(\n        self,\n        strategy: Dict,\n        full_code: str,\n        failed_step: int,\n        executor_function\n    ) -> Tuple[bool, Dict, str]:\n        \"\"\"\n        Test a single strategy by executing it.\n        Returns: (success, result, strategy_name)\n        \"\"\"\n        strategy_name = strategy.get('name', 'Unknown')\n        \n        try:\n            print(f\"   üß™ Testing: {strategy_name}...\")\n            \n            # Apply the strategy to the code\n            healed_code = self._apply_strategy(full_code, failed_step, strategy)\n            \n            # Execute the healed code\n            result = await executor_function(healed_code)\n            \n            success = result.get('success', False)\n            \n            if success:\n                print(f\"   ‚úÖ {strategy_name} SUCCEEDED!\")\n                # Record success\n                self._record_success(strategy)\n            else:\n                print(f\"   ‚ùå {strategy_name} failed\")\n            \n            return (success, result, strategy_name)\n        \n        except Exception as e:\n            print(f\"   ‚ùå {strategy_name} error: {e}\")\n            return (False, {'success': False, 'error': str(e)}, strategy_name)\n    \n    def _apply_strategy(self, full_code: str, failed_step: int, strategy: Dict) -> str:\n        \"\"\"Apply a strategy to the code\"\"\"\n        # Find and replace the failed step with the strategy's code\n        lines = full_code.split('\\n')\n        new_lines = []\n        in_failed_step = False\n        step_replaced = False\n        \n        for line in lines:\n            # Check if we're at the failed step\n            if f'STEP {failed_step}:' in line or f'Step {failed_step}:' in line:\n                in_failed_step = True\n                new_lines.append(line)  # Keep the comment\n                # Add the strategy code\n                strategy_code = strategy.get('code', '')\n                for strategy_line in strategy_code.split('\\n'):\n                    new_lines.append(' ' * 12 + strategy_line)  # Proper indentation\n                step_replaced = True\n                continue\n            \n            # Skip original failed step code\n            if in_failed_step:\n                # Check if we've moved to next step\n                if ('STEP' in line or 'Step' in line) and str(failed_step) not in line:\n                    in_failed_step = False\n                    new_lines.append(line)\n                elif not line.strip().startswith('#'):\n                    # Skip the original failed code\n                    continue\n                else:\n                    new_lines.append(line)\n            else:\n                new_lines.append(line)\n        \n        if not step_replaced:\n            # Fallback: just append strategy at the end\n            return full_code + '\\n' + strategy.get('code', '')\n        \n        return '\\n'.join(new_lines)\n    \n    def _record_success(self, strategy: Dict):\n        \"\"\"Record a successful strategy\"\"\"\n        strategy_type = strategy.get('type', 'unknown')\n        \n        if strategy_type not in self.strategy_success_history:\n            self.strategy_success_history[strategy_type] = {\n                'total_attempts': 0,\n                'successes': 0,\n                'success_rate': 0.0\n            }\n        \n        self.strategy_success_history[strategy_type]['total_attempts'] += 1\n        self.strategy_success_history[strategy_type]['successes'] += 1\n        self.strategy_success_history[strategy_type]['success_rate'] = (\n            self.strategy_success_history[strategy_type]['successes'] /\n            self.strategy_success_history[strategy_type]['total_attempts'] * 100\n        )\n        \n        self._save_history()\n    \n    async def heal_with_parallel_strategies(\n        self,\n        failed_code: str,\n        error_message: str,\n        failed_step: int,\n        page_content: str,\n        executor_function\n    ) -> Dict:\n        \"\"\"\n        Main healing function: Generate and test multiple strategies in parallel.\n        Returns the best working solution.\n        \"\"\"\n        print(f\"\\nüöÄ Multi-Strategy Parallel Healing...\")\n        \n        # Generate multiple strategies\n        strategies = self.generate_multiple_strategies(\n            failed_code,\n            error_message,\n            failed_step,\n            page_content\n        )\n        \n        if not strategies:\n            return {\n                'success': False,\n                'error': 'No strategies generated'\n            }\n        \n        # Test strategies in parallel\n        print(f\"\\nüß™ Testing {len(strategies)} strategies in parallel...\")\n        \n        tasks = [\n            self.test_strategy(strategy, failed_code, failed_step, executor_function)\n            for strategy in strategies\n        ]\n        \n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Find the first successful strategy\n        for item in results:\n            # Handle exceptions in results\n            if isinstance(item, Exception):\n                print(f\"   ‚ö†Ô∏è  Strategy error: {item}\")\n                continue\n            \n            # Unpack the tuple safely\n            try:\n                success, result, strategy_name = item\n            except (TypeError, ValueError):\n                print(f\"   ‚ö†Ô∏è  Invalid result format: {item}\")\n                continue\n            \n            if success:\n                print(f\"\\n‚úÖ SUCCESS! {strategy_name} worked!\")\n                return {\n                    'success': True,\n                    'healed_code': result.get('healed_code') if isinstance(result, dict) else None,\n                    'strategy_used': strategy_name,\n                    'result': result\n                }\n        \n        # If no strategy worked, return the result from the highest confidence strategy\n        print(f\"\\n‚ùå All strategies failed. Using highest confidence attempt.\")\n        for item in results:\n            if not isinstance(item, Exception):\n                try:\n                    _, result, strategy_name = item\n                    return {\n                        'success': False,\n                        'attempted_strategies': len(strategies),\n                        'best_strategy': strategy_name,\n                        'result': result\n                    }\n                except (TypeError, ValueError):\n                    continue\n        \n        return {\n            'success': False,\n            'error': 'All strategies failed',\n            'attempted_strategies': len(strategies)\n        }\n","size_bytes":14311},"visionvault/agents/recording_session.py":{"content":"import asyncio\nimport os\nimport subprocess\nfrom .config import AGENT_ID, SERVER_URL\n\nclass CodegenRecordingSessionManager:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n        self.sessions = {}  # session_id -> subprocess info\n\n    async def start_recording_session(self, session_id: str, start_url: str = \"\"):\n        \"\"\"Start a Playwright codegen session in a subprocess.\"\"\"\n        if session_id in self.sessions:\n            print(f\"Session {session_id} is already running\")\n            return\n\n        os.makedirs(\"recordings\", exist_ok=True)\n        output_file = os.path.join(\"recordings\", f\"{session_id}.py\")\n\n        cmd = [\n            \"playwright\",\n            \"codegen\",\n            \"--target=python\",\n            \"--output\", output_file\n        ]\n        if start_url:\n            cmd.append(start_url)\n\n        print(f\"üé¨ Starting codegen session {session_id}\")\n        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        self.sessions[session_id] = {\n            \"process\": process,\n            \"output_file\": output_file,\n            \"start_url\": start_url\n        }\n\n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"started\",\n            \"output_file\": output_file\n        })\n        \n        asyncio.create_task(self._monitor_process(session_id))\n\n    async def _monitor_process(self, session_id: str):\n        \"\"\"Monitor the recording process and auto-stop when browser closes.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            return\n        \n        process = session[\"process\"]\n        \n        await asyncio.get_event_loop().run_in_executor(None, process.wait)\n        \n        print(f\"üîî Browser closed for session {session_id}. Auto-stopping recording...\")\n        await self.stop_recording_session(session_id, auto_stopped=True)\n\n    async def stop_recording_session(self, session_id: str, auto_stopped: bool = False):\n        \"\"\"Stop the codegen subprocess and read the generated file.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            print(f\"Session {session_id} not found\")\n            return\n\n        process = session[\"process\"]\n        output_file = session[\"output_file\"]\n        \n        if process.poll() is None:\n            process.terminate()\n            try:\n                await asyncio.get_event_loop().run_in_executor(None, lambda: process.wait(timeout=5))\n            except subprocess.TimeoutExpired:\n                process.kill()\n        \n        await asyncio.sleep(0.5)\n        \n        playwright_code = None\n        actions = []\n        \n        if os.path.exists(output_file):\n            try:\n                with open(output_file, 'r') as f:\n                    playwright_code = f.read()\n                \n                actions = self._extract_actions_from_code(playwright_code)\n                print(f\"‚úÖ Extracted {len(actions)} actions from recording\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Error reading recording file: {e}\")\n        \n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"stopped\",\n            \"output_file\": output_file,\n            \"playwright_code\": playwright_code,\n            \"actions\": actions,\n            \"auto_stopped\": auto_stopped\n        })\n\n        print(f\"‚úÖ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped. Output: {output_file}\")\n        del self.sessions[session_id]\n    \n    def _extract_actions_from_code(self, code: str) -> list:\n        \"\"\"Extract human-readable actions with locators from generated Playwright code.\"\"\"\n        actions = []\n        lines = code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            if 'page.goto(' in line:\n                import re\n                match = re.search(r'page\\.goto\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Navigate',\n                        'locator': match.group(1),\n                        'description': f'Navigate to {match.group(1)}'\n                    })\n            \n            elif 'page.click(' in line:\n                import re\n                match = re.search(r'page\\.click\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Click',\n                        'locator': match.group(1),\n                        'description': f'Click element: {match.group(1)}'\n                    })\n            \n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r'page\\.fill\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Type',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Type \"{match.group(2)}\" into {match.group(1)}'\n                    })\n            \n            elif 'page.select_option(' in line:\n                import re\n                match = re.search(r'page\\.select_option\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Select',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Select option \"{match.group(2)}\" in {match.group(1)}'\n                    })\n            \n            elif 'page.check(' in line:\n                import re\n                match = re.search(r'page\\.check\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Check',\n                        'locator': match.group(1),\n                        'description': f'Check checkbox: {match.group(1)}'\n                    })\n            \n            elif 'page.press(' in line or 'page.keyboard.press(' in line:\n                import re\n                match = re.search(r'press\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Press Key',\n                        'locator': match.group(1),\n                        'description': f'Press key: {match.group(1)}'\n                    })\n        \n        return actions\n","size_bytes":6586},"visionvault/mcp/__init__.py":{"content":"\"\"\"MCP (Model Context Protocol) integration for VisionVault.\"\"\"\n\nfrom .server import VisionVaultMCPServer\n\n__all__ = ['VisionVaultMCPServer']\n","size_bytes":142},"visionvault/mcp/server.py":{"content":"\"\"\"\nVisionVault MCP Server\n\nProvides Model Context Protocol tools for enhanced code generation and healing.\nExposes VisionVault's intelligence (learned tasks, DOM inspection, healing strategies)\nas tools that can be used by AI models for better automation code.\n\"\"\"\n\nimport json\nimport asyncio\nfrom typing import Dict, List, Any, Optional\nimport sqlite3\nfrom pathlib import Path\n\n\nclass VisionVaultMCPServer:\n    \"\"\"MCP Server that exposes VisionVault's automation intelligence as tools.\"\"\"\n    \n    def __init__(self, database_path: str, vector_store=None, dom_inspector=None):\n        \"\"\"\n        Initialize MCP server with access to VisionVault's data and services.\n        \n        Args:\n            database_path: Path to the automation database\n            vector_store: Vector store for semantic search (optional)\n            dom_inspector: DOM inspector service (optional)\n        \"\"\"\n        self.database_path = database_path\n        self.vector_store = vector_store\n        self.dom_inspector = dom_inspector\n        \n        # Define available tools\n        self.tools = {\n            'search_learned_tasks': {\n                'description': 'Search for similar learned automation tasks using semantic search',\n                'parameters': {\n                    'query': 'Natural language description of the automation task',\n                    'top_k': 'Number of similar tasks to return (default: 3)'\n                },\n                'handler': self.search_learned_tasks\n            },\n            'get_task_execution_history': {\n                'description': 'Get execution history and success patterns for similar tasks',\n                'parameters': {\n                    'task_description': 'Description of the task to find history for',\n                    'limit': 'Maximum number of executions to return (default: 5)'\n                },\n                'handler': self.get_task_execution_history\n            },\n            'analyze_page_dom': {\n                'description': 'Analyze a web page DOM structure to find optimal locators',\n                'parameters': {\n                    'url': 'URL of the page to analyze',\n                    'intent': 'What you want to do on the page (e.g., \"click login button\")'\n                },\n                'handler': self.analyze_page_dom\n            },\n            'get_healing_strategies': {\n                'description': 'Get recommended healing strategies for a specific error type',\n                'parameters': {\n                    'error_type': 'Type of error (locator_not_found, timeout, api_error, etc.)',\n                    'error_message': 'The actual error message',\n                    'failed_step': 'The step number that failed'\n                },\n                'handler': self.get_healing_strategies\n            },\n            'format_reusable_script': {\n                'description': 'Format healed code into clean, documented, reusable script',\n                'parameters': {\n                    'code': 'The healed Playwright code',\n                    'task_description': 'Description of what the script does',\n                    'healing_notes': 'Notes about what was healed (optional)'\n                },\n                'handler': self.format_reusable_script\n            },\n            'get_best_locator_strategies': {\n                'description': 'Get prioritized locator strategies based on historical success rates',\n                'parameters': {\n                    'element_type': 'Type of element (button, input, link, etc.)',\n                    'context': 'Additional context about the element'\n                },\n                'handler': self.get_best_locator_strategies\n            }\n        }\n    \n    async def handle_tool_call(self, tool_name: str, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Handle a tool call from the AI model.\n        \n        Args:\n            tool_name: Name of the tool to execute\n            parameters: Parameters for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if tool_name not in self.tools:\n            return {\n                'success': False,\n                'error': f'Unknown tool: {tool_name}',\n                'available_tools': list(self.tools.keys())\n            }\n        \n        tool = self.tools[tool_name]\n        handler = tool['handler']\n        \n        try:\n            result = await handler(**parameters)\n            return {\n                'success': True,\n                'tool': tool_name,\n                'result': result\n            }\n        except Exception as e:\n            return {\n                'success': False,\n                'tool': tool_name,\n                'error': str(e)\n            }\n    \n    async def search_learned_tasks(self, query: str, top_k: int = 3) -> Dict[str, Any]:\n        \"\"\"Search for similar learned tasks using semantic search.\"\"\"\n        if not self.vector_store:\n            return {\n                'found': False,\n                'message': 'Vector store not available',\n                'tasks': []\n            }\n        \n        try:\n            results = self.vector_store.search_tasks(query, top_k=top_k)\n            return {\n                'found': len(results) > 0,\n                'count': len(results),\n                'tasks': results\n            }\n        except Exception as e:\n            return {\n                'found': False,\n                'error': str(e),\n                'tasks': []\n            }\n    \n    async def get_task_execution_history(self, task_description: str, limit: int = 5) -> Dict[str, Any]:\n        \"\"\"Get execution history for similar tasks.\"\"\"\n        try:\n            conn = sqlite3.connect(self.database_path)\n            c = conn.cursor()\n            \n            c.execute('''\n                SELECT command, success, error_message, generated_code, healed_code, \n                       execution_time, timestamp\n                FROM test_history \n                WHERE command LIKE ? \n                ORDER BY timestamp DESC \n                LIMIT ?\n            ''', (f'%{task_description}%', limit))\n            \n            rows = c.fetchall()\n            conn.close()\n            \n            history = []\n            success_rate = 0\n            \n            for row in rows:\n                history.append({\n                    'command': row[0],\n                    'success': bool(row[1]),\n                    'error': row[2],\n                    'generated_code': row[3],\n                    'healed_code': row[4],\n                    'execution_time': row[5],\n                    'timestamp': row[6]\n                })\n            \n            if history:\n                success_rate = sum(1 for h in history if h['success']) / len(history) * 100\n            \n            return {\n                'found': len(history) > 0,\n                'count': len(history),\n                'success_rate': round(success_rate, 1),\n                'history': history,\n                'insights': self._generate_insights(history)\n            }\n        except Exception as e:\n            return {\n                'found': False,\n                'error': str(e),\n                'history': []\n            }\n    \n    async def analyze_page_dom(self, url: str, intent: str) -> Dict[str, Any]:\n        \"\"\"Analyze page DOM to find optimal locators.\"\"\"\n        if not self.dom_inspector:\n            return {\n                'success': False,\n                'message': 'DOM inspector not available',\n                'elements': []\n            }\n        \n        try:\n            analysis = await self.dom_inspector.analyze_page(url, intent)\n            \n            if 'error' in analysis:\n                return {\n                    'success': False,\n                    'error': analysis['error'],\n                    'elements': []\n                }\n            \n            return {\n                'success': True,\n                'intent_matched': analysis.get('intent_matched_elements', []),\n                'form_elements': analysis.get('form_elements', []),\n                'interactive_elements': analysis.get('interactive_elements', []),\n                'recommended_locators': analysis.get('recommended_locators', [])\n            }\n        except Exception as e:\n            return {\n                'success': False,\n                'error': str(e),\n                'elements': []\n            }\n    \n    async def get_healing_strategies(self, error_type: str, error_message: str, \n                                     failed_step: int = 0) -> Dict[str, Any]:\n        \"\"\"Get recommended healing strategies for an error.\"\"\"\n        strategies = {\n            'locator_not_found': [\n                'Use more robust locator (get_by_role, get_by_text)',\n                'Add explicit wait before interaction',\n                'Check if element is in iframe or shadow DOM',\n                'Use get_by_test_id if available',\n                'Add timeout to locator action (5000ms)'\n            ],\n            'timeout': [\n                'Increase timeout duration',\n                'Add wait_for_load_state before action',\n                'Check for dynamic content loading',\n                'Use wait_for_selector with visible state',\n                'Add retry logic with exponential backoff'\n            ],\n            'element_not_found': [\n                'Verify element exists in current page state',\n                'Check if page navigation completed',\n                'Look for alternative locators (text, aria-label)',\n                'Ensure element is not hidden or disabled',\n                'Add wait for selector visibility'\n            ],\n            'api_error': [\n                'Preserve existing locators (likely correct)',\n                'Fix API usage (remove invalid parameters)',\n                'Check Playwright version compatibility',\n                'Validate method signature',\n                'Review timeout parameter placement'\n            ],\n            'multiple_matches': [\n                'Add more specific locator constraints',\n                'Use first() or nth() to target specific element',\n                'Combine multiple attributes for uniqueness',\n                'Use parent/child relationships in locator',\n                'Filter by additional attributes (aria-label, text)'\n            ],\n            'unknown': [\n                'Analyze error message for clues',\n                'Review generated code for syntax issues',\n                'Check browser console for JavaScript errors',\n                'Verify page URL and navigation state',\n                'Add comprehensive error handling'\n            ]\n        }\n        \n        selected_strategies = strategies.get(error_type, strategies['unknown'])\n        \n        return {\n            'error_type': error_type,\n            'failed_step': failed_step,\n            'strategies': selected_strategies,\n            'priority': 'high' if error_type in ['locator_not_found', 'timeout'] else 'medium',\n            'recommendation': self._get_strategy_recommendation(error_type, error_message)\n        }\n    \n    async def format_reusable_script(self, code: str, task_description: str, \n                                     healing_notes: str = '') -> Dict[str, Any]:\n        \"\"\"Format healed code into clean, documented, reusable script.\"\"\"\n        \n        # Add documentation header\n        doc_header = f'''\"\"\"\nVisionVault Automation Script\nGenerated: {self._get_timestamp()}\n\nTask: {task_description}\n{f\"Healing Notes: {healing_notes}\" if healing_notes else \"\"}\n\nThis script can be reused for similar automation tasks.\nSimply modify the parameters as needed.\n\"\"\"\n\n'''\n        \n        # Clean up the code\n        clean_code = code.strip()\n        \n        # Remove any temporary variables or debug code\n        lines = clean_code.split('\\n')\n        cleaned_lines = []\n        \n        for line in lines:\n            # Skip debug prints that aren't step logs\n            if 'print(' in line and 'STEP' not in line and 'logs.append' not in line:\n                continue\n            cleaned_lines.append(line)\n        \n        clean_code = '\\n'.join(cleaned_lines)\n        \n        # Add usage instructions\n        usage_instructions = '''\n\n# USAGE:\n# 1. Install required packages: pip install playwright\n# 2. Install browsers: playwright install chromium\n# 3. Run the script: python script.py\n# \n# CUSTOMIZATION:\n# - Modify browser_name: 'chromium', 'firefox', or 'webkit'\n# - Set headless=False to see the browser in action\n# - Adjust timeouts in the code as needed\n\nif __name__ == \"__main__\":\n    import asyncio\n    result = asyncio.run(run_test(browser_name='chromium', headless=True))\n    print(f\"Success: {result['success']}\")\n    if not result['success']:\n        print(f\"Errors: {result['logs']}\")\n'''\n        \n        formatted_script = doc_header + clean_code + usage_instructions\n        \n        return {\n            'formatted_code': formatted_script,\n            'original_length': len(code),\n            'formatted_length': len(formatted_script),\n            'improvements': [\n                'Added comprehensive documentation header',\n                'Cleaned up debug code',\n                'Added usage instructions',\n                'Added customization guide',\n                'Made ready for standalone execution'\n            ]\n        }\n    \n    async def get_best_locator_strategies(self, element_type: str, context: str = '') -> Dict[str, Any]:\n        \"\"\"Get prioritized locator strategies based on historical success.\"\"\"\n        \n        # Query database for success rates by locator type\n        try:\n            conn = sqlite3.connect(self.database_path)\n            c = conn.cursor()\n            \n            # This would require tracking locator types in the database\n            # For now, return best practices based on element type\n            \n            strategies = {\n                'button': [\n                    ('get_by_role(\"button\", name=\"...\")', 95),\n                    ('get_by_text(\"Button Text\")', 90),\n                    ('get_by_test_id(\"button-id\")', 99),\n                    ('get_by_label(\"...\")', 85)\n                ],\n                'input': [\n                    ('get_by_placeholder(\"...\")', 92),\n                    ('get_by_label(\"...\")', 95),\n                    ('get_by_test_id(\"input-id\")', 99),\n                    ('get_by_role(\"textbox\", name=\"...\")', 88)\n                ],\n                'link': [\n                    ('get_by_role(\"link\", name=\"...\")', 94),\n                    ('get_by_text(\"Link Text\")', 92),\n                    ('get_by_test_id(\"link-id\")', 99)\n                ],\n                'default': [\n                    ('get_by_test_id(\"...\")', 99),\n                    ('get_by_role(...)', 90),\n                    ('get_by_text(\"...\")', 85),\n                    ('get_by_label(\"...\")', 88)\n                ]\n            }\n            \n            conn.close()\n            \n            element_strategies = strategies.get(element_type.lower(), strategies['default'])\n            \n            return {\n                'element_type': element_type,\n                'strategies': [\n                    {'locator': s[0], 'success_rate': s[1]} \n                    for s in sorted(element_strategies, key=lambda x: x[1], reverse=True)\n                ],\n                'recommendation': element_strategies[0][0] if element_strategies else None\n            }\n        except Exception as e:\n            return {\n                'element_type': element_type,\n                'error': str(e),\n                'strategies': []\n            }\n    \n    def list_tools(self) -> List[Dict[str, Any]]:\n        \"\"\"List all available MCP tools.\"\"\"\n        return [\n            {\n                'name': name,\n                'description': tool['description'],\n                'parameters': tool['parameters']\n            }\n            for name, tool in self.tools.items()\n        ]\n    \n    def _generate_insights(self, history: List[Dict]) -> List[str]:\n        \"\"\"Generate insights from execution history.\"\"\"\n        insights = []\n        \n        if not history:\n            return insights\n        \n        success_count = sum(1 for h in history if h['success'])\n        failure_count = len(history) - success_count\n        \n        if failure_count > 0:\n            insights.append(f'{failure_count} out of {len(history)} attempts failed')\n            \n            common_errors = {}\n            for h in history:\n                if h['error']:\n                    error_key = h['error'][:50]\n                    common_errors[error_key] = common_errors.get(error_key, 0) + 1\n            \n            if common_errors:\n                most_common = max(common_errors.items(), key=lambda x: x[1])\n                insights.append(f'Most common error: {most_common[0]}...')\n        \n        if success_count > 0 and failure_count > 0:\n            insights.append('Some attempts succeeded - healing strategies available')\n        \n        return insights\n    \n    def _get_strategy_recommendation(self, error_type: str, error_message: str) -> str:\n        \"\"\"Get specific strategy recommendation based on error.\"\"\"\n        recommendations = {\n            'locator_not_found': 'Focus on robust locators (role, text, test-id). Add explicit waits.',\n            'timeout': 'Increase timeout and add wait_for_load_state. Check for dynamic content.',\n            'api_error': 'Preserve locators. Fix API usage - likely parameter placement issue.',\n            'element_not_found': 'Verify page state and element visibility. Add selector wait.',\n            'multiple_matches': 'Make locator more specific using combined attributes or nth().'\n        }\n        \n        return recommendations.get(error_type, 'Analyze error message and apply best practices.')\n    \n    def _get_timestamp(self) -> str:\n        \"\"\"Get current timestamp.\"\"\"\n        from datetime import datetime\n        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n","size_bytes":18049},"visionvault/mcp/client.py":{"content":"\"\"\"\nMCP Client Integration for Code Generation and Healing\n\nThis module integrates MCP tools into the code generation and healing workflow,\nallowing AI models to leverage VisionVault's intelligence for better automation code.\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional\nimport json\n\n\nclass MCPEnhancedCodeGenerator:\n    \"\"\"Enhances code generation with MCP tool integration.\"\"\"\n    \n    def __init__(self, mcp_server, openai_client):\n        \"\"\"\n        Initialize MCP-enhanced code generator.\n        \n        Args:\n            mcp_server: VisionVaultMCPServer instance\n            openai_client: OpenAI client for AI generation\n        \"\"\"\n        self.mcp_server = mcp_server\n        self.openai_client = openai_client\n    \n    async def generate_with_mcp(self, command: str, browser: str = 'chromium', \n                                url: str = None) -> Dict[str, Any]:\n        \"\"\"\n        Generate Playwright code using MCP tools for enhanced intelligence.\n        \n        Args:\n            command: Natural language automation command\n            browser: Browser type\n            url: Target URL (optional)\n            \n        Returns:\n            Dict with generated code and MCP insights\n        \"\"\"\n        mcp_context = {}\n        \n        # Step 1: Search for similar learned tasks via MCP\n        learned_tasks_result = await self.mcp_server.handle_tool_call(\n            'search_learned_tasks',\n            {'query': command, 'top_k': 3}\n        )\n        \n        if learned_tasks_result['success']:\n            mcp_context['learned_tasks'] = learned_tasks_result['result']\n        \n        # Step 2: Get execution history via MCP\n        history_result = await self.mcp_server.handle_tool_call(\n            'get_task_execution_history',\n            {'task_description': command, 'limit': 5}\n        )\n        \n        if history_result['success']:\n            mcp_context['execution_history'] = history_result['result']\n        \n        # Step 3: If URL provided, analyze DOM via MCP\n        if url:\n            dom_result = await self.mcp_server.handle_tool_call(\n                'analyze_page_dom',\n                {'url': url, 'intent': command}\n            )\n            \n            if dom_result['success']:\n                mcp_context['dom_analysis'] = dom_result['result']\n        \n        # Step 4: Build enhanced system prompt with MCP context\n        system_prompt = self._build_mcp_enhanced_prompt(mcp_context)\n        \n        # Step 5: Generate code with AI using MCP context\n        response = self.openai_client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": f\"Generate Playwright code for: {command}\\nBrowser: {browser}\"}\n            ],\n            temperature=0.3,\n            max_tokens=2000\n        )\n        \n        generated_code = response.choices[0].message.content.strip()\n        \n        # Clean up code formatting\n        if generated_code.startswith('```python'):\n            generated_code = generated_code[9:]\n        elif generated_code.startswith('```'):\n            generated_code = generated_code[3:]\n        if generated_code.endswith('```'):\n            generated_code = generated_code[:-3]\n        \n        generated_code = generated_code.strip()\n        \n        return {\n            'code': generated_code,\n            'mcp_context': mcp_context,\n            'insights': self._extract_insights(mcp_context)\n        }\n    \n    def _build_mcp_enhanced_prompt(self, mcp_context: Dict) -> str:\n        \"\"\"Build system prompt enhanced with MCP tool results.\"\"\"\n        \n        base_prompt = \"\"\"You are an expert at converting natural language commands into Playwright Python code.\nYour code is enhanced with intelligence from VisionVault's MCP (Model Context Protocol) tools.\n\nGenerate complete, executable Playwright code that:\n1. Uses async/await syntax\n2. Includes proper browser launch\n3. Has error handling with proper cleanup\n4. Returns a dict with 'success', 'logs', 'screenshot', and 'current_step' keys\n5. ALWAYS takes screenshot BEFORE closing browser\n6. Uses the most reliable locator strategies\n\n\"\"\"\n        \n        # Add learned tasks context\n        if 'learned_tasks' in mcp_context and mcp_context['learned_tasks'].get('found'):\n            tasks = mcp_context['learned_tasks']['tasks']\n            base_prompt += f\"\\nüéì LEARNED TASKS (from MCP):\\n\"\n            base_prompt += f\"Found {len(tasks)} similar tasks you can learn from:\\n\\n\"\n            \n            for i, task in enumerate(tasks, 1):\n                similarity = task.get('similarity_score', 0)\n                base_prompt += f\"Task {i} (Similarity: {similarity:.0%}): {task['task_name']}\\n\"\n                if task.get('playwright_code'):\n                    base_prompt += f\"Proven Code:\\n```python\\n{task['playwright_code'][:500]}...\\n```\\n\\n\"\n        \n        # Add execution history insights\n        if 'execution_history' in mcp_context and mcp_context['execution_history'].get('found'):\n            history = mcp_context['execution_history']\n            base_prompt += f\"\\nüìä EXECUTION HISTORY (from MCP):\\n\"\n            base_prompt += f\"Success Rate: {history['success_rate']}%\\n\"\n            \n            if history.get('insights'):\n                base_prompt += \"Insights:\\n\"\n                for insight in history['insights']:\n                    base_prompt += f\"- {insight}\\n\"\n        \n        # Add DOM analysis\n        if 'dom_analysis' in mcp_context and mcp_context['dom_analysis'].get('success'):\n            dom = mcp_context['dom_analysis']\n            base_prompt += f\"\\nüîç PAGE ANALYSIS (from MCP):\\n\"\n            \n            if dom.get('intent_matched'):\n                base_prompt += f\"Intent-Matched Elements: {len(dom['intent_matched'])}\\n\"\n                for elem in dom['intent_matched'][:3]:\n                    base_prompt += f\"  - {elem.get('tag', 'unknown')}: {elem.get('text', '')[:50]}\\n\"\n            \n            if dom.get('recommended_locators'):\n                base_prompt += f\"\\nRecommended Locators:\\n\"\n                for loc in dom['recommended_locators'][:5]:\n                    base_prompt += f\"  - {loc}\\n\"\n        \n        base_prompt += \"\"\"\n\nCRITICAL RULES:\n1. Use MCP insights above to write better, more reliable code\n2. Prefer locators from learned tasks (proven to work)\n3. Apply lessons from execution history (avoid past failures)\n4. Use DOM analysis locators (verified to exist on page)\n5. Add 5000ms timeout to LOCATOR action methods only (click, fill, press)\n6. NEVER add timeout to: locator() calls, page.keyboard.press()\n\nReturn ONLY the complete Python code:\"\"\"\n        \n        return base_prompt\n    \n    def _extract_insights(self, mcp_context: Dict) -> List[str]:\n        \"\"\"Extract key insights from MCP context.\"\"\"\n        insights = []\n        \n        if 'learned_tasks' in mcp_context and mcp_context['learned_tasks'].get('found'):\n            count = mcp_context['learned_tasks']['count']\n            insights.append(f'Found {count} similar learned tasks to reuse patterns from')\n        \n        if 'execution_history' in mcp_context and mcp_context['execution_history'].get('found'):\n            rate = mcp_context['execution_history']['success_rate']\n            insights.append(f'Historical success rate: {rate}%')\n        \n        if 'dom_analysis' in mcp_context and mcp_context['dom_analysis'].get('success'):\n            insights.append('Page DOM analyzed for optimal locators')\n        \n        return insights\n\n\nclass MCPEnhancedHealer:\n    \"\"\"Enhances healing process with MCP tool integration.\"\"\"\n    \n    def __init__(self, mcp_server, openai_client):\n        \"\"\"\n        Initialize MCP-enhanced healer.\n        \n        Args:\n            mcp_server: VisionVaultMCPServer instance\n            openai_client: OpenAI client for AI healing\n        \"\"\"\n        self.mcp_server = mcp_server\n        self.openai_client = openai_client\n    \n    async def heal_with_mcp(self, original_code: str, error_message: str, \n                           error_type: str, failed_step: int = 0) -> Dict[str, Any]:\n        \"\"\"\n        Heal failed code using MCP tools for intelligent strategy selection.\n        \n        Args:\n            original_code: The original/failed code\n            error_message: Error message from execution\n            error_type: Type of error (locator_not_found, timeout, etc.)\n            failed_step: Step number that failed\n            \n        Returns:\n            Dict with healed code and MCP insights\n        \"\"\"\n        # Step 1: Get healing strategies from MCP\n        strategies_result = await self.mcp_server.handle_tool_call(\n            'get_healing_strategies',\n            {\n                'error_type': error_type,\n                'error_message': error_message,\n                'failed_step': failed_step\n            }\n        )\n        \n        mcp_strategies = strategies_result['result'] if strategies_result['success'] else {}\n        \n        # Step 2: Build healing prompt with MCP strategies\n        system_prompt = f\"\"\"You are an expert at healing failed Playwright automation code.\nYou have access to MCP (Model Context Protocol) healing intelligence.\n\nMCP HEALING STRATEGIES for {error_type}:\n\"\"\"\n        \n        if mcp_strategies.get('strategies'):\n            for i, strategy in enumerate(mcp_strategies['strategies'], 1):\n                system_prompt += f\"{i}. {strategy}\\n\"\n        \n        system_prompt += f\"\\nPriority: {mcp_strategies.get('priority', 'medium')}\"\n        system_prompt += f\"\\nRecommendation: {mcp_strategies.get('recommendation', 'Apply best practices')}\"\n        \n        system_prompt += \"\"\"\n\nHEALING RULES:\n1. Apply MCP strategies in order of priority\n2. Preserve working code from other steps\n3. Focus healing on the failed step only\n4. Use proven locator patterns\n5. Add appropriate waits and timeouts\n6. Return ONLY the complete healed code\n\nOriginal code that failed:\"\"\"\n        \n        # Step 3: Generate healed code with AI\n        response = self.openai_client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": f\"\"\"\nFailed Code:\n```python\n{original_code}\n```\n\nError at STEP {failed_step}: {error_message}\n\nGenerate the healed code:\"\"\"}\n            ],\n            temperature=0.3,\n            max_tokens=2000\n        )\n        \n        healed_code = response.choices[0].message.content.strip()\n        \n        # Clean up formatting\n        if healed_code.startswith('```python'):\n            healed_code = healed_code[9:]\n        elif healed_code.startswith('```'):\n            healed_code = healed_code[3:]\n        if healed_code.endswith('```'):\n            healed_code = healed_code[:-3]\n        \n        healed_code = healed_code.strip()\n        \n        # Step 4: Format healed code for reusability using MCP\n        format_result = await self.mcp_server.handle_tool_call(\n            'format_reusable_script',\n            {\n                'code': healed_code,\n                'task_description': f'Healed automation script (fixed: {error_type})',\n                'healing_notes': f'Applied MCP strategies: {\", \".join(mcp_strategies.get(\"strategies\", [])[:3])}'\n            }\n        )\n        \n        if format_result['success']:\n            formatted_code = format_result['result']['formatted_code']\n        else:\n            formatted_code = healed_code\n        \n        return {\n            'healed_code': healed_code,\n            'reusable_code': formatted_code,\n            'mcp_strategies': mcp_strategies,\n            'applied_strategies': mcp_strategies.get('strategies', [])[:3],\n            'improvements': format_result['result'].get('improvements', []) if format_result['success'] else []\n        }\n","size_bytes":11896}},"version":2}