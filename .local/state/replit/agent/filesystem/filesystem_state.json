{"file_contents":{"index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"app/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\n\nlet lastExecution = null;\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ instruction }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `Completed in ${data.iterations} iteration(s)`);\n            displayResults(data);\n            // Store last execution for export\n            lastExecution = {\n                instruction: instruction,\n                steps: data.steps\n            };\n            showExportButton();\n        } else {\n            showStatus('error', `Error: ${data.error || 'Unknown error'}`);\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to execute: ${error.message}`);\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history.')) {\n        return;\n    }\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', 'Agent reset successfully');\n            resultsDiv.innerHTML = '';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to reset: ${error.message}`);\n    }\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.className = 'final-message';\n        messageEl.textContent = data.message;\n        resultsDiv.appendChild(messageEl);\n    }\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? 'Success' : 'Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.style.color = '#721c24';\n        errorEl.style.marginTop = '10px';\n        errorEl.textContent = `Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\nfunction showExportButton() {\n    // Check if export button already exists\n    if (document.getElementById('export-btn')) return;\n    \n    const buttonGroup = document.querySelector('.button-group');\n    const exportBtn = document.createElement('button');\n    exportBtn.id = 'export-btn';\n    exportBtn.className = 'btn btn-export';\n    exportBtn.textContent = 'Export as Playwright';\n    exportBtn.style.backgroundColor = '#10b981';\n    \n    exportBtn.addEventListener('click', async () => {\n        if (!lastExecution) {\n            showStatus('error', 'No execution to export');\n            return;\n        }\n        \n        try {\n            const response = await fetch('/api/export-playwright', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(lastExecution),\n            });\n            \n            const data = await response.json();\n            \n            if (data.success) {\n                // Create a modal to show the code\n                showExportModal(data.playwright_code, data.json_export);\n            } else {\n                showStatus('error', `Export failed: ${data.error}`);\n            }\n            \n        } catch (error) {\n            showStatus('error', `Export failed: ${error.message}`);\n        }\n    });\n    \n    buttonGroup.appendChild(exportBtn);\n}\n\nfunction showExportModal(playwrightCode, jsonExport) {\n    // Create modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';\n    \n    const content = document.createElement('div');\n    content.style.cssText = 'background: white; padding: 30px; border-radius: 12px; max-width: 800px; max-height: 80vh; overflow: auto; width: 90%;';\n    \n    content.innerHTML = `\n        <h2 style=\"margin-top: 0; color: #667eea;\">Export Options</h2>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">Playwright Test Code:</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(playwrightCode)}</pre>\n            <button id=\"copy-code-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Copy Code</button>\n            <button id=\"download-code-btn\" style=\"margin-top: 10px; margin-left: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download .spec.ts</button>\n        </div>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">JSON Export (for replay):</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(JSON.stringify(jsonExport, null, 2))}</pre>\n            <button id=\"download-json-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download JSON</button>\n        </div>\n        \n        <button id=\"close-modal-btn\" style=\"padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;\">Close</button>\n    `;\n    \n    modal.appendChild(content);\n    document.body.appendChild(modal);\n    \n    // Event handlers\n    document.getElementById('copy-code-btn').addEventListener('click', () => {\n        navigator.clipboard.writeText(playwrightCode);\n        showStatus('success', 'Code copied to clipboard!');\n    });\n    \n    document.getElementById('download-code-btn').addEventListener('click', () => {\n        downloadFile('automation.spec.ts', playwrightCode);\n        showStatus('success', 'Playwright code downloaded!');\n    });\n    \n    document.getElementById('download-json-btn').addEventListener('click', () => {\n        downloadFile('automation-steps.json', JSON.stringify(jsonExport, null, 2));\n        showStatus('success', 'JSON export downloaded!');\n    });\n    \n    document.getElementById('close-modal-btn').addEventListener('click', () => {\n        document.body.removeChild(modal);\n    });\n    \n    modal.addEventListener('click', (e) => {\n        if (e.target === modal) {\n            document.body.removeChild(modal);\n        }\n    });\n}\n\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\nfunction downloadFile(filename, content) {\n    const blob = new Blob([content], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            if (data.mcp_connected) {\n                console.log('Application is healthy and connected to MCP server');\n            } else {\n                console.log('Application is ready. MCP will initialize on first use.');\n            }\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":11652},"app/app.py":{"content":"\"\"\"\nFlask Web Application for Browser Automation\nProvides web interface for users to input instructions\n\"\"\"\nfrom flask import Flask, render_template, request, jsonify\nfrom app.mcp_stdio_client import MCPStdioClient\nfrom app.browser_agent import BrowserAgent\nimport os\nimport re\nimport configparser\nfrom datetime import datetime\n\n# Load configuration from .ini file\nconfig = configparser.ConfigParser()\nconfig.read('config.ini')\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(24)\n\n# Initialize MCP client and agent (using STDIO transport)\nmcp_client = None\nbrowser_agent = None\n\ndef get_mcp_client():\n    \"\"\"Lazy initialization of MCP client\"\"\"\n    global mcp_client, browser_agent\n    if mcp_client is None:\n        # MCP client will read browser settings from config.ini\n        mcp_client = MCPStdioClient()\n        browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n@app.route('/')\ndef index():\n    \"\"\"Render main page\"\"\"\n    return render_template('index.html')\n\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_instruction():\n    \"\"\"Execute a browser automation instruction\"\"\"\n    try:\n        data = request.get_json()\n        instruction = data.get('instruction', '').strip()\n        \n        if not instruction:\n            return jsonify({\n                'success': False,\n                'error': 'Please provide an instruction'\n            }), 400\n        \n        # Get or create MCP client\n        _, agent = get_mcp_client()\n        \n        # Execute the instruction\n        result = agent.execute_instruction(instruction)\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/api/tools', methods=['GET'])\ndef get_tools():\n    \"\"\"Get available browser tools\"\"\"\n    try:\n        client, _ = get_mcp_client()\n        \n        if not client.initialized:\n            client.initialize()\n        \n        tools = client.list_tools()\n        \n        return jsonify({\n            'success': True,\n            'tools': tools\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/api/reset', methods=['POST'])\ndef reset_agent():\n    \"\"\"Reset the browser agent\"\"\"\n    try:\n        _, agent = get_mcp_client()\n        agent.reset_conversation()\n        \n        return jsonify({\n            'success': True,\n            'message': 'Agent reset successfully'\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\n@app.route('/api/export-playwright', methods=['POST'])\ndef export_playwright():\n    \"\"\"Export last execution as Playwright code\"\"\"\n    try:\n        data = request.get_json()\n        steps = data.get('steps', [])\n        instruction = data.get('instruction', 'Automated task')\n        \n        if not steps:\n            return jsonify({\n                'success': False,\n                'error': 'No steps to export'\n            }), 400\n        \n        # Generate Playwright code\n        playwright_code = generate_playwright_code(steps, instruction)\n        \n        # Enhanced JSON export with selector information\n        json_export = {\n            'instruction': instruction,\n            'timestamp': datetime.now().isoformat(),\n            'steps': steps,\n            'usage_notes': {\n                'description': 'Steps executed by AI with full context',\n                'replay': 'Can be used to replay automation programmatically',\n                'selectors': 'Check result.snapshot fields for element information'\n            }\n        }\n        \n        return jsonify({\n            'success': True,\n            'playwright_code': playwright_code,\n            'json_export': json_export\n        })\n        \n    except Exception as e:\n        return jsonify({\n            'success': False,\n            'error': str(e)\n        }), 500\n\n\ndef generate_playwright_code(steps, instruction):\n    \"\"\"Generate Playwright test code from execution steps\"\"\"\n    code_lines = [\n        \"import { test, expect } from '@playwright/test';\",\n        \"\",\n        f\"test('{instruction}', async ({{ page }}) => {{\",\n    ]\n    \n    # Track page snapshots to extract selectors\n    last_snapshot = None\n    \n    for step in steps:\n        if not step.get('success'):\n            continue\n            \n        tool = step.get('tool', '')\n        args = step.get('arguments', {})\n        result = step.get('result', {})\n        \n        if tool == 'browser_navigate':\n            url = args.get('url', '')\n            code_lines.append(f\"  await page.goto('{url}');\")\n            # Check if result has snapshot\n            if isinstance(result, dict) and 'snapshot' in result:\n                last_snapshot = result['snapshot']\n            \n        elif tool == 'browser_snapshot':\n            # Store snapshot for reference extraction\n            if isinstance(result, dict) and 'snapshot' in result:\n                last_snapshot = result['snapshot']\n                \n        elif tool == 'browser_click':\n            ref = args.get('ref', '')\n            selector = extract_selector_from_ref(ref, last_snapshot, result)\n            if selector:\n                code_lines.append(f\"  await page.locator('{selector}').click();\")\n            else:\n                code_lines.append(f\"  // Click element [ref={ref}] - TODO: Add proper selector\")\n            \n        elif tool == 'browser_fill':\n            ref = args.get('ref', '')\n            value = args.get('value', '').replace(\"'\", \"\\\\'\")\n            selector = extract_selector_from_ref(ref, last_snapshot, result)\n            if selector:\n                code_lines.append(f\"  await page.locator('{selector}').fill('{value}');\")\n            else:\n                code_lines.append(f\"  // Fill element [ref={ref}] with '{value}' - TODO: Add proper selector\")\n            \n        elif tool == 'browser_screenshot':\n            code_lines.append(f\"  await page.screenshot({{ path: 'screenshot.png' }});\")\n            \n        elif tool == 'browser_close':\n            code_lines.append(f\"  // Browser will close automatically after test\")\n    \n    code_lines.extend([\n        \"});\",\n        \"\",\n        \"// Note: This is a template generated from AI execution.\",\n        \"// You may need to:\",\n        \"// 1. Refine selectors for better stability (use data-testid when available)\",\n        \"// 2. Add waits and assertions as needed\",\n        \"// 3. Handle dynamic content appropriately\"\n    ])\n    \n    return '\\n'.join(code_lines)\n\n\ndef extract_selector_from_ref(ref, snapshot, result):\n    \"\"\"\n    Extract a usable CSS selector from ref and snapshot data\n    Returns the best available selector or None\n    \"\"\"\n    if not ref:\n        return None\n    \n    # Try to parse the snapshot YAML to find element info\n    # The snapshot contains element references like [ref=e1]\n    # We need to find the element and extract its selector\n    \n    # For now, we'll look for common patterns in the result\n    # The MCP server might include selector info in the result\n    if isinstance(result, dict):\n        # Check if result contains content with element info\n        content = result.get('content', [])\n        if isinstance(content, list) and len(content) > 0:\n            first_content = content[0]\n            if isinstance(first_content, dict):\n                text = first_content.get('text', '')\n                # Try to extract selector from text\n                if 'selector' in text.lower():\n                    # Parse for selector info\n                    pass\n    \n    # If we have snapshot data, parse it\n    if snapshot and isinstance(snapshot, str):\n        # Parse YAML-like snapshot to find the ref\n        # Look for the ref in the snapshot and try to find associated tag/attributes\n        ref_pattern = rf'\\[ref={re.escape(ref)}\\]'\n        lines = snapshot.split('\\n')\n        \n        for i, line in enumerate(lines):\n            if ref_pattern in line:\n                # Found the reference, try to extract tag and attributes from previous lines\n                # Look for role, name, or tag information\n                for j in range(max(0, i-5), i):\n                    prev_line = lines[j]\n                    # Check for role attribute\n                    if 'role=' in prev_line:\n                        role_match = re.search(r\"role=['\\\"]([^'\\\"]+)['\\\"]\", prev_line)\n                        if role_match:\n                            role = role_match.group(1)\n                            # Try to get name or text\n                            name_match = re.search(r\"name=['\\\"]([^'\\\"]+)['\\\"]\", line)\n                            if name_match:\n                                name = name_match.group(1)\n                                return f\"[role='{role}'][name='{name}']\"\n                            return f\"[role='{role}']\"\n                \n                # Try to extract text content\n                text_match = re.search(r'[\"\\']([^\"\\']+)[\"\\'].*\\[ref=', line)\n                if text_match:\n                    text = text_match.group(1)\n                    # Use text selector\n                    return f\"text='{text}'\"\n    \n    return None\n\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    try:\n        # Only check if MCP client exists, don't force initialization\n        global mcp_client\n        \n        if mcp_client is not None:\n            # Client exists, check if process is alive\n            if mcp_client.process and mcp_client.process.poll() is None:\n                return jsonify({\n                    'status': 'healthy',\n                    'mcp_connected': True,\n                    'transport': 'STDIO'\n                })\n        \n        # MCP client not yet initialized, but that's okay\n        return jsonify({\n            'status': 'healthy',\n            'mcp_connected': False,\n            'message': 'MCP will initialize on first use'\n        })\n    except Exception as e:\n        return jsonify({\n            'status': 'unhealthy',\n            'mcp_connected': False,\n            'error': str(e)\n        }), 503\n\n\nif __name__ == '__main__':\n    # Read host and port from config.ini\n    host = config.get('server', 'host')\n    port = config.getint('server', 'port')\n    app.run(host=host, port=port, debug=True)\n","size_bytes":10470},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask>=3.1.2\",\n    \"openai>=2.6.0\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":236},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nfrom app.app import app\n\nif __name__ == '__main__':\n    # Run Flask on port 5000, bound to all interfaces for Replit\n    app.run(host='0.0.0.0', port=5000, debug=False)\n","size_bytes":240},"app/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 16px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\nheader {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 40px;\n    text-align: center;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.subtitle {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.main-content {\n    padding: 40px;\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 40px;\n}\n\n@media (max-width: 768px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n}\n\n.instruction-panel,\n.results-panel {\n    background: #f8f9fa;\n    padding: 30px;\n    border-radius: 12px;\n}\n\n.instruction-panel h2,\n.results-panel h2 {\n    font-size: 1.5rem;\n    margin-bottom: 20px;\n    color: #667eea;\n}\n\n.help-text {\n    color: #666;\n    margin-bottom: 10px;\n}\n\n.examples {\n    list-style: none;\n    margin-bottom: 20px;\n    padding-left: 0;\n}\n\n.examples li {\n    background: white;\n    padding: 10px 15px;\n    margin-bottom: 8px;\n    border-radius: 6px;\n    border-left: 3px solid #667eea;\n    font-size: 0.9rem;\n    color: #555;\n}\n\n#instruction-input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    margin-bottom: 20px;\n    transition: border-color 0.3s;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n}\n\n.button-group {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 12px 30px;\n    border: none;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    flex: 1;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #d0d0d0;\n}\n\n.spinner {\n    width: 16px;\n    height: 16px;\n    border: 2px solid #ffffff;\n    border-top: 2px solid transparent;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.status {\n    padding: 15px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    font-weight: 600;\n    display: none;\n}\n\n.status.success {\n    background: #d4edda;\n    color: #155724;\n    border: 1px solid #c3e6cb;\n    display: block;\n}\n\n.status.error {\n    background: #f8d7da;\n    color: #721c24;\n    border: 1px solid #f5c6cb;\n    display: block;\n}\n\n.status.processing {\n    background: #d1ecf1;\n    color: #0c5460;\n    border: 1px solid #bee5eb;\n    display: block;\n}\n\n.results-container {\n    max-height: 600px;\n    overflow-y: auto;\n}\n\n.step {\n    background: white;\n    padding: 20px;\n    margin-bottom: 15px;\n    border-radius: 8px;\n    border-left: 4px solid #667eea;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    background: #667eea;\n    color: white;\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status {\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d4edda;\n    color: #155724;\n}\n\n.step-status.error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #764ba2;\n    margin-bottom: 8px;\n}\n\n.step-args {\n    background: #f8f9fa;\n    padding: 10px;\n    border-radius: 6px;\n    font-size: 0.9rem;\n    font-family: monospace;\n    margin-top: 8px;\n    overflow-x: auto;\n}\n\n.final-message {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 8px;\n    margin-top: 20px;\n    font-size: 1.1rem;\n}\n\nfooter {\n    background: #f8f9fa;\n    padding: 20px;\n    text-align: center;\n    color: #666;\n    border-top: 1px solid #e0e0e0;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f1f1;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #667eea;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #764ba2;\n}\n","size_bytes":4892},"SETUP.md":{"content":"# Setup Guide - AI Browser Automation Agent\n\n## Complete setup instructions for running this project on Windows\n\n---\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed on your Windows machine:\n\n### 1. Python 3.11 or higher\n- Download from: https://www.python.org/downloads/\n- During installation, **check the box \"Add Python to PATH\"**\n- Verify installation:\n  ```cmd\n  python --version\n  ```\n\n### 2. Node.js 18 or higher\n- Download from: https://nodejs.org/\n- Use the LTS (Long Term Support) version\n- Verify installation:\n  ```cmd\n  node --version\n  npm --version\n  ```\n\n### 3. Git (optional, for cloning)\n- Download from: https://git-scm.com/download/win\n\n---\n\n## Step 1: Download the Project\n\n### Option A: Download from Replit\n1. In Replit, click the three dots menu (⋮) at the top\n2. Select \"Download as zip\"\n3. Extract the zip file to your desired location (e.g., `C:\\Projects\\ai-browser-agent`)\n\n### Option B: Clone from Git (if available)\n```cmd\ngit clone <repository-url>\ncd ai-browser-agent\n```\n\n---\n\n## Step 2: Install Python Dependencies\n\nOpen **Command Prompt** or **PowerShell** in the project directory:\n\n```cmd\ncd C:\\Projects\\ai-browser-agent\n```\n\nInstall Python packages:\n\n```cmd\npip install flask openai requests sseclient-py\n```\n\n---\n\n## Step 3: Install Node.js Dependencies\n\nIn the same directory, install the Playwright MCP server dependencies:\n\n```cmd\nnpm install\n```\n\nThis will install:\n- `@modelcontextprotocol/sdk`\n- `playwright`\n- `@playwright/test`\n- Other required packages\n\n---\n\n## Step 4: Install Playwright Browsers\n\nPlaywright needs to download browser binaries (Chromium):\n\n```cmd\nnpx playwright install chromium\n```\n\n---\n\n## Step 5: Set Up OpenAI API Key\n\nYou need an OpenAI API key to use the GPT-5 model.\n\n### Get your API key:\n1. Go to https://platform.openai.com/api-keys\n2. Sign in or create an account\n3. Click \"Create new secret key\"\n4. Copy the key (starts with `sk-`)\n\n### Set the environment variable:\n\n**Option A: Temporary (for current session only)**\n```cmd\nset OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n**Option B: Permanent (recommended)**\n1. Open **System Properties** (search \"environment variables\" in Windows)\n2. Click \"Environment Variables\"\n3. Under \"User variables\", click \"New\"\n4. Variable name: `OPENAI_API_KEY`\n5. Variable value: `sk-your-actual-api-key-here`\n6. Click OK\n\n**Option C: Create a .env file** (if you modify the code to use python-dotenv)\n```\nOPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n---\n\n## Step 6: Run the Application\n\nStart the Flask web server:\n\n```cmd\npython main.py\n```\n\nYou should see output like:\n```\n * Serving Flask app 'app.web_app'\n * Debug mode: off\n * Running on http://127.0.0.1:5000\n```\n\n---\n\n## Step 7: Access the Web Interface\n\nOpen your web browser and go to:\n\n```\nhttp://localhost:5000\n```\n\nYou should see the AI Browser Automation Agent interface!\n\n---\n\n## Testing the Application\n\nTry these example instructions:\n\n1. **Simple navigation:**\n   ```\n   Go to example.com\n   ```\n\n2. **Search task:**\n   ```\n   Navigate to google.com and search for 'Playwright MCP'\n   ```\n\n3. **Page interaction:**\n   ```\n   Open github.com and find trending repositories\n   ```\n\n---\n\n## Troubleshooting\n\n### Issue: \"Python is not recognized\"\n- Make sure Python is added to your PATH during installation\n- Restart Command Prompt after installing Python\n- Try using `py` instead of `python`\n\n### Issue: \"npm is not recognized\"\n- Make sure Node.js is installed correctly\n- Restart Command Prompt after installing Node.js\n- Check if Node.js is in PATH: `where node`\n\n### Issue: \"OPENAI_API_KEY not set\"\n- Make sure you set the environment variable\n- Restart Command Prompt after setting permanent variables\n- Verify it's set: `echo %OPENAI_API_KEY%`\n\n### Issue: \"Port 5000 already in use\"\n- Another application is using port 5000\n- Edit `main.py` and change the port:\n  ```python\n  app.run(host='0.0.0.0', port=8000)\n  ```\n- Then access at: `http://localhost:8000`\n\n### Issue: Browser automation fails\n- Make sure Playwright browsers are installed: `npx playwright install chromium`\n- Check if antivirus is blocking browser execution\n- Try running as Administrator\n\n### Issue: \"Module not found\" errors\n- Make sure all Python packages are installed: `pip install flask openai requests sseclient-py`\n- Make sure Node.js packages are installed: `npm install`\n\n---\n\n## Project Structure\n\n```\nai-browser-agent/\n├── app/                      # Python application\n│   ├── __init__.py\n│   ├── web_app.py           # Flask web server\n│   ├── mcp_stdio_client.py  # MCP client (subprocess)\n│   ├── browser_agent.py     # OpenAI agent\n│   ├── templates/\n│   │   └── index.html       # Web UI\n│   └── static/\n│       ├── css/style.css\n│       └── js/app.js\n├── main.py                  # Application entry point\n├── cli.js                   # Playwright MCP server (Node.js)\n├── package.json             # Node.js dependencies\n├── pyproject.toml           # Python project config\n└── SETUP.md                 # This file\n```\n\n---\n\n## How It Works\n\n1. **Flask Server**: Runs on port 5000, serves the web interface\n2. **User Input**: You enter a natural language instruction in the browser\n3. **OpenAI Processing**: GPT-5 interprets your instruction\n4. **MCP Communication**: Python spawns Node.js subprocess running Playwright MCP\n5. **Browser Automation**: Playwright executes browser actions (navigate, click, fill, etc.)\n6. **Results**: Actions and results are displayed in real-time\n\n---\n\n## API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute an instruction\n- `GET /api/tools` - List available browser tools\n- `POST /api/reset` - Reset agent conversation\n- `GET /health` - Health check\n\n---\n\n## Stopping the Application\n\nPress `Ctrl + C` in the Command Prompt window to stop the server.\n\n---\n\n## Notes for Windows Users\n\n1. **Firewall**: Windows may ask for firewall permission - allow it\n2. **Antivirus**: Some antivirus software may block browser automation - add exception if needed\n3. **PowerShell**: If using PowerShell, use `$env:OPENAI_API_KEY=\"sk-...\"` to set variables\n4. **Paths**: Use backslashes (`\\`) for Windows paths, or forward slashes (`/`) work too\n5. **Long Paths**: If you encounter path length issues, enable long paths in Windows\n\n---\n\n## Production Deployment\n\nThis setup is for **development/testing only**. For production:\n\n1. **Use a production WSGI server** (not Flask development server):\n   ```cmd\n   pip install gunicorn\n   gunicorn --bind 0.0.0.0:5000 app.web_app:app\n   ```\n   Note: Gunicorn doesn't work natively on Windows. Use `waitress` instead:\n   ```cmd\n   pip install waitress\n   waitress-serve --host=0.0.0.0 --port=5000 app.web_app:app\n   ```\n\n2. **Use environment variables** for all secrets (never hardcode API keys)\n\n3. **Add security headers** and CORS configuration\n\n4. **Consider deploying to a cloud platform** (Replit, Heroku, AWS, Azure, etc.)\n\n---\n\n## Cost Considerations\n\n- **OpenAI API**: You'll be charged based on GPT-5 usage (tokens processed)\n- Each instruction execution calls OpenAI multiple times (typically 2-5 calls)\n- Monitor your usage at: https://platform.openai.com/usage\n\n---\n\n## Support\n\nIf you encounter issues:\n1. Check the console output for error messages\n2. Verify all prerequisites are installed correctly\n3. Make sure your OpenAI API key is valid and has credits\n4. Check that port 5000 is not blocked by firewall\n\n---\n\n## License\n\nSee LICENSE file for details.\n\n---\n\n**Enjoy automating with AI!** 🤖\n","size_bytes":7614},"replit.md":{"content":"# AI Browser Automation Agent\n\n## Overview\nThis is an AI-powered browser automation agent that combines OpenAI's GPT-4o-mini with Playwright's Model Context Protocol (MCP) server to enable natural language browser automation. Users can give instructions in plain English, and the AI will execute complex browser actions like navigation, clicking, form filling, and data extraction.\n\n## Architecture\n- **Frontend**: Flask web application (Python) serving a clean, modern UI\n- **Backend**: \n  - Python Flask server on port 5000\n  - OpenAI API integration for natural language understanding\n  - MCP STDIO Client for communication with Playwright\n- **Browser Automation**: Playwright MCP Server (Node.js) running as a subprocess\n  - Uses Chromium browser in headless mode\n  - Communicates via JSON-RPC over stdio\n\n## Project Structure\n```\n.\n├── app/\n│   ├── __init__.py\n│   ├── app.py               # Flask routes and application\n│   ├── browser_agent.py     # OpenAI agent logic\n│   ├── mcp_stdio_client.py  # MCP client for Playwright\n│   ├── templates/\n│   │   └── index.html       # Web UI\n│   └── static/\n│       ├── css/style.css    # Styling\n│       └── js/app.js        # Frontend JavaScript\n├── main.py                  # Application entry point\n├── cli.js                   # Playwright MCP server entry point\n├── config.ini               # Configuration file (server, browser, OpenAI settings)\n├── package.json             # Node.js dependencies\n├── pyproject.toml           # Python dependencies (uv package manager)\n├── SETUP.md                 # Setup guide for local Windows installation\n└── EXPORT_GUIDE.md          # Documentation for Playwright export feature\n```\n\n## Configuration\n- **OpenAI API Key**: Set via `OPENAI_API_KEY` environment secret\n- **Model**: gpt-4o-mini (configurable in config.ini)\n- **Browser**: Chromium in headless mode\n- **Server**: Runs on 0.0.0.0:5000\n\n## Recent Changes\n- 2025-10-20: GitHub Import Setup for Replit\n  - Fixed hardcoded API key security issue in browser_agent.py\n  - Created config.ini with default settings (server, browser, OpenAI model)\n  - Installed Python dependencies via uv (flask, openai, requests, sseclient-py)\n  - Node.js dependencies already present (playwright, @modelcontextprotocol/sdk)\n  - Installed Playwright Chromium browser with headless support\n  - Configured OPENAI_API_KEY environment secret\n  - Set up Flask workflow: `uv run python main.py` on port 5000\n  - Configured VM deployment (stateful, always-running for MCP subprocess)\n  - Updated .gitignore to include config.ini (was previously excluded)\n  - Fixed port configuration: changed from 5002 to 5000 in main.py\n  - Verified web interface is working correctly\n  - All features operational: Export as Playwright, JSON export, browser automation\n\n## Dependencies\n**Python** (via uv):\n- flask\n- openai\n- requests\n- sseclient-py\n\n**Node.js** (via npm):\n- playwright\n- playwright-core\n- @modelcontextprotocol/sdk\n- @playwright/test\n\n## API Endpoints\n- `GET /` - Web interface\n- `POST /api/execute` - Execute browser automation instruction\n- `GET /api/tools` - List available browser tools\n- `POST /api/reset` - Reset agent conversation history\n- `POST /api/export-playwright` - Export last execution as Playwright code\n- `GET /health` - Health check endpoint\n\n## How It Works\n1. User enters a natural language instruction in the web UI\n2. Flask server receives the instruction\n3. BrowserAgent uses OpenAI to interpret the instruction\n4. OpenAI decides which browser tools to call (navigate, click, fill, etc.)\n5. MCPStdioClient spawns a Node.js subprocess running Playwright MCP\n6. Playwright executes the browser actions\n7. Results are streamed back to the UI in real-time\n\n## Environment Variables\n- `OPENAI_API_KEY` (required): Your OpenAI API key\n- `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS`: Set to '1' to skip browser dependency checks\n\n## Deployment Notes\n- Deployed as a **VM** (always-running, stateful) because:\n  - The MCP subprocess needs to maintain state\n  - Browser sessions are persistent\n  - Immediate response time is important\n- The application runs on port 5000 (only non-firewalled port in Replit)\n- Uses development Flask server (suitable for Replit environment)\n\n## Export Feature\n\n📖 **See EXPORT_GUIDE.md for complete documentation**\n\nAfter successfully executing an instruction, an \"Export as Playwright\" button appears. This allows you to:\n\n1. **Export as Playwright Test Code**: \n   - Generates a `.spec.ts` file with Playwright test code\n   - Ready to use in your own Playwright test suite\n   - Includes all successful actions (navigate, click, fill, etc.)\n   - Download or copy to clipboard\n\n2. **Export as JSON**:\n   - Contains all steps with their arguments and results\n   - Can be used for programmatic replay\n   - Includes timestamp and original instruction\n\n### Workflow: Record Once, Replay Fast\n\n1. **Record (Slow)**: Use AI to figure out the automation steps\n   - Example: \"Go to example.com and click the login button\"\n   - AI navigates, finds elements, performs actions\n   - Takes 10-20 seconds due to AI reasoning\n\n2. **Export**: Click \"Export as Playwright\" button\n   - Download the generated Playwright code\n   - Or copy the JSON for programmatic use\n\n3. **Replay (Fast)**: Run the exported code directly\n   - No AI overhead\n   - No MCP communication delays\n   - Runs in < 1 second\n\nThis is perfect for:\n- Creating test suites from manual exploration\n- Automating repetitive tasks\n- Learning Playwright syntax from AI-generated examples\n\n## Known Limitations\n- MCP subprocess communication requires process persistence (hence VM deployment)\n- Browser runs in headless mode (no GUI visible to user)\n- Maximum 10 iterations per instruction to prevent infinite loops\n- Exported Playwright code may need selector refinement for dynamic content\n","size_bytes":5940},"app/__init__.py":{"content":"# Flask app package\n","size_bytes":20},"index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"EXPORT_GUIDE.md":{"content":"# Export Feature Guide\n\n## Overview\nThe export feature allows you to convert AI-powered browser automation into reusable Playwright code and JSON data.\n\n## How to Use\n\n### 1. Execute an Instruction\nType any instruction in the web UI, for example:\n- \"Go to example.com\"\n- \"Navigate to github.com and search for playwright\"\n- \"Open google.com and search for 'AI automation'\"\n\n### 2. Click Export\nAfter successful execution, the green \"Export as Playwright\" button appears. Click it to see two export formats:\n\n---\n\n## Export Format 1: Playwright Test Code\n\nGenerated `.spec.ts` file ready for Playwright test suites.\n\n### Example Output:\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest('Go to example.com', async ({ page }) => {\n  await page.goto('https://example.com');\n  // Browser will close automatically after test\n});\n```\n\n### With Interactions:\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest('Search on Google', async ({ page }) => {\n  await page.goto('https://google.com');\n  await page.locator('[role=\"textbox\"][name=\"q\"]').fill('AI automation');\n  await page.locator('[role=\"button\"][name=\"Google Search\"]').click();\n});\n```\n\n### Selector Extraction\n\nThe code generator attempts to extract selectors in this priority:\n\n1. **Role + Name attributes**: `[role=\"button\"][name=\"Submit\"]`\n2. **Text content**: `text='Click Here'`\n3. **Fallback**: Comment with `[ref=...]` for manual replacement\n\n---\n\n## Export Format 2: JSON Data\n\nComplete execution data including all steps, arguments, and results.\n\n### Example JSON Structure:\n\n```json\n{\n  \"instruction\": \"Go to example.com\",\n  \"timestamp\": \"2025-10-20T22:30:00.000000\",\n  \"steps\": [\n    {\n      \"tool\": \"browser_navigate\",\n      \"arguments\": {\n        \"url\": \"https://example.com\"\n      },\n      \"success\": true,\n      \"result\": {\n        \"content\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"Navigated to https://example.com\"\n          }\n        ],\n        \"snapshot\": \"page: Example Domain\\nlink: 'More information...' [ref=e1]\"\n      }\n    }\n  ],\n  \"usage_notes\": {\n    \"description\": \"Steps executed by AI with full context\",\n    \"replay\": \"Can be used to replay automation programmatically\",\n    \"selectors\": \"Check result.snapshot fields for element information\"\n  }\n}\n```\n\n### JSON Fields Explained:\n\n- **instruction**: Original natural language instruction\n- **timestamp**: When the automation was executed\n- **steps**: Array of all actions taken\n  - **tool**: MCP tool used (browser_navigate, browser_click, browser_fill, etc.)\n  - **arguments**: Parameters passed to the tool\n  - **success**: Whether the step succeeded\n  - **result**: Response from MCP including:\n    - **content**: Action result message\n    - **snapshot**: Page state in YAML format with element refs\n\n---\n\n## Using Exported Data\n\n### Option 1: Direct Playwright Usage\n\n1. Download the `.spec.ts` file\n2. Add to your Playwright test suite\n3. Run with: `npx playwright test`\n\n```bash\n# Save exported code as test.spec.ts\nnpx playwright test test.spec.ts\n```\n\n### Option 2: Programmatic Replay\n\nUse the JSON export to replay steps programmatically:\n\n```python\nimport json\nfrom app.mcp_stdio_client import MCPStdioClient\n\n# Load exported JSON\nwith open('automation-steps.json') as f:\n    data = json.load(f)\n\n# Replay steps\nclient = MCPStdioClient()\nclient.initialize()\n\nfor step in data['steps']:\n    tool = step['tool']\n    args = step['arguments']\n    result = client.call_tool(tool, args)\n    print(f\"Executed {tool}: {result}\")\n```\n\n### Option 3: Convert to Other Frameworks\n\nThe JSON data can be converted to other automation frameworks:\n\n- **Selenium**: Convert locators to By.CSS_SELECTOR or By.XPATH\n- **Puppeteer**: Use `page.goto()`, `page.click()`, `page.type()`\n- **Cypress**: Convert to `cy.visit()`, `cy.get()`, `cy.click()`\n\n---\n\n## Understanding Locators\n\n### What MCP Returns\n\nMCP uses temporary references in snapshots like `[ref=e1]`, `[ref=e2]`. These work during AI session but need conversion for standalone scripts.\n\n### What Gets Exported\n\nThe export feature analyzes the snapshot data and extracts:\n\n1. **ARIA roles and names**: Most reliable for accessibility\n   ```typescript\n   page.locator('[role=\"button\"][name=\"Submit\"]')\n   ```\n\n2. **Text content**: Good for unique text elements\n   ```typescript\n   page.locator('text=\"Click Here\"')\n   ```\n\n3. **Comments with refs**: When selector can't be determined\n   ```typescript\n   // Click element [ref=e1] - TODO: Add proper selector\n   ```\n\n### Improving Selectors\n\nIf you get TODO comments, you can:\n\n1. **Inspect the snapshot in JSON** - Look at `result.snapshot` field\n2. **Use browser DevTools** - Find stable selectors manually\n3. **Add data-testid attributes** - In your own app for reliable testing\n\n```typescript\n// Instead of:\n// Click element [ref=e1] - TODO: Add proper selector\n\n// Replace with:\nawait page.locator('data-testid=submit-button').click();\n// or\nawait page.locator('#submit-btn').click();\n// or\nawait page.locator('button:has-text(\"Submit\")').click();\n```\n\n---\n\n## Performance Comparison\n\n### AI Execution (Slow but Smart)\n- Figures out what to do: 5-10 seconds\n- Each action: 2-3 seconds (AI decides + execute)\n- **Total for 5 actions: 15-25 seconds**\n\n### Exported Code Execution (Fast but Fixed)\n- No AI reasoning needed\n- Direct Playwright commands\n- **Total for 5 actions: < 1 second**\n\n---\n\n## Best Practices\n\n### 1. Use AI for Discovery\n- Explore new websites\n- Figure out complex workflows\n- Handle dynamic content\n\n### 2. Export for Repetition\n- Regression testing\n- Scheduled automation\n- CI/CD pipelines\n\n### 3. Refine Manually\n- Review exported code\n- Add assertions (`expect()` statements)\n- Handle edge cases\n- Add proper waits\n\n### Example Workflow:\n\n```\n1. AI Discovery (Once)\n   \"Go to my-app.com, login as test@example.com with password 'test123', \n    and verify the dashboard shows user profile\"\n\n2. Export Code\n   - Click \"Export as Playwright\"\n   - Download .spec.ts file\n\n3. Manual Refinement\n   - Add assertions for verification\n   - Add data-testid to your app\n   - Replace dynamic selectors\n\n4. Run in CI/CD (Many times, fast)\n   - npx playwright test login.spec.ts\n   - Runs in < 1 second\n   - No API costs\n```\n\n---\n\n## Troubleshooting\n\n### \"No steps to export\"\n- Execute an instruction first\n- Wait for completion\n- Only successful executions can be exported\n\n### \"TODO: Add proper selector\" comments\n- Check the JSON export for snapshot data\n- Use browser DevTools to find stable selectors\n- Update the generated code manually\n\n### Selectors not working\n- Page structure may have changed\n- Use more specific selectors\n- Add waits: `await page.waitForSelector()`\n- Use data-testid attributes in your app\n\n---\n\n## Advanced: Custom Export Processing\n\nYou can process the JSON export programmatically:\n\n```javascript\n// Load JSON export\nconst data = require('./automation-steps.json');\n\n// Extract all URLs visited\nconst urls = data.steps\n  .filter(s => s.tool === 'browser_navigate')\n  .map(s => s.arguments.url);\n\nconsole.log('URLs visited:', urls);\n\n// Extract all clicks and their targets\nconst clicks = data.steps\n  .filter(s => s.tool === 'browser_click')\n  .map(s => ({\n    ref: s.arguments.ref,\n    snapshot: s.result.snapshot\n  }));\n\n// Generate custom framework code\n// ... your custom code generator ...\n```\n\n---\n\n## Summary\n\n✅ **Record once with AI** - Let AI figure out the steps  \n✅ **Export for reuse** - Get Playwright code + JSON data  \n✅ **Replay instantly** - No AI overhead, sub-second execution  \n✅ **Customize as needed** - Refine selectors and add logic  \n\nThe export feature bridges the gap between AI-powered exploration and production automation!\n","size_bytes":7705},"app/browser_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom typing import List, Dict, Any\nfrom openai import OpenAI\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        # Get API key from config.ini first, fallback to environment variable\n        api_key = config.get('openai', 'api_key', fallback=None)\n        if not api_key or api_key == 'YOUR_OPENAI_API_KEY_HERE':\n            api_key = os.environ.get('OPENAI_API_KEY')\n        \n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set in config.ini [openai] api_key field\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Initialize MCP connection and get available tools\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        # Start conversation\n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                # Call OpenAI with function calling\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,  # type: ignore\n                    tools=tools,  # type: ignore\n                    tool_choice=\"auto\",\n                    max_completion_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                # Check if assistant wants to call tools\n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name  # type: ignore\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                        \n                        # Execute the tool\n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            # Extract useful information from result\n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            # Add tool result to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            # Add error to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    # Assistant has finished\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6587},"app/mcp_stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        # Use provided values or fall back to config.ini\n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        \n        # Start MCP server process\n        args = [\"node\", \"cli.js\", \"--headless\" if headless else \"\", f\"--browser={browser}\"]\n        args = [arg for arg in args if arg]  # Remove empty strings\n        \n        # Set environment variable to skip Playwright host validation\n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        # Start reader thread\n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        # Give the process a moment to start\n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            # This is a response to a request\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            # This is a notification\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        # Not JSON, might be log output - ignore\n                        pass\n                except UnicodeDecodeError as ude:\n                    # Skip lines with encoding issues\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        # Create queue for this request\n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            # Send request\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            # Wait for response\n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            # Clean up\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)  # Timeout for tool calls\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8290}},"version":2}