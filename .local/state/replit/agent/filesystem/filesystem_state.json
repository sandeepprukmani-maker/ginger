{"file_contents":{"app/middleware/security.py":{"content":"\"\"\"\nSecurity Middleware\nAuthentication, rate limiting, and security utilities\n\"\"\"\nimport os\nimport time\nimport logging\nfrom functools import wraps\nfrom flask import request, jsonify\nfrom typing import Dict, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self, max_requests: int = 10, window_seconds: int = 60):\n        \"\"\"\n        Initialize rate limiter\n        \n        Args:\n            max_requests: Maximum requests allowed in the time window\n            window_seconds: Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests: Dict[str, list] = {}\n    \n    def is_allowed(self, client_id: str) -> Tuple[bool, Optional[int]]:\n        \"\"\"\n        Check if request is allowed for client\n        \n        Args:\n            client_id: Unique identifier for the client\n            \n        Returns:\n            Tuple of (is_allowed, retry_after_seconds)\n        \"\"\"\n        now = time.time()\n        \n        if client_id not in self.requests:\n            self.requests[client_id] = []\n        \n        requests = self.requests[client_id]\n        requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n        \n        if len(requests) >= self.max_requests:\n            oldest_request = min(requests)\n            retry_after = int(self.window_seconds - (now - oldest_request)) + 1\n            return False, retry_after\n        \n        requests.append(now)\n        self.requests[client_id] = requests\n        \n        self._cleanup_old_entries(now)\n        \n        return True, None\n    \n    def _cleanup_old_entries(self, now: float):\n        \"\"\"Clean up old entries to prevent memory bloat\"\"\"\n        clients_to_remove = []\n        for client_id, requests in self.requests.items():\n            active_requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n            if not active_requests:\n                clients_to_remove.append(client_id)\n            else:\n                self.requests[client_id] = active_requests\n        \n        for client_id in clients_to_remove:\n            del self.requests[client_id]\n\n\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n\n\ndef require_api_key(f):\n    \"\"\"\n    Decorator to require API key authentication\n    \n    Checks for API key in:\n    1. X-API-Key header\n    2. api_key query parameter\n    \n    Set API_KEY environment variable to enable authentication.\n    If API_KEY is not set, authentication is disabled (development mode).\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        expected_api_key = os.environ.get('API_KEY')\n        \n        if not expected_api_key:\n            logger.warning(\"‚ö†Ô∏è  API_KEY not set - authentication disabled (development mode)\")\n            return f(*args, **kwargs)\n        \n        provided_api_key = request.headers.get('X-API-Key') or request.args.get('api_key')\n        \n        if not provided_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - no API key provided\")\n            return jsonify({\n                'success': False,\n                'error': 'Authentication required',\n                'message': 'Please provide an API key via X-API-Key header or api_key parameter'\n            }), 401\n        \n        if provided_api_key != expected_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - invalid API key\")\n            return jsonify({\n                'success': False,\n                'error': 'Invalid API key'\n            }), 403\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef rate_limit(f):\n    \"\"\"\n    Decorator to apply rate limiting\n    \n    Uses IP address as client identifier\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        client_id = request.remote_addr or 'unknown'\n        \n        allowed, retry_after = rate_limiter.is_allowed(client_id)\n        \n        if not allowed:\n            logger.warning(f\"‚ö†Ô∏è  Rate limit exceeded for {client_id}\")\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded',\n                'message': f'Too many requests. Please try again in {retry_after} seconds.',\n                'retry_after': retry_after\n            }), 429\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef validate_engine_type(engine_type: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate engine type parameter\n    \n    Args:\n        engine_type: Engine type to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    valid_engines = ['hybrid', 'browser_use', 'playwright_mcp']\n    \n    if engine_type not in valid_engines:\n        return False, f\"Invalid engine type '{engine_type}'. Must be one of: {', '.join(valid_engines)}\"\n    \n    return True, None\n\n\ndef validate_instruction(instruction: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate instruction parameter\n    \n    Args:\n        instruction: Instruction to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not instruction or not instruction.strip():\n        return False, \"Instruction cannot be empty\"\n    \n    if len(instruction) > 5000:\n        return False, \"Instruction is too long (maximum 5000 characters)\"\n    \n    return True, None\n\n\ndef sanitize_error_message(error: Exception) -> str:\n    \"\"\"\n    Convert internal exception to user-safe error message\n    \n    Args:\n        error: Exception to sanitize\n        \n    Returns:\n        User-safe error message\n    \"\"\"\n    error_str = str(error).lower()\n    \n    if 'openai' in error_str or 'api' in error_str:\n        return \"AI service error. Please try again later.\"\n    \n    if 'browser' in error_str or 'playwright' in error_str:\n        return \"Browser automation error. Please try again.\"\n    \n    if 'timeout' in error_str:\n        return \"Operation timed out. The task took too long to complete.\"\n    \n    if 'permission' in error_str or 'denied' in error_str:\n        return \"Permission denied. Please check your access rights.\"\n    \n    return \"An unexpected error occurred. Please try again.\"\n","size_bytes":6346},"app/services/__init__.py":{"content":"\"\"\"\nFlask Services Module\n\"\"\"\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n__all__ = ['EngineOrchestrator']\n","size_bytes":128},"app/routes/api.py":{"content":"\"\"\"\nAPI Routes\nRESTful endpoints for browser automation with security and validation\n\"\"\"\nimport os\nimport logging\nfrom flask import Blueprint, render_template, request, jsonify\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.middleware.security import (\n    require_api_key,\n    rate_limit,\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\nfrom app.utils.timeout import run_with_timeout, TimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_api_routes(orchestrator: EngineOrchestrator) -> Blueprint:\n    \"\"\"\n    Create API routes blueprint\n    \n    Args:\n        orchestrator: Engine orchestrator instance\n        \n    Returns:\n        Flask Blueprint with all routes\n    \"\"\"\n    api = Blueprint('api', __name__)\n    \n    @api.route('/')\n    def index():\n        \"\"\"Render main page\"\"\"\n        return render_template('index.html')\n    \n    @api.route('/api/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            instruction = data.get('instruction', '').strip()\n            engine_type = data.get('engine', 'hybrid')\n            headless = data.get('headless', False)\n\n            print(instruction,engine_type)\n            \n            is_valid, error_msg = validate_instruction(instruction)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid instruction: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid instruction',\n                    'message': error_msg\n                }), 400\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid engine type: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            if not isinstance(headless, bool):\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid parameter',\n                    'message': 'headless must be a boolean'\n                }), 400\n            \n            logger.info(\"=\"*80)\n            logger.info(\"üì® NEW AUTOMATION REQUEST\")\n            logger.info(f\"üìù Instruction: {instruction}\")\n            logger.info(f\"üîß Engine: {engine_type}\")\n            logger.info(f\"üëÅÔ∏è  Headless: {headless}\")\n            logger.info(f\"üåê Client: {request.remote_addr}\")\n            logger.info(\"=\"*80)\n            \n            logger.info(\"üöÄ Starting automation execution...\")\n            \n            try:\n                result = run_with_timeout(\n                    orchestrator.execute_instruction,\n                    300,\n                    instruction,\n                    engine_type,\n                    headless\n                )\n            except TimeoutError as e:\n                logger.error(f\"‚è±Ô∏è  Automation timed out: {str(e)}\")\n                orchestrator.cleanup_after_timeout(engine_type, headless)\n                return jsonify({\n                    'success': False,\n                    'error': 'Timeout',\n                    'message': 'Operation timed out. The task took longer than 5 minutes to complete.',\n                    'timeout': True\n                }), 408\n            \n            if result.get('success'):\n                logger.info(f\"‚úÖ Automation completed successfully in {result.get('iterations', 0)} steps\")\n            else:\n                logger.error(f\"‚ùå Automation failed: {result.get('error', 'Unknown error')}\")\n            \n            logger.info(\"=\"*80)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            logger.error(f\"üí• Exception in execute_instruction: {str(e)}\", exc_info=True)\n            \n            user_message = sanitize_error_message(e)\n            \n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': user_message\n            }), 500\n    \n    @api.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            engine_type = request.args.get('engine', 'hybrid')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            tools = orchestrator.get_tools(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'tools': tools,\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting tools: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/reset', methods=['POST'])\n    @require_api_key\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_type = data.get('engine', 'hybrid')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            orchestrator.reset_agent(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully',\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error resetting agent: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            return jsonify({\n                'status': 'healthy',\n                'engines': {\n                    'hybrid': 'available',\n                    'browser_use': 'available',\n                    'playwright_mcp': 'available'\n                },\n                'message': 'Hybrid-engine browser automation ready',\n                'security': {\n                    'authentication': 'enabled' if os.environ.get('API_KEY') else 'disabled',\n                    'rate_limiting': 'enabled'\n                }\n            })\n        except Exception as e:\n            logger.error(f\"Health check failed: {str(e)}\", exc_info=True)\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Service unavailable'\n            }), 503\n    \n    return api\n","size_bytes":7540},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.5.9\",\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=2.6.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pytest>=8.4.2\",\n    \"pytest-cov>=7.0.0\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":508},"app/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\nconst engineSelect = document.getElementById('engine-select');\nconst headlessToggle = document.getElementById('headless-toggle');\nconst statusBadge = document.getElementById('status-badge');\nconst currentEngineDisplay = document.getElementById('current-engine');\nconst currentModeDisplay = document.getElementById('current-mode');\n\n// Update footer display when engine or mode changes\nfunction updateFooterDisplay() {\n    const engineText = engineSelect.value === 'browser_use' ? 'Browser-Use' : 'Playwright MCP';\n    const modeText = headlessToggle.checked ? 'Headless' : 'Headful';\n    \n    currentEngineDisplay.textContent = engineText;\n    currentModeDisplay.textContent = modeText;\n}\n\n// Initialize\nengineSelect.addEventListener('change', updateFooterDisplay);\nheadlessToggle.addEventListener('change', updateFooterDisplay);\nupdateFooterDisplay();\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    const engine = engineSelect.value;\n    const headless = headlessToggle.checked;\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    showStatusBadge('running', 'Processing...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ \n                instruction,\n                engine,\n                headless\n            }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `‚úÖ Completed in ${data.iterations} iteration(s) using ${data.engine}`);\n            showStatusBadge('success', 'Completed');\n            displayResults(data);\n        } else {\n            showStatus('error', `‚ùå Error: ${data.error || 'Unknown error'}`);\n            showStatusBadge('error', 'Failed');\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `‚ùå Failed to execute: ${error.message}`);\n        showStatusBadge('error', 'Failed');\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history and browser state.')) {\n        return;\n    }\n    \n    const engine = engineSelect.value;\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ engine }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', '‚úÖ Agent reset successfully');\n            showStatusBadge('', '');\n            resultsDiv.innerHTML = '<div class=\"empty-state\"><div class=\"empty-icon\">üöÄ</div><p>Enter an instruction and click Execute to begin automation</p></div>';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `‚ùå Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `‚ùå Failed to reset: ${error.message}`);\n    }\n});\n\n// Example buttons\ndocument.querySelectorAll('.example-btn').forEach(btn => {\n    btn.addEventListener('click', () => {\n        instructionInput.value = btn.dataset.instruction;\n        instructionInput.focus();\n    });\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction showStatusBadge(type, text) {\n    statusBadge.className = `status-badge ${type}`;\n    statusBadge.textContent = text;\n    statusBadge.style.display = text ? 'block' : 'none';\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.style.cssText = 'background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 16px; border-radius: 8px; margin-top: 16px; font-weight: 500; color: #0c4a6e;';\n        messageEl.innerHTML = `<strong>Final Result:</strong> ${data.message}`;\n        resultsDiv.appendChild(messageEl);\n    }\n    \n    // Display engine info\n    const engineInfo = document.createElement('div');\n    engineInfo.style.cssText = 'margin-top: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; font-size: 0.9rem; color: #666;';\n    engineInfo.innerHTML = `<strong>Engine:</strong> ${data.engine || 'unknown'} | <strong>Mode:</strong> ${data.headless ? 'Headless' : 'Headful'}`;\n    resultsDiv.appendChild(engineInfo);\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? '‚úì Success' : '‚úó Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `üîß Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.textContent = `‚ùå Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'üìÑ View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            console.log('Application is healthy and ready');\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":8901},"app/utils/timeout.py":{"content":"\"\"\"\nCross-platform timeout utility\nWorks on Windows, Linux, and macOS with proper cancellation\n\"\"\"\nimport threading\nimport logging\nfrom typing import Callable, Any, Optional\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeoutError(Exception):\n    \"\"\"Raised when operation times out\"\"\"\n    pass\n\n\ndef run_with_timeout(func: Callable, timeout_seconds: int, *args, **kwargs) -> Any:\n    \"\"\"\n    Run a function with a timeout (cross-platform)\n    \n    Note: This implementation returns promptly on timeout but cannot\n    forcefully terminate the underlying function if it's stuck. The\n    worker thread continues in the background but HTTP request returns.\n    \n    Args:\n        func: Function to execute\n        timeout_seconds: Timeout in seconds\n        *args: Positional arguments to pass to func\n        **kwargs: Keyword arguments to pass to func\n        \n    Returns:\n        Result from func\n        \n    Raises:\n        TimeoutError: If function execution exceeds timeout\n    \"\"\"\n    executor = ThreadPoolExecutor(max_workers=1)\n    future = executor.submit(func, *args, **kwargs)\n    \n    try:\n        result = future.result(timeout=timeout_seconds)\n        executor.shutdown(wait=False)\n        return result\n    except FutureTimeoutError:\n        logger.warning(f\"‚è±Ô∏è Operation timed out after {timeout_seconds} seconds\")\n        future.cancel()\n        executor.shutdown(wait=False)\n        raise TimeoutError(f\"Operation timed out after {timeout_seconds} seconds\")\n    except Exception as e:\n        logger.error(f\"‚ùå Error during timed execution: {str(e)}\")\n        executor.shutdown(wait=False)\n        raise\n","size_bytes":1714},"browser_use_codebase/popup_handler.py":{"content":"\"\"\"\nPopup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Monitors and handles popup windows automatically\n    Switches to new windows when they appear during automation\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext):\n        \"\"\"\n        Initialize the popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        \n        context.on(\"page\", self._on_new_page)\n        logger.info(\"üîç Popup window handler initialized\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Event handler for new pages/windows\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        logger.info(f\"üÜï New window detected: {page.url}\")\n        self.new_pages.append(page)\n        self.popup_detected = True\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page (prioritizes new popups)\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=5000)\n                logger.info(f\"‚úÖ Switched to popup window: {latest_page.url}\")\n                return latest_page\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è Popup not ready yet: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    def reset(self):\n        \"\"\"Reset the handler state\"\"\"\n        self.new_pages.clear()\n        self.popup_detected = False\n        logger.info(\"üîÑ Popup handler reset\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":2324},"test_engines.py":{"content":"\"\"\"\nEngine Test Script\nTests if the engines can initialize properly with your API key\nRun this BEFORE starting the web app to verify everything works\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\n\nprint(\"=\" * 60)\nprint(\"Engine Initialization Test\")\nprint(\"=\" * 60)\n\n# Step 1: Load .env file\nprint(\"\\n[Step 1] Loading .env file...\")\nif not os.path.exists('.env'):\n    print(\"‚ùå FATAL ERROR: .env file not found!\")\n    print(\"   You must create a .env file in this directory\")\n    print(\"   Run: copy .env.example .env\")\n    print(\"   Then edit .env and add your API key\")\n    sys.exit(1)\n\nload_dotenv(override=True)\napi_key = os.environ.get('OPENAI_API_KEY')\n\nif not api_key:\n    print(\"‚ùå FATAL ERROR: OPENAI_API_KEY not found in .env file!\")\n    print(\"   Open your .env file and make sure it contains:\")\n    print(\"   OPENAI_API_KEY=sk-your-actual-key-here\")\n    sys.exit(1)\n\nmasked_key = api_key[:10] + \"...\" + api_key[-4:] if len(api_key) > 14 else \"***\"\nprint(f\"‚úÖ API key loaded: {masked_key}\")\n\n# Step 2: Test Browser-Use engine initialization\nprint(\"\\n[Step 2] Testing Browser-Use engine...\")\ntry:\n    from browser_use_codebase.engine import BrowserUseEngine\n    engine = BrowserUseEngine(headless=True)\n    print(\"‚úÖ Browser-Use engine initialized successfully!\")\nexcept Exception as e:\n    print(f\"‚ùå Browser-Use engine FAILED: {str(e)}\")\n    print(\"\\nThis is the exact error the web app will show!\")\n    sys.exit(1)\n\n# Step 3: Test Playwright MCP engine initialization\nprint(\"\\n[Step 3] Testing Playwright MCP engine...\")\ntry:\n    from playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n    from playwright_mcp_codebase.client.stdio_client import MCPStdioClient\n    \n    # Don't actually initialize the client, just test the agent can be created\n    client = MCPStdioClient(headless=True)\n    agent = BrowserAgent(client)\n    print(\"‚úÖ Playwright MCP engine initialized successfully!\")\nexcept Exception as e:\n    print(f\"‚ùå Playwright MCP engine FAILED: {str(e)}\")\n    print(\"\\nThis is the exact error the web app will show!\")\n    sys.exit(1)\n\n# Step 4: Success!\nprint(\"\\n\" + \"=\" * 60)\nprint(\"üéâ SUCCESS! All engines initialized correctly!\")\nprint(\"=\" * 60)\nprint(\"\\nYour setup is correct. You can now run:\")\nprint(\"  python main.py\")\nprint(\"\\nThe web application should work without API key errors.\")\nprint(\"=\" * 60)\n","size_bytes":2366},"browser_use_codebase/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"app/services/engine_orchestrator.py":{"content":"\"\"\"\nEngine Orchestrator\nManages and coordinates all browser automation engines\n\"\"\"\nfrom typing import Dict, Any, Tuple, Optional\nimport logging\nimport playwright_mcp_codebase\nimport browser_use_codebase\nimport hybrid_engine\nfrom app.middleware.security import sanitize_error_message\n\nlogger = logging.getLogger(__name__)\n\n\nclass EngineOrchestrator:\n    \"\"\"\n    Orchestrates browser automation engines (Hybrid, Playwright MCP, and Browser-Use)\n    Handles engine instantiation, caching, and execution delegation\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the orchestrator with empty engine caches\"\"\"\n        self.playwright_engines = {}\n        self.browser_use_engines = {}\n        self.hybrid_engines = {}\n    \n    def get_playwright_engine(self, headless: bool) -> Tuple[Any, Any]:\n        \"\"\"\n        Get or create Playwright MCP engine instance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            Tuple of (mcp_client, browser_agent)\n        \"\"\"\n        if headless not in self.playwright_engines:\n            mcp_client, browser_agent = playwright_mcp_codebase.create_engine(headless=headless)\n            self.playwright_engines[headless] = (mcp_client, browser_agent)\n        \n        return self.playwright_engines[headless]\n    \n    def get_browser_use_engine(self, headless: bool):\n        \"\"\"\n        Get or create Browser-Use engine instance\n        Caches instances per headless mode for better performance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            BrowserUseEngine instance\n        \"\"\"\n        if headless not in self.browser_use_engines:\n            self.browser_use_engines[headless] = browser_use_codebase.create_engine(headless=headless)\n        \n        return self.browser_use_engines[headless]\n    \n    def get_hybrid_engine(self, headless: bool):\n        \"\"\"\n        Get or create Hybrid engine instance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            HybridEngine instance\n        \"\"\"\n        if headless not in self.hybrid_engines:\n            self.hybrid_engines[headless] = hybrid_engine.create_engine(headless=headless)\n        \n        return self.hybrid_engines[headless]\n    \n    def execute_instruction(self, instruction: str, engine_type: str, headless: bool) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction using the specified engine\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'hybrid', 'playwright_mcp', or 'browser_use'\n            headless: Run in headless mode\n            \n        Returns:\n            Execution result dictionary\n        \"\"\"\n        valid_engines = ['hybrid', 'playwright_mcp', 'browser_use']\n        if engine_type not in valid_engines:\n            logger.error(f\"Invalid engine type: {engine_type}\")\n            return {\n                'success': False,\n                'error': f\"Invalid engine type: {engine_type}. Must be one of: {', '.join(valid_engines)}\",\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n        \n        result = None\n        try:\n            if engine_type == 'hybrid':\n                engine = self.get_hybrid_engine(headless)\n                result = engine.execute_instruction_sync(instruction)\n                \n            elif engine_type == 'playwright_mcp':\n                client, agent = self.get_playwright_engine(headless)\n                \n                try:\n                    if not client.initialized:\n                        logger.info(\"Initializing Playwright MCP client...\")\n                        client.initialize()\n                    \n                    result = agent.execute_instruction(instruction)\n                except Exception as e:\n                    logger.error(f\"Playwright MCP error: {str(e)}, attempting to reinitialize\")\n                    self._reset_playwright_engine(headless)\n                    raise\n                \n            elif engine_type == 'browser_use':\n                engine = self.get_browser_use_engine(headless)\n                result = engine.execute_instruction_sync(instruction)\n            \n            if result is not None:\n                result['engine'] = engine_type\n                result['headless'] = headless\n                return result\n            else:\n                raise ValueError(\"Engine returned no result\")\n            \n        except Exception as e:\n            logger.error(f\"Engine execution error ({engine_type}): {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n    \n    def _reset_playwright_engine(self, headless: bool):\n        \"\"\"\n        Reset Playwright engine if it crashes or becomes unresponsive\n        \n        Args:\n            headless: Headless mode setting\n        \"\"\"\n        if headless in self.playwright_engines:\n            logger.warning(f\"Resetting Playwright engine (headless={headless})\")\n            try:\n                client, _ = self.playwright_engines[headless]\n                if hasattr(client, 'cleanup'):\n                    client.cleanup()\n            except Exception as e:\n                logger.error(f\"Error during Playwright cleanup: {str(e)}\")\n            finally:\n                del self.playwright_engines[headless]\n    \n    def get_tools(self, engine_type: str) -> list:\n        \"\"\"\n        Get available tools for the specified engine\n        \n        Args:\n            engine_type: 'hybrid', 'playwright_mcp', or 'browser_use'\n            \n        Returns:\n            List of available tools\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            client, _ = self.get_playwright_engine(headless=True)\n            \n            if not client.initialized:\n                client.initialize()\n            \n            return client.list_tools()\n        elif engine_type == 'hybrid':\n            return [\n                {'name': 'hybrid_agent', 'description': 'Intelligent hybrid automation (Browser-Use + Playwright MCP fallback)'}\n            ]\n        else:\n            return [\n                {'name': 'browser_use_agent', 'description': 'AI-powered browser automation'}\n            ]\n    \n    def cleanup_after_timeout(self, engine_type: str, headless: bool):\n        \"\"\"\n        Clean up resources after a timed-out execution\n        \n        Args:\n            engine_type: Engine that was executing when timeout occurred\n            headless: Headless mode setting\n        \"\"\"\n        logger.warning(f\"Cleaning up after timeout for {engine_type} (headless={headless})\")\n        \n        try:\n            if engine_type == 'playwright_mcp' or engine_type == 'hybrid':\n                self._reset_playwright_engine(headless)\n            \n            if engine_type == 'hybrid' and headless in self.hybrid_engines:\n                del self.hybrid_engines[headless]\n        except Exception as e:\n            logger.error(f\"Error during timeout cleanup: {str(e)}\")\n    \n    def reset_agent(self, engine_type: str, headless: bool = True):\n        \"\"\"\n        Reset the conversation history for the specified engine\n        \n        Args:\n            engine_type: 'hybrid', 'playwright_mcp', or 'browser_use'\n            headless: Headless mode (for Playwright MCP and Hybrid)\n        \"\"\"\n        if engine_type == 'hybrid':\n            engine = self.get_hybrid_engine(headless)\n            engine.reset()\n        elif engine_type == 'playwright_mcp':\n            _, agent = self.get_playwright_engine(headless)\n            agent.reset_conversation()\n","size_bytes":7987},"playwright_mcp_codebase/agent/conversation_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom pathlib import Path\nfrom typing import List, Dict, Any\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,\n                    tools=tools,\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name\n                        tool_args = json.loads(tool_call.function.arguments)\n                        \n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6087},"browser_use_codebase/engine.py":{"content":"\"\"\"\nBrowser-Use Engine\nAI-powered browser automation using browser-use library\n\nThread Safety Notes:\n- This engine creates a fresh Browser instance per request\n- Each request runs on its own event loop to ensure thread safety\n- Browser instances are NOT cached to prevent asyncio loop affinity issues\n- Memory is cleaned up after each request via finally block\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, List\nfrom dotenv import load_dotenv\nfrom browser_use import Agent\nfrom browser_use.llm import ChatOpenAI\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BrowserUseEngine:\n    \"\"\"\n    Browser automation engine using browser-use library\n    \n    Thread Safety: This engine is designed for Flask's multi-threaded environment.\n    Each request creates its own event loop and browser instance, which are\n    properly cleaned up after execution.\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        api_key = os.environ.get('OPENAI_API_KEY')\n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set as OPENAI_API_KEY environment variable. Never store API keys in config files for security reasons.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        \n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        self.llm = ChatOpenAI(\n            model=model,\n            api_key=api_key,\n            timeout=timeout\n        )\n    \n    async def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        try:\n            logger.info(\"ü§ñ Initializing Browser-Use Agent\")\n            logger.info(f\"üìã Task: {instruction}\")\n            logger.info(f\"üî¢ Max steps: {self.max_steps}\")\n            \n            # Custom system message to ensure literal execution and popup handling\n            system_instructions = \"\"\"\nCRITICAL INSTRUCTIONS - KEEP RESPONSES BRIEF:\n1. Follow the user's instruction LITERALLY - do only what is explicitly asked\n2. STOP IMMEDIATELY once the stated task is complete\n3. Do NOT extract, save, or compile data unless explicitly requested\n4. Do NOT perform additional \"helpful\" actions beyond the instruction\n5. If asked to \"search\", stop when search results appear\n6. If asked to \"navigate\", stop when the page loads\n7. If asked to \"click\", stop after clicking\n8. Only do extra work (extract, save, analyze) if the instruction explicitly asks for it\n9. IMPORTANT: Keep all your reasoning and output SHORT and DIRECT to avoid timeouts\n\nPOPUP WINDOW HANDLING:\n- When a button opens a NEW WINDOW or POPUP (like \"Sign in with Google\", \"Continue with X\", etc.):\n  * The browser will automatically switch to the new window\n  * Continue your task in the NEW WINDOW without mentioning the window switch\n  * All subsequent actions should be performed in the NEW WINDOW\n  * Example: If user says \"click sign in with Google, then enter email\", you click the button and the new Google window opens automatically - just proceed to enter the email in that new window\n- DO NOT try to switch windows manually - it happens automatically\n- DO NOT mention window switches in your output - just continue the task seamlessly\n            \"\"\"\n            \n            logger.info(\"‚öôÔ∏è  Configuring agent with literal execution instructions\")\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"‚ñ∂Ô∏è  Starting agent execution...\")\n            history = await agent.run(max_steps=self.max_steps)\n            logger.info(f\"‚èπÔ∏è  Agent execution completed\")\n            \n            logger.info(\"üìä Processing execution history...\")\n            steps = []\n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                logger.info(f\"  Step {step_num}: {action[:100]}...\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Check if task actually succeeded - if 0 steps executed, it likely failed\n            if len(steps) == 0:\n                logger.error(f\"‚ùå Task failed - no steps were executed successfully\")\n                return {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps. This usually means the browser could not launch.\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            \n            logger.info(f\"‚úÖ Task completed successfully!\")\n            logger.info(f\"üìà Total steps executed: {len(steps)}\")\n            if final_result:\n                logger.info(f\"üéØ Final result: {str(final_result)[:200]}\")\n            \n            return {\n                \"success\": True,\n                \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                \"steps\": steps,\n                \"iterations\": len(steps),\n                \"final_result\": final_result\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Browser-Use execution failed: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"steps\": [],\n                \"iterations\": 0\n            }\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        Each call creates a new event loop to ensure thread safety\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction))\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n","size_bytes":7729},"README.md":{"content":"# AI Browser Automation\n\nA professional hybrid-engine browser automation system powered by AI, offering intelligent automation with automatic fallback for maximum reliability through a modern Flask web interface.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Features](#features)\n- [Automation Engines](#automation-engines)\n- [Architecture](#architecture)\n- [Technology Stack](#technology-stack)\n- [Prerequisites](#prerequisites)\n- [Installation & Setup](#installation--setup)\n  - [Windows](#windows-setup)\n  - [Linux](#linux-setup)\n  - [macOS](#macos-setup)\n  - [Replit](#replit-setup)\n- [Running the Application](#running-the-application)\n- [Usage](#usage)\n- [API Documentation](#api-documentation)\n- [Security](#security)\n- [Testing](#testing)\n- [Deployment](#deployment)\n- [Configuration](#configuration)\n- [Troubleshooting](#troubleshooting)\n- [Contributing](#contributing)\n- [License](#license)\n\n---\n\n## Overview\n\nThis project provides intelligent browser automation using natural language instructions. Users can choose between three powerful automation engines through an intuitive web interface, with the Hybrid engine providing the best of both worlds through automatic fallback mechanisms.\n\n### Automation Engines\n\n1. **Hybrid Engine** ‚≠ê **Recommended - Default**\n   - **Intelligent Fallback**: Combines Browser-Use with Playwright MCP fallback\n   - Attempts Browser-Use first for autonomous, intelligent automation\n   - Automatically falls back to Playwright MCP if Browser-Use fails\n   - Provides execution metadata showing which engine succeeded\n   - **Best reliability**: Get the power of AI with the stability of tool-based control\n   - Ideal for production use cases requiring high success rates\n\n2. **Browser-Use Engine**\n   - AI-powered automation with advanced reasoning capabilities\n   - Uses the browser-use library with LLM reasoning\n   - Autonomous task completion with minimal tool calls\n   - Best for complex, multi-step workflows requiring adaptability\n\n3. **Playwright MCP Engine**\n   - Tool-based automation using Playwright's Model Context Protocol\n   - Discrete, controllable browser actions\n   - Fine-grained control over each automation step\n   - Best for precise, repeatable tasks with predictable behavior\n\n---\n\n## Features\n\n- **Hybrid Intelligence**: Smart automation with automatic fallback for reliability\n- **Triple Engine System**: Choose between hybrid, AI-powered, or tool-based automation\n- **Headless/Headful Modes**: Run browser invisibly for speed or visibly for debugging\n- **Natural Language Instructions**: Describe tasks in plain English\n- **Real-time Feedback**: See step-by-step execution progress with engine metadata\n- **Modern Web Interface**: Clean two-column layout with configuration panel\n- **Quick Examples**: Pre-loaded examples for common automation tasks\n- **RESTful API**: Programmatic access to automation capabilities\n- **Security Features**: API authentication, rate limiting, input validation, CORS support\n- **Cross-Platform**: Works on Windows, Linux, macOS, and Replit\n\n---\n\n## Architecture\n\n### Directory Structure\n\n```\n.\n‚îú‚îÄ‚îÄ app/                           # Flask web application\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py               # Application factory\n‚îÇ   ‚îú‚îÄ‚îÄ middleware/               # Security & validation\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py           # Auth, rate limiting, validation\n‚îÇ   ‚îú‚îÄ‚îÄ services/                 # Business logic layer\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ engine_orchestrator.py  # Engine coordination\n‚îÇ   ‚îú‚îÄ‚îÄ routes/                   # API endpoints\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.py                # REST routes\n‚îÇ   ‚îú‚îÄ‚îÄ templates/                # HTML templates\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html\n‚îÇ   ‚îú‚îÄ‚îÄ static/                   # Static assets\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/style.css\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ js/app.js\n‚îÇ   ‚îî‚îÄ‚îÄ utils/                    # Utilities\n‚îÇ       ‚îî‚îÄ‚îÄ timeout.py            # Timeout handling\n‚îú‚îÄ‚îÄ browser_use_codebase/         # Browser-Use engine\n‚îÇ   ‚îú‚îÄ‚îÄ engine.py                 # Browser-Use implementation\n‚îÇ   ‚îî‚îÄ‚îÄ config/                   # Configuration helpers\n‚îú‚îÄ‚îÄ hybrid_engine/                # Hybrid engine (recommended)\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py              # Package initialization\n‚îÇ   ‚îî‚îÄ‚îÄ engine.py                # Intelligent fallback logic\n‚îú‚îÄ‚îÄ playwright_mcp_codebase/      # Playwright MCP engine\n‚îÇ   ‚îú‚îÄ‚îÄ agent/                    # Conversation agent\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ conversation_agent.py\n‚îÇ   ‚îú‚îÄ‚îÄ client/                   # MCP STDIO client\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stdio_client.py\n‚îÇ   ‚îî‚îÄ‚îÄ config/                   # Configuration helpers\n‚îú‚îÄ‚îÄ tests/                        # Unit tests\n‚îÇ   ‚îú‚îÄ‚îÄ test_api_routes.py\n‚îÇ   ‚îî‚îÄ‚îÄ test_engine_orchestrator.py\n‚îú‚îÄ‚îÄ config/                       # Configuration files\n‚îÇ   ‚îî‚îÄ‚îÄ config.ini                # Application configuration\n‚îú‚îÄ‚îÄ node/                         # Node.js dependencies\n‚îÇ   ‚îú‚îÄ‚îÄ cli.js                    # Playwright MCP server entry point\n‚îÇ   ‚îú‚îÄ‚îÄ index.js                  # Package main entry\n‚îÇ   ‚îú‚îÄ‚îÄ index.d.ts                # TypeScript definitions\n‚îÇ   ‚îú‚îÄ‚îÄ package.json              # Node.js dependencies\n‚îÇ   ‚îî‚îÄ‚îÄ package-lock.json         # Dependency lock file\n‚îú‚îÄ‚îÄ main.py                       # Application entry point\n‚îú‚îÄ‚îÄ pyproject.toml                # Python dependencies (uv)\n‚îú‚îÄ‚îÄ requirements.txt              # Python dependencies (pip)\n‚îú‚îÄ‚îÄ uv.lock                       # Python dependency lock file\n‚îú‚îÄ‚îÄ LICENSE                       # License file\n‚îî‚îÄ‚îÄ README.md                     # This file\n```\n\n### Design Patterns\n\n**Frontend Architecture:**\n- Vanilla JavaScript with server-side Jinja2 templates\n- Two-column responsive layout\n- RESTful API communication using fetch API\n\n**Backend Architecture:**\n- Application Factory Pattern for Flask initialization\n- Service-oriented architecture with clear separation of concerns\n- Blueprint pattern for modular route organization\n- Engine orchestration for managing multiple automation engines\n\n### Thread Safety\n\n**Browser-Use Engine:**\n- Creates fresh browser instances per request\n- Uses new event loop for each execution\n- No instance caching to prevent loop affinity issues\n- Automatic cleanup in finally blocks\n\n**Playwright MCP Engine:**\n- Subprocess-based communication is thread-safe\n- Instances cached by headless mode setting\n- Shared across requests for efficiency\n\n---\n\n## Technology Stack\n\n### Backend\n- **Python 3.11+** with Flask web framework\n- **OpenAI GPT-4o-mini** for AI reasoning\n- **Playwright** (via browser-use and MCP)\n- **browser-use** library for autonomous automation\n- **langchain-openai** for LLM integration\n- **gunicorn** for production WSGI server\n\n### Frontend\n- Modern HTML5/CSS3/JavaScript\n- RESTful API communication\n- Real-time status updates\n\n### Infrastructure\n- Subprocess-based MCP communication (Playwright)\n- Async execution with thread-safe event loops (Browser-Use)\n- Environment-based secret management\n\n---\n\n## Prerequisites\n\n- **Python 3.11+**: Required for async features\n- **Node.js 18+**: Required for Playwright MCP server\n- **OpenAI API Key**: Get from https://platform.openai.com/api-keys\n\n---\n\n## Installation & Setup\n\n### Windows Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\nDownload from https://www.python.org/downloads/\n\n**Node.js 18+:**\nDownload from https://nodejs.org/\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\nUsing pip:\n```bash\npip install -r requirements.txt\n```\n\nOr using uv (faster):\n```bash\npip install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\n```\n\n#### 6. Configure OpenAI API Key\n\nSet as environment variable (PowerShell):\n```powershell\n$env:OPENAI_API_KEY=\"sk-your-actual-api-key-here\"\n```\n\nOr set as environment variable (Command Prompt):\n```cmd\nset OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to System Environment Variables:\n1. Search \"Environment Variables\" in Windows\n2. Click \"Environment Variables\" button\n3. Add new User or System variable: `OPENAI_API_KEY`\n\n#### 7. Run the Application\n\n```bash\npython main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### Linux Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\n```bash\nsudo apt update\nsudo apt install python3.11 python3.11-venv python3-pip\n```\n\n**Node.js 18+:**\n```bash\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt install -y nodejs\n```\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\n```bash\npip3 install -r requirements.txt\n```\n\nOr using uv:\n```bash\npip3 install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\nnpx playwright install-deps chromium\n```\n\n#### 6. Configure OpenAI API Key\n\n```bash\nexport OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to `~/.bashrc` or `~/.profile`:\n```bash\necho 'export OPENAI_API_KEY=sk-your-actual-api-key-here' >> ~/.bashrc\nsource ~/.bashrc\n```\n\n#### 7. Run the Application\n\n```bash\npython3 main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### macOS Setup\n\n#### 1. Install Prerequisites\n\n**Python 3.11+:**\n```bash\nbrew install python@3.11\n```\n\n**Node.js 18+:**\n```bash\nbrew install node@18\n```\n\n#### 2. Clone Repository\n\n```bash\ngit clone <repository-url>\ncd ai-browser-automation\n```\n\n#### 3. Install Python Dependencies\n\n```bash\npip3 install -r requirements.txt\n```\n\nOr using uv:\n```bash\npip3 install uv\nuv sync\n```\n\n#### 4. Install Node.js Dependencies\n\n```bash\nnpm install\n```\n\n#### 5. Install Playwright Browsers\n\n```bash\nnpx playwright install chromium\n```\n\n#### 6. Configure OpenAI API Key\n\n```bash\nexport OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\nFor persistent configuration, add to `~/.zshrc` or `~/.bash_profile`:\n```bash\necho 'export OPENAI_API_KEY=sk-your-actual-api-key-here' >> ~/.zshrc\nsource ~/.zshrc\n```\n\n#### 7. Run the Application\n\n```bash\npython3 main.py\n```\n\nAccess at: `http://localhost:5000`\n\n---\n\n### Replit Setup\n\nThis application is pre-configured for Replit with optimized deployment settings.\n\n#### 1. Environment Variables\n\nSet in Replit Secrets (click the lock icon üîí):\n\n**Required:**\n- `OPENAI_API_KEY`: Your OpenAI API key\n\n**Automatically Provided:**\n- `SESSION_SECRET`: Flask session secret (auto-generated by Replit)\n\n**Optional (for production):**\n- `API_KEY`: Enable API authentication\n- `CORS_ALLOWED_ORIGINS`: Comma-separated allowed origins (default: `*`)\n\n#### 2. Workflow Configuration\n\nThe workflow is pre-configured to run:\n```bash\ngunicorn --bind 0.0.0.0:5000 --reuse-port --reload main:app\n```\n\nPort 5000 is used as it's the only non-firewalled port in Replit.\n\n#### 3. Deployment Configuration\n\n- **Target**: VM (always-running, stateful)\n- **Required for**: Browser automation state persistence\n- **Benefits**: MCP subprocess persistence, no browser recreation overhead\n\n#### 4. Browser Installation\n\nPlaywright browsers are pre-installed. If needed:\n```bash\nnpx playwright install chromium\n```\n\n#### 5. Running on Replit\n\nClick the **Run** button or restart the workflow. The application will:\n- Start on port 5000\n- Disable cache for proper hot-reload\n- Show webview preview automatically\n\nAccess via the Replit webview or your Replit domain.\n\n---\n\n## Running the Application\n\n### Development Mode\n\n**All Platforms:**\n```bash\npython main.py\n```\n\nThe server starts on `http://0.0.0.0:5000`\n\nAccess the web interface:\n```\nhttp://localhost:5000\n```\n\n### Production Mode\n\nUse a production WSGI server like gunicorn:\n\n```bash\npip install gunicorn\ngunicorn --workers 4 --bind 0.0.0.0:5000 main:app\n```\n\nFor Replit (pre-configured):\n```bash\ngunicorn --bind 0.0.0.0:5000 --reuse-port --reload main:app\n```\n\n---\n\n## Usage\n\n### Web Interface\n\n1. **Select Engine**: Choose between Hybrid (Recommended), Browser-Use, or Playwright MCP\n2. **Configure Mode**: Toggle headless mode on/off\n3. **Enter Instruction**: Describe your automation task in natural language\n4. **Execute**: Click the Execute button\n5. **View Results**: See step-by-step execution logs in real-time\n\n### Example Instructions\n\n```\nGo to example.com\n```\n\n```\nNavigate to google.com and search for 'browser automation'\n```\n\n```\nOpen github.com/trending and find the top repository\n```\n\n```\nGo to reddit.com and find the top post on the homepage\n```\n\n---\n\n## API Documentation\n\n### Base URL\n```\nhttp://localhost:5000\n```\n\n### Authentication\n\nIf `API_KEY` environment variable is set, include in requests:\n\n**Header (Recommended):**\n```http\nX-API-Key: your-api-key-here\n```\n\n**Query Parameter:**\n```\n?api_key=your-api-key-here\n```\n\n### Endpoints\n\n#### Execute Instruction\n\n```http\nPOST /api/execute\nContent-Type: application/json\nX-API-Key: your-api-key-here\n\n{\n  \"instruction\": \"Go to example.com\",\n  \"engine\": \"hybrid\",\n  \"headless\": false\n}\n```\n\n**Parameters:**\n- `instruction` (string, required): Natural language instruction\n- `engine` (string, optional): `hybrid`, `browser_use`, or `playwright_mcp` (default: `hybrid`)\n- `headless` (boolean, optional): Run headless browser (default: `false`)\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Task completed successfully\",\n  \"steps\": [...],\n  \"iterations\": 3,\n  \"engine\": \"hybrid\",\n  \"engine_metadata\": {\n    \"primary_engine\": \"browser_use\",\n    \"fallback_used\": false\n  }\n}\n```\n\n#### List Available Tools\n\n```http\nGET /api/tools?engine=playwright_mcp\nX-API-Key: your-api-key-here\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"tools\": [...],\n  \"engine\": \"playwright_mcp\"\n}\n```\n\n#### Reset Agent\n\n```http\nPOST /api/reset\nContent-Type: application/json\nX-API-Key: your-api-key-here\n\n{\n  \"engine\": \"hybrid\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Agent reset successfully\",\n  \"engine\": \"hybrid\"\n}\n```\n\n#### Health Check\n\n```http\nGET /health\n```\n\n**Response:**\n```json\n{\n  \"status\": \"healthy\",\n  \"engines\": {\n    \"hybrid\": \"available\",\n    \"browser_use\": \"available\",\n    \"playwright_mcp\": \"available\"\n  },\n  \"message\": \"Hybrid-engine browser automation ready\",\n  \"security\": {\n    \"authentication\": \"enabled\",\n    \"rate_limiting\": \"enabled\"\n  }\n}\n```\n\n### Rate Limiting\n\n- **Default**: 10 requests per minute per IP\n- **Response on limit**:\n```json\n{\n  \"success\": false,\n  \"error\": \"Rate limit exceeded\",\n  \"message\": \"Too many requests. Please try again in 45 seconds.\",\n  \"retry_after\": 45\n}\n```\n\n---\n\n## Security\n\n### Environment Variables\n\n**Never commit secrets to version control**. Always use environment variables:\n\n| Variable | Required | Default | Description |\n|----------|----------|---------|-------------|\n| `OPENAI_API_KEY` | Yes | - | OpenAI API key for AI automation |\n| `API_KEY` | No | - | API key for endpoint authentication |\n| `CORS_ALLOWED_ORIGINS` | No | `*` | Comma-separated allowed origins |\n| `SESSION_SECRET` | Recommended | - | Flask session secret key |\n\n### Security Features\n\n1. **API Authentication**\n   - Optional API key protection for all automation endpoints\n   - Header or query parameter authentication\n   - Disabled by default (development mode)\n\n2. **Rate Limiting**\n   - 10 requests/minute per IP by default\n   - Prevents abuse and cost exhaustion\n   - Automatic cleanup of old request records\n\n3. **Input Validation**\n   - All inputs validated before processing\n   - Instruction: max 5000 characters\n   - Engine type: must be valid option\n   - Headless: must be boolean\n\n4. **CORS Configuration**\n   - Control which domains can access the API\n   - Configure via `CORS_ALLOWED_ORIGINS`\n   - Default: `*` (all origins - development)\n\n5. **Error Sanitization**\n   - Internal error details hidden from users\n   - Prevents information leakage\n   - Generic user-facing messages\n\n6. **Timeout Protection**\n   - 5-minute timeout on all requests\n   - Cross-platform implementation\n   - Automatic resource cleanup\n\n7. **Process Monitoring**\n   - Automatic subprocess recovery\n   - Detects and handles crashed processes\n   - Zombie process cleanup\n\n### Best Practices\n\n1. **Use HTTPS in production**\n   - Configure with reverse proxy (nginx/Apache)\n   - API keys transmitted over HTTP can be intercepted\n\n2. **Rotate credentials regularly**\n   - Change `API_KEY` periodically\n   - Update `OPENAI_API_KEY` if compromised\n\n3. **Monitor API usage**\n   - Track OpenAI API costs: https://platform.openai.com/usage\n   - Monitor authentication failures\n   - Alert on unusual traffic patterns\n\n4. **Production Deployment Checklist**\n   - [ ] Set `API_KEY` to strong random value\n   - [ ] Set `CORS_ALLOWED_ORIGINS` to specific domains\n   - [ ] Set `SESSION_SECRET` to secure random value\n   - [ ] Enable HTTPS with reverse proxy\n   - [ ] Monitor logs for authentication failures\n   - [ ] Set up alerting for rate limit violations\n\n### Reporting Security Issues\n\nIf you discover a security vulnerability:\n1. **Do NOT** open a public issue\n2. Contact the maintainer privately\n3. Include description, reproduction steps, and potential impact\n\n---\n\n## Testing\n\n### Running Tests\n\nRun all tests:\n```bash\npython -m pytest tests/\n```\n\nRun specific test file:\n```bash\npython -m pytest tests/test_engine_orchestrator.py\npython -m pytest tests/test_api_routes.py\n```\n\nRun with coverage:\n```bash\npython -m pytest --cov=app tests/\n```\n\n### Test Structure\n\n- `test_engine_orchestrator.py` - Engine coordination and caching tests\n- `test_api_routes.py` - Flask API endpoint tests\n\n### Writing New Tests\n\n1. Create file starting with `test_`\n2. Import `unittest` or use `pytest`\n3. Add test methods starting with `test_`\n4. Use mocks for external dependencies (browsers, OpenAI API)\n\n---\n\n## Deployment\n\n### Development\n\nThe application runs on Flask's development server, suitable for testing and local development.\n\n### Production\n\n#### Using Gunicorn (Recommended)\n\n```bash\npip install gunicorn\ngunicorn --workers 4 --bind 0.0.0.0:5000 main:app\n```\n\n#### Using Reverse Proxy\n\n**Nginx Configuration Example:**\n```nginx\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:5000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n#### Docker Deployment\n\nCreate `Dockerfile`:\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -r requirements.txt\nRUN npm install\nRUN npx playwright install chromium --with-deps\n\nEXPOSE 5000\n\nCMD [\"gunicorn\", \"--workers\", \"4\", \"--bind\", \"0.0.0.0:5000\", \"main:app\"]\n```\n\nBuild and run:\n```bash\ndocker build -t ai-browser-automation .\ndocker run -p 5000:5000 -e OPENAI_API_KEY=sk-your-key ai-browser-automation\n```\n\n#### Replit Deployment\n\nPre-configured for Replit VM deployment:\n- Always-running, stateful instance\n- MCP subprocess persistence\n- Port 5000 (non-firewalled)\n- Click \"Deploy\" in Replit UI to publish\n\n---\n\n## Configuration\n\n### config/config.ini\n\nApplication-level configuration file (non-sensitive settings):\n\n```ini\n[server]\nhost = 0.0.0.0\nport = 5000\n\n[browser]\nheadless = true\nbrowser = chromium\n\n[openai]\nmodel = gpt-4o-mini\n\n[agent]\nmax_steps = 100\n```\n\n**Note**: Never store API keys in config.ini. Use environment variables.\n\n### Customizing Rate Limits\n\nEdit `app/middleware/security.py`:\n\n```python\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n```\n\n---\n\n## Troubleshooting\n\n### Port Already in Use\n\n**Linux/macOS:**\n```bash\nlsof -ti:5000 | xargs kill -9\n```\n\n**Windows:**\n```powershell\nnetstat -ano | findstr :5000\ntaskkill /PID <PID> /F\n```\n\n### Missing OpenAI API Key\n\nEnsure environment variable is set:\n\n**Check (Linux/macOS):**\n```bash\necho $OPENAI_API_KEY\n```\n\n**Check (Windows PowerShell):**\n```powershell\n$env:OPENAI_API_KEY\n```\n\n### Playwright Installation Issues\n\n**Linux:**\n```bash\nnpx playwright install-deps chromium\nnpx playwright install chromium\n```\n\n**All platforms:**\n```bash\nnpx playwright install chromium\n```\n\n### Browser Crashes\n\n- Ensure sufficient memory (2GB+ recommended)\n- Try headless mode for lower resource usage\n- Check Playwright logs for specific errors\n\n### Cached CSS Not Loading (Windows)\n\nClear browser cache with hard refresh:\n- Chrome/Edge: `Ctrl + Shift + R` or `Ctrl + F5`\n- Firefox: `Ctrl + Shift + R` or `Ctrl + F5`\n- Alternative: Open DevTools (F12) ‚Üí Right-click refresh ‚Üí \"Empty Cache and Hard Reload\"\n\n### Permission Denied Errors (Linux/macOS)\n\n```bash\nchmod +x cli.js\n```\n\n---\n\n## Performance Considerations\n\n### OpenAI API Costs\n\n- Each instruction execution calls OpenAI API multiple times\n- Browser-Use: 1-5 calls per instruction (autonomous)\n- Playwright MCP: 2-10+ calls per instruction (iterative)\n- Hybrid: Uses Browser-Use first, falls back to MCP if needed\n- Monitor usage at: https://platform.openai.com/usage\n\n### Resource Usage\n\n- **Headless mode**: ~200-500MB RAM per browser instance\n- **Headful mode**: ~500MB-1GB RAM per browser instance\n- **Recommended**: 4GB+ total system RAM for optimal performance\n\n---\n\n## Contributing\n\nContributions are welcome! Please:\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Add tests if applicable\n5. Ensure all tests pass\n6. Commit your changes (`git commit -m 'Add amazing feature'`)\n7. Push to the branch (`git push origin feature/amazing-feature`)\n8. Submit a pull request\n\n---\n\n## License\n\nSee LICENSE file for details.\n\n---\n\n## Support\n\nFor issues and questions:\n- Check the Troubleshooting section above\n- Review console output for error messages\n- Verify OpenAI API key is valid and has credits\n- Ensure all dependencies are installed correctly\n- Check the health endpoint: `http://localhost:5000/health`\n\n---\n\n**Built with ‚ù§Ô∏è using Playwright, browser-use, OpenAI GPT-4o-mini, and Flask**\n","size_bytes":22201},"hybrid_engine/engine.py":{"content":"\"\"\"\nHybrid Engine Implementation\nUses Browser-Use (AI-powered) as primary engine with Playwright MCP (tool-based) as fallback\n\"\"\"\nfrom typing import Dict, Any\nimport browser_use_codebase\nimport playwright_mcp_codebase\n\n\nclass HybridEngine:\n    \"\"\"\n    Hybrid browser automation engine\n    \n    Strategy:\n    1. Attempt execution with Browser-Use (AI-powered, autonomous)\n    2. If Browser-Use fails, fallback to Playwright MCP (tool-based, reliable)\n    3. Track and report which engine was actually used\n    \n    This provides the best of both worlds:\n    - Browser-Use's intelligent autonomous behavior for complex tasks\n    - Playwright MCP's reliability and discrete control as safety net\n    \"\"\"\n    \n    def __init__(self, headless: bool = False):\n        \"\"\"\n        Initialize Hybrid Engine\n        \n        Args:\n            headless: Run browser in headless mode\n        \"\"\"\n        self.headless = headless\n        self.browser_use_engine = None\n        self.playwright_client = None\n        self.playwright_agent = None\n    \n    def _ensure_browser_use_engine(self):\n        \"\"\"Lazily create Browser-Use engine\"\"\"\n        if self.browser_use_engine is None:\n            self.browser_use_engine = browser_use_codebase.create_engine(headless=self.headless)\n        return self.browser_use_engine\n    \n    def _ensure_playwright_engine(self):\n        \"\"\"Lazily create Playwright MCP engine\"\"\"\n        if self.playwright_client is None or self.playwright_agent is None:\n            self.playwright_client, self.playwright_agent = playwright_mcp_codebase.create_engine(\n                headless=self.headless\n            )\n        return self.playwright_client, self.playwright_agent\n    \n    def execute_instruction_sync(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute instruction with hybrid approach\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and engine metadata\n        \"\"\"\n        # First attempt: Browser-Use (AI-powered)\n        try:\n            engine = self._ensure_browser_use_engine()\n            result = engine.execute_instruction_sync(instruction)\n            \n            if result.get('success', False):\n                result['engine_used'] = 'browser_use'\n                result['fallback_triggered'] = False\n                result['hybrid_mode'] = True\n                return result\n            else:\n                # Browser-Use returned failure, try fallback\n                browser_use_error = result.get('error', 'Unknown error')\n                return self._fallback_to_playwright(instruction, browser_use_error)\n                \n        except Exception as e:\n            # Browser-Use threw exception, try fallback\n            return self._fallback_to_playwright(instruction, str(e))\n    \n    def _fallback_to_playwright(self, instruction: str, browser_use_error: str) -> Dict[str, Any]:\n        \"\"\"\n        Fallback to Playwright MCP engine\n        \n        Args:\n            instruction: User's natural language instruction\n            browser_use_error: Error message from Browser-Use attempt\n            \n        Returns:\n            Dictionary with execution results and fallback metadata\n        \"\"\"\n        try:\n            client, agent = self._ensure_playwright_engine()\n            \n            # Initialize if needed\n            if not client.initialized:\n                client.initialize()\n            \n            # Execute with Playwright MCP\n            result = agent.execute_instruction(instruction)\n            \n            # Add hybrid metadata\n            result['engine_used'] = 'playwright_mcp'\n            result['fallback_triggered'] = True\n            result['hybrid_mode'] = True\n            result['browser_use_error'] = browser_use_error\n            \n            return result\n            \n        except Exception as e:\n            # Both engines failed\n            return {\n                'success': False,\n                'error': f'Both engines failed. Browser-Use: {browser_use_error}. Playwright MCP: {str(e)}',\n                'engine_used': 'none',\n                'fallback_triggered': True,\n                'hybrid_mode': True,\n                'browser_use_error': browser_use_error,\n                'playwright_error': str(e),\n                'steps': [],\n                'iterations': 0\n            }\n    \n    def reset(self):\n        \"\"\"Reset both engines\"\"\"\n        # Browser-Use doesn't maintain state, so nothing to reset\n        \n        # Reset Playwright agent if it exists\n        if self.playwright_agent is not None:\n            self.playwright_agent.reset_conversation()\n","size_bytes":4698},"browser_use_codebase/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom browser_use_codebase.engine import BrowserUseEngine\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Browser-Use engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        BrowserUseEngine instance\n    \"\"\"\n    return BrowserUseEngine(headless=headless)\n\n\n__all__ = ['BrowserUseEngine', 'create_engine']\n","size_bytes":498},"hybrid_engine/__init__.py":{"content":"\"\"\"\nHybrid Engine\nIntelligent browser automation that uses Browser-Use by default with Playwright MCP fallback\n\"\"\"\nfrom hybrid_engine.engine import HybridEngine\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Hybrid engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        HybridEngine instance\n    \"\"\"\n    return HybridEngine(headless=headless)\n\n\n__all__ = ['HybridEngine', 'create_engine']\n","size_bytes":481},"PLEASE_READ_WINDOWS.md":{"content":"# ‚ö†Ô∏è IMPORTANT: Windows Setup Required\n\n## YOU ARE SEEING THIS ERROR ON WINDOWS\n\nThe error you're seeing:\n```\n‚ùå Error: Both engines failed. Browser-Use: OpenAI API key must be set...\n```\n\nThis means **you haven't set up the .env file on your Windows machine yet!**\n\n## üîë Key Point\n\n**The API key you configured in Replit Secrets only works IN REPLIT!**\n\nYour **Windows computer** needs its OWN `.env` file with your API key.\n\n## ‚úÖ How to Fix This (Step by Step)\n\n### 1. Create a `.env` file on your Windows computer\n\nIn the **same folder** where you have `main.py`, create a file named `.env` (not `.env.txt`!)\n\n**Using Notepad:**\n1. Open Notepad\n2. Paste this content:\n   ```\n   OPENAI_API_KEY=sk-your-actual-api-key-here\n   SESSION_SECRET=my-secret-key-123\n   CORS_ALLOWED_ORIGINS=*\n   ```\n3. Replace `sk-your-actual-api-key-here` with your real OpenAI API key\n4. Click \"File\" ‚Üí \"Save As\"\n5. Change \"Save as type\" to **\"All Files (*.*)\"**\n6. Name it: `.env` (with the dot at the start!)\n7. Save it in your project folder (where `main.py` is)\n\n**Using Command Prompt:**\n```cmd\ncopy .env.example .env\nnotepad .env\n```\nThen edit it to add your actual API key.\n\n### 2. Verify your setup\n\nRun this test script to check if everything is configured correctly:\n\n```bash\npython test_engines.py\n```\n\n**If it passes:** ‚úÖ You're all set! Run `python main.py`\n\n**If it fails:** ‚ùå The script will tell you exactly what's wrong\n\n### 3. Run the application\n\n**OPTION A - Easy Way (Recommended for Windows):**\n```cmd\nrun_windows.bat\n```\nThis batch file ensures console logs appear properly and checks for the .env file.\n\n**OPTION B - Manual Way:**\n```bash\npython main.py\n```\n\n**üí° IMPORTANT:** Keep the console window open while using the app! \nAll automation logs will appear there when you click \"Execute\".\n\n## üÜò Still Not Working?\n\nRun these diagnostic commands and send me the output:\n\n```bash\n# Check if .env file exists\ndir .env\n\n# Check what's in it (will show your key, so be careful sharing!)\ntype .env\n\n# Run the environment checker\npython check_env.py\n\n# Test the engines\npython test_engines.py\n```\n\n## üí° Common Mistakes\n\n1. **File named `.env.txt` instead of `.env`**\n   - Windows hides extensions by default\n   - Check: File Explorer ‚Üí View ‚Üí File name extensions\n\n2. **No .env file at all on Windows**\n   - The Replit environment variables don't transfer to your PC!\n   - You MUST create a local .env file\n\n3. **Wrong API key**\n   - Make sure you're using YOUR OpenAI API key\n   - It should start with `sk-` or `sk-proj-`\n\n4. **File in wrong location**\n   - The `.env` file must be in the same folder as `main.py`\n   - Check with: `dir` command in your project folder\n\n5. **No console logs appearing**\n   - Use `run_windows.bat` instead of running `python main.py` directly\n   - This ensures unbuffered output so logs appear immediately\n   - Keep the console window visible while using the web app\n\n## üìÇ Your Project Folder Should Look Like This\n\n```\nyour-project-folder/\n‚îú‚îÄ‚îÄ .env                    ‚Üê YOU NEED THIS FILE!\n‚îú‚îÄ‚îÄ .env.example           ‚Üê Template to copy from\n‚îú‚îÄ‚îÄ main.py                ‚Üê Main app file\n‚îú‚îÄ‚îÄ run_windows.bat        ‚Üê Easy launcher for Windows (ensures logs work)\n‚îú‚îÄ‚îÄ check_env.py           ‚Üê Diagnostic script\n‚îú‚îÄ‚îÄ test_engines.py        ‚Üê Engine test script\n‚îú‚îÄ‚îÄ app/\n‚îú‚îÄ‚îÄ browser_use_codebase/\n‚îî‚îÄ‚îÄ ... (other files)\n```\n\n## üîç Troubleshooting: No Console Logs?\n\nIf you click \"Execute\" but don't see any logs in your console:\n\n1. **Make sure you're using the batch file:**\n   ```cmd\n   run_windows.bat\n   ```\n   (Not `python main.py` directly)\n\n2. **Keep the console window visible** - logs only appear in the console where you launched the app, not in the web browser\n\n3. **The logs will show:**\n   - When you start the app\n   - Each time you click \"Execute\"\n   - Every step the AI takes\n   - Any errors that occur\n\n4. **Example of what you should see:**\n   ```\n   ================================================================================\n   üì® NEW AUTOMATION REQUEST\n   üìù Instruction: go to google.com\n   üîß Engine: hybrid\n   ================================================================================\n   üöÄ Starting automation execution...\n   ü§ñ Initializing Browser-Use Agent\n   ‚ñ∂Ô∏è  Starting agent execution...\n   ```\n","size_bytes":4374},"playwright_mcp_codebase/config/__init__.py":{"content":"\"\"\"\nPlaywright MCP Configuration Module\n\"\"\"\n","size_bytes":44},"app/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n}\n\n/* Header */\nheader {\n    text-align: center;\n    color: white;\n    margin-bottom: 30px;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 10px;\n}\n\nheader .subtitle {\n    font-size: 1.1rem;\n    opacity: 0.95;\n    font-weight: 400;\n}\n\n/* Main Content - Two Column Layout */\n.main-content {\n    display: grid;\n    grid-template-columns: 450px 1fr;\n    gap: 25px;\n    margin-bottom: 20px;\n}\n\n/* Left Panel */\n.left-panel {\n    display: flex;\n    flex-direction: column;\n    gap: 20px;\n}\n\n.config-section,\n.instruction-section,\n.examples-section {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n}\n\n.config-section h3,\n.instruction-section h3,\n.examples-section h4 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    margin-bottom: 16px;\n    color: #667eea;\n}\n\n.config-group {\n    margin-bottom: 20px;\n}\n\n.config-group:last-child {\n    margin-bottom: 0;\n}\n\n.config-group label {\n    display: block;\n    font-weight: 600;\n    margin-bottom: 8px;\n    color: #333;\n    font-size: 0.95rem;\n}\n\n.config-select {\n    width: 100%;\n    padding: 12px 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    font-size: 1rem;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.config-select:hover {\n    border-color: #667eea;\n}\n\n.config-select:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n.config-help {\n    margin-top: 6px;\n    font-size: 0.85rem;\n    color: #666;\n    line-height: 1.4;\n}\n\n/* Toggle Switch */\n.toggle-label {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    margin-bottom: 0;\n}\n\n.toggle-label input[type=\"checkbox\"] {\n    display: none;\n}\n\n.toggle-slider {\n    position: relative;\n    width: 52px;\n    height: 28px;\n    background: #e0e0e0;\n    border-radius: 34px;\n    margin-right: 12px;\n    transition: background 0.3s ease;\n}\n\n.toggle-slider::before {\n    content: '';\n    position: absolute;\n    width: 22px;\n    height: 22px;\n    left: 3px;\n    top: 3px;\n    background: white;\n    border-radius: 50%;\n    transition: transform 0.3s ease;\n}\n\n.toggle-label input:checked + .toggle-slider {\n    background: #667eea;\n}\n\n.toggle-label input:checked + .toggle-slider::before {\n    transform: translateX(24px);\n}\n\n.toggle-text {\n    font-weight: 600;\n    color: #333;\n}\n\n/* Instruction Input */\n#instruction-input {\n    width: 100%;\n    padding: 16px;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    transition: border-color 0.3s ease;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n#instruction-input::placeholder {\n    color: #999;\n}\n\n/* Buttons */\n.button-group {\n    display: flex;\n    gap: 12px;\n    margin-top: 16px;\n}\n\n.btn {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n    padding: 14px 24px;\n    border: none;\n    border-radius: 10px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.btn-icon {\n    font-size: 1.1rem;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #f3f4f6;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #e5e7eb;\n}\n\n.spinner {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-top-color: white;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n/* Examples */\n.example-buttons {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.example-btn {\n    padding: 12px 16px;\n    background: #f8f9fa;\n    border: 2px solid #e9ecef;\n    border-radius: 8px;\n    font-size: 0.9rem;\n    cursor: pointer;\n    text-align: left;\n    transition: all 0.2s ease;\n    font-weight: 500;\n    color: #333;\n}\n\n.example-btn:hover {\n    background: #667eea;\n    border-color: #667eea;\n    color: white;\n    transform: translateX(4px);\n}\n\n/* Right Panel - Results */\n.right-panel {\n    background: white;\n    border-radius: 16px;\n    padding: 24px;\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n    display: flex;\n    flex-direction: column;\n}\n\n.results-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 16px;\n}\n\n.results-header h3 {\n    font-size: 1.1rem;\n    font-weight: 600;\n    color: #667eea;\n}\n\n.status-badge {\n    padding: 6px 14px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.status-badge.running {\n    background: #fef3c7;\n    color: #92400e;\n}\n\n.status-badge.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.status-badge.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.status {\n    padding: 14px 18px;\n    border-radius: 10px;\n    margin-bottom: 16px;\n    font-weight: 500;\n    display: none;\n}\n\n.status.success {\n    background: #d1fae5;\n    color: #065f46;\n    border-left: 4px solid #10b981;\n    display: block;\n}\n\n.status.error {\n    background: #fee2e2;\n    color: #991b1b;\n    border-left: 4px solid #ef4444;\n    display: block;\n}\n\n.status.processing {\n    background: #fef3c7;\n    color: #92400e;\n    border-left: 4px solid #f59e0b;\n    display: block;\n}\n\n/* Results Container */\n.results-container {\n    flex: 1;\n    overflow-y: auto;\n    max-height: calc(100vh - 400px);\n}\n\n.empty-state {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    padding: 60px 20px;\n    color: #9ca3af;\n}\n\n.empty-icon {\n    font-size: 4rem;\n    margin-bottom: 16px;\n    opacity: 0.5;\n}\n\n.empty-state p {\n    font-size: 1rem;\n}\n\n/* Step Display */\n.step {\n    background: #f8f9fa;\n    border-left: 4px solid #667eea;\n    border-radius: 8px;\n    padding: 16px;\n    margin-bottom: 14px;\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    font-weight: 700;\n    color: #667eea;\n    font-size: 0.95rem;\n}\n\n.step-status {\n    padding: 4px 12px;\n    border-radius: 12px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d1fae5;\n    color: #065f46;\n}\n\n.step-status.error {\n    background: #fee2e2;\n    color: #991b1b;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #333;\n    margin-bottom: 8px;\n    font-size: 0.95rem;\n}\n\n.step-args {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    font-family: 'Courier New', monospace;\n    font-size: 0.85rem;\n    color: #555;\n    white-space: pre-wrap;\n    word-break: break-all;\n}\n\n.step-error {\n    color: #991b1b;\n    margin-top: 10px;\n    font-weight: 500;\n}\n\ndetails {\n    margin-top: 10px;\n}\n\nsummary {\n    cursor: pointer;\n    color: #667eea;\n    font-weight: 600;\n    font-size: 0.9rem;\n}\n\ndetails pre {\n    background: white;\n    padding: 12px;\n    border-radius: 6px;\n    margin-top: 8px;\n    font-size: 0.85rem;\n    overflow: auto;\n    max-height: 300px;\n}\n\n/* Footer */\nfooter {\n    background: rgba(255, 255, 255, 0.95);\n    border-radius: 12px;\n    padding: 16px 24px;\n    text-align: center;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.footer-content p {\n    color: #666;\n    margin-bottom: 8px;\n    font-size: 0.9rem;\n}\n\n.footer-links {\n    display: flex;\n    justify-content: center;\n    gap: 24px;\n    font-size: 0.9rem;\n    color: #666;\n}\n\n.footer-links strong {\n    color: #667eea;\n}\n\n/* Responsive */\n@media (max-width: 1024px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n    \n    .left-panel {\n        order: 1;\n    }\n    \n    .right-panel {\n        order: 2;\n    }\n}\n","size_bytes":8389},"docs/POPUP_HANDLING.md":{"content":"# Popup Window Handling\n\n## Overview\n\nThe browser-use engine has been enhanced to automatically handle popup windows and new tabs that open during automation.\n\n## How It Works\n\nWhen a button or link opens a new window (like \"Sign in with Google\", \"Continue with Facebook\", etc.), the browser-use AI agent:\n\n1. **Detects the new window** - Playwright automatically tracks new windows/tabs\n2. **Switches context automatically** - The AI agent continues working in the new window\n3. **Completes the task seamlessly** - No manual window switching required\n\n## Enhanced System Instructions\n\nThe AI agent now receives specific instructions about popup handling:\n\n- When a popup opens, it automatically switches to work in the new window\n- All subsequent actions are performed in the active window\n- Window switches happen transparently without user intervention\n\n## Examples\n\n### LinkedIn Sign-in with Google\n\n**Instruction:**\n```\nOpen https://www.linkedin.com/, click \"Join now\", click \"Continue with Google\", enter email \"test@example.com\", click next\n```\n\n**What happens:**\n1. Opens LinkedIn\n2. Clicks \"Join now\"\n3. Clicks \"Continue with Google\" ‚Üí **New popup window opens**\n4. **Automatically switches to Google sign-in window**\n5. Enters email in the popup\n6. Clicks next\n\n### Multi-Window Workflow\n\nThe agent can handle complex multi-window scenarios:\n- OAuth flows (Google, Facebook, etc.)\n- Payment gateways\n- External verification pages\n- Pop-up forms\n\n## Configuration\n\nThe popup handling is enabled by default in browser-use engine with these optimizations:\n\n- **LLM Timeout**: 180 seconds (increased from 60s)\n- **Max Steps**: 25 steps (optimized for performance)\n- **System Prompt**: Enhanced with popup handling instructions\n\n## Best Practices\n\n### 1. Be Explicit in Instructions\n‚úÖ **Good:** \"Click 'Sign in with Google', enter email 'test@example.com' in the popup, click next\"\n\n‚ùå **Avoid:** \"Sign in with Google\" (too vague)\n\n### 2. Break Complex Tasks into Steps\nFor very complex workflows, break them into smaller tasks:\n\n**Step 1:**\n```\nNavigate to site.com and click \"Sign in with Google\"\n```\n\n**Step 2:**\n```\nEnter email \"test@example.com\" and click next\n```\n\n### 3. Use Headless Mode for Faster Performance\nHeadless mode (checkbox in UI) runs faster and is more reliable for popup handling.\n\n## Troubleshooting\n\n### Popup Not Detected\nIf the agent doesn't switch to a popup:\n\n1. **Check if it's actually a popup** - Some sites use embedded forms instead\n2. **Use explicit instructions** - Tell the agent to work in the new window\n3. **Try Playwright MCP engine** - More granular control for complex scenarios\n\n### Timeout Issues\nIf actions in popups timeout:\n\n1. **Enable headless mode** - Faster execution\n2. **Simplify the instruction** - Break into smaller steps\n3. **Check network speed** - OpenAI API calls need good connectivity\n\n## Technical Details\n\n### Browser-Use Integration\n- Built on Playwright (version 1.52+)\n- Uses AI-powered element detection\n- Automatically handles browser contexts\n\n### Window Switching Logic\n- Browser-use tracks all open pages/windows\n- AI agent automatically works in the most recently opened window\n- Falls back to main window when popups close\n\n## Limitations\n\n1. **Nested Popups**: Multiple levels of popups may require explicit instructions\n2. **Browser Security**: Some sites block automation in popups\n3. **Timing**: Very fast popup opens/closes might be missed\n\n## Future Enhancements\n\nPlanned improvements:\n- [ ] Explicit popup detection logging\n- [ ] Configurable popup timeout\n- [ ] Popup window priority rules\n- [ ] Multi-popup orchestration\n","size_bytes":3614},"node/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"playwright_mcp_codebase/client/__init__.py":{"content":"\"\"\"\nPlaywright MCP Client Module\n\"\"\"\nfrom playwright_mcp_codebase.client.stdio_client import MCPStdioClient\n\n__all__ = ['MCPStdioClient']\n","size_bytes":138},"tests/__init__.py":{"content":"\"\"\"\nUnit tests for AI Browser Automation\n\"\"\"\n","size_bytes":45},"tests/test_api_routes.py":{"content":"\"\"\"\nTests for API Routes\n\"\"\"\nimport unittest\nimport json\nfrom unittest.mock import Mock, patch\nfrom app import create_app\n\n\nclass TestAPIRoutes(unittest.TestCase):\n    \"\"\"Test cases for API routes\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.app = create_app()\n        self.app.config['TESTING'] = True\n        self.client = self.app.test_client()\n    \n    def test_index_route(self):\n        \"\"\"Test that index route returns HTML\"\"\"\n        response = self.client.get('/')\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b'AI Browser Automation', response.data)\n    \n    def test_health_check(self):\n        \"\"\"Test health check endpoint\"\"\"\n        response = self.client.get('/health')\n        self.assertEqual(response.status_code, 200)\n        \n        data = json.loads(response.data)\n        self.assertEqual(data['status'], 'healthy')\n        self.assertIn('engines', data)\n    \n    def test_execute_empty_instruction(self):\n        \"\"\"Test that empty instruction returns 400 error\"\"\"\n        response = self.client.post('/api/execute',\n                                   json={'instruction': '', 'engine': 'hybrid'})\n        self.assertEqual(response.status_code, 400)\n        \n        data = json.loads(response.data)\n        self.assertFalse(data['success'])\n        self.assertIn('provide an instruction', data['error'])\n    \n    def test_execute_missing_instruction(self):\n        \"\"\"Test that missing instruction key returns 400 error\"\"\"\n        response = self.client.post('/api/execute',\n                                   json={'engine': 'hybrid'})\n        self.assertEqual(response.status_code, 400)\n        \n        data = json.loads(response.data)\n        self.assertFalse(data['success'])\n    \n    @patch('app.services.engine_orchestrator.EngineOrchestrator.execute_instruction')\n    def test_execute_success(self, mock_execute):\n        \"\"\"Test successful execution\"\"\"\n        mock_execute.return_value = {\n            'success': True,\n            'message': 'Task completed',\n            'iterations': 3,\n            'steps': []\n        }\n        \n        response = self.client.post('/api/execute',\n                                   json={\n                                       'instruction': 'Go to google.com',\n                                       'engine': 'hybrid',\n                                       'headless': True\n                                   })\n        \n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data)\n        self.assertTrue(data['success'])\n        self.assertEqual(data['iterations'], 3)\n    \n    def test_reset_agent(self):\n        \"\"\"Test reset agent endpoint\"\"\"\n        response = self.client.post('/api/reset',\n                                   json={'engine': 'hybrid'})\n        \n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data)\n        self.assertTrue(data['success'])\n        self.assertIn('reset successfully', data['message'])\n\n\nif __name__ == '__main__':\n    unittest.main()\n","size_bytes":3082},"replit.md":{"content":"# AI Browser Automation\n\n## Overview\n\nAI Browser Automation is a Flask-based web application that provides intelligent browser automation through natural language instructions. The system implements a hybrid approach that combines AI-powered autonomous automation with reliable tool-based control, offering automatic fallback mechanisms for maximum reliability.\n\nThe application exposes a RESTful API and web interface that allows users to execute browser automation tasks using three distinct engines:\n- **Hybrid Engine** (recommended): Attempts AI-powered Browser-Use first, automatically falls back to Playwright MCP if needed\n- **Browser-Use Engine**: Fully autonomous AI agent using LLM reasoning for complex workflows\n- **Playwright MCP Engine**: Deterministic tool-based automation using Microsoft's Model Context Protocol\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Application Framework\n- **Web Framework**: Flask with factory pattern (`create_app()`)\n- **Frontend**: Server-side rendered HTML with vanilla JavaScript\n- **API Design**: RESTful endpoints with JSON request/response format\n- **Multi-threading**: Flask's default threaded mode with per-request resource isolation\n\n### Core Components\n\n#### Engine Orchestration Layer\nThe `EngineOrchestrator` serves as the central coordinator:\n- Manages three distinct automation engines (Hybrid, Browser-Use, Playwright MCP)\n- Implements per-headless-mode caching for engine instances\n- Delegates execution based on engine selection\n- Rationale: Centralized management ensures consistent engine lifecycle and prevents resource leaks\n\n#### Automation Engines\n\n**1. Hybrid Engine** (`hybrid_engine/`)\n- Strategy: Primary-fallback pattern\n- Uses Browser-Use as primary, Playwright MCP as automatic fallback\n- Returns metadata indicating which engine succeeded\n- Design rationale: Combines AI intelligence with tool-based reliability for production use\n\n**2. Browser-Use Engine** (`browser_use_codebase/`)\n- AI-powered automation using the `browser-use` library\n- Leverages OpenAI LLMs for autonomous reasoning\n- Thread safety: Creates fresh browser instance per request with isolated event loops\n- No instance caching to prevent asyncio loop affinity issues\n- Design rationale: Maximizes autonomy for complex multi-step workflows\n\n**3. Playwright MCP Engine** (`playwright_mcp_codebase/`)\n- Tool-based automation using Microsoft's Playwright MCP server\n- Client-server architecture over STDIO transport\n- OpenAI agent converts natural language to discrete tool calls\n- Design rationale: Provides deterministic control for reliability\n\n#### Security & Middleware Layer\n- **Authentication**: API key validation via headers\n- **Rate Limiting**: In-memory rate limiter (10 requests/60 seconds per client)\n- **Input Validation**: Instruction sanitization and engine type validation\n- **Error Handling**: Sanitized error messages to prevent information leakage\n- Design rationale: Multi-layer security without external dependencies\n\n#### Timeout Management\n- Cross-platform timeout utility using ThreadPoolExecutor\n- Graceful timeout handling that returns promptly to HTTP clients\n- Note: Background threads may continue but don't block responses\n- Design rationale: Prevents hung requests across Windows/Linux/macOS\n\n### Request Flow\n\n1. Client submits instruction via web UI or API endpoint\n2. Security middleware validates API key and applies rate limiting\n3. Request validation checks instruction and engine type\n4. EngineOrchestrator retrieves/creates appropriate engine instance\n5. Engine executes instruction with timeout protection\n6. Results formatted and returned as JSON response\n7. Frontend updates UI with execution results and metadata\n\n### Thread Safety Model\n\n**Browser-Use Engine**: \n- Creates new event loop per request\n- No shared state between requests\n- Browser instances disposed after execution\n- Trade-off: Slower startup but complete isolation\n\n**Playwright MCP Engine**:\n- Subprocess-based MCP server\n- STDIO communication via JSON-RPC\n- Thread-safe client with request ID tracking\n- Trade-off: Subprocess overhead but predictable lifecycle\n\n**Hybrid Engine**:\n- Lazy initialization of both engines\n- Falls back automatically on Browser-Use failure\n- Tracks which engine succeeded for transparency\n\n### Configuration Management\n- Environment variables for secrets (OPENAI_API_KEY, SESSION_SECRET)\n- INI files for non-sensitive settings (config/config.ini)\n- Runtime overrides via API parameters (headless mode, browser choice)\n- Design rationale: Separates secrets from configuration, supports flexibility\n\n### Error Handling Strategy\n- Graceful degradation: Hybrid engine falls back automatically\n- Timeout protection: All engine executions wrapped in timeout utility\n- Error sanitization: Production errors don't leak internal details\n- Logging: Comprehensive logging at INFO level for debugging\n\n## External Dependencies\n\n### AI & Language Models\n- **OpenAI API**: LLM for natural language understanding and reasoning\n  - Used by both Browser-Use and Playwright MCP agents\n  - Configured via OPENAI_API_KEY environment variable\n  - Default model: gpt-4o-mini (configurable)\n\n### Browser Automation Libraries\n- **browser-use** (>=0.5.9): AI-powered autonomous browser automation\n- **Playwright**: Browser automation framework (via @playwright/mcp Node package)\n- **playwright-core**: Core Playwright functionality\n\n### Web Framework & HTTP\n- **Flask** (>=3.1.2): Python web framework\n- **flask-cors** (>=6.0.1): Cross-origin resource sharing\n- **flask-sqlalchemy** (>=3.1.1): Database ORM (prepared for future persistence)\n- **gunicorn** (>=23.0.0): WSGI HTTP server for production\n\n### Node.js Integration\n- **@playwright/mcp** (v0.0.43): Playwright Model Context Protocol server\n- **@modelcontextprotocol/sdk**: MCP SDK for tool-based automation\n- Communication: Subprocess with STDIO transport using JSON-RPC\n\n### Supporting Libraries\n- **langchain-openai** (>=1.0.1): LangChain OpenAI integration\n- **python-dotenv** (>=1.1.1): Environment variable management\n- **psycopg2-binary** (>=2.9.11): PostgreSQL adapter (for future database features)\n- **requests** (>=2.32.5): HTTP library\n- **sseclient-py** (>=1.8.0): Server-sent events client\n\n### Testing\n- **pytest** (>=8.4.2): Testing framework\n- **pytest-cov** (>=7.0.0): Code coverage reporting\n\n### Security Considerations\n- API keys stored exclusively in environment variables\n- No secrets in configuration files or code\n- Input sanitization on all user-provided data\n- Rate limiting to prevent abuse\n- CORS configured with explicit allowed origins","size_bytes":6647},"playwright_mcp_codebase/client/stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        args = [\"node\", \"node/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        pass\n                except UnicodeDecodeError:\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8234},"app/__init__.py":{"content":"\"\"\"\nFlask Application Factory\n\"\"\"\nimport os\nimport logging\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.routes.api import create_api_routes\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\ndef create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \n    Returns:\n        Configured Flask app instance\n    \"\"\"\n    # Configure detailed logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s [%(name)s] %(levelname)s: %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S',\n        handlers=[\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n    \n    # Set browser-use and agent loggers to INFO to see detailed steps\n    logging.getLogger('browser_use').setLevel(logging.INFO)\n    logging.getLogger('Agent').setLevel(logging.INFO)\n    logging.getLogger('service').setLevel(logging.INFO)\n    logging.getLogger('tools').setLevel(logging.INFO)\n    logging.getLogger('BrowserSession').setLevel(logging.INFO)\n    \n    logger = logging.getLogger(__name__)\n    logger.info(\"üöÄ Starting AI Browser Automation application\")\n    \n    app = Flask(__name__)\n    app.config['SECRET_KEY'] = os.environ.get(\"SESSION_SECRET\")\n    \n    allowed_origins = os.environ.get('CORS_ALLOWED_ORIGINS', '*').split(',')\n    CORS(app, \n         resources={r\"/api/*\": {\"origins\": allowed_origins}},\n         methods=[\"GET\", \"POST\", \"OPTIONS\"],\n         allow_headers=[\"Content-Type\", \"X-API-Key\"],\n         supports_credentials=True)\n    \n    logger.info(f\"üîí CORS configured with origins: {allowed_origins}\")\n    logger.info(\"üì¶ Initializing Engine Orchestrator\")\n    orchestrator = EngineOrchestrator()\n    \n    logger.info(\"üîó Registering API routes\")\n    api_routes = create_api_routes(orchestrator)\n    app.register_blueprint(api_routes)\n    \n    # Add cache control headers to prevent browser caching issues\n    @app.after_request\n    def add_cache_control_headers(response):\n        \"\"\"Add Cache-Control headers to all responses to prevent caching\"\"\"\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, public, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        return response\n    \n    logger.info(\"‚úÖ Application initialization complete\")\n    \n    return app\n","size_bytes":2572},"node/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"app/middleware/__init__.py":{"content":"\"\"\"Middleware package\"\"\"\n","size_bytes":25},"check_env.py":{"content":"\"\"\"\nEnvironment Check Script\nRun this script to verify your .env file is set up correctly\n\"\"\"\nimport os\nfrom dotenv import load_dotenv, dotenv_values\n\nprint(\"=\" * 60)\nprint(\"Environment Configuration Check\")\nprint(\"=\" * 60)\n\n# Check if .env file exists\nif os.path.exists('.env'):\n    print(\"‚úÖ .env file found\")\nelse:\n    print(\"‚ùå .env file NOT found\")\n    print(\"   Please create a .env file in the project root directory\")\n    print(\"   You can copy .env.example and rename it to .env\")\n    exit(1)\n\n# Check what's in the .env file (before loading into environment)\nprint(\"\\nüìÑ Checking .env file contents...\")\nenv_values = dotenv_values('.env')\nif 'OPENAI_API_KEY' in env_values:\n    env_key = env_values['OPENAI_API_KEY']\n    masked_env = env_key[:10] + \"...\" + env_key[-4:] if len(env_key) > 14 else \"***\"\n    print(f\"   .env file contains OPENAI_API_KEY: {masked_env}\")\nelse:\n    print(\"   ‚ö†Ô∏è  .env file does NOT contain OPENAI_API_KEY\")\n\n# Check if there's a system environment variable (before loading .env)\nprint(\"\\nüîç Checking system environment variables...\")\nsystem_key = os.environ.get('OPENAI_API_KEY')\nif system_key:\n    masked_sys = system_key[:10] + \"...\" + system_key[-4:] if len(system_key) > 14 else \"***\"\n    print(f\"   ‚ö†Ô∏è  WARNING: System has OPENAI_API_KEY set: {masked_sys}\")\n    print(\"   This might conflict with your .env file!\")\n    print(\"\\n   To remove the system environment variable:\")\n    print(\"   - Close all Command Prompt/PowerShell windows\")\n    print(\"   - Open a fresh terminal and run this script again\")\n    print(\"   - Or in current session, run: set OPENAI_API_KEY=\")\nelse:\n    print(\"   ‚úÖ No system OPENAI_API_KEY found (good!)\")\n\n# Load .env file with override\nprint(\"\\nüîÑ Loading .env file...\")\nload_dotenv(override=True)\n\n# Check for OPENAI_API_KEY after loading\nprint(\"\\n‚úÖ Final environment check:\")\napi_key = os.environ.get('OPENAI_API_KEY')\nif api_key:\n    # Mask the key for security\n    masked_key = api_key[:10] + \"...\" + api_key[-4:] if len(api_key) > 14 else \"***\"\n    print(f\"   OPENAI_API_KEY is set: {masked_key}\")\n    \n    # Check if it matches the .env file\n    if 'OPENAI_API_KEY' in env_values and api_key == env_values['OPENAI_API_KEY']:\n        print(\"   ‚úÖ Matches .env file - Perfect!\")\n    elif system_key and api_key == env_values['OPENAI_API_KEY']:\n        print(\"   ‚úÖ Using .env file (system variable was overridden)\")\n    else:\n        print(\"   ‚ö†Ô∏è  Using system environment variable\")\nelse:\n    print(\"   ‚ùå OPENAI_API_KEY is NOT set\")\n    print(\"   Please add OPENAI_API_KEY=your-key-here to your .env file\")\n    exit(1)\n\n# Check for SESSION_SECRET\nsession_secret = os.environ.get('SESSION_SECRET')\nif session_secret:\n    print(f\"   ‚úÖ SESSION_SECRET is set\")\nelse:\n    print(\"   ‚ö†Ô∏è  SESSION_SECRET is not set (optional but recommended)\")\n\nprint(\"=\" * 60)\nprint(\"‚úÖ All required environment variables are configured!\")\nprint(\"You can now run: python main.py\")\nprint(\"=\" * 60)\n","size_bytes":2985},"app/routes/__init__.py":{"content":"\"\"\"\nFlask Routes Module\n\"\"\"\nfrom app.routes.api import create_api_routes\n\n__all__ = ['create_api_routes']\n","size_bytes":106},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\nfrom app import create_app\n\n# Force unbuffered output for better logging\nif hasattr(sys.stdout, 'reconfigure'):\n    sys.stdout.reconfigure(line_buffering=True)  # type: ignore\nos.environ['PYTHONUNBUFFERED'] = '1'\n\n# Load .env file and override any existing environment variables\nload_dotenv(override=True)\n\napp = create_app()\n\nif __name__ == '__main__':\n    # IMPORTANT: Do not hardcode API keys in source files. Read from environment.\n    api_key = os.environ.get(\"OPENAI_API_KEY\")\n    \n    print(\"=\"*80)\n    print(\"üöÄ AI BROWSER AUTOMATION - STARTING UP\")\n    print(\"=\"*80)\n    \n    if not api_key:\n        print(\"\\n‚ö†Ô∏è  WARNING: OPENAI_API_KEY environment variable is not set.\")\n        print(\"   The application will start but AI features will not work.\")\n        print(\"   Please set the OPENAI_API_KEY in your Replit Secrets.\\n\")\n    else:\n        print(f\"‚úÖ API Key found: {api_key[:20]}...{api_key[-4:]}\")\n    \n    sys.stdout.flush()\n\n    print(\"\\nüåê Starting Flask web server on port 5000...\")\n    print(\"=\"*80)\n    print(\"\\nüí° TIP: Keep this console window open to see automation logs\\n\")\n    sys.stdout.flush()\n\n    # Start the web app with debug mode for better console output\n    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)\n","size_bytes":1393},"node/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"playwright_mcp_codebase/__init__.py":{"content":"\"\"\"\nPlaywright MCP Codebase\nTool-based browser automation using Playwright's Model Context Protocol\n\"\"\"\nfrom playwright_mcp_codebase.client.stdio_client import MCPStdioClient\nfrom playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Playwright MCP engine instance\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        Tuple of (mcp_client, browser_agent)\n    \"\"\"\n    mcp_client = MCPStdioClient(headless=headless)\n    browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n__all__ = ['MCPStdioClient', 'BrowserAgent', 'create_engine']\n","size_bytes":700},"app/utils/__init__.py":{"content":"\"\"\"Utilities package\"\"\"\n","size_bytes":24},"playwright_mcp_codebase/agent/__init__.py":{"content":"\"\"\"\nPlaywright MCP Agent Module\n\"\"\"\nfrom playwright_mcp_codebase.agent.conversation_agent import BrowserAgent\n\n__all__ = ['BrowserAgent']\n","size_bytes":138},"WINDOWS_SETUP.md":{"content":"# Windows Setup Guide\n\n## Quick Start for Windows\n\n### Step 1: Create a `.env` file\n\n**IMPORTANT**: The file MUST be named `.env` exactly (no `.txt` extension!)\n\n1. Open Notepad or any text editor\n2. Copy this template and paste it:\n   ```\n   OPENAI_API_KEY=your-openai-api-key-here\n   SESSION_SECRET=my-secret-key-123\n   CORS_ALLOWED_ORIGINS=*\n   ```\n3. Replace `your-openai-api-key-here` with your actual OpenAI API key\n4. Click \"File\" ‚Üí \"Save As\"\n5. **Important**: In the \"Save as type\" dropdown, select \"All Files (*.*)\"\n6. Name the file exactly: `.env` (with the dot at the beginning)\n7. Save it in the project root directory (same folder as `main.py`)\n\n**Common Mistake**: Windows often hides file extensions. If your file shows as `.env.txt`, you need to:\n- Open File Explorer\n- Click \"View\" ‚Üí Check \"File name extensions\"\n- Rename the file to remove the `.txt` part\n\n### Step 2: Verify Your Setup\n\n**Run this command to check if your .env file is configured correctly:**\n\n```bash\npython check_env.py\n```\n\nIf you see all green checkmarks (‚úÖ), you're good to go!\n\nIf you see red X marks (‚ùå), follow the error messages to fix the issues.\n\n### Step 3: Install Python Dependencies\n\nOpen Command Prompt or PowerShell in the project directory and run:\n\n```bash\npip install -r requirements.txt\n```\n\n### Step 4: Run the Application\n\n```bash\npython main.py\n```\n\nThe application will:\n- Load your `.env` file automatically\n- Start the web server on http://localhost:5782\n- Open your browser to that address\n\n## Troubleshooting\n\n### Error: \"OPENAI_API_KEY environment variable is not set\"\n\n**Solution**: Make sure you created the `.env` file (not `.env.txt`) in the project root directory with your actual API key.\n\n### Error: \"No module named 'dotenv'\"\n\n**Solution**: Install python-dotenv:\n```bash\npip install python-dotenv\n```\n\n### Browser doesn't open automatically\n\n**Solution**: Manually open your browser and go to:\n```\nhttp://localhost:5782\n```\n\n## Getting Your OpenAI API Key\n\n1. Go to https://platform.openai.com/\n2. Sign in or create an account\n3. Navigate to API Keys section\n4. Click \"Create new secret key\"\n5. Copy the key (it starts with `sk-`)\n6. Paste it into your `.env` file\n\n## Security Note\n\n**IMPORTANT**: Never commit your `.env` file to Git! It's already listed in `.gitignore` to prevent accidental commits.\n","size_bytes":2337},"tests/test_engine_orchestrator.py":{"content":"\"\"\"\nTests for Engine Orchestrator\n\"\"\"\nimport unittest\nfrom unittest.mock import Mock, patch, MagicMock\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n\nclass TestEngineOrchestrator(unittest.TestCase):\n    \"\"\"Test cases for EngineOrchestrator\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures\"\"\"\n        self.orchestrator = EngineOrchestrator()\n    \n    def test_initialization(self):\n        \"\"\"Test orchestrator initializes with empty caches\"\"\"\n        self.assertEqual(self.orchestrator.playwright_engines, {})\n        self.assertEqual(self.orchestrator.browser_use_engines, {})\n        self.assertEqual(self.orchestrator.hybrid_engines, {})\n    \n    @patch('app.services.engine_orchestrator.browser_use_codebase')\n    def test_browser_use_engine_caching(self, mock_browser_use):\n        \"\"\"Test that Browser-Use engines are cached per headless mode\"\"\"\n        mock_engine = Mock()\n        mock_browser_use.create_engine.return_value = mock_engine\n        \n        # First call should create engine\n        engine1 = self.orchestrator.get_browser_use_engine(headless=True)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 1)\n        \n        # Second call with same headless should return cached engine\n        engine2 = self.orchestrator.get_browser_use_engine(headless=True)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 1)\n        self.assertIs(engine1, engine2)\n        \n        # Call with different headless should create new engine\n        engine3 = self.orchestrator.get_browser_use_engine(headless=False)\n        self.assertEqual(mock_browser_use.create_engine.call_count, 2)\n        self.assertIsNot(engine1, engine3)\n    \n    @patch('app.services.engine_orchestrator.hybrid_engine')\n    def test_hybrid_engine_caching(self, mock_hybrid):\n        \"\"\"Test that Hybrid engines are cached per headless mode\"\"\"\n        mock_engine = Mock()\n        mock_hybrid.create_engine.return_value = mock_engine\n        \n        # First call should create engine\n        engine1 = self.orchestrator.get_hybrid_engine(headless=True)\n        self.assertEqual(mock_hybrid.create_engine.call_count, 1)\n        \n        # Second call should return cached engine\n        engine2 = self.orchestrator.get_hybrid_engine(headless=True)\n        self.assertEqual(mock_hybrid.create_engine.call_count, 1)\n        self.assertIs(engine1, engine2)\n    \n    def test_execute_instruction_invalid_engine(self):\n        \"\"\"Test that invalid engine type raises ValueError\"\"\"\n        with self.assertRaises(ValueError) as context:\n            self.orchestrator.execute_instruction(\n                \"test instruction\",\n                \"invalid_engine\",\n                headless=True\n            )\n        self.assertIn(\"Unknown engine type\", str(context.exception))\n    \n    @patch('app.services.engine_orchestrator.browser_use_codebase')\n    def test_execute_instruction_browser_use(self, mock_browser_use):\n        \"\"\"Test executing instruction with Browser-Use engine\"\"\"\n        mock_engine = Mock()\n        mock_engine.execute_instruction_sync.return_value = {\n            'success': True,\n            'message': 'Task completed',\n            'iterations': 5\n        }\n        mock_browser_use.create_engine.return_value = mock_engine\n        \n        result = self.orchestrator.execute_instruction(\n            \"Go to google.com\",\n            \"browser_use\",\n            headless=True\n        )\n        \n        self.assertTrue(result['success'])\n        self.assertEqual(result['engine'], 'browser_use')\n        self.assertTrue(result['headless'])\n        mock_engine.execute_instruction_sync.assert_called_once_with(\"Go to google.com\")\n\n\nif __name__ == '__main__':\n    unittest.main()\n","size_bytes":3734},"WINDOWS_TROUBLESHOOTING.md":{"content":"# Windows Troubleshooting Guide\n\n## Problem: API Key from Wrong Source\n\n### Symptom\nWhen you run `python main.py`, it prints an API key, but it's not the one from your `.env` file.\n\n### Cause\nYou likely set `OPENAI_API_KEY` as a **system environment variable** on Windows at some point (maybe when testing earlier). Windows system environment variables take priority over `.env` files.\n\n### Solution: Clear the System Environment Variable\n\n**Option 1: Temporary Fix (Current Terminal Only)**\n```cmd\nset OPENAI_API_KEY=\n```\nThen close and reopen your terminal, and run the app again.\n\n**Option 2: Permanent Fix (Remove from System)**\n\n1. Press `Windows Key + R`\n2. Type `sysdm.cpl` and press Enter\n3. Click \"Advanced\" tab\n4. Click \"Environment Variables\" button\n5. Look in both sections:\n   - \"User variables for [your username]\"\n   - \"System variables\"\n6. Find `OPENAI_API_KEY` if it exists\n7. Select it and click \"Delete\"\n8. Click OK on all windows\n9. **Close ALL Command Prompt/PowerShell windows**\n10. Open a fresh terminal\n\n**Option 3: Just Use the .env File (Current Fix)**\n\nGood news! I've updated the code to use `load_dotenv(override=True)`, which means your `.env` file will now **override** any system environment variables. Just make sure you have the correct API key in your `.env` file.\n\n### Verify Your Setup\n\nRun this diagnostic script:\n```bash\npython check_env.py\n```\n\nThis will show you:\n- ‚úÖ What's in your `.env` file\n- ‚ö†Ô∏è  If you have a system environment variable set\n- ‚úÖ Which one is actually being used\n\n## Problem: Still Getting \"API Key Not Set\" Error\n\n### Check These Things:\n\n1. **File is named correctly**\n   - Must be `.env` (not `.env.txt` or `env`)\n   - Run: `dir .env` in the project folder\n   - You should see: `.env`\n\n2. **File is in the right location**\n   - Must be in the same folder as `main.py`\n   - Run: `dir` and verify both `.env` and `main.py` are listed\n\n3. **File has correct content**\n   - Run: `type .env` to see contents\n   - Should show: `OPENAI_API_KEY=sk-...`\n   - Make sure there are NO spaces around the `=` sign\n   - Make sure there are NO quotes around the key\n\n4. **Dependencies are installed**\n   - Run: `pip install python-dotenv`\n   - Then: `pip install -r requirements.txt`\n\n## Common Mistakes\n\n### ‚ùå WRONG: .env.txt\nWindows often adds `.txt` extension automatically when you save in Notepad.\n\n**Fix**: In Notepad, choose \"All Files (*.*)\" when saving, not \"Text Documents (*.txt)\"\n\n### ‚ùå WRONG: Quotes around the key\n```\nOPENAI_API_KEY=\"sk-your-key-here\"\n```\n\n**Fix**: Remove the quotes:\n```\nOPENAI_API_KEY=sk-your-key-here\n```\n\n### ‚ùå WRONG: Spaces around equals\n```\nOPENAI_API_KEY = sk-your-key-here\n```\n\n**Fix**: Remove spaces:\n```\nOPENAI_API_KEY=sk-your-key-here\n```\n\n### ‚ùå WRONG: Missing the `sk-` prefix\nYour OpenAI API key should start with `sk-` or `sk-proj-`\n\n## Still Not Working?\n\nRun the diagnostic and send me the output:\n```bash\npython check_env.py\n```\n\nThis will help me see exactly what's wrong!\n","size_bytes":2987}},"version":2}