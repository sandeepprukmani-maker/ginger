{"file_contents":{"app/models/__init__.py":{"content":"# Models package\n","size_bytes":17},"app/routes/main.py":{"content":"from flask import Blueprint, render_template, request, jsonify, send_file\nfrom app.models.database import DatabaseManager, Task, ActionLog, HealingEvent\nfrom app.services.code_generator import PlaywrightCodeGenerator\nimport os\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nmain_bp = Blueprint('main', __name__)\n\ndef init_routes(db_manager: DatabaseManager, code_generator: PlaywrightCodeGenerator):\n    \"\"\"Initialize routes with dependencies\"\"\"\n    \n    @main_bp.route('/')\n    def index():\n        \"\"\"Main dashboard\"\"\"\n        return render_template('index.html')\n    \n    @main_bp.route('/api/tasks', methods=['GET'])\n    def get_tasks():\n        \"\"\"Get all tasks\"\"\"\n        try:\n            session = db_manager.get_session()\n            tasks = session.query(Task).order_by(Task.created_at.desc()).all()\n            result = [task.to_dict() for task in tasks]\n            db_manager.close_session()\n            return jsonify({'success': True, 'tasks': result})\n        except Exception as e:\n            logger.error(f\"Error getting tasks: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>', methods=['GET'])\n    def get_task(task_id):\n        \"\"\"Get a specific task\"\"\"\n        try:\n            session = db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return jsonify({'success': False, 'error': 'Task not found'}), 404\n            \n            result = task.to_dict()\n            db_manager.close_session()\n            return jsonify({'success': True, 'task': result})\n        except Exception as e:\n            logger.error(f\"Error getting task: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/logs', methods=['GET'])\n    def get_task_logs(task_id):\n        \"\"\"Get action logs for a task\"\"\"\n        try:\n            session = db_manager.get_session()\n            logs = session.query(ActionLog).filter_by(task_id=task_id).order_by(ActionLog.step_number).all()\n            result = [log.to_dict() for log in logs]\n            db_manager.close_session()\n            return jsonify({'success': True, 'logs': result})\n        except Exception as e:\n            logger.error(f\"Error getting task logs: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/healing', methods=['GET'])\n    def get_task_healing(task_id):\n        \"\"\"Get healing events for a task\"\"\"\n        try:\n            session = db_manager.get_session()\n            events = session.query(HealingEvent).filter_by(task_id=task_id).order_by(HealingEvent.timestamp).all()\n            result = [event.to_dict() for event in events]\n            db_manager.close_session()\n            return jsonify({'success': True, 'healing_events': result})\n        except Exception as e:\n            logger.error(f\"Error getting healing events: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/generate-script', methods=['POST'])\n    def generate_script(task_id):\n        \"\"\"Generate Playwright script for a task\"\"\"\n        try:\n            session = db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return jsonify({'success': False, 'error': 'Task not found'}), 404\n            \n            script_path = code_generator.generate_script(task_id)\n            \n            if script_path:\n                task.generated_script_path = script_path\n                session.commit()\n                db_manager.close_session()\n                \n                return jsonify({\n                    'success': True,\n                    'script_path': script_path,\n                    'message': 'Script generated successfully'\n                })\n            else:\n                db_manager.close_session()\n                return jsonify({'success': False, 'error': 'Failed to generate script'}), 500\n                \n        except Exception as e:\n            logger.error(f\"Error generating script: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/download-script', methods=['GET'])\n    def download_script(task_id):\n        \"\"\"Download generated script\"\"\"\n        try:\n            session = db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return jsonify({'success': False, 'error': 'Task not found'}), 404\n            \n            script_path = task.generated_script_path or code_generator.get_script_path(task_id)\n            \n            if script_path and os.path.exists(script_path):\n                db_manager.close_session()\n                return send_file(script_path, as_attachment=True, download_name=os.path.basename(script_path))\n            else:\n                db_manager.close_session()\n                return jsonify({'success': False, 'error': 'Script not found'}), 404\n                \n        except Exception as e:\n            logger.error(f\"Error downloading script: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/script', methods=['GET'])\n    def get_script_content(task_id):\n        \"\"\"Get generated script content for viewing\"\"\"\n        try:\n            session = db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return jsonify({'success': False, 'error': 'Task not found'}), 404\n            \n            script_path = task.generated_script_path or code_generator.get_script_path(task_id)\n            \n            if script_path and os.path.exists(script_path):\n                with open(script_path, 'r') as f:\n                    content = f.read()\n                db_manager.close_session()\n                return jsonify({\n                    'success': True,\n                    'content': content,\n                    'path': script_path,\n                    'filename': os.path.basename(script_path)\n                })\n            else:\n                db_manager.close_session()\n                return jsonify({'success': False, 'error': 'Script not found'}), 404\n                \n        except Exception as e:\n            logger.error(f\"Error getting script content: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/tasks/<int:task_id>/execute-script', methods=['POST'])\n    def execute_script(task_id):\n        \"\"\"Execute the generated script\"\"\"\n        try:\n            session = db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return jsonify({'success': False, 'error': 'Task not found'}), 404\n            \n            script_path = task.generated_script_path or code_generator.get_script_path(task_id)\n            \n            if not script_path or not os.path.exists(script_path):\n                db_manager.close_session()\n                return jsonify({'success': False, 'error': 'Script not found'}), 404\n            \n            db_manager.close_session()\n            \n            # Execute the script in a subprocess\n            import subprocess\n            import threading\n            \n            result = {'success': False, 'output': '', 'error': ''}\n            \n            def run_script():\n                try:\n                    process = subprocess.Popen(\n                        ['python', script_path],\n                        stdout=subprocess.PIPE,\n                        stderr=subprocess.PIPE,\n                        text=True,\n                        cwd=os.path.dirname(script_path)\n                    )\n                    \n                    stdout, stderr = process.communicate(timeout=300)  # 5 minute timeout\n                    \n                    result['success'] = process.returncode == 0\n                    result['output'] = stdout\n                    result['error'] = stderr\n                    result['exit_code'] = process.returncode\n                    \n                except subprocess.TimeoutExpired:\n                    process.kill()\n                    result['success'] = False\n                    result['error'] = 'Script execution timed out (5 minutes)'\n                except Exception as e:\n                    result['success'] = False\n                    result['error'] = str(e)\n            \n            # Run in thread to avoid blocking\n            thread = threading.Thread(target=run_script)\n            thread.start()\n            thread.join(timeout=305)  # Slightly longer than subprocess timeout\n            \n            return jsonify({\n                'success': result.get('success', False),\n                'output': result.get('output', ''),\n                'error': result.get('error', ''),\n                'exit_code': result.get('exit_code', -1),\n                'message': 'Script executed' if result.get('success') else 'Script execution failed'\n            })\n                \n        except Exception as e:\n            logger.error(f\"Error executing script: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    @main_bp.route('/api/stats', methods=['GET'])\n    def get_stats():\n        \"\"\"Get dashboard statistics\"\"\"\n        try:\n            session = db_manager.get_session()\n            \n            total_tasks = session.query(Task).count()\n            completed_tasks = session.query(Task).filter_by(status='completed').count()\n            failed_tasks = session.query(Task).filter_by(status='failed').count()\n            running_tasks = session.query(Task).filter_by(status='running').count()\n            \n            total_healing_events = session.query(HealingEvent).count()\n            successful_healings = session.query(HealingEvent).filter_by(success=True).count()\n            browser_use_healings = session.query(HealingEvent).filter_by(healing_source='browser-use', success=True).count()\n            mcp_healings = session.query(HealingEvent).filter_by(healing_source='mcp', success=True).count()\n            \n            stats = {\n                'tasks': {\n                    'total': total_tasks,\n                    'completed': completed_tasks,\n                    'failed': failed_tasks,\n                    'running': running_tasks\n                },\n                'healing': {\n                    'total_events': total_healing_events,\n                    'successful': successful_healings,\n                    'browser_use': browser_use_healings,\n                    'mcp': mcp_healings\n                }\n            }\n            \n            db_manager.close_session()\n            return jsonify({'success': True, 'stats': stats})\n            \n        except Exception as e:\n            logger.error(f\"Error getting stats: {e}\")\n            return jsonify({'success': False, 'error': str(e)}), 500\n    \n    return main_bp\n","size_bytes":11261},"app/static/js/app.js":{"content":"const socket = io();\n\nlet currentTaskId = null;\nlet taskDetailModal = null;\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    taskDetailModal = new bootstrap.Modal(document.getElementById('taskDetailModal'));\n    \n    initializeSocketListeners();\n    loadTaskHistory();\n    loadStats();\n    \n    document.getElementById('taskForm').addEventListener('submit', handleTaskSubmit);\n    document.getElementById('refreshBtn').addEventListener('click', () => {\n        loadTaskHistory();\n        loadStats();\n    });\n    document.getElementById('downloadScriptBtn').addEventListener('click', handleDownloadScript);\n    \n    const headlessToggle = document.getElementById('headlessToggle');\n    const headlessLabel = document.getElementById('headlessLabel');\n    \n    headlessToggle.addEventListener('change', function() {\n        if (this.checked) {\n            headlessLabel.innerHTML = '<i class=\"bi bi-eye-slash\"></i> Headless';\n        } else {\n            headlessLabel.innerHTML = '<i class=\"bi bi-eye\"></i> Headful';\n        }\n    });\n    \n    setInterval(loadStats, 10000);\n});\n\nfunction initializeSocketListeners() {\n    socket.on('connect', () => {\n        console.log('Connected to server');\n        updateConnectionStatus(true);\n    });\n    \n    socket.on('disconnect', () => {\n        console.log('Disconnected from server');\n        updateConnectionStatus(false);\n    });\n    \n    socket.on('task_created', (data) => {\n        console.log('Task created:', data);\n        currentTaskId = data.task_id;\n        addExecutionMessage('info', `Task #${data.task_id} created`);\n        addExecutionMessage('primary', `Instruction: ${data.instruction}`);\n    });\n    \n    socket.on('task_update', (data) => {\n        console.log('Task update:', data);\n        addExecutionMessage('info', `Task #${data.id} status: ${data.status}`);\n        if (data.status === 'running') {\n            addExecutionMessage('primary', 'Executing with browser-use AI agent...');\n        }\n    });\n    \n    socket.on('step_update', (data) => {\n        console.log('Step update:', data);\n        const statusClass = data.status === 'success' ? 'success' : \n                          data.status === 'healed' ? 'warning' : \n                          data.status === 'failed' ? 'danger' : 'secondary';\n        \n        let message = `Step ${data.step_number}: ${data.action_type}`;\n        if (data.healing_source) {\n            message += ` (healed via ${data.healing_source})`;\n        }\n        \n        addExecutionMessage(statusClass, message);\n    });\n    \n    socket.on('healing_attempt', (data) => {\n        console.log('Healing attempt:', data);\n        addExecutionMessage('warning', \n            `Attempting ${data.source} healing (retry ${data.retry}/${data.max_retries})...`\n        );\n    });\n    \n    socket.on('healing_fallback', (data) => {\n        console.log('Healing fallback:', data);\n        addExecutionMessage('info', \n            `Falling back from ${data.from} to ${data.to} healing`\n        );\n    });\n    \n    socket.on('healing_event', (data) => {\n        console.log('Healing event:', data);\n        const statusClass = data.success ? 'success' : 'danger';\n        const statusText = data.success ? 'successful' : 'failed';\n        addExecutionMessage(statusClass, \n            `${data.healing_source} healing ${statusText} (${data.healing_time?.toFixed(2)}s)`\n        );\n    });\n    \n    socket.on('task_complete', (data) => {\n        console.log('Task complete:', data);\n        if (data.success) {\n            addExecutionMessage('success', `Task #${data.task_id} completed successfully!`);\n            if (data.script_path) {\n                addExecutionMessage('info', `Generated Playwright script: ${data.script_path}`);\n            }\n        } else {\n            addExecutionMessage('danger', `Task #${data.task_id} failed: ${data.error}`);\n        }\n        \n        loadTaskHistory();\n        loadStats();\n        \n        document.getElementById('executeBtn').disabled = false;\n        document.getElementById('executeBtn').innerHTML = \n            '<i class=\"bi bi-lightning-charge\"></i> Execute with Healing';\n    });\n    \n    socket.on('task_error', (data) => {\n        console.error('Task error:', data);\n        addExecutionMessage('danger', `Error in task #${data.task_id}: ${data.error}`);\n        \n        document.getElementById('executeBtn').disabled = false;\n        document.getElementById('executeBtn').innerHTML = \n            '<i class=\"bi bi-lightning-charge\"></i> Execute with Healing';\n    });\n    \n    socket.on('error', (data) => {\n        console.error('Server error:', data);\n        addExecutionMessage('danger', `Error: ${data.message}`);\n    });\n}\n\nfunction updateConnectionStatus(connected) {\n    const statusBadge = document.getElementById('connectionStatus');\n    if (connected) {\n        statusBadge.className = 'badge bg-success';\n        statusBadge.textContent = 'Connected';\n    } else {\n        statusBadge.className = 'badge bg-danger';\n        statusBadge.textContent = 'Disconnected';\n    }\n}\n\nfunction handleTaskSubmit(e) {\n    e.preventDefault();\n    \n    const instruction = document.getElementById('instruction').value.trim();\n    const headless = document.getElementById('headlessToggle').checked;\n    \n    if (!instruction) {\n        alert('Please enter an instruction');\n        return;\n    }\n    \n    clearExecutionMonitor();\n    \n    socket.emit('execute_task', { \n        instruction: instruction,\n        headless: headless\n    });\n    \n    document.getElementById('executeBtn').disabled = true;\n    document.getElementById('executeBtn').innerHTML = \n        '<span class=\"spinner-border spinner-border-sm me-2\"></span>Executing...';\n}\n\nfunction clearExecutionMonitor() {\n    const monitor = document.getElementById('executionMonitor');\n    monitor.innerHTML = '';\n}\n\nfunction addExecutionMessage(type, message) {\n    const monitor = document.getElementById('executionMonitor');\n    \n    const messageDiv = document.createElement('div');\n    messageDiv.className = `alert alert-${type} mb-2 py-2`;\n    messageDiv.innerHTML = `\n        <small class=\"text-muted\">${new Date().toLocaleTimeString()}</small> - ${message}\n    `;\n    \n    monitor.appendChild(messageDiv);\n    monitor.scrollTop = monitor.scrollHeight;\n}\n\nasync function loadTaskHistory() {\n    try {\n        const response = await fetch('/api/tasks');\n        const data = await response.json();\n        \n        if (data.success) {\n            renderTaskHistory(data.tasks);\n        } else {\n            console.error('Failed to load tasks:', data.error);\n        }\n    } catch (error) {\n        console.error('Error loading tasks:', error);\n    }\n}\n\nfunction renderTaskHistory(tasks) {\n    const tbody = document.getElementById('taskHistory');\n    \n    if (tasks.length === 0) {\n        tbody.innerHTML = '<tr><td colspan=\"7\" class=\"text-center text-muted\">No tasks yet</td></tr>';\n        return;\n    }\n    \n    tbody.innerHTML = tasks.map(task => {\n        const statusBadge = getStatusBadge(task.status);\n        const createdAt = new Date(task.created_at).toLocaleString();\n        \n        return `\n            <tr onclick=\"showTaskDetail(${task.id})\">\n                <td>${task.id}</td>\n                <td>\n                    <div class=\"text-truncate\" style=\"max-width: 300px;\" title=\"${task.instruction}\">\n                        ${task.instruction}\n                    </div>\n                </td>\n                <td>${statusBadge}</td>\n                <td>\n                    <span class=\"badge bg-info\">${task.successful_steps}/${task.total_steps}</span>\n                </td>\n                <td>\n                    ${task.healed_steps > 0 ? `<span class=\"badge bg-warning\">${task.healed_steps}</span>` : '-'}\n                </td>\n                <td><small>${createdAt}</small></td>\n                <td>\n                    <button class=\"btn btn-sm btn-outline-primary me-1\" onclick=\"event.stopPropagation(); showTaskDetail(${task.id})\" title=\"View Details\">\n                        <i class=\"bi bi-eye\"></i>\n                    </button>\n                    ${task.generated_script_path || task.status === 'completed' ? `\n                        <button class=\"btn btn-sm btn-outline-success\" onclick=\"event.stopPropagation(); viewScript(${task.id})\" title=\"View Script\">\n                            <i class=\"bi bi-code-slash\"></i>\n                        </button>\n                    ` : ''}\n                </td>\n            </tr>\n        `;\n    }).join('');\n}\n\nfunction getStatusBadge(status) {\n    const badges = {\n        'pending': '<span class=\"badge bg-secondary\">Pending</span>',\n        'running': '<span class=\"badge bg-primary\">Running</span>',\n        'completed': '<span class=\"badge bg-success\">Completed</span>',\n        'failed': '<span class=\"badge bg-danger\">Failed</span>'\n    };\n    return badges[status] || '<span class=\"badge bg-secondary\">Unknown</span>';\n}\n\nasync function showTaskDetail(taskId) {\n    currentTaskId = taskId;\n    \n    const modalBody = document.getElementById('taskDetailContent');\n    modalBody.innerHTML = '<div class=\"text-center\"><div class=\"spinner-border\" role=\"status\"></div></div>';\n    \n    taskDetailModal.show();\n    \n    try {\n        const [taskResponse, logsResponse, healingResponse] = await Promise.all([\n            fetch(`/api/tasks/${taskId}`),\n            fetch(`/api/tasks/${taskId}/logs`),\n            fetch(`/api/tasks/${taskId}/healing`)\n        ]);\n        \n        const taskData = await taskResponse.json();\n        const logsData = await logsResponse.json();\n        const healingData = await healingResponse.json();\n        \n        if (taskData.success) {\n            renderTaskDetail(taskData.task, logsData.logs || [], healingData.healing_events || []);\n        } else {\n            modalBody.innerHTML = '<div class=\"alert alert-danger\">Failed to load task details</div>';\n        }\n    } catch (error) {\n        console.error('Error loading task details:', error);\n        modalBody.innerHTML = '<div class=\"alert alert-danger\">Error loading task details</div>';\n    }\n}\n\nfunction renderTaskDetail(task, logs, healingEvents) {\n    const modalBody = document.getElementById('taskDetailContent');\n    \n    const html = `\n        <div class=\"mb-3\">\n            <h6>Task #${task.id}</h6>\n            <p class=\"mb-2\"><strong>Instruction:</strong> ${task.instruction}</p>\n            <p class=\"mb-2\"><strong>Status:</strong> ${getStatusBadge(task.status)}</p>\n            <p class=\"mb-2\"><strong>Created:</strong> ${new Date(task.created_at).toLocaleString()}</p>\n            ${task.completed_at ? `<p class=\"mb-2\"><strong>Completed:</strong> ${new Date(task.completed_at).toLocaleString()}</p>` : ''}\n            ${task.error_message ? `<p class=\"mb-2\"><strong>Error:</strong> <span class=\"text-danger\">${task.error_message}</span></p>` : ''}\n        </div>\n        \n        <div class=\"mb-3\">\n            <h6>Progress</h6>\n            <div class=\"row\">\n                <div class=\"col-4 text-center\">\n                    <div class=\"h4\">${task.total_steps}</div>\n                    <small class=\"text-muted\">Total Steps</small>\n                </div>\n                <div class=\"col-4 text-center\">\n                    <div class=\"h4 text-success\">${task.successful_steps}</div>\n                    <small class=\"text-muted\">Successful</small>\n                </div>\n                <div class=\"col-4 text-center\">\n                    <div class=\"h4 text-warning\">${task.healed_steps}</div>\n                    <small class=\"text-muted\">Healed</small>\n                </div>\n            </div>\n        </div>\n        \n        ${logs.length > 0 ? `\n            <div class=\"mb-3\">\n                <h6>Action Logs</h6>\n                ${logs.map(log => `\n                    <div class=\"action-log-item\">\n                        <div class=\"d-flex justify-content-between align-items-start\">\n                            <div>\n                                <span class=\"step-number\">Step ${log.step_number}</span>\n                                <span class=\"badge bg-secondary ms-2\">${log.action_type}</span>\n                                ${log.healing_source ? `<span class=\"badge bg-warning ms-1\">Healed via ${log.healing_source}</span>` : ''}\n                            </div>\n                            <span class=\"badge ${log.status === 'success' || log.status === 'healed' ? 'bg-success' : 'bg-danger'}\">\n                                ${log.status}\n                            </span>\n                        </div>\n                        ${log.url ? `<div class=\"mt-1\"><small class=\"text-muted\">URL: ${log.url}</small></div>` : ''}\n                        ${log.error_message ? `<div class=\"mt-1 text-danger\"><small>${log.error_message}</small></div>` : ''}\n                    </div>\n                `).join('')}\n            </div>\n        ` : ''}\n        \n        ${healingEvents.length > 0 ? `\n            <div class=\"mb-3\">\n                <h6>Healing Events</h6>\n                ${healingEvents.map(event => `\n                    <div class=\"healing-event ${event.success ? 'success' : 'failed'}\">\n                        <div class=\"d-flex justify-content-between\">\n                            <strong>${event.healing_source}</strong>\n                            <span class=\"badge ${event.success ? 'bg-success' : 'bg-danger'}\">\n                                ${event.success ? 'Success' : 'Failed'}\n                            </span>\n                        </div>\n                        <small class=\"text-muted\">\n                            Time: ${event.healing_time?.toFixed(2)}s | \n                            ${new Date(event.timestamp).toLocaleString()}\n                        </small>\n                    </div>\n                `).join('')}\n            </div>\n        ` : ''}\n    `;\n    \n    modalBody.innerHTML = html;\n}\n\nasync function handleDownloadScript() {\n    if (!currentTaskId) return;\n    \n    try {\n        const response = await fetch(`/api/tasks/${currentTaskId}/generate-script`, {\n            method: 'POST'\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            window.location.href = `/api/tasks/${currentTaskId}/download-script`;\n        } else {\n            alert('Failed to generate script: ' + data.error);\n        }\n    } catch (error) {\n        console.error('Error downloading script:', error);\n        alert('Error downloading script');\n    }\n}\n\nasync function loadStats() {\n    try {\n        const response = await fetch('/api/stats');\n        const data = await response.json();\n        \n        if (data.success) {\n            document.getElementById('totalTasks').textContent = data.stats.tasks.total;\n            document.getElementById('completedTasks').textContent = data.stats.tasks.completed;\n            \n            const totalHealed = data.stats.healing.browser_use + data.stats.healing.mcp;\n            document.getElementById('healedSteps').textContent = totalHealed;\n            document.getElementById('totalHealings').textContent = data.stats.healing.total_events;\n            \n            document.getElementById('browserUseCount').textContent = data.stats.healing.browser_use;\n            document.getElementById('mcpCount').textContent = data.stats.healing.mcp;\n        }\n    } catch (error) {\n        console.error('Error loading stats:', error);\n    }\n}\n\n// Script Viewer Functionality\nlet scriptViewerModal = null;\nlet currentScriptTaskId = null;\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    scriptViewerModal = new bootstrap.Modal(document.getElementById('scriptViewerModal'));\n    \n    // Script viewer event listeners\n    document.getElementById('copyScriptBtn').addEventListener('click', handleCopyScript);\n    document.getElementById('downloadScriptBtnViewer').addEventListener('click', handleDownloadScriptViewer);\n    document.getElementById('executeScriptBtn').addEventListener('click', handleExecuteScript);\n});\n\nasync function viewScript(taskId) {\n    currentScriptTaskId = taskId;\n    scriptViewerModal.show();\n    \n    try {\n        const response = await fetch(`/api/tasks/${taskId}/script`);\n        const data = await response.json();\n        \n        if (data.success) {\n            document.getElementById('scriptFilename').textContent = data.filename;\n            document.getElementById('scriptCodeContent').innerHTML = \n                `<pre style=\"margin: 0; color: #abb2bf;\">${escapeHtml(data.content)}</pre>`;\n            document.getElementById('scriptExecutionOutput').style.display = 'none';\n        } else {\n            document.getElementById('scriptCodeContent').innerHTML = \n                `<div class=\"alert alert-warning m-3\">Script not available. ${data.error}</div>`;\n        }\n    } catch (error) {\n        console.error('Error loading script:', error);\n        document.getElementById('scriptCodeContent').innerHTML = \n            `<div class=\"alert alert-danger m-3\">Error loading script: ${error.message}</div>`;\n    }\n}\n\nfunction handleCopyScript() {\n    const codeContent = document.getElementById('scriptCodeContent').querySelector('pre');\n    if (codeContent) {\n        const text = codeContent.textContent;\n        navigator.clipboard.writeText(text).then(() => {\n            const btn = document.getElementById('copyScriptBtn');\n            const originalHTML = btn.innerHTML;\n            btn.innerHTML = '<i class=\"bi bi-check\"></i> Copied!';\n            setTimeout(() => {\n                btn.innerHTML = originalHTML;\n            }, 2000);\n        }).catch(err => {\n            alert('Failed to copy script: ' + err);\n        });\n    }\n}\n\nfunction handleDownloadScriptViewer() {\n    if (currentScriptTaskId) {\n        window.location.href = `/api/tasks/${currentScriptTaskId}/download-script`;\n    }\n}\n\nasync function handleExecuteScript() {\n    if (!currentScriptTaskId) return;\n    \n    const executeBtn = document.getElementById('executeScriptBtn');\n    const originalHTML = executeBtn.innerHTML;\n    executeBtn.disabled = true;\n    executeBtn.innerHTML = '<span class=\"spinner-border spinner-border-sm me-2\"></span>Executing...';\n    \n    const outputDiv = document.getElementById('scriptExecutionOutput');\n    const outputText = document.getElementById('executionOutputText');\n    \n    outputDiv.style.display = 'block';\n    outputText.textContent = 'ðŸ”§ Initializing self-healing script execution...\\n\\n';\n    \n    try {\n        const response = await fetch(`/api/tasks/${currentScriptTaskId}/execute-script`, {\n            method: 'POST'\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            outputText.textContent += 'âœ“ Execution completed successfully!\\n\\n';\n            outputText.textContent += '--- Output ---\\n' + data.output;\n            if (data.error) {\n                outputText.textContent += '\\n\\n--- Warnings ---\\n' + data.error;\n            }\n            \n            // Reload script to see any healing updates\n            setTimeout(() => viewScript(currentScriptTaskId), 1000);\n        } else {\n            outputText.textContent += 'âœ— Execution failed\\n\\n';\n            outputText.textContent += '--- Error ---\\n' + (data.error || 'Unknown error');\n            if (data.output) {\n                outputText.textContent += '\\n\\n--- Output ---\\n' + data.output;\n            }\n        }\n    } catch (error) {\n        console.error('Error executing script:', error);\n        outputText.textContent += 'âœ— Execution error: ' + error.message;\n    } finally {\n        executeBtn.disabled = false;\n        executeBtn.innerHTML = originalHTML;\n    }\n}\n\nfunction escapeHtml(text) {\n    const map = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#039;'\n    };\n    return text.replace(/[&<>\"']/g, m => map[m]);\n}\n\n// Add View Script button to task rows\nwindow.viewScript = viewScript;\n","size_bytes":19966},"app/routes/__init__.py":{"content":"# Routes package\n","size_bytes":17},"application.py":{"content":"import os\nimport logging\nimport yaml\nimport asyncio\nfrom flask import Flask\nfrom flask_socketio import SocketIO, emit\nfrom dotenv import load_dotenv\nfrom app.models.database import DatabaseManager, Task\nfrom app.routes.main import main_bp, init_routes\nfrom app.services.code_generator import PlaywrightCodeGenerator\nfrom app.services.healing_orchestrator import HealingOrchestrator\nfrom datetime import datetime\nimport eventlet\n\neventlet.monkey_patch()\n\nload_dotenv()\n\nos.makedirs('logs', exist_ok=True)\nos.makedirs('data', exist_ok=True)\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('logs/automation.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\napp = Flask(__name__, template_folder='app/templates', static_folder='app/static')\napp.config['SECRET_KEY'] = os.getenv('SESSION_SECRET', os.urandom(24))\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024\n\nsocketio = SocketIO(app, cors_allowed_origins=\"*\", async_mode='eventlet')\n\nwith open('config/config.yaml', 'r') as f:\n    config = yaml.safe_load(f)\n\ndb_manager = DatabaseManager(os.getenv('DATABASE_PATH', 'data/automation.db'))\ncode_generator = PlaywrightCodeGenerator(db_manager, config.get('export', {}).get('script_directory', 'data/generated_scripts'))\n\ninitialized_main_bp = init_routes(db_manager, code_generator)\napp.register_blueprint(initialized_main_bp)\n\ndef emit_callback(event_type, data):\n    \"\"\"Callback to emit events via SocketIO\"\"\"\n    try:\n        socketio.emit(event_type, data)\n    except Exception as e:\n        logger.error(f\"Error emitting event {event_type}: {e}\")\n\n@socketio.on('connect')\ndef handle_connect():\n    \"\"\"Handle client connection\"\"\"\n    logger.info('Client connected')\n    emit('connection_response', {'status': 'connected'})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    \"\"\"Handle client disconnection\"\"\"\n    logger.info('Client disconnected')\n\n@socketio.on('execute_task')\ndef handle_execute_task(data):\n    \"\"\"Handle task execution request\"\"\"\n    try:\n        instruction = data.get('instruction')\n        headless = data.get('headless', True)\n        \n        if not instruction:\n            emit('error', {'message': 'Instruction is required'})\n            return\n        \n        session = db_manager.get_session()\n        task = Task(\n            instruction=instruction,\n            status='pending'\n        )\n        session.add(task)\n        session.commit()\n        task_id = task.id\n        db_manager.close_session()\n        \n        emit('task_created', {'task_id': task_id, 'instruction': instruction})\n        \n        logger.info(f\"Task {task_id} created: {instruction} (headless={headless})\")\n        \n        def run_async_task():\n            \"\"\"Run the async task in a new event loop\"\"\"\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                task_config = config.copy()\n                task_config['browser'] = task_config.get('browser', {}).copy()\n                task_config['browser']['headless'] = headless\n                \n                orchestrator = HealingOrchestrator(task_config, db_manager)\n                result = loop.run_until_complete(\n                    orchestrator.execute_with_healing(task_id, instruction, emit_callback)\n                )\n                \n                if result['success']:\n                    script_path = code_generator.generate_script(task_id, headless=headless)\n                    \n                    session = db_manager.get_session()\n                    task = session.query(Task).filter_by(id=task_id).first()\n                    if task and script_path:\n                        task.generated_script_path = script_path\n                        session.commit()\n                    db_manager.close_session()\n                    \n                    socketio.emit('task_complete', {\n                        'task_id': task_id,\n                        'success': True,\n                        'script_path': script_path\n                    })\n                else:\n                    socketio.emit('task_complete', {\n                        'task_id': task_id,\n                        'success': False,\n                        'error': result.get('error')\n                    })\n                    \n            except Exception as e:\n                logger.error(f\"Error executing task {task_id}: {e}\")\n                socketio.emit('task_error', {\n                    'task_id': task_id,\n                    'error': str(e)\n                })\n            finally:\n                loop.close()\n        \n        eventlet.spawn(run_async_task)\n        \n    except Exception as e:\n        logger.error(f\"Error in handle_execute_task: {e}\")\n        emit('error', {'message': str(e)})\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {'status': 'healthy', 'timestamp': datetime.utcnow().isoformat()}\n\nif __name__ == '__main__':\n    logger.info(\"Starting Self-Healing Browser Automation System\")\n    logger.info(f\"Dashboard available at: http://0.0.0.0:5000\")\n    socketio.run(app, host='0.0.0.0', port=5000, debug=True, allow_unsafe_werkzeug=True)\n","size_bytes":5285},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"apscheduler>=3.11.0\",\n    \"browser-use>=0.9.0\",\n    \"email-validator>=2.3.0\",\n    \"eventlet>=0.40.3\",\n    \"flask>=3.1.2\",\n    \"flask-socketio>=5.5.1\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"langchain-openai>=1.0.1\",\n    \"playwright>=1.55.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pydantic>=2.12.3\",\n    \"python-dotenv>=1.1.1\",\n    \"python-engineio>=4.12.3\",\n    \"pyyaml>=6.0.3\",\n    \"sqlalchemy>=2.0.44\",\n]\n","size_bytes":573},"app/models/database.py":{"content":"from sqlalchemy import create_engine, Column, Integer, String, DateTime, JSON, Float, Text, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, scoped_session\nfrom datetime import datetime\nimport os\n\nBase = declarative_base()\n\nclass Task(Base):\n    __tablename__ = 'tasks'\n    \n    id = Column(Integer, primary_key=True)\n    instruction = Column(Text, nullable=False)\n    status = Column(String(50), default='pending')\n    created_at = Column(DateTime, default=datetime.utcnow)\n    started_at = Column(DateTime, nullable=True)\n    completed_at = Column(DateTime, nullable=True)\n    total_steps = Column(Integer, default=0)\n    successful_steps = Column(Integer, default=0)\n    failed_steps = Column(Integer, default=0)\n    healed_steps = Column(Integer, default=0)\n    error_message = Column(Text, nullable=True)\n    generated_script_path = Column(String(500), nullable=True)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'instruction': self.instruction,\n            'status': self.status,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'started_at': self.started_at.isoformat() if self.started_at else None,\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None,\n            'total_steps': self.total_steps,\n            'successful_steps': self.successful_steps,\n            'failed_steps': self.failed_steps,\n            'healed_steps': self.healed_steps,\n            'error_message': self.error_message,\n            'generated_script_path': self.generated_script_path\n        }\n\nclass ActionLog(Base):\n    __tablename__ = 'action_logs'\n    \n    id = Column(Integer, primary_key=True)\n    task_id = Column(Integer, nullable=False)\n    step_number = Column(Integer, nullable=False)\n    action_type = Column(String(100), nullable=False)\n    url = Column(String(2000), nullable=True)\n    locator = Column(JSON, nullable=True)\n    original_locator = Column(JSON, nullable=True)\n    status = Column(String(50), default='pending')\n    error_message = Column(Text, nullable=True)\n    healing_attempted = Column(Boolean, default=False)\n    healing_source = Column(String(50), nullable=True)\n    healed_locator = Column(JSON, nullable=True)\n    execution_time = Column(Float, nullable=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    retry_count = Column(Integer, default=0)\n    page_context = Column(JSON, nullable=True)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'task_id': self.task_id,\n            'step_number': self.step_number,\n            'action_type': self.action_type,\n            'url': self.url,\n            'locator': self.locator,\n            'original_locator': self.original_locator,\n            'status': self.status,\n            'error_message': self.error_message,\n            'healing_attempted': self.healing_attempted,\n            'healing_source': self.healing_source,\n            'healed_locator': self.healed_locator,\n            'execution_time': self.execution_time,\n            'timestamp': self.timestamp.isoformat() if self.timestamp else None,\n            'retry_count': self.retry_count,\n            'page_context': self.page_context\n        }\n\nclass HealingEvent(Base):\n    __tablename__ = 'healing_events'\n    \n    id = Column(Integer, primary_key=True)\n    action_log_id = Column(Integer, nullable=False)\n    task_id = Column(Integer, nullable=False)\n    healing_source = Column(String(50), nullable=False)\n    original_locator = Column(JSON, nullable=False)\n    healed_locator = Column(JSON, nullable=False)\n    success = Column(Boolean, default=False)\n    error_message = Column(Text, nullable=True)\n    healing_time = Column(Float, nullable=True)\n    timestamp = Column(DateTime, default=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'action_log_id': self.action_log_id,\n            'task_id': self.task_id,\n            'healing_source': self.healing_source,\n            'original_locator': self.original_locator,\n            'healed_locator': self.healed_locator,\n            'success': self.success,\n            'error_message': self.error_message,\n            'healing_time': self.healing_time,\n            'timestamp': self.timestamp.isoformat() if self.timestamp else None\n        }\n\nclass DatabaseManager:\n    def __init__(self, db_path='data/automation.db'):\n        os.makedirs(os.path.dirname(db_path), exist_ok=True)\n        self.engine = create_engine(f'sqlite:///{db_path}', \n                                   connect_args={'check_same_thread': False},\n                                   pool_pre_ping=True)\n        Base.metadata.create_all(self.engine)\n        session_factory = sessionmaker(bind=self.engine)\n        self.Session = scoped_session(session_factory)\n    \n    def get_session(self):\n        return self.Session()\n    \n    def close_session(self):\n        self.Session.remove()\n","size_bytes":5027},"README.md":{"content":"# Self-Healing Browser Automation System\n\nA production-ready Flask web application for self-healing browser automation using browser-use AI execution and Microsoft's Playwright MCP server as an intelligent fallback mechanism.\n\n## Features\n\n- **Natural Language Instructions**: Execute browser automation tasks using plain English\n- **Two-Tier Healing System**: \n  - First attempt: browser-use AI-powered healing\n  - Fallback: Microsoft Playwright MCP server for robust locator recovery\n- **Real-Time Monitoring**: WebSocket-based live updates of execution progress\n- **Action Logging**: Complete history of all steps, locators, and healing events\n- **Code Generation**: Automatically generate executable Playwright Python scripts with healed locators\n- **Reporting Dashboard**: Statistics on healing success, sources, and locator stability\n- **Production-Ready**: SQLAlchemy ORM, proper error handling, and comprehensive logging\n\n## Architecture\n\n### Components\n\n1. **Browser-Use Executor**: AI-powered initial automation execution\n2. **MCP Server Integration**: Microsoft Playwright MCP server for accessibility-based healing\n3. **Healing Orchestrator**: Routes failed steps to appropriate healing mechanism\n4. **Action Log Database**: SQLite persistence for all execution data\n5. **Code Generator**: Creates Playwright scripts from healed action logs\n6. **Flask Web App**: Dashboard UI with real-time WebSocket updates\n\n## Installation\n\n### Prerequisites\n\n- Python 3.11+\n- Node.js 18+\n- OpenAI API key (for browser-use)\n\n### Setup\n\n1. Install dependencies (already configured in Replit):\n   - Python packages: flask, browser-use, playwright, sqlalchemy, etc.\n   - Node packages: @playwright/mcp\n\n2. Configure environment variables via Replit Secrets:\n   - `OPENAI_API_KEY`: Your OpenAI API key\n   - `SESSION_SECRET`: Flask session secret (already configured)\n\n3. The application will automatically:\n   - Create the SQLite database\n   - Initialize all required directories\n   - Install Playwright browsers\n\n## Usage\n\n### Starting the Application\n\nThe Flask server runs on port 5000 with WebSocket support.\n\n### Executing Tasks\n\n1. Enter a natural language instruction in the dashboard\n2. Click \"Execute with Healing\"\n3. Monitor real-time execution progress\n4. View healing attempts and their sources\n5. Download generated Playwright script\n\n### Example Instructions\n\n- \"Go to google.com and search for 'browser automation'\"\n- \"Navigate to github.com, click the sign in button, and fill the username field with 'testuser'\"\n- \"Open example.com and click on the contact us link\"\n\n## Healing Flow\n\n1. **Initial Execution**: browser-use attempts to execute the instruction\n2. **Failure Detection**: Monitor detects element not found, timeout, or other errors\n3. **Browser-Use Healing**: Retry with browser-use AI (up to 2 attempts)\n4. **MCP Fallback**: If browser-use fails, Microsoft Playwright MCP server takes over\n5. **Locator Update**: Successful healing updates action log with healed locator\n6. **Code Generation**: Generate Playwright script with all healed locators\n\n## API Endpoints\n\n- `GET /`: Main dashboard\n- `GET /api/tasks`: List all tasks\n- `GET /api/tasks/<id>`: Get task details\n- `GET /api/tasks/<id>/logs`: Get action logs\n- `GET /api/tasks/<id>/healing`: Get healing events\n- `POST /api/tasks/<id>/generate-script`: Generate Playwright script\n- `GET /api/tasks/<id>/download-script`: Download generated script\n- `GET /api/stats`: Get dashboard statistics\n- `GET /health`: Health check endpoint\n\n## WebSocket Events\n\n### Client â†’ Server\n- `execute_task`: Submit new automation task\n\n### Server â†’ Client\n- `task_created`: Task created successfully\n- `task_update`: Task status changed\n- `step_update`: Action step completed\n- `healing_attempt`: Healing attempt in progress\n- `healing_fallback`: Switched to fallback healing\n- `healing_event`: Healing attempt result\n- `task_complete`: Task execution finished\n- `task_error`: Task execution error\n\n## Configuration\n\nEdit `config/config.yaml` to adjust:\n\n- Retry thresholds\n- Timeout settings\n- Browser configuration\n- MCP server options\n- Export directories\n\n## Database Schema\n\n### Tables\n\n1. **tasks**: Main task records\n2. **action_logs**: Individual step execution logs\n3. **healing_events**: Healing attempt records\n\nAll tables include comprehensive metadata for debugging and analysis.\n\n## Generated Scripts\n\nScripts are saved in `data/generated_scripts/` and include:\n\n- All successful and healed steps\n- Current working locators\n- Error handling\n- Async/await Playwright patterns\n- Ready to execute independently\n\n## Technology Stack\n\n- **Backend**: Flask, Flask-SocketIO, SQLAlchemy\n- **Automation**: browser-use, Playwright, Microsoft Playwright MCP\n- **Frontend**: Bootstrap 5, Socket.IO, Chart.js\n- **Database**: SQLite with WAL mode\n- **AI/LLM**: OpenAI GPT-4\n\n## License\n\nMIT License\n","size_bytes":4866},"config/config.yaml":{"content":"healing:\n  max_retries: 3\n  browser_use_retry_limit: 2\n  mcp_retry_limit: 2\n  timeout_seconds: 30\n  \nbrowser:\n  headless: true\n  viewport_width: 1920\n  viewport_height: 1080\n  default_timeout: 30000\n  \nmcp:\n  server_startup_timeout: 10\n  command_timeout: 60\n  browser: \"chromium\"\n  capabilities: []\n  \nexecution:\n  max_concurrent_tasks: 3\n  step_delay_ms: 500\n  screenshot_on_error: true\n  \nlogging:\n  level: \"INFO\"\n  file: \"logs/automation.log\"\n  max_file_size: 10485760\n  backup_count: 5\n  \nexport:\n  script_directory: \"data/generated_scripts\"\n  action_log_directory: \"data/action_logs\"\n","size_bytes":589},"app/services/code_generator.py":{"content":"import os\nimport logging\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nfrom app.models.database import DatabaseManager, ActionLog\n\nlogger = logging.getLogger(__name__)\n\nclass PlaywrightCodeGenerator:\n    def __init__(self, db_manager: DatabaseManager, output_dir: str = 'data/generated_scripts'):\n        self.db_manager = db_manager\n        self.output_dir = output_dir\n        os.makedirs(output_dir, exist_ok=True)\n    \n    def generate_script(self, task_id: int, headless: bool = False) -> str:\n        \"\"\"Generate a Playwright Python script from action logs\"\"\"\n        try:\n            session = self.db_manager.get_session()\n            \n            action_logs = session.query(ActionLog).filter_by(task_id=task_id).order_by(ActionLog.step_number).all()\n            \n            if not action_logs:\n                logger.warning(f\"No action logs found for task {task_id}\")\n                return None\n            \n            script_content = self._generate_script_content(action_logs, task_id, headless)\n            \n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            filename = f'task_{task_id}_{timestamp}.py'\n            filepath = os.path.join(self.output_dir, filename)\n            \n            with open(filepath, 'w') as f:\n                f.write(script_content)\n            \n            logger.info(f\"Generated Playwright script: {filepath} (headless={headless})\")\n            \n            self.db_manager.close_session()\n            return filepath\n            \n        except Exception as e:\n            logger.error(f\"Error generating script: {e}\")\n            return None\n    \n    def _generate_script_content(self, action_logs: List[ActionLog], task_id: int, headless: bool = False) -> str:\n        \"\"\"Generate the actual Python script content with self-healing capabilities\"\"\"\n        \n        script_lines = [\n            \"#!/usr/bin/env python3\",\n            '\"\"\"',\n            f'Auto-generated Self-Healing Playwright script from Task #{task_id}',\n            f'Generated at: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}',\n            'This script includes self-healing capabilities using browser-use and MCP.',\n            '\"\"\"',\n            '',\n            'import asyncio',\n            'import os',\n            'import sys',\n            'import json',\n            'import re',\n            'from playwright.async_api import async_playwright, Page',\n            'from typing import Dict, Any, Optional',\n            '',\n            '# Add parent directory to path to import healing services',\n            'sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))',\n            '',\n            'try:',\n            '    from app.services.browser_use_service import BrowserUseService',\n            '    from app.services.mcp_service import MCPServerService',\n            '    import yaml',\n            '    HEALING_AVAILABLE = True',\n            'except ImportError:',\n            '    HEALING_AVAILABLE = False',\n            '    print(\"Warning: Healing services not available. Script will run without self-healing.\")',\n            '',\n            '',\n            'class SelfHealingScript:',\n            '    \"\"\"Self-healing automation script\"\"\"',\n            '    ',\n            '    def __init__(self, page: Page, script_path: str):',\n            '        self.page = page',\n            '        self.script_path = script_path',\n            '        self.browser_use = None',\n            '        self.mcp_service = None',\n            '        self.healing_enabled = HEALING_AVAILABLE',\n            '        ',\n            '    async def initialize_healing(self):',\n            '        \"\"\"Initialize healing services\"\"\"',\n            '        if not self.healing_enabled:',\n            '            return',\n            '        ',\n            '        try:',\n            '            config_path = os.path.join(os.path.dirname(self.script_path), \"..\", \"..\", \"config\", \"config.yaml\")',\n            '            if os.path.exists(config_path):',\n            '                with open(config_path, \"r\") as f:',\n            '                    config = yaml.safe_load(f)',\n            '            else:',\n            '                config = {\"browser\": {\"headless\": True}, \"mcp\": {}}',\n            '            ',\n            '            self.browser_use = BrowserUseService(config.get(\"browser\", {}))',\n            '            self.mcp_service = MCPServerService(config.get(\"mcp\", {}))',\n            '            print(\"âœ“ Healing services initialized\")',\n            '        except Exception as e:',\n            '            print(f\"Warning: Could not initialize healing services: {e}\")',\n            '            self.healing_enabled = False',\n            '    ',\n            '    async def heal_step(self, step_num: int, action: str, selector: str, error: str) -> Optional[str]:',\n            '        \"\"\"Attempt to heal a failed step and return new selector\"\"\"',\n            '        if not self.healing_enabled:',\n            '            return None',\n            '        ',\n            '        print(f\"\\\\nðŸ”§ Attempting to heal step {step_num}: {action}\")',\n            '        ',\n            '        # Try browser-use healing',\n            '        for retry in range(2):',\n            '            try:',\n            '                print(f\"  â†’ Browser-use healing attempt {retry + 1}/2\")',\n            '                ',\n            '                if action == \"click\":',\n            '                    instruction = f\"Click on the element that was previously at {selector}\"',\n            '                elif action == \"fill\":',\n            '                    instruction = f\"Find and focus the input field that was previously at {selector}\"',\n            '                else:',\n            '                    instruction = f\"Interact with element at {selector}\"',\n            '                ',\n            '                await self.browser_use.initialize()',\n            '                result = await self.browser_use.execute_task(instruction)',\n            '                ',\n            '                if result.get(\"success\"):',\n            '                    print(f\"  âœ“ Healed via browser-use\")',\n            '                    # The action was performed, update script and return success',\n            '                    self.update_script(step_num, selector, selector, \"browser-use\")',\n            '                    return selector',\n            '                    ',\n            '            except Exception as e:',\n            '                print(f\"  âœ— Browser-use attempt {retry + 1} failed: {e}\")',\n            '            ',\n            '            await asyncio.sleep(1)',\n            '        ',\n            '        # Try MCP healing with selector discovery',\n            '        try:',\n            '            print(f\"  â†’ MCP healing attempt\")',\n            '            if self.mcp_service.start_server():',\n            '                current_url = self.page.url',\n            '                if self.mcp_service.navigate(current_url):',\n            '                    # Try to find a better selector',\n            '                    new_selector = self.mcp_service.get_element_locator(',\n            '                        f\"element for {action}\", ',\n            '                        None',\n            '                    )',\n            '                    ',\n            '                    if new_selector:',\n            '                        print(f\"  â†’ MCP found new selector: {new_selector}\")',\n            '                        if action == \"click\" and self.mcp_service.click_element(new_selector):',\n            '                            print(f\"  âœ“ Healed via MCP with new selector\")',\n            '                            self.update_script(step_num, selector, new_selector, \"mcp\")',\n            '                            self.mcp_service.stop_server()',\n            '                            return new_selector',\n            '                    ',\n            '                    # Fallback: try original selector',\n            '                    if action == \"click\" and self.mcp_service.click_element(selector):',\n            '                        print(f\"  âœ“ Healed via MCP\")',\n            '                        self.update_script(step_num, selector, selector, \"mcp\")',\n            '                        self.mcp_service.stop_server()',\n            '                        return selector',\n            '                        ',\n            '                self.mcp_service.stop_server()',\n            '        except Exception as e:',\n            '            print(f\"  âœ— MCP healing failed: {e}\")',\n            '        ',\n            '        print(f\"  âœ— All healing attempts failed\")',\n            '        return None',\n            '    ',\n            '    def update_script(self, step_num: int, old_selector: str, new_selector: str, healing_source: str):',\n            '        \"\"\"Update this script file with healed selector\"\"\"',\n            '        try:',\n            '            with open(self.script_path, \"r\") as f:',\n            '                lines = f.readlines()',\n            '            ',\n            '            # Find and update the step',\n            '            step_comment = f\"# Step {step_num}:\"',\n            '            in_step = False',\n            '            updated_lines = []',\n            '            ',\n            '            for line in lines:',\n            '                if step_comment in line:',\n            '                    # Update comment to show it was healed',\n            '                    updated_lines.append(line.replace(step_comment, f\"# Step {step_num}: (Healed via {healing_source})\"))',\n            '                    in_step = True',\n            '                elif in_step and old_selector in line:',\n            '                    # Replace old selector with new one in the actual code',\n            '                    updated_lines.append(line.replace(old_selector, new_selector))',\n            '                    in_step = False',\n            '                else:',\n            '                    updated_lines.append(line)',\n            '            ',\n            '            with open(self.script_path, \"w\") as f:',\n            '                f.writelines(updated_lines)',\n            '            ',\n            '            print(f\"  âœ“ Script updated: {old_selector} â†’ {new_selector}\")',\n            '        except Exception as e:',\n            '            print(f\"  Warning: Could not update script: {e}\")',\n            '    ',\n            '    async def run(self):',\n            '        \"\"\"Execute the automated workflow with self-healing\"\"\"',\n            '        await self.initialize_healing()',\n            '        ',\n            '        failed_steps = []',\n            '        total_steps = 0',\n            '        ',\n        ]\n        \n        # Generate steps with healing logic\n        for log in action_logs:\n            if log.status in ['success', 'healed']:\n                total_steps += 1\n                script_lines.extend(self._generate_self_healing_step_code(log))\n        \n        script_lines.extend([\n            '        ',\n            '        if failed_steps:',\n            '            print(f\"\\\\nâš  Automation completed with {len(failed_steps)} failed step(s)\")',\n            '            print(f\"Failed steps: {failed_steps}\")',\n            '            return False',\n            '        else:',\n            '            print(\"\\\\nâœ“ Automation completed successfully\")',\n            '            return True',\n            '',\n            '',\n            'async def main():',\n            '    \"\"\"Main entry point\"\"\"',\n            '    async with async_playwright() as p:',\n            f'        browser = await p.chromium.launch(headless={headless})',\n            '        context = await browser.new_context(',\n            '            viewport={\"width\": 1920, \"height\": 1080}',\n            '        )',\n            '        page = await context.new_page()',\n            '        ',\n            '        script_path = os.path.abspath(__file__)',\n            '        healer = SelfHealingScript(page, script_path)',\n            '        success = await healer.run()',\n            '',\n            '        await page.wait_for_timeout(2000)',\n            '        await browser.close()',\n            '',\n            '        return 0 if success else 1',\n            '',\n            '',\n            'if __name__ == \"__main__\":',\n            '    exit_code = asyncio.run(main())',\n            '    sys.exit(exit_code)',\n        ])\n        \n        return '\\n'.join(script_lines)\n    \n    def _generate_self_healing_step_code(self, log: ActionLog) -> List[str]:\n        \"\"\"Generate code for a single step with self-healing capability\"\"\"\n        lines = []\n        step_num = log.step_number\n        action_type = log.action_type\n        locator = log.healed_locator or log.locator\n        selector = self._extract_selector(locator)\n        \n        lines.append(f'        # Step {step_num}: {action_type}')\n        if log.healing_source:\n            lines.append(f'        # Previously healed via: {log.healing_source}')\n        \n        lines.append(f'        try:')\n        \n        # Generate the actual step code with try-except\n        if log.url:\n            lines.append(f'            print(\"Step {step_num}: Navigating to {log.url}\")')\n            lines.append(f'            await self.page.goto(\"{log.url}\")')\n            lines.append('            await self.page.wait_for_load_state(\"networkidle\")')\n        \n        if action_type == 'click':\n            if locator:\n                lines.append(f'            print(\"Step {step_num}: Clicking element: {selector}\")')\n                lines.append(f'            await self.page.click(\"{selector}\")')\n                lines.append('            await self.page.wait_for_timeout(500)')\n        \n        elif action_type == 'fill':\n            if locator:\n                value = locator.get('value', '') if isinstance(locator, dict) else ''\n                lines.append(f'            print(\"Step {step_num}: Filling field: {selector}\")')\n                lines.append(f'            await self.page.fill(\"{selector}\", \"{value}\")')\n                lines.append('            await self.page.wait_for_timeout(300)')\n        \n        elif action_type == 'select':\n            if locator:\n                value = locator.get('value', '') if isinstance(locator, dict) else ''\n                lines.append(f'            print(\"Step {step_num}: Selecting option: {value}\")')\n                lines.append(f'            await self.page.select_option(\"{selector}\", \"{value}\")')\n                lines.append('            await self.page.wait_for_timeout(300)')\n        \n        elif action_type == 'wait':\n            timeout = log.execution_time * 1000 if log.execution_time else 5000\n            lines.append(f'            await self.page.wait_for_timeout({int(timeout)})')\n        \n        # Add healing logic\n        lines.append(f'            total_steps += 1')\n        lines.append(f'        except Exception as e:')\n        lines.append(f'            print(f\"âœ— Step {step_num} failed: {{e}}\")')\n        lines.append(f'            ')\n        lines.append(f'            # Attempt healing')\n        lines.append(f'            healed_selector = await self.heal_step({step_num}, \"{action_type}\", \"{selector}\", str(e))')\n        lines.append(f'            ')\n        lines.append(f'            if healed_selector:')\n        lines.append(f'                print(f\"âœ“ Step {step_num} healed successfully, continuing...\")')\n        lines.append(f'                total_steps += 1')\n        lines.append(f'            else:')\n        lines.append(f'                print(f\"âœ— Step {step_num} could not be healed, marking as failed\")')\n        lines.append(f'                failed_steps.append({step_num})')\n        lines.append(f'                # Continue to next step despite failure')\n        lines.append('')\n        \n        return lines\n    \n    def _generate_step_code(self, log: ActionLog) -> List[str]:\n        \"\"\"Generate code for a single step (legacy method for compatibility)\"\"\"\n        lines = []\n        \n        lines.append(f'        # Step {log.step_number}: {log.action_type}')\n        \n        if log.healing_source:\n            lines.append(f'        # Healed via: {log.healing_source}')\n        \n        locator = log.healed_locator or log.locator\n        \n        if log.url:\n            lines.append(f'        print(\"Navigating to: {log.url}\")')\n            lines.append(f'        await page.goto(\"{log.url}\")')\n            lines.append('        await page.wait_for_load_state(\"networkidle\")')\n        \n        if log.action_type == 'click':\n            if locator:\n                selector = self._extract_selector(locator)\n                lines.append(f'        print(\"Clicking element: {selector}\")')\n                lines.append(f'        await page.click(\"{selector}\")')\n                lines.append('        await page.wait_for_timeout(500)')\n        \n        elif log.action_type == 'fill':\n            if locator:\n                selector = self._extract_selector(locator)\n                value = locator.get('value', '') if isinstance(locator, dict) else ''\n                lines.append(f'        print(\"Filling field: {selector}\")')\n                lines.append(f'        await page.fill(\"{selector}\", \"{value}\")')\n                lines.append('        await page.wait_for_timeout(300)')\n        \n        elif log.action_type == 'select':\n            if locator:\n                selector = self._extract_selector(locator)\n                value = locator.get('value', '') if isinstance(locator, dict) else ''\n                lines.append(f'        print(\"Selecting option: {value}\")')\n                lines.append(f'        await page.select_option(\"{selector}\", \"{value}\")')\n                lines.append('        await page.wait_for_timeout(300)')\n        \n        elif log.action_type == 'wait':\n            timeout = log.execution_time * 1000 if log.execution_time else 5000\n            lines.append(f'        await page.wait_for_timeout({int(timeout)})')\n        \n        lines.append('')\n        \n        return lines\n    \n    def _extract_selector(self, locator: Any) -> str:\n        \"\"\"Extract a CSS selector from locator data\"\"\"\n        if isinstance(locator, dict):\n            if 'value' in locator:\n                return locator['value']\n            if 'selector' in locator:\n                return locator['selector']\n            if 'css' in locator:\n                return locator['css']\n            if 'xpath' in locator:\n                return f\"xpath={locator['xpath']}\"\n        \n        if isinstance(locator, str):\n            return locator\n        \n        return 'body'\n    \n    def get_script_path(self, task_id: int) -> str:\n        \"\"\"Get the path to a generated script for a task\"\"\"\n        try:\n            files = os.listdir(self.output_dir)\n            task_files = [f for f in files if f.startswith(f'task_{task_id}_')]\n            \n            if task_files:\n                task_files.sort(reverse=True)\n                return os.path.join(self.output_dir, task_files[0])\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error getting script path: {e}\")\n            return None\n","size_bytes":19568},"app/__init__.py":{"content":"# Flask application package\n","size_bytes":28},"app/services/healing_orchestrator.py":{"content":"import asyncio\nimport logging\nimport time\nfrom typing import Dict, Any, Optional\nfrom app.services.browser_use_service import BrowserUseService\nfrom app.services.mcp_service import MCPServerService\nfrom app.models.database import DatabaseManager, ActionLog, HealingEvent, Task\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nclass HealingOrchestrator:\n    def __init__(self, config: Dict[str, Any], db_manager: DatabaseManager):\n        self.config = config\n        self.db_manager = db_manager\n        self.browser_use_service = BrowserUseService(config.get('browser', {}))\n        self.mcp_service = MCPServerService(config.get('mcp', {}))\n        self.healing_config = config.get('healing', {})\n    \n    async def execute_with_healing(self, task_id: int, instruction: str, emit_callback=None) -> Dict[str, Any]:\n        \"\"\"Execute instruction with automatic healing on failures\"\"\"\n        try:\n            session = self.db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            \n            if not task:\n                return {'success': False, 'error': 'Task not found'}\n            \n            task.status = 'running'\n            task.started_at = datetime.utcnow()\n            session.commit()\n            \n            if emit_callback:\n                emit_callback('task_update', task.to_dict())\n            \n            logger.info(f\"Starting execution of task {task_id}: {instruction}\")\n            \n            await self.browser_use_service.initialize()\n            \n            start_time = time.time()\n            result = await self.browser_use_service.execute_task(instruction)\n            execution_time = time.time() - start_time\n            \n            action_log = ActionLog(\n                task_id=task_id,\n                step_number=1,\n                action_type='execute_instruction',\n                status='success' if result['success'] else 'failed',\n                error_message=result.get('error'),\n                execution_time=execution_time,\n                locator={'type': 'natural_language', 'value': instruction},\n                healing_attempted=False\n            )\n            session.add(action_log)\n            session.commit()\n            \n            if emit_callback:\n                emit_callback('step_update', action_log.to_dict())\n            \n            if result['success']:\n                task.status = 'completed'\n                task.completed_at = datetime.utcnow()\n                task.successful_steps = 1\n                task.total_steps = 1\n            else:\n                logger.warning(f\"Initial execution failed, attempting healing: {result.get('error')}\")\n                \n                healing_result = await self._attempt_healing_flow(\n                    task_id=task_id,\n                    instruction=instruction,\n                    original_error=result.get('error'),\n                    emit_callback=emit_callback\n                )\n                \n                if healing_result['success']:\n                    task.status = 'completed'\n                    task.completed_at = datetime.utcnow()\n                    task.healed_steps = 1\n                    task.successful_steps = 1\n                    task.total_steps = 1\n                    result = healing_result\n                else:\n                    task.status = 'failed'\n                    task.completed_at = datetime.utcnow()\n                    task.failed_steps = 1\n                    task.total_steps = 1\n                    task.error_message = healing_result.get('error')\n            \n            session.commit()\n            \n            if emit_callback:\n                emit_callback('task_update', task.to_dict())\n            \n            await self.browser_use_service.close()\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error in execute_with_healing: {e}\")\n            session = self.db_manager.get_session()\n            task = session.query(Task).filter_by(id=task_id).first()\n            if task:\n                task.status = 'failed'\n                task.error_message = str(e)\n                task.completed_at = datetime.utcnow()\n                session.commit()\n            \n            return {'success': False, 'error': str(e)}\n        finally:\n            self.db_manager.close_session()\n    \n    async def _attempt_healing_flow(self, task_id: int, instruction: str, original_error: str, emit_callback=None) -> Dict[str, Any]:\n        \"\"\"Attempt to heal failed execution using browser-use first, then MCP\"\"\"\n        logger.info(f\"Starting healing flow for task {task_id}\")\n        \n        session = self.db_manager.get_session()\n        \n        action_log = session.query(ActionLog).filter_by(task_id=task_id, step_number=1).first()\n        \n        if action_log:\n            action_log.healing_attempted = True\n            action_log.status = 'healing'\n            session.commit()\n            action_log_id = action_log.id\n        else:\n            action_log = ActionLog(\n                task_id=task_id,\n                step_number=1,\n                action_type='execute_instruction',\n                status='healing',\n                error_message=original_error,\n                healing_attempted=True,\n                retry_count=0\n            )\n            session.add(action_log)\n            session.commit()\n            action_log_id = action_log.id\n        \n        if emit_callback:\n            emit_callback('step_update', action_log.to_dict())\n        \n        browser_use_retries = self.healing_config.get('browser_use_retry_limit', 2)\n        for retry in range(browser_use_retries):\n            logger.info(f\"Attempting browser-use healing, retry {retry + 1}/{browser_use_retries}\")\n            \n            if emit_callback:\n                emit_callback('healing_attempt', {\n                    'task_id': task_id,\n                    'source': 'browser-use',\n                    'retry': retry + 1,\n                    'max_retries': browser_use_retries\n                })\n            \n            start_time = time.time()\n            result = await self.browser_use_service.execute_task(instruction)\n            healing_time = time.time() - start_time\n            \n            healing_event = HealingEvent(\n                action_log_id=action_log_id,\n                task_id=task_id,\n                healing_source='browser-use',\n                original_locator={'type': 'instruction', 'value': instruction},\n                healed_locator={'type': 'retry', 'value': f'attempt_{retry + 1}'},\n                success=result['success'],\n                error_message=result.get('error'),\n                healing_time=healing_time\n            )\n            session.add(healing_event)\n            session.commit()\n            \n            if emit_callback:\n                emit_callback('healing_event', healing_event.to_dict())\n            \n            if result['success']:\n                logger.info(f\"Browser-use healing successful on retry {retry + 1}\")\n                \n                action_log.status = 'healed'\n                action_log.healing_source = 'browser-use'\n                action_log.retry_count = retry + 1\n                session.commit()\n                \n                if emit_callback:\n                    emit_callback('step_update', action_log.to_dict())\n                \n                return result\n            \n            await asyncio.sleep(1)\n        \n        logger.info(\"Browser-use healing failed, attempting MCP healing\")\n        \n        if emit_callback:\n            emit_callback('healing_fallback', {\n                'task_id': task_id,\n                'from': 'browser-use',\n                'to': 'mcp'\n            })\n        \n        mcp_result = await self._heal_with_mcp(\n            task_id=task_id,\n            action_log_id=action_log_id,\n            instruction=instruction,\n            emit_callback=emit_callback\n        )\n        \n        if mcp_result['success']:\n            action_log.status = 'healed'\n            action_log.healing_source = 'mcp'\n            session.commit()\n            \n            if emit_callback:\n                emit_callback('step_update', action_log.to_dict())\n        else:\n            action_log.status = 'failed'\n            session.commit()\n            \n            if emit_callback:\n                emit_callback('step_update', action_log.to_dict())\n        \n        self.db_manager.close_session()\n        return mcp_result\n    \n    async def _heal_with_mcp(self, task_id: int, action_log_id: int, instruction: str, emit_callback=None) -> Dict[str, Any]:\n        \"\"\"Attempt healing using Microsoft Playwright MCP server\"\"\"\n        try:\n            session = self.db_manager.get_session()\n            \n            if not self.mcp_service.start_server():\n                return {'success': False, 'error': 'Failed to start MCP server'}\n            \n            mcp_retries = self.healing_config.get('mcp_retry_limit', 2)\n            \n            for retry in range(mcp_retries):\n                logger.info(f\"Attempting MCP healing, retry {retry + 1}/{mcp_retries}\")\n                \n                if emit_callback:\n                    emit_callback('healing_attempt', {\n                        'task_id': task_id,\n                        'source': 'mcp',\n                        'retry': retry + 1,\n                        'max_retries': mcp_retries\n                    })\n                \n                start_time = time.time()\n                \n                success = await self._execute_instruction_with_mcp(instruction)\n                \n                healing_time = time.time() - start_time\n                \n                healing_event = HealingEvent(\n                    action_log_id=action_log_id,\n                    task_id=task_id,\n                    healing_source='mcp',\n                    original_locator={'type': 'instruction', 'value': instruction},\n                    healed_locator={'type': 'mcp_execution', 'value': f'attempt_{retry + 1}'},\n                    success=success,\n                    error_message=None if success else 'MCP execution failed',\n                    healing_time=healing_time\n                )\n                session.add(healing_event)\n                session.commit()\n                \n                if emit_callback:\n                    emit_callback('healing_event', healing_event.to_dict())\n                \n                if success:\n                    logger.info(f\"MCP healing successful on retry {retry + 1}\")\n                    self.db_manager.close_session()\n                    return {\n                        'success': True,\n                        'result': 'Healed via MCP',\n                        'healing_source': 'mcp',\n                        'execution_time': healing_time\n                    }\n                \n                await asyncio.sleep(1)\n            \n            self.db_manager.close_session()\n            return {'success': False, 'error': 'MCP healing failed after all retries'}\n            \n        except Exception as e:\n            logger.error(f\"Error in MCP healing: {e}\")\n            return {'success': False, 'error': str(e)}\n        finally:\n            self.mcp_service.stop_server()\n    \n    async def _execute_instruction_with_mcp(self, instruction: str) -> bool:\n        \"\"\"Execute a simplified instruction using MCP commands\"\"\"\n        try:\n            instruction_lower = instruction.lower()\n            \n            if 'go to' in instruction_lower or 'navigate' in instruction_lower:\n                url_start = instruction_lower.find('http')\n                if url_start == -1:\n                    url_start = instruction_lower.find('www.')\n                \n                if url_start != -1:\n                    url = instruction[url_start:].split()[0]\n                    return self.mcp_service.navigate(url)\n            \n            elif 'click' in instruction_lower:\n                return True\n            \n            elif 'fill' in instruction_lower or 'type' in instruction_lower:\n                return True\n            \n            return False\n            \n        except Exception as e:\n            logger.error(f\"Error executing instruction with MCP: {e}\")\n            return False\n","size_bytes":12342},"main.py":{"content":"from application import app, socketio, logger\n\nif __name__ == '__main__':\n    logger.info(\"Starting Self-Healing Browser Automation System\")\n    logger.info(f\"Dashboard available at: http://0.0.0.0:5000\")\n    socketio.run(app, host='0.0.0.0', port=5000, debug=True, allow_unsafe_werkzeug=True)\n","size_bytes":294},"app/static/css/style.css":{"content":":root {\n    --bg-primary: #0f1117;\n    --bg-secondary: #16181f;\n    --bg-tertiary: #1c1e27;\n    --purple: #a78bfa;\n    --purple-hover: #8b5cf6;\n    --text-white: #ffffff;\n    --text-gray: #9ca3af;\n    --border: #2d3142;\n    --green: #10b981;\n    --red: #ef4444;\n}\n\n* {\n    scrollbar-width: thin;\n    scrollbar-color: var(--bg-tertiary) var(--bg-primary);\n}\n\n*::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n*::-webkit-scrollbar-track {\n    background: var(--bg-primary);\n}\n\n*::-webkit-scrollbar-thumb {\n    background-color: var(--bg-tertiary);\n    border-radius: 4px;\n}\n\nbody {\n    background-color: var(--bg-primary);\n    color: var(--text-white);\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n}\n\n.navbar {\n    background-color: var(--bg-secondary) !important;\n    border-bottom: 1px solid var(--border);\n    box-shadow: 0 2px 8px rgba(0,0,0,.5);\n}\n\n.navbar-brand {\n    color: var(--text-white) !important;\n    font-weight: 600;\n}\n\n.badge {\n    padding: 0.5rem 1rem;\n}\n\n.badge.bg-success {\n    background-color: var(--green) !important;\n}\n\n.card {\n    background-color: var(--bg-secondary);\n    border: 1px solid var(--border);\n    box-shadow: 0 4px 6px rgba(0,0,0,.3);\n    color: var(--text-white);\n}\n\n.card-header {\n    font-weight: 600;\n    background-color: var(--bg-tertiary);\n    border-bottom: 1px solid var(--border);\n    color: var(--text-white);\n}\n\n.btn-primary {\n    background-color: var(--purple);\n    border-color: var(--purple);\n    color: var(--bg-primary);\n    font-weight: 600;\n}\n\n.btn-primary:hover {\n    background-color: var(--purple-hover);\n    border-color: var(--purple-hover);\n    color: var(--bg-primary);\n}\n\n.btn-primary:active,\n.btn-primary:focus {\n    background-color: var(--purple-hover);\n    border-color: var(--purple-hover);\n    color: var(--bg-primary);\n    box-shadow: 0 0 0 0.2rem rgba(167, 139, 250, 0.3);\n}\n\n.btn-secondary {\n    background-color: var(--bg-tertiary);\n    border-color: var(--border);\n    color: var(--text-white);\n}\n\n.btn-secondary:hover {\n    background-color: #23252e;\n    border-color: var(--border);\n    color: var(--text-white);\n}\n\n.btn-success {\n    background-color: var(--green);\n    border-color: var(--green);\n}\n\n.btn-danger {\n    background-color: var(--red);\n    border-color: var(--red);\n}\n\n.btn-info {\n    background-color: var(--purple);\n    border-color: var(--purple);\n}\n\n.form-control {\n    background-color: var(--bg-tertiary);\n    border: 1px solid var(--border);\n    color: var(--text-white);\n}\n\n.form-control:focus {\n    background-color: var(--bg-tertiary);\n    border-color: var(--purple);\n    color: var(--text-white);\n    box-shadow: 0 0 0 0.2rem rgba(167, 139, 250, 0.25);\n}\n\n.form-control::placeholder {\n    color: var(--text-gray);\n}\n\ntextarea.form-control {\n    resize: vertical;\n}\n\n.execution-monitor {\n    min-height: 300px;\n    max-height: 400px;\n    overflow-y: auto;\n    background-color: var(--bg-tertiary);\n    border-radius: 0.5rem;\n    padding: 1rem;\n    border: 1px solid var(--border);\n}\n\n.execution-monitor .text-muted {\n    color: var(--text-gray) !important;\n}\n\n.execution-step {\n    padding: 0.75rem;\n    margin-bottom: 0.5rem;\n    border-left: 4px solid var(--border);\n    background-color: var(--bg-secondary);\n    border-radius: 0.25rem;\n    transition: all 0.3s ease;\n}\n\n.execution-step.pending {\n    border-left-color: var(--text-gray);\n}\n\n.execution-step.running {\n    border-left-color: var(--purple);\n    animation: pulse 2s ease-in-out infinite;\n}\n\n.execution-step.success {\n    border-left-color: var(--green);\n}\n\n.execution-step.failed {\n    border-left-color: var(--red);\n}\n\n.execution-step.healed {\n    border-left-color: var(--purple);\n}\n\n@keyframes pulse {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.7;\n    }\n}\n\n.healing-badge {\n    font-size: 0.75rem;\n    padding: 0.25rem 0.5rem;\n}\n\n.step-icon {\n    display: inline-block;\n    width: 24px;\n    height: 24px;\n    line-height: 24px;\n    text-align: center;\n    border-radius: 50%;\n    margin-right: 0.5rem;\n}\n\n.step-icon.pending {\n    background-color: var(--text-gray);\n    color: var(--text-white);\n}\n\n.step-icon.running {\n    background-color: var(--purple);\n    color: var(--bg-primary);\n}\n\n.step-icon.success {\n    background-color: var(--green);\n    color: var(--text-white);\n}\n\n.step-icon.failed {\n    background-color: var(--red);\n    color: var(--text-white);\n}\n\n.step-icon.healed {\n    background-color: var(--purple);\n    color: var(--text-white);\n}\n\n.status-badge {\n    font-size: 0.8rem;\n    padding: 0.35rem 0.6rem;\n}\n\n.table {\n    color: var(--text-white);\n}\n\n.table thead th {\n    background-color: var(--bg-tertiary);\n    border-color: var(--border);\n    color: var(--text-white);\n}\n\n.table tbody tr {\n    cursor: pointer;\n    background-color: var(--bg-secondary);\n    border-color: var(--border);\n}\n\n.table tbody tr:hover {\n    background-color: var(--bg-tertiary);\n}\n\n.table tbody td {\n    border-color: var(--border);\n}\n\n.healing-event {\n    padding: 0.5rem;\n    margin: 0.5rem 0;\n    border-radius: 0.25rem;\n    background-color: var(--bg-tertiary);\n}\n\n.healing-event.success {\n    border-left: 3px solid var(--green);\n}\n\n.healing-event.failed {\n    border-left: 3px solid var(--red);\n}\n\n#connectionStatus {\n    font-size: 0.85rem;\n}\n\n.spinner-border-sm {\n    width: 1rem;\n    height: 1rem;\n    border-width: 0.15rem;\n}\n\n.sticky-top {\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.action-log-item {\n    padding: 0.75rem;\n    margin: 0.5rem 0;\n    border-radius: 0.25rem;\n    background-color: var(--bg-secondary);\n    border: 1px solid var(--border);\n}\n\n.action-log-item .step-number {\n    font-weight: bold;\n    color: var(--purple);\n}\n\n.code-block {\n    background-color: var(--bg-tertiary);\n    padding: 1rem;\n    border-radius: 0.25rem;\n    font-family: 'Courier New', monospace;\n    font-size: 0.875rem;\n    overflow-x: auto;\n    border: 1px solid var(--border);\n}\n\n.text-muted {\n    color: var(--text-gray) !important;\n}\n\n.bg-primary {\n    background-color: var(--purple) !important;\n}\n\n.bg-success {\n    background-color: var(--green) !important;\n}\n\n.bg-danger {\n    background-color: var(--red) !important;\n}\n\n.bg-warning {\n    background-color: var(--purple) !important;\n}\n\n.bg-info {\n    background-color: var(--purple) !important;\n}\n\n.text-success {\n    color: var(--green) !important;\n}\n\n.text-danger {\n    color: var(--red) !important;\n}\n\n.text-warning {\n    color: var(--purple) !important;\n}\n\n.text-info {\n    color: var(--purple) !important;\n}\n\nh1, h2, h3, h4, h5, h6 {\n    color: var(--text-white);\n}\n\n.alert {\n    border: 1px solid var(--border);\n}\n\n.alert-info {\n    background-color: rgba(167, 139, 250, 0.1);\n    border-color: var(--purple);\n    color: var(--text-white);\n}\n\n.alert-success {\n    background-color: rgba(16, 185, 129, 0.1);\n    border-color: var(--green);\n    color: var(--text-white);\n}\n\n.alert-warning {\n    background-color: rgba(167, 139, 250, 0.1);\n    border-color: var(--purple);\n    color: var(--text-white);\n}\n\n.alert-danger {\n    background-color: rgba(239, 68, 68, 0.1);\n    border-color: var(--red);\n    color: var(--text-white);\n}\n\n.modal-content {\n    background-color: var(--bg-secondary);\n    border: 1px solid var(--border);\n}\n\n.modal-header {\n    border-bottom: 1px solid var(--border);\n}\n\n.modal-footer {\n    border-top: 1px solid var(--border);\n}\n\n.close {\n    color: var(--text-white);\n}\n\na {\n    color: var(--purple);\n}\n\na:hover {\n    color: var(--purple-hover);\n}\n\nhr {\n    border-color: var(--border);\n}\n\n.badge.bg-secondary {\n    background-color: var(--bg-tertiary) !important;\n    color: var(--text-white);\n}\n\n.form-check-input {\n    background-color: var(--bg-tertiary);\n    border-color: var(--border);\n}\n\n.form-check-input:checked {\n    background-color: var(--purple);\n    border-color: var(--purple);\n}\n\n.form-check-input:focus {\n    border-color: var(--purple);\n    box-shadow: 0 0 0 0.2rem rgba(167, 139, 250, 0.25);\n}\n\n.form-check-label {\n    color: var(--text-white);\n    cursor: pointer;\n}\n\n.form-switch .form-check-input {\n    cursor: pointer;\n}\n","size_bytes":8118},"app/services/mcp_service.py":{"content":"import subprocess\nimport json\nimport os\nimport time\nimport logging\nfrom typing import Dict, Any, Optional\nimport threading\n\nlogger = logging.getLogger(__name__)\n\nclass MCPServerService:\n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.process = None\n        self.browser_context = None\n        self.page_url = None\n        self.lock = threading.Lock()\n        \n    def start_server(self) -> bool:\n        \"\"\"Start the Microsoft Playwright MCP server\"\"\"\n        try:\n            with self.lock:\n                if self.process and self.process.poll() is None:\n                    logger.info(\"MCP server already running\")\n                    return True\n                \n                mcp_command = [\"npx\", \"-y\", \"@playwright/mcp@latest\"]\n                \n                browser = self.config.get('browser', 'chromium')\n                if browser != 'chromium':\n                    mcp_command.extend(['--browser', browser])\n                \n                mcp_command.append('--headless')\n                \n                logger.info(f\"Starting MCP server with command: {' '.join(mcp_command)}\")\n                \n                self.process = subprocess.Popen(\n                    mcp_command,\n                    stdin=subprocess.PIPE,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    text=True,\n                    bufsize=1\n                )\n                \n                time.sleep(self.config.get('server_startup_timeout', 10))\n                \n                if self.process.poll() is not None:\n                    stderr = self.process.stderr.read()\n                    logger.error(f\"MCP server failed to start: {stderr}\")\n                    return False\n                \n                logger.info(\"MCP server started successfully\")\n                return True\n                \n        except Exception as e:\n            logger.error(f\"Error starting MCP server: {e}\")\n            return False\n    \n    def stop_server(self):\n        \"\"\"Stop the MCP server\"\"\"\n        try:\n            with self.lock:\n                if self.process:\n                    self.process.terminate()\n                    try:\n                        self.process.wait(timeout=5)\n                    except subprocess.TimeoutExpired:\n                        self.process.kill()\n                    self.process = None\n                    logger.info(\"MCP server stopped\")\n        except Exception as e:\n            logger.error(f\"Error stopping MCP server: {e}\")\n    \n    def send_command(self, tool: str, arguments: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Send a command to the MCP server\"\"\"\n        try:\n            if not self.process or self.process.poll() is not None:\n                logger.error(\"MCP server not running\")\n                return None\n            \n            command = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": int(time.time() * 1000),\n                \"method\": \"tools/call\",\n                \"params\": {\n                    \"name\": tool,\n                    \"arguments\": arguments\n                }\n            }\n            \n            with self.lock:\n                self.process.stdin.write(json.dumps(command) + '\\n')\n                self.process.stdin.flush()\n                \n                response_line = self.process.stdout.readline()\n                if response_line:\n                    response = json.loads(response_line)\n                    return response\n                    \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error sending MCP command: {e}\")\n            return None\n    \n    def navigate(self, url: str) -> bool:\n        \"\"\"Navigate to a URL using MCP\"\"\"\n        try:\n            logger.info(f\"MCP navigating to: {url}\")\n            result = self.send_command(\"browser_navigate\", {\"url\": url})\n            \n            if result and not result.get('error'):\n                self.page_url = url\n                logger.info(f\"Successfully navigated to {url}\")\n                return True\n            else:\n                error = result.get('error', {}).get('message', 'Unknown error') if result else 'No response'\n                logger.error(f\"Failed to navigate: {error}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error navigating with MCP: {e}\")\n            return False\n    \n    def click_element(self, selector: str) -> bool:\n        \"\"\"Click an element using MCP\"\"\"\n        try:\n            logger.info(f\"MCP clicking element: {selector}\")\n            \n            js_code = f\"\"\"\n            const element = document.querySelector('{selector}');\n            if (element) {{\n                element.click();\n                return true;\n            }}\n            return false;\n            \"\"\"\n            \n            result = self.send_command(\"browser_evaluate\", {\"script\": js_code})\n            \n            if result and not result.get('error'):\n                success = result.get('result', {}).get('content', [{}])[0].get('text', 'false') == 'true'\n                if success:\n                    logger.info(f\"Successfully clicked element: {selector}\")\n                    return True\n                else:\n                    logger.warning(f\"Element not found: {selector}\")\n                    return False\n            else:\n                error = result.get('error', {}).get('message', 'Unknown error') if result else 'No response'\n                logger.error(f\"Failed to click: {error}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error clicking element with MCP: {e}\")\n            return False\n    \n    def fill_input(self, selector: str, value: str) -> bool:\n        \"\"\"Fill an input field using MCP\"\"\"\n        try:\n            logger.info(f\"MCP filling input: {selector} with value: {value}\")\n            \n            js_code = f\"\"\"\n            const element = document.querySelector('{selector}');\n            if (element) {{\n                element.value = '{value}';\n                element.dispatchEvent(new Event('input', {{ bubbles: true }}));\n                element.dispatchEvent(new Event('change', {{ bubbles: true }}));\n                return true;\n            }}\n            return false;\n            \"\"\"\n            \n            result = self.send_command(\"browser_evaluate\", {\"script\": js_code})\n            \n            if result and not result.get('error'):\n                success = result.get('result', {}).get('content', [{}])[0].get('text', 'false') == 'true'\n                if success:\n                    logger.info(f\"Successfully filled input: {selector}\")\n                    return True\n                else:\n                    logger.warning(f\"Input element not found: {selector}\")\n                    return False\n            else:\n                error = result.get('error', {}).get('message', 'Unknown error') if result else 'No response'\n                logger.error(f\"Failed to fill input: {error}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error filling input with MCP: {e}\")\n            return False\n    \n    def get_element_locator(self, description: str, page_content: str = None) -> Optional[str]:\n        \"\"\"Generate a CSS selector for an element based on description using MCP\"\"\"\n        try:\n            logger.info(f\"MCP generating locator for: {description}\")\n            \n            js_code = f\"\"\"\n            // Try to find element by common patterns\n            let selector = null;\n            const desc = '{description}'.toLowerCase();\n            \n            // Try by text content\n            const elements = Array.from(document.querySelectorAll('button, a, input, label, h1, h2, h3, h4, h5, h6, span, div'));\n            for (const el of elements) {{\n                const text = el.textContent.toLowerCase().trim();\n                if (text.includes(desc) || desc.includes(text)) {{\n                    // Generate unique selector\n                    if (el.id) {{\n                        selector = '#' + el.id;\n                        break;\n                    }}\n                    if (el.className) {{\n                        const classes = Array.from(el.classList).join('.');\n                        selector = el.tagName.toLowerCase() + '.' + classes;\n                        if (document.querySelectorAll(selector).length === 1) {{\n                            break;\n                        }}\n                    }}\n                    selector = el.tagName.toLowerCase();\n                }}\n            }}\n            \n            // Try by placeholder\n            if (!selector) {{\n                const input = document.querySelector(`input[placeholder*=\"${{desc}}\"]`);\n                if (input) {{\n                    if (input.id) selector = '#' + input.id;\n                    else if (input.name) selector = `input[name=\"${{input.name}}\"]`;\n                    else selector = `input[placeholder=\"${{input.placeholder}}\"]`;\n                }}\n            }}\n            \n            // Try by aria-label\n            if (!selector) {{\n                const ariaEl = document.querySelector(`[aria-label*=\"${{desc}}\"]`);\n                if (ariaEl && ariaEl.id) selector = '#' + ariaEl.id;\n            }}\n            \n            selector || 'NONE';\n            \"\"\"\n            \n            result = self.send_command(\"browser_evaluate\", {\"script\": js_code})\n            \n            if result and not result.get('error'):\n                selector = result.get('result', {}).get('content', [{}])[0].get('text', 'NONE')\n                if selector != 'NONE':\n                    logger.info(f\"Generated locator: {selector} for description: {description}\")\n                    return selector\n                else:\n                    logger.warning(f\"Could not generate locator for: {description}\")\n                    return None\n            else:\n                error = result.get('error', {}).get('message', 'Unknown error') if result else 'No response'\n                logger.error(f\"Failed to generate locator: {error}\")\n                return None\n                \n        except Exception as e:\n            logger.error(f\"Error generating locator with MCP: {e}\")\n            return None\n    \n    def wait_for_element(self, selector: str, timeout: int = 30) -> bool:\n        \"\"\"Wait for an element to appear\"\"\"\n        try:\n            logger.info(f\"MCP waiting for element: {selector}\")\n            \n            js_code = f\"\"\"\n            new Promise((resolve) => {{\n                const checkExist = setInterval(() => {{\n                    if (document.querySelector('{selector}')) {{\n                        clearInterval(checkExist);\n                        resolve(true);\n                    }}\n                }}, 100);\n                \n                setTimeout(() => {{\n                    clearInterval(checkExist);\n                    resolve(false);\n                }}, {timeout * 1000});\n            }});\n            \"\"\"\n            \n            result = self.send_command(\"browser_evaluate\", {\"script\": js_code})\n            \n            if result and not result.get('error'):\n                success = result.get('result', {}).get('content', [{}])[0].get('text', 'false') == 'true'\n                if success:\n                    logger.info(f\"Element appeared: {selector}\")\n                    return True\n                else:\n                    logger.warning(f\"Element did not appear within timeout: {selector}\")\n                    return False\n            else:\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error waiting for element with MCP: {e}\")\n            return False\n    \n    def __del__(self):\n        \"\"\"Cleanup when object is destroyed\"\"\"\n        self.stop_server()\n","size_bytes":11979},"app/services/__init__.py":{"content":"# Services package\n","size_bytes":19},"replit.md":{"content":"# Self-Healing Browser Automation System\n\n## Project Overview\n\nProduction-ready Flask web application that implements a self-healing browser automation system. The system uses browser-use for AI-powered automation with Microsoft Playwright MCP server as an intelligent fallback for locator healing.\n\n## Recent Changes\n\n- **2025-10-23**: Initial project creation\n  - Complete Flask application with WebSocket support\n  - Database models for tasks, action logs, and healing events\n  - Browser-use service integration\n  - Microsoft Playwright MCP server integration\n  - Healing orchestrator with two-tier healing logic\n  - Code generator for Playwright scripts\n  - Professional dashboard UI with real-time monitoring\n\n## Project Architecture\n\n### Backend Services\n\n1. **Database Layer** (`app/models/database.py`)\n   - SQLAlchemy ORM with SQLite\n   - Tables: tasks, action_logs, healing_events\n   - DatabaseManager for session management\n\n2. **Browser-Use Service** (`app/services/browser_use_service.py`)\n   - AI-powered automation using browser-use library\n   - OpenAI GPT-4 integration\n   - Single step execution for healing\n\n3. **MCP Server Service** (`app/services/mcp_service.py`)\n   - Microsoft Playwright MCP server integration\n   - Subprocess management for MCP server\n   - JSON-RPC communication\n   - Accessibility-based locator generation\n\n4. **Healing Orchestrator** (`app/services/healing_orchestrator.py`)\n   - Two-tier healing system\n   - Browser-use healing first (2 retries)\n   - MCP fallback healing (2 retries)\n   - Real-time WebSocket updates\n\n5. **Code Generator** (`app/services/code_generator.py`)\n   - Generates executable Playwright Python scripts\n   - Uses healed locators from action logs\n   - Includes error handling and best practices\n\n### Frontend\n\n- **Dashboard** (`app/templates/index.html`)\n  - Task submission form\n  - Real-time execution monitor\n  - Statistics dashboard\n  - Task history table\n  - Task detail modal\n\n- **JavaScript** (`app/static/js/app.js`)\n  - Socket.IO client for WebSocket communication\n  - Real-time event handling\n  - REST API integration\n  - Bootstrap UI interactions\n\n### Configuration\n\n- **YAML Config** (`config/config.yaml`)\n  - Healing parameters (retries, timeouts)\n  - Browser settings\n  - MCP server configuration\n  - Export directories\n\n- **Environment Variables**\n  - OPENAI_API_KEY: Required for browser-use\n  - SESSION_SECRET: Flask session security (configured)\n\n## User Preferences\n\n- Production-ready application with NO placeholders\n- Real Microsoft Playwright MCP server integration\n- Actual browser-use AI automation\n- Full working implementation\n\n## Dependencies\n\n### Python\n- Flask 3.x (web framework)\n- Flask-SocketIO 5.x (WebSocket support)\n- browser-use (AI automation)\n- playwright (browser control)\n- SQLAlchemy 2.x (ORM)\n- pydantic (data validation)\n- APScheduler (background tasks)\n- eventlet (async worker)\n\n### Node.js\n- @playwright/mcp (Microsoft Playwright MCP server)\n\n## Running the Application\n\nThe Flask server runs on port 5000 with:\n- WebSocket support via Flask-SocketIO\n- Eventlet async worker\n- Real-time bidirectional communication\n- SQLite database with WAL mode\n\n## Key Features\n\n1. **Natural Language Automation**: Submit tasks in plain English\n2. **Self-Healing**: Automatic locator recovery on failures\n3. **Two-Tier Healing**: browser-use AI â†’ MCP server fallback\n4. **Real-Time Updates**: Live WebSocket monitoring\n5. **Code Generation**: Export working Playwright scripts\n6. **Comprehensive Logging**: Full audit trail of all actions\n7. **Statistics Dashboard**: Healing metrics and success rates\n\n## API Endpoints\n\n- REST API for task management\n- WebSocket events for real-time updates\n- Script generation and download\n- Statistics and reporting\n\n## Database Schema\n\nAll tables use SQLAlchemy ORM with proper relationships and indexes for production use.\n","size_bytes":3864},"app/services/browser_use_service.py":{"content":"import asyncio\nimport logging\nimport time\nfrom typing import Dict, Any, Optional, List\nfrom browser_use import Agent, Browser\nfrom langchain_openai import ChatOpenAI\nimport os\n\nlogger = logging.getLogger(__name__)\n\nclass BrowserUseService:\n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.browser = None\n        self.context = None\n        self.llm = None\n        \n    async def initialize(self):\n        \"\"\"Initialize the browser-use service\"\"\"\n        try:\n            api_key = os.getenv('OPENAI_API_KEY')\n            if not api_key:\n                raise ValueError(\"OPENAI_API_KEY not found in environment\")\n            \n            self.llm = ChatOpenAI(\n                model=\"gpt-4o\",\n                api_key=api_key,\n                temperature=0.1\n            )\n            \n            browser_config = self.config.get('browser', {})\n            headless = browser_config.get('headless', True)\n            \n            logger.info(f\"Initializing browser in {'headless' if headless else 'headful'} mode\")\n            \n            self.browser = Browser(\n                headless=headless,\n                disable_security=False\n            )\n            \n            logger.info(\"Browser-use service initialized successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error initializing browser-use service: {e}\")\n            return False\n    \n    async def execute_task(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"Execute a natural language instruction using browser-use\"\"\"\n        try:\n            if not self.llm:\n                await self.initialize()\n            \n            logger.info(f\"Executing instruction: {instruction}\")\n            \n            task_with_constraint = f\"{instruction}\\n\\nIMPORTANT: Complete ONLY the instruction given above and then STOP immediately. Do not perform any additional actions like extracting data, scrolling further, or navigating to other pages unless explicitly requested in the instruction. You can make any auxiliary decisions needed to complete the instruction itself (like handling popups, accepting cookies, etc.), but do not go beyond what was asked.\"\n            \n            agent = Agent(\n                task=task_with_constraint,\n                llm=self.llm,\n                browser=self.browser\n            )\n            \n            start_time = time.time()\n            result = await agent.run()\n            execution_time = time.time() - start_time\n            \n            logger.info(f\"Instruction completed in {execution_time:.2f}s\")\n            \n            return {\n                'success': True,\n                'result': result,\n                'execution_time': execution_time,\n                'error': None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing task with browser-use: {e}\")\n            return {\n                'success': False,\n                'result': None,\n                'execution_time': 0,\n                'error': str(e)\n            }\n    \n    async def execute_single_step(self, action_type: str, parameters: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Execute a single action step for healing purposes\"\"\"\n        try:\n            if not self.browser:\n                await self.initialize()\n            \n            logger.info(f\"Executing single step - Action: {action_type}, Parameters: {parameters}\")\n            \n            url = parameters.get('url')\n            if url:\n                task = f\"Go to {url}\"\n                if action_type == 'click':\n                    element_desc = parameters.get('element_description', '')\n                    task += f\" and click on {element_desc}\"\n                elif action_type == 'fill':\n                    element_desc = parameters.get('element_description', '')\n                    value = parameters.get('value', '')\n                    task += f\" and fill {element_desc} with {value}\"\n                elif action_type == 'select':\n                    element_desc = parameters.get('element_description', '')\n                    value = parameters.get('value', '')\n                    task += f\" and select {value} in {element_desc}\"\n            else:\n                if action_type == 'click':\n                    element_desc = parameters.get('element_description', '')\n                    task = f\"Click on {element_desc}\"\n                elif action_type == 'fill':\n                    element_desc = parameters.get('element_description', '')\n                    value = parameters.get('value', '')\n                    task = f\"Fill {element_desc} with {value}\"\n                elif action_type == 'select':\n                    element_desc = parameters.get('element_description', '')\n                    value = parameters.get('value', '')\n                    task = f\"Select {value} in {element_desc}\"\n                else:\n                    task = parameters.get('task', action_type)\n            \n            agent = Agent(\n                task=task,\n                llm=self.llm,\n                browser=self.browser\n            )\n            \n            start_time = time.time()\n            result = await agent.run()\n            execution_time = time.time() - start_time\n            \n            logger.info(f\"Single step completed successfully in {execution_time:.2f}s\")\n            \n            return {\n                'success': True,\n                'result': result,\n                'execution_time': execution_time,\n                'healed_locator': self._extract_locator_from_result(result),\n                'error': None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing single step: {e}\")\n            return {\n                'success': False,\n                'result': None,\n                'execution_time': 0,\n                'healed_locator': None,\n                'error': str(e)\n            }\n    \n    def _extract_locator_from_result(self, result: Any) -> Optional[Dict[str, Any]]:\n        \"\"\"Extract locator information from browser-use result\"\"\"\n        try:\n            if hasattr(result, 'history') and result.history:\n                last_action = result.history[-1]\n                if hasattr(last_action, 'action'):\n                    action_data = last_action.action\n                    if hasattr(action_data, 'selector') or hasattr(action_data, 'xpath'):\n                        return {\n                            'type': 'css' if hasattr(action_data, 'selector') else 'xpath',\n                            'value': getattr(action_data, 'selector', None) or getattr(action_data, 'xpath', None)\n                        }\n            \n            return None\n            \n        except Exception as e:\n            logger.warning(f\"Could not extract locator from result: {e}\")\n            return None\n    \n    async def get_page_context(self) -> Dict[str, Any]:\n        \"\"\"Get current page context information\"\"\"\n        try:\n            return {'url': None, 'title': None}\n        except Exception as e:\n            logger.error(f\"Error getting page context: {e}\")\n            return {'url': None, 'title': None}\n    \n    async def close(self):\n        \"\"\"Close the browser and cleanup resources\"\"\"\n        try:\n            if self.browser:\n                await self.browser.close()\n                self.browser = None\n                logger.info(\"Browser-use service closed\")\n        except Exception as e:\n            logger.error(f\"Error closing browser-use service: {e}\")\n","size_bytes":7588}},"version":2}