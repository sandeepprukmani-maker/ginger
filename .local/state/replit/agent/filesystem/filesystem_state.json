{"file_contents":{"src/automation/__init__.py":{"content":"from .browser_engine import BrowserEngine\nfrom .task_executor import TaskExecutor\nfrom .ai_generator import AITaskGenerator\nfrom .advanced_tools import AdvancedPlaywrightTools\nfrom .vision_analyzer import VisionPageAnalyzer\nfrom .mcp_client import PlaywrightMCPClient\nfrom .config_loader import ConfigLoader, get_config\n\ntry:\n    from openai import AsyncOpenAI\n    AI_AVAILABLE = True\nexcept ImportError:\n    AI_AVAILABLE = False\n\n__all__ = [\n    'BrowserEngine', \n    'TaskExecutor', \n    'AITaskGenerator', \n    'AdvancedPlaywrightTools',\n    'VisionPageAnalyzer',\n    'PlaywrightMCPClient',\n    'ConfigLoader',\n    'get_config',\n    'AI_AVAILABLE'\n]\n","size_bytes":653},"src/automation/session_memory.py":{"content":"import json\nimport os\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass SessionMemory:\n    \"\"\"\n    Persistent storage for automation execution history.\n    Tracks successful patterns and failures to improve future executions.\n    \"\"\"\n    \n    def __init__(self, session_dir: str = \"sessions\"):\n        self.session_dir = Path(session_dir)\n        self.session_dir.mkdir(exist_ok=True)\n        self.memory_file = self.session_dir / \"execution_memory.json\"\n        self.memory: Dict[str, Any] = self._load_memory()\n    \n    def _load_memory(self) -> Dict[str, Any]:\n        \"\"\"Load execution memory from disk.\"\"\"\n        if self.memory_file.exists():\n            try:\n                with open(self.memory_file, 'r') as f:\n                    data = json.load(f)\n                    logger.debug(f\"Loaded {len(data.get('executions', []))} executions from memory\")\n                    return data\n            except Exception as e:\n                logger.error(f\"Failed to load memory: {e}\")\n                return {\"executions\": [], \"patterns\": {}}\n        return {\"executions\": [], \"patterns\": {}}\n    \n    def _save_memory(self):\n        \"\"\"Save execution memory to disk.\"\"\"\n        try:\n            with open(self.memory_file, 'w') as f:\n                json.dump(self.memory, f, indent=2)\n            logger.debug(\"Memory saved to disk\")\n        except Exception as e:\n            logger.error(f\"Failed to save memory: {e}\")\n    \n    def record_execution(self, instruction: str, success: bool, \n                        steps: List[Dict[str, Any]], error: Optional[str] = None):\n        \"\"\"Record an execution attempt.\"\"\"\n        execution = {\n            \"instruction\": instruction,\n            \"success\": success,\n            \"steps\": steps,\n            \"error\": error,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        self.memory[\"executions\"].append(execution)\n        \n        if len(self.memory[\"executions\"]) > 100:\n            self.memory[\"executions\"] = self.memory[\"executions\"][-100:]\n        \n        if success:\n            self._update_patterns(instruction, steps)\n        \n        self._save_memory()\n        logger.info(f\"Recorded {'successful' if success else 'failed'} execution\")\n    \n    def _update_patterns(self, instruction: str, steps: List[Dict[str, Any]]):\n        \"\"\"Learn from successful patterns.\"\"\"\n        instruction_lower = instruction.lower()\n        \n        key_phrases = [\"search\", \"login\", \"click\", \"fill\", \"navigate\", \"extract\", \"scrape\"]\n        \n        for phrase in key_phrases:\n            if phrase in instruction_lower:\n                if phrase not in self.memory[\"patterns\"]:\n                    self.memory[\"patterns\"][phrase] = []\n                \n                pattern = {\n                    \"instruction\": instruction,\n                    \"steps\": steps,\n                    \"timestamp\": datetime.now().isoformat()\n                }\n                \n                self.memory[\"patterns\"][phrase].append(pattern)\n                \n                if len(self.memory[\"patterns\"][phrase]) > 5:\n                    self.memory[\"patterns\"][phrase] = self.memory[\"patterns\"][phrase][-5:]\n    \n    def get_similar_patterns(self, instruction: str) -> List[Dict[str, Any]]:\n        \"\"\"Get similar successful patterns based on instruction.\"\"\"\n        instruction_lower = instruction.lower()\n        similar = []\n        \n        for phrase, patterns in self.memory[\"patterns\"].items():\n            if phrase in instruction_lower:\n                similar.extend(patterns)\n        \n        return similar\n    \n    def get_recent_successes(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent successful executions.\"\"\"\n        successes = [e for e in self.memory[\"executions\"] if e[\"success\"]]\n        return successes[-limit:]\n    \n    def get_recent_failures(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent failed executions.\"\"\"\n        failures = [e for e in self.memory[\"executions\"] if not e[\"success\"]]\n        return failures[-limit:]\n    \n    def get_context_for_instruction(self, instruction: str) -> str:\n        \"\"\"Build context string for similar instructions.\"\"\"\n        similar = self.get_similar_patterns(instruction)\n        \n        if not similar:\n            return \"\"\n        \n        context_parts = [\"Similar successful patterns:\"]\n        for pattern in similar[-3:]:\n            context_parts.append(f\"- {pattern['instruction']}: {len(pattern['steps'])} steps\")\n        \n        return \"\\n\".join(context_parts)\n    \n    def clear_memory(self):\n        \"\"\"Clear all execution memory.\"\"\"\n        self.memory = {\"executions\": [], \"patterns\": {}}\n        self._save_memory()\n        logger.info(\"Memory cleared\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about executions.\"\"\"\n        total = len(self.memory[\"executions\"])\n        successes = len([e for e in self.memory[\"executions\"] if e[\"success\"]])\n        failures = total - successes\n        \n        return {\n            \"total_executions\": total,\n            \"successes\": successes,\n            \"failures\": failures,\n            \"success_rate\": (successes / total * 100) if total > 0 else 0,\n            \"learned_patterns\": len(self.memory[\"patterns\"])\n        }\n","size_bytes":5397},"src/automation/config.py":{"content":"from dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Dict, Any\nimport os\n\n\nclass BrowserType(Enum):\n    CHROMIUM = \"chromium\"\n    FIREFOX = \"firefox\"\n    WEBKIT = \"webkit\"\n\n\nclass SelectorStrategy(Enum):\n    CSS = \"css\"\n    XPATH = \"xpath\"\n    TEXT = \"text\"\n    ARIA = \"aria\"\n    AUTO = \"auto\"\n\n\n@dataclass\nclass BrowserConfig:\n    browser_type: BrowserType = BrowserType.CHROMIUM\n    headless: bool = True\n    timeout: int = 30000\n    viewport_width: int = 1920\n    viewport_height: int = 1080\n    user_agent: Optional[str] = None\n    locale: str = \"en-US\"\n    timezone: str = \"America/New_York\"\n    \n    screenshot_on_error: bool = True\n    video_recording: bool = False\n    trace_recording: bool = False\n    \n    slow_mo: int = 0\n    \n    proxy: Optional[Dict[str, str]] = None\n    \n    ignore_https_errors: bool = True\n    \n    downloads_path: Optional[str] = None\n\n\n@dataclass\nclass AutomationConfig:\n    max_retries: int = 3\n    retry_delay: int = 2\n    wait_strategy: str = \"networkidle\"\n    \n    screenshot_dir: str = \"screenshots\"\n    video_dir: str = \"videos\"\n    session_dir: str = \"sessions\"\n    \n    log_level: str = \"INFO\"\n    log_file: Optional[str] = \"automation.log\"\n    \n    save_session: bool = False\n    session_name: str = \"default\"\n    \n    openai_model: str = \"gpt-4o-mini\"\n    mcp_timeout: int = 300\n\n\ndef load_config_from_env() -> Dict[str, Any]:\n    return {\n        \"browser_type\": BrowserType(os.getenv(\"BROWSER_TYPE\", \"chromium\")),\n        \"headless\": os.getenv(\"HEADLESS\", \"true\").lower() == \"true\",\n        \"timeout\": int(os.getenv(\"TIMEOUT\", \"30000\")),\n        \"max_retries\": int(os.getenv(\"MAX_RETRIES\", \"3\")),\n        \"log_level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),\n    }\n","size_bytes":1735},"test_automation.py":{"content":"import asyncio\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def test_basic_automation():\n    logger.info(\"Testing basic browser automation framework\")\n    \n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\"\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        logger.info(\"Starting browser...\")\n        await browser.start()\n        logger.success(\"Browser started successfully!\")\n        \n        logger.info(\"Navigating to Python.org...\")\n        await browser.navigate(\"https://www.python.org\")\n        await browser.wait_for_load()\n        logger.success(\"Navigation successful!\")\n        \n        logger.info(\"Extracting page title...\")\n        title = await browser.get_text(\"h1\")\n        logger.success(f\"Page title: {title}\")\n        \n        logger.info(\"Taking screenshot...\")\n        screenshot_path = await browser.screenshot(\"test_python_org\")\n        logger.success(f\"Screenshot saved to: {screenshot_path}\")\n        \n        logger.info(\"\\n\" + \"=\"*50)\n        logger.success(\"âœ… All tests passed! Framework is working correctly.\")\n        logger.info(\"=\"*50 + \"\\n\")\n        \n    except Exception as e:\n        logger.exception(f\"âŒ Test failed: {e}\")\n        return False\n    finally:\n        logger.info(\"Stopping browser...\")\n        await browser.stop()\n        logger.success(\"Browser stopped successfully!\")\n    \n    return True\n\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_basic_automation())\n    exit(0 if success else 1)\n","size_bytes":1858},"nrw.py":{"content":"import tenacity\nprint(tenacity.__version__)","size_bytes":43},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"mcp>=1.18.0\",\n    \"openai>=2.4.0\",\n    \"playwright>=1.55.0\",\n    \"pydantic>=2.12.2\",\n    \"python-dotenv>=1.1.1\",\n    \"rich>=14.2.0\",\n    \"tenacity>=9.1.2\",\n]\n","size_bytes":305},"src/automation/config_loader.py":{"content":"\"\"\"\nConfiguration loader for reading from config.ini file\n\"\"\"\nimport configparser\nimport os\nfrom pathlib import Path\nfrom typing import Optional\n\n\nclass ConfigLoader:\n    \"\"\"Load and manage configuration from config.ini file\"\"\"\n    \n    def __init__(self, config_file: str = \"config.ini\"):\n        self.config_file = config_file\n        self.config = configparser.ConfigParser()\n        self._load_config()\n    \n    def _load_config(self):\n        \"\"\"Load configuration from .ini file\"\"\"\n        if not Path(self.config_file).exists():\n            raise FileNotFoundError(f\"Configuration file {self.config_file} not found!\")\n        \n        self.config.read(self.config_file)\n    \n    def _get_value(self, section: str, key: str, fallback: Optional[str] = None) -> Optional[str]:\n        \"\"\"Get a value from config, supporting environment variable substitution\"\"\"\n        value = self.config.get(section, key, fallback=fallback)\n        \n        if value and value.startswith(\"${\") and value.endswith(\"}\"):\n            # Environment variable substitution\n            env_var = value[2:-1]\n            return os.getenv(env_var, fallback)\n        \n        return value\n    \n    def _get_bool(self, section: str, key: str, fallback: bool = False) -> bool:\n        \"\"\"Get a boolean value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        return value.lower() in ('true', 'yes', '1', 'on') if value else fallback\n    \n    def _get_int(self, section: str, key: str, fallback: int = 0) -> int:\n        \"\"\"Get an integer value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        try:\n            return int(value) if value else fallback\n        except ValueError:\n            return fallback\n    \n    # OpenAI Configuration\n    @property\n    def openai_api_key(self) -> Optional[str]:\n        return self._get_value('OpenAI', 'api_key')\n    \n    @property\n    def openai_model(self) -> str:\n        return self._get_value('OpenAI', 'model', 'gpt-4o-mini') or 'gpt-4o-mini'\n    \n    # Browser Configuration\n    @property\n    def browser_type(self) -> str:\n        return self._get_value('Browser', 'browser_type', 'chromium') or 'chromium'\n    \n    @property\n    def browser_headless(self) -> bool:\n        return self._get_bool('Browser', 'headless', False)\n    \n    @property\n    def browser_timeout(self) -> int:\n        return self._get_int('Browser', 'timeout', 30000)\n    \n    @property\n    def screenshot_on_error(self) -> bool:\n        return self._get_bool('Browser', 'screenshot_on_error', True)\n    \n    # Automation Configuration\n    @property\n    def max_retries(self) -> int:\n        return self._get_int('Automation', 'max_retries', 3)\n    \n    @property\n    def retry_delay(self) -> int:\n        return self._get_int('Automation', 'retry_delay', 2)\n    \n    @property\n    def log_level(self) -> str:\n        return self._get_value('Automation', 'log_level', 'INFO') or 'INFO'\n    \n    @property\n    def enable_vision(self) -> bool:\n        return self._get_bool('Automation', 'enable_vision', True)\n    \n    # Paths Configuration\n    @property\n    def screenshots_dir(self) -> str:\n        return self._get_value('Paths', 'screenshots_dir', 'screenshots') or 'screenshots'\n    \n    @property\n    def logs_dir(self) -> str:\n        return self._get_value('Paths', 'logs_dir', 'logs') or 'logs'\n    \n    # MCP Configuration\n    @property\n    def auto_refresh_dom(self) -> bool:\n        return self._get_bool('MCP', 'auto_refresh_dom', True)\n    \n    @property\n    def autonomous_execution(self) -> bool:\n        return self._get_bool('MCP', 'autonomous_execution', True)\n\n\n# Singleton instance\n_config_instance: Optional[ConfigLoader] = None\n\n\ndef get_config() -> ConfigLoader:\n    \"\"\"Get the global configuration instance\"\"\"\n    global _config_instance\n    if _config_instance is None:\n        _config_instance = ConfigLoader()\n    return _config_instance\n","size_bytes":3929},"src/automation/mcp_client.py":{"content":"import asyncio\nimport os\nfrom contextlib import AsyncExitStack\nfrom typing import Optional, Dict, Any, List\nimport json\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass PlaywrightMCPClient:\n    \"\"\"\n    Client for communicating with Playwright MCP server.\n    Provides browser automation capabilities via Model Context Protocol.\n    \"\"\"\n    \n    def __init__(self):\n        self.session: Optional[ClientSession] = None\n        self.exit_stack = AsyncExitStack()\n        self.tools: List[Dict[str, Any]] = []\n        \n    async def connect(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"\n        Connect to Playwright MCP server.\n        \n        Args:\n            browser: Browser type (chromium, firefox, webkit)\n            headless: Whether to run in headless mode\n        \"\"\"\n        try:\n            logger.info(f\"Connecting to Playwright MCP server (browser={browser}, headless={headless})\")\n            \n            # Set up environment for npx command (fix NixOS env issues)\n            env = os.environ.copy()\n            env.setdefault(\"XDG_CONFIG_HOME\", os.path.expanduser(\"~/.config\"))\n            env.setdefault(\"XDG_DATA_HOME\", os.path.expanduser(\"~/.local/share\"))\n            env.setdefault(\"XDG_CACHE_HOME\", os.path.expanduser(\"~/.cache\"))\n            \n            # Build args (only add --headless if headless mode is enabled)\n            args = [\"@playwright/mcp@latest\", \"--browser\", browser]\n            if headless:\n                args.append(\"--headless\")\n            \n            server_params = StdioServerParameters(\n                command=\"npx\",\n                args=args,\n                env=env\n            )\n            \n            stdio_transport = await self.exit_stack.enter_async_context(\n                stdio_client(server_params)\n            )\n            read_stream, write_stream = stdio_transport\n            \n            self.session = await self.exit_stack.enter_async_context(\n                ClientSession(read_stream, write_stream)\n            )\n            \n            await self.session.initialize()\n            \n            response = await self.session.list_tools()\n            self.tools = [\n                {\n                    \"name\": tool.name,\n                    \"description\": tool.description,\n                    \"input_schema\": tool.inputSchema\n                }\n                for tool in response.tools\n            ]\n            \n            logger.success(f\"Connected to Playwright MCP! Available tools: {[t['name'] for t in self.tools]}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to connect to Playwright MCP: {e}\")\n            raise\n    \n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:\n        \"\"\"\n        Call a Playwright MCP tool.\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Tool arguments\n            \n        Returns:\n            Tool result\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(\"Not connected to MCP server. Call connect() first.\")\n        \n        try:\n            logger.info(f\"Calling MCP tool: {tool_name} with args: {arguments}\")\n            \n            result = await self.session.call_tool(tool_name, arguments)\n            \n            if result.content:\n                content = result.content[0]\n                if hasattr(content, 'text'):\n                    return_value = content.text\n                    try:\n                        return_value = json.loads(return_value)\n                    except json.JSONDecodeError:\n                        pass\n                    logger.success(f\"Tool {tool_name} completed successfully\")\n                    return return_value\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Tool {tool_name} failed: {e}\")\n            raise\n    \n    async def navigate(self, url: str) -> Dict[str, Any]:\n        \"\"\"Navigate to a URL.\"\"\"\n        return await self.call_tool(\"browser_navigate\", {\"url\": url})\n    \n    async def click(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Click an element.\"\"\"\n        return await self.call_tool(\"browser_click\", {\"selector\": selector})\n    \n    async def fill(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Fill an input field.\"\"\"\n        return await self.call_tool(\"browser_fill_form\", {\n            \"selector\": selector,\n            \"value\": value\n        })\n    \n    async def screenshot(self, path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Take a screenshot.\"\"\"\n        args = {}\n        if path:\n            args[\"path\"] = path\n        return await self.call_tool(\"browser_take_screenshot\", args)\n    \n    async def evaluate(self, expression: str) -> Any:\n        \"\"\"Execute JavaScript in the browser.\"\"\"\n        return await self.call_tool(\"browser_evaluate\", {\"expression\": expression})\n    \n    async def get_page_content(self) -> str:\n        \"\"\"Get the current page HTML content.\"\"\"\n        result = await self.call_tool(\"browser_snapshot\", {})\n        return result if isinstance(result, str) else \"\"\n    \n    async def extract_text(self, selector: str) -> str:\n        \"\"\"Extract text from an element using JavaScript.\"\"\"\n        js_code = f\"document.querySelector('{selector}')?.innerText || ''\"\n        result = await self.evaluate(js_code)\n        return str(result) if result else \"\"\n    \n    async def extract_all_text(self, selector: str) -> List[str]:\n        \"\"\"Extract text from multiple elements.\"\"\"\n        js_code = f\"Array.from(document.querySelectorAll('{selector}')).map(el => el.innerText)\"\n        result = await self.evaluate(js_code)\n        return result if isinstance(result, list) else []\n    \n    async def wait_for_selector(self, selector: str, timeout: int = 30000) -> Dict[str, Any]:\n        \"\"\"Wait for a selector to appear on the page.\"\"\"\n        return await self.call_tool(\"browser_wait_for\", {\n            \"selector\": selector,\n            \"timeout\": timeout\n        })\n    \n    async def type_text(self, selector: str, text: str, delay: int = 50) -> Dict[str, Any]:\n        \"\"\"Type text into an element with delay between keystrokes.\"\"\"\n        return await self.call_tool(\"browser_type\", {\n            \"selector\": selector,\n            \"text\": text,\n            \"delay\": delay\n        })\n    \n    async def select_dropdown(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Select a dropdown option.\"\"\"\n        return await self.call_tool(\"browser_select_option\", {\n            \"selector\": selector,\n            \"value\": value\n        })\n    \n    async def hover(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Hover over an element.\"\"\"\n        return await self.call_tool(\"browser_hover\", {\"selector\": selector})\n    \n    async def press_key(self, key: str) -> Dict[str, Any]:\n        \"\"\"Press a keyboard key.\"\"\"\n        return await self.call_tool(\"browser_press_key\", {\"key\": key})\n    \n    async def get_console_messages(self) -> List[str]:\n        \"\"\"Get browser console messages.\"\"\"\n        result = await self.call_tool(\"browser_console_messages\", {})\n        return result if isinstance(result, list) else []\n    \n    async def get_network_requests(self) -> List[Dict[str, Any]]:\n        \"\"\"Get network requests made by the page.\"\"\"\n        result = await self.call_tool(\"browser_network_requests\", {})\n        return result if isinstance(result, list) else []\n    \n    async def upload_file(self, selector: str, file_path: str) -> Dict[str, Any]:\n        \"\"\"Upload a file to an input element.\"\"\"\n        return await self.call_tool(\"browser_file_upload\", {\n            \"selector\": selector,\n            \"filePath\": file_path\n        })\n    \n    async def handle_dialog(self, action: str = \"accept\", text: str = \"\") -> Dict[str, Any]:\n        \"\"\"Handle browser dialog (alert, confirm, prompt).\"\"\"\n        args: Dict[str, Any] = {\"action\": action}\n        if text:\n            args[\"text\"] = text\n        return await self.call_tool(\"browser_handle_dialog\", args)\n    \n    async def go_back(self) -> Dict[str, Any]:\n        \"\"\"Navigate back in browser history.\"\"\"\n        return await self.call_tool(\"browser_navigate_back\", {})\n    \n    async def resize_viewport(self, width: int, height: int) -> Dict[str, Any]:\n        \"\"\"Resize browser viewport.\"\"\"\n        return await self.call_tool(\"browser_resize\", {\n            \"width\": width,\n            \"height\": height\n        })\n    \n    async def get_tabs(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of open browser tabs.\"\"\"\n        result = await self.call_tool(\"browser_tabs\", {})\n        return result if isinstance(result, list) else []\n    \n    async def close_browser(self) -> Dict[str, Any]:\n        \"\"\"Close the browser.\"\"\"\n        return await self.call_tool(\"browser_close\", {})\n    \n    async def close(self):\n        \"\"\"Close the MCP client connection.\"\"\"\n        try:\n            await self.exit_stack.aclose()\n            logger.info(\"MCP client connection closed\")\n        except Exception as e:\n            logger.error(f\"Error closing MCP client: {e}\")\n    \n    def get_available_tools(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of available MCP tools.\"\"\"\n        return self.tools\n","size_bytes":9367},"nl_automation_mcp.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nEnhanced Natural Language Browser Automation using Playwright MCP Server\nFeatures: Vision-based intelligence, smart error recovery, session memory, advanced web handling\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nimport base64\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\nfrom src.automation.mcp_client import PlaywrightMCPClient\nfrom src.automation.logger import get_logger\nfrom src.automation.vision_analyzer import VisionAnalyzer\nfrom src.automation.session_memory import SessionMemory\nfrom src.automation.recorder import BrowserRecorder\nfrom openai import AsyncOpenAI\n\nlogger = get_logger()\n\n\nclass EnhancedMCPAutomation:\n    \"\"\"Enhanced natural language automation with vision, memory, and intelligent error recovery.\"\"\"\n    \n    def __init__(self, api_key: str, enable_vision: bool = True, max_retries: int = 3, screenshots_dir: str = \"screenshots\"):\n        self.client = AsyncOpenAI(api_key=api_key)\n        self.mcp = PlaywrightMCPClient()\n        self.conversation_history = []\n        self.enable_vision = enable_vision\n        self.vision_analyzer = VisionAnalyzer(api_key) if enable_vision else None\n        self.session_memory = SessionMemory()\n        self.recorder = BrowserRecorder(api_key)\n        self.max_retries = max_retries\n        self.screenshot_count = 0\n        self.screenshots_dir = screenshots_dir\n        self._recording_task: Optional[asyncio.Task] = None\n    \n    async def initialize(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"Initialize MCP connection.\"\"\"\n        # Create screenshots folder if it doesn't exist\n        Path(self.screenshots_dir).mkdir(parents=True, exist_ok=True)\n        logger.info(f\"Created screenshots folder: {self.screenshots_dir}\")\n        \n        await self.mcp.connect(browser=browser, headless=headless)\n        logger.success(\"Enhanced MCP automation initialized with vision and memory!\")\n    \n    async def _take_screenshot(self, context: str = \"debug\") -> Optional[str]:\n        \"\"\"Take a screenshot and return base64 encoded image.\"\"\"\n        try:\n            self.screenshot_count += 1\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            screenshot_path = f\"screenshots/mcp_{context}_{timestamp}_{self.screenshot_count}.png\"\n            \n            result = await self.mcp.call_tool(\"browser_take_screenshot\", {\"path\": screenshot_path})\n            \n            if Path(screenshot_path).exists():\n                with open(screenshot_path, \"rb\") as f:\n                    return base64.b64encode(f.read()).decode()\n            return None\n        except Exception as e:\n            logger.error(f\"Screenshot failed: {e}\")\n            return None\n    \n    async def _analyze_page_with_vision(self, instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Use vision to analyze the page and get better selectors.\"\"\"\n        if not self.vision_analyzer:\n            return None\n        \n        try:\n            screenshot_b64 = await self._take_screenshot(\"vision_analysis\")\n            if not screenshot_b64:\n                return None\n            \n            analysis = await self.vision_analyzer.analyze_page(screenshot_b64, instruction)\n            logger.info(f\"Vision analysis: {analysis}\")\n            return analysis\n        except Exception as e:\n            logger.error(f\"Vision analysis failed: {e}\")\n            return None\n    \n    async def _get_page_context(self) -> str:\n        \"\"\"Get current page context for better decision making.\"\"\"\n        try:\n            snapshot = await self.mcp.call_tool(\"browser_snapshot\", {})\n            if isinstance(snapshot, str):\n                return snapshot[:2000]  # Smaller limit for speed\n            return \"\"\n        except Exception as e:\n            logger.debug(f\"Failed to get page context: {e}\")\n            return \"\"\n    \n    async def _wait_for_stable_page(self, timeout: int = 10000) -> bool:\n        \"\"\"Wait for page to stabilize (network idle, DOM ready).\"\"\"\n        try:\n            # Wait for network to be idle (no pending requests)\n            await self.mcp.call_tool(\"browser_wait_for\", {\n                \"state\": \"networkidle\",\n                \"timeout\": timeout\n            })\n            logger.info(\"âœ“ Page stabilized (network idle)\")\n            return True\n        except Exception as e:\n            logger.debug(f\"Network idle wait failed: {e}\")\n            # Fallback: just wait a bit\n            await asyncio.sleep(1)\n            return False\n    \n    async def _recover_with_page_refresh(self, instruction: str) -> bool:\n        \"\"\"Attempt to recover from critical failures by refreshing the page.\"\"\"\n        try:\n            logger.warning(\"âš ï¸ Attempting recovery with page refresh...\")\n            # Get current URL\n            current_url = await self.mcp.evaluate(\"window.location.href\")\n            if current_url:\n                # Refresh by navigating to same URL\n                await self.mcp.call_tool(\"browser_navigate\", {\"url\": current_url})\n                await self._wait_for_stable_page()\n                logger.success(\"âœ“ Page refreshed successfully\")\n                return True\n        except Exception as e:\n            logger.error(f\"Page refresh recovery failed: {e}\")\n        return False\n    \n    async def _get_page_elements_catalog(self) -> Dict[str, List[Dict[str, str]]]:\n        \"\"\"Get catalog of interactive elements on the page for smart retries.\"\"\"\n        try:\n            js_code = \"\"\"\n            (function() {\n                const elements = {\n                    buttons: [],\n                    links: [],\n                    inputs: [],\n                    selects: []\n                };\n                \n                // Catalog buttons\n                document.querySelectorAll('button, input[type=\"submit\"], input[type=\"button\"]').forEach(el => {\n                    elements.buttons.push({\n                        text: (el.innerText || el.value || '').trim().substring(0, 50),\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || '',\n                        type: el.type || 'button'\n                    });\n                });\n                \n                // Catalog links\n                document.querySelectorAll('a[href]').forEach(el => {\n                    elements.links.push({\n                        text: (el.innerText || '').trim().substring(0, 50),\n                        href: el.href || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog inputs\n                document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], input[type=\"search\"], textarea').forEach(el => {\n                    elements.inputs.push({\n                        type: el.type || 'text',\n                        placeholder: el.placeholder || '',\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog selects\n                document.querySelectorAll('select').forEach(el => {\n                    elements.selects.push({\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                return elements;\n            })()\n            \"\"\"\n            result = await self.mcp.evaluate(js_code)\n            return result if isinstance(result, dict) else {}\n        except Exception as e:\n            logger.debug(f\"Could not get elements catalog: {e}\")\n            return {}\n    \n    async def _smart_retry_with_vision(self, tool_name: str, tool_args: Dict[str, Any], error: str, instruction: str, retry_attempt: int = 1) -> tuple[Any, Dict[str, Any]]:\n        \"\"\"Retry failed action with vision-based correction and intelligent catalog matching.\n        Returns: (result, modified_tool_args_that_worked)\n        \"\"\"\n        logger.info(f\"Attempting smart retry #{retry_attempt} for {tool_name}...\")\n        \n        # Strategy 1: Vision-based selector correction (ONLY ON FIRST RETRY for speed + success)\n        vision_analysis = None\n        if retry_attempt == 1 and self.enable_vision:\n            logger.info(f\"ðŸ” First retry - activating GPT-4 Vision for intelligent element detection...\")\n            vision_analysis = await self._analyze_page_with_vision(instruction)\n        else:\n            if retry_attempt > 1:\n                logger.info(f\"Retry #{retry_attempt} - using element catalog (vision already attempted)\")\n        \n        if vision_analysis and vision_analysis.get(\"suggested_selector\"):\n            new_selector = vision_analysis[\"suggested_selector\"]\n            logger.info(f\"Vision suggests selector: {new_selector}\")\n            \n            if \"selector\" in tool_args:\n                tool_args[\"selector\"] = new_selector\n                try:\n                    result = await self.mcp.call_tool(tool_name, tool_args)\n                    return (result, tool_args)  # Return the modified args that worked\n                except Exception as e:\n                    logger.debug(f\"Vision selector failed: {e}\")\n        \n        # Strategy 2: Use element catalog based on TOOL TYPE\n        elements_catalog = await self._get_page_elements_catalog()\n        original_selector = tool_args.get(\"selector\", \"\")\n        \n        # Extract keywords from both instruction and original selector\n        search_keywords = set(instruction.lower().split() + original_selector.lower().split())\n        \n        # Determine element type from tool name\n        if tool_name in [\"browser_click\"]:\n            # Try buttons first, then links\n            logger.info(\"Retrying click action - searching buttons and links\")\n            \n            for btn in elements_catalog.get(\"buttons\", []):\n                if btn.get(\"text\") and any(word in btn[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={btn['text']}\", f\"role=button[name=/{btn['text']}/i]\"]\n                    if btn.get(\"id\"):\n                        selectors.append(f\"#{btn['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying button selector: {sel}\")\n                            result = await self.mcp.call_tool(tool_name, tool_args)\n                            return (result, tool_args)  # Return modified args that worked\n                        except:\n                            continue\n            \n            for link in elements_catalog.get(\"links\", []):\n                if link.get(\"text\") and any(word in link[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={link['text']}\", f\"role=link[name=/{link['text']}/i]\"]\n                    if link.get(\"id\"):\n                        selectors.append(f\"#{link['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying link selector: {sel}\")\n                            result = await self.mcp.call_tool(tool_name, tool_args)\n                            return (result, tool_args)  # Return modified args that worked\n                        except:\n                            continue\n        \n        elif tool_name in [\"browser_type\", \"browser_fill_form\"]:\n            # Looking for input fields\n            logger.info(\"Retrying fill/type action - searching inputs\")\n            \n            for inp in elements_catalog.get(\"inputs\", []):\n                selectors = []\n                # Match by placeholder, name, or keywords\n                if inp.get(\"placeholder\") and any(word in inp[\"placeholder\"].lower() for word in search_keywords):\n                    selectors.append(f\"[placeholder*='{inp['placeholder']}']\")\n                if inp.get(\"name\"):\n                    selectors.append(f\"[name='{inp['name']}']\")\n                    # Also try text matching on name\n                    if any(word in inp[\"name\"].lower() for word in search_keywords):\n                        selectors.insert(0, f\"[name='{inp['name']}']\")\n                if inp.get(\"id\"):\n                    selectors.append(f\"#{inp['id']}\")\n                if inp.get(\"ariaLabel\") and any(word in inp[\"ariaLabel\"].lower() for word in search_keywords):\n                    selectors.insert(0, f\"[aria-label='{inp['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying input selector: {sel}\")\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        elif tool_name in [\"browser_select_option\"]:\n            # Looking for select elements\n            logger.info(\"Retrying select action - searching selects\")\n            \n            for sel_elem in elements_catalog.get(\"selects\", []):\n                selectors = []\n                if sel_elem.get(\"name\"):\n                    selectors.append(f\"[name='{sel_elem['name']}']\")\n                if sel_elem.get(\"id\"):\n                    selectors.append(f\"#{sel_elem['id']}\")\n                if sel_elem.get(\"ariaLabel\"):\n                    selectors.append(f\"[aria-label='{sel_elem['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying select selector: {sel}\")\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        else:\n            # For other tools, try generic matching\n            logger.info(f\"Retrying {tool_name} - trying generic element matching\")\n            all_elements = (\n                elements_catalog.get(\"buttons\", []) + \n                elements_catalog.get(\"links\", []) + \n                elements_catalog.get(\"inputs\", [])\n            )\n            \n            for elem in all_elements:\n                if elem.get(\"id\") and any(word in elem[\"id\"].lower() for word in search_keywords):\n                    tool_args[\"selector\"] = f\"#{elem['id']}\"\n                    try:\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        raise Exception(f\"All vision and element catalog strategies exhausted for {tool_name}\")\n    \n    async def execute_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language command using AI + MCP with enhanced capabilities.\n        \n        Args:\n            command: Natural language instruction\n            \n        Returns:\n            Dict with status, summary, and continuation info\n        \"\"\"\n        logger.info(f\"Processing command: {command}\")\n        \n        # Check session memory for similar successful patterns\n        similar_patterns = self.session_memory.get_similar_patterns(command)\n        memory_context = self.session_memory.get_context_for_instruction(command)\n        if similar_patterns:\n            logger.info(f\"Found {len(similar_patterns)} similar patterns from memory\")\n        \n        # Get page context for better decisions\n        page_context = await self._get_page_context()\n        \n        # Get available MCP tools\n        tools = self.mcp.get_available_tools()\n        \n        # Format tools for OpenAI\n        openai_tools: list = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool[\"description\"],\n                    \"parameters\": tool[\"input_schema\"]\n                }\n            }\n            for tool in tools\n        ]\n        \n        # Enhanced system prompt with aggressive intelligence\n        system_prompt = f\"\"\"You are an ULTRA-INTELLIGENT browser automation AI with MAXIMUM TASK COMPLETION capability.\n\nMISSION: Complete ANY valid task at all costs using all available strategies.\n\nPOWER FEATURES:\n- 21+ Playwright MCP tools for total browser control\n- GPT-4 Vision analysis activates on FIRST retry for intelligent element detection\n- 5 retry attempts with progressive intelligence escalation\n- Smart element catalog with fuzzy matching across buttons/links/inputs/selects\n- Session memory learns from every successful execution\n- Autonomous multi-step execution without user interruption\n\nAGGRESSIVE COMPLETION STRATEGY:\n1. ALWAYS use browser_snapshot first to deeply understand page structure\n2. For navigation: browser_navigate with full URLs, wait for network idle\n3. For element interactions: Use MULTIPLE selector strategies in parallel:\n   - Text selectors: text=exact_text (most reliable)\n   - Role selectors: role=button[name=/pattern/i]\n   - Attribute selectors: [placeholder*='value'], [aria-label='value']\n   - ID/Class: #id, .class\n4. For waiting: browser_wait_for with networkidle/load states for dynamic content\n5. For data extraction: browser_evaluate with robust JavaScript\n6. For forms: browser_fill_form for complex multi-field forms\n7. For failures: System auto-retries with vision + element catalog + fuzzy matching\n\nINTELLIGENT ADAPTATIONS:\n- If selector fails â†’ Vision AI finds element â†’ Element catalog suggests alternatives\n- If page changes â†’ Auto-refresh DOM context â†’ Re-analyze structure\n- If timing issue â†’ Wait for network idle â†’ Retry with extended timeout\n- If element hidden â†’ Scroll into view â†’ Wait for visibility â†’ Click\n- If multiple matches â†’ Use most specific selector â†’ Verify with text content\n\nCURRENT PAGE:\n{page_context[:800] if page_context else 'No context - use browser_snapshot first!'}\n\nSUCCESS PATTERNS FROM MEMORY:\n{memory_context if memory_context else 'No patterns yet - creating new one!'}\n\nEXECUTE WITH MAXIMUM INTELLIGENCE. Never give up until task completes or all 5 retries exhausted.\"\"\"\n\n        # Add to conversation history\n        self.conversation_history.append({\n            \"role\": \"user\",\n            \"content\": command\n        })\n        \n        # Call OpenAI to determine which tools to use\n        response = await self.client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                *self.conversation_history\n            ],\n            tools=openai_tools,\n            tool_choice=\"required\",  # Force AI to use tools instead of returning text\n            temperature=0.3  # Lower temperature for more consistent automation\n        )\n        \n        message = response.choices[0].message\n        results = []\n        tool_execution_log = []\n        \n        # Check if AI returned tool calls (should always be true with tool_choice=\"required\")\n        if not message.tool_calls:\n            error_msg = f\"AI did not return tool calls. Response: {message.content}\"\n            logger.error(error_msg)\n            self.session_memory.record_execution(\n                instruction=command,\n                success=False,\n                steps=[],\n                error=error_msg\n            )\n            return {\n                \"status\": \"error\",\n                \"summary\": \"AI failed to generate tool calls\",\n                \"should_continue\": False\n            }\n        \n        # Execute tool calls with smart retry\n        if message.tool_calls:\n            for tool_call in message.tool_calls:\n                if hasattr(tool_call, 'function'):\n                    tool_name = tool_call.function.name  # type: ignore\n                    try:\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                    except json.JSONDecodeError as e:\n                        logger.error(f\"Failed to parse tool arguments: {e}\")\n                        continue\n                else:\n                    continue\n                \n                logger.info(f\"âš¡ Executing: {tool_name}({tool_args})\")\n                \n                # Ensure screenshots go to screenshots folder with unique names\n                if tool_name == \"browser_take_screenshot\":\n                    self.screenshot_count += 1\n                    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                    filename = tool_args.get(\"filename\", f\"screenshot_{timestamp}_{self.screenshot_count}.png\")\n                    # Ensure it's saved in screenshots folder\n                    if not filename.startswith(f\"{self.screenshots_dir}/\"):\n                        filename = f\"{self.screenshots_dir}/{filename}\"\n                    tool_args[\"path\"] = filename\n                    logger.info(f\"Screenshot will be saved to: {filename}\")\n                \n                # Try executing with retries\n                retry_count = 0\n                while retry_count < self.max_retries:\n                    try:\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        logger.success(f\"âœ“ {tool_name} succeeded\")\n                        results.append(f\"âœ“ {tool_name}: {result}\")\n                        \n                        # Log successful execution\n                        tool_execution_log.append({\n                            \"tool\": tool_name,\n                            \"args\": tool_args,\n                            \"success\": True\n                        })\n                        \n                        # Add tool result to conversation\n                        self.conversation_history.append({\n                            \"role\": \"assistant\",\n                            \"content\": None,\n                            \"tool_calls\": [tool_call]\n                        })\n                        self.conversation_history.append({\n                            \"role\": \"tool\",\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": str(result)\n                        })\n                        \n                        # Auto-refresh DOM context after navigation with intelligent waiting\n                        if tool_name in [\"browser_navigate\", \"browser_navigate_back\", \"browser_navigate_forward\"]:\n                            # Wait for page to stabilize (network idle)\n                            await self._wait_for_stable_page()\n                            fresh_context = await self._get_page_context()\n                            if fresh_context:\n                                logger.info(f\"ðŸ“Š Refreshed DOM context after navigation\")\n                                # Update conversation with fresh context (smaller for speed)\n                                self.conversation_history.append({\n                                    \"role\": \"system\",\n                                    \"content\": f\"Page context updated: {fresh_context[:300]}\"\n                                })\n                            \n                            # Re-inject recorder script if recording is active\n                            if self.recorder.is_recording:\n                                try:\n                                    await self.mcp.evaluate(self.recorder.get_recorder_script())\n                                    logger.info(\"ðŸŽ¥ Recorder script re-injected after navigation\")\n                                except Exception as e:\n                                    logger.warning(f\"Failed to re-inject recorder script: {e}\")\n                        \n                        # Inform AI about screenshot location\n                        if tool_name == \"browser_take_screenshot\":\n                            screenshot_path = tool_args.get(\"path\", \"unknown\")\n                            self.conversation_history.append({\n                                \"role\": \"system\",\n                                \"content\": f\"Screenshot saved to: {screenshot_path}\"\n                            })\n                            logger.success(f\"ðŸ“¸ Screenshot saved to: {screenshot_path}\")\n                        \n                        break  # Success, exit retry loop\n                        \n                    except Exception as e:\n                        retry_count += 1\n                        error_msg = f\"âœ— {tool_name} failed (attempt {retry_count}/{self.max_retries}): {e}\"\n                        logger.warning(error_msg)\n                        \n                        if retry_count < self.max_retries:\n                            # Try smart retry with vision activated on first retry\n                            try:\n                                result, working_args = await self._smart_retry_with_vision(tool_name, tool_args.copy(), str(e), command, retry_count)\n                                results.append(f\"âœ“ {tool_name} (retry): {result}\")\n                                \n                                # Log successful retry WITH THE WORKING ARGS!\n                                # Extract the working selector for logging\n                                working_selector = working_args.get(\"selector\", \"\")\n                                if working_selector and working_selector != tool_args.get(\"selector\", \"\"):\n                                    logger.success(f\"âœ“ Found working selector: '{working_selector}' (original failed)\")\n                                \n                                tool_execution_log.append({\n                                    \"tool\": tool_name,\n                                    \"args\": working_args,  # Use the modified args that actually worked\n                                    \"success\": True,\n                                    \"retry\": True\n                                })\n                                \n                                break\n                            except Exception as retry_error:\n                                if retry_count == self.max_retries - 1:\n                                    # FINAL FALLBACK: Try page refresh recovery\n                                    logger.warning(\"âš ï¸ All retries exhausted, attempting page refresh recovery...\")\n                                    if await self._recover_with_page_refresh(command):\n                                        # One more try after refresh - try with vision-suggested selector if available\n                                        try:\n                                            # Try one more smart retry after refresh\n                                            result, final_working_args = await self._smart_retry_with_vision(tool_name, tool_args.copy(), str(retry_error), command, retry_count)\n                                            results.append(f\"âœ“ {tool_name} (after refresh): {result}\")\n                                            tool_execution_log.append({\n                                                \"tool\": tool_name,\n                                                \"args\": final_working_args,  # Use the working args, not original\n                                                \"success\": True,\n                                                \"recovery\": \"page_refresh\"\n                                            })\n                                            break\n                                        except:\n                                            pass\n                                    \n                                    results.append(error_msg)\n                                    tool_execution_log.append({\n                                        \"tool\": tool_name,\n                                        \"args\": tool_args,\n                                        \"success\": False,\n                                        \"error\": str(retry_error)\n                                    })\n                        else:\n                            results.append(error_msg)\n                            tool_execution_log.append({\n                                \"tool\": tool_name,\n                                \"args\": tool_args,\n                                \"success\": False,\n                                \"error\": str(e)\n                            })\n        \n        # Generate Playwright code from successful executions\n        playwright_code = self._generate_playwright_code(tool_execution_log, command)\n        \n        # Save execution to memory\n        success = any(log[\"success\"] for log in tool_execution_log)\n        error_msg = None\n        if not success:\n            failed_logs = [log for log in tool_execution_log if not log[\"success\"]]\n            if failed_logs:\n                error_msg = failed_logs[0].get(\"error\", \"Unknown error\")\n        \n        self.session_memory.record_execution(\n            instruction=command,\n            success=success,\n            steps=tool_execution_log,\n            error=error_msg\n        )\n        \n        # Determine if we need to continue autonomously or ask user\n        if results:\n            # Ask AI if task is complete or needs more steps\n            decision_response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": f\"\"\"Analyze the ORIGINAL user request against what has been accomplished so far.\n\nORIGINAL REQUEST: \"{command}\"\n\nCompare this against the conversation history to determine if ALL parts of the request are complete.\n\nRespond with JSON:\n{{\n  \"status\": \"complete\" | \"continue\",\n  \"summary\": \"brief summary of current progress\",\n  \"next_action\": \"specific next command to execute (required if status is continue)\"\n}}\n\nRules:\n- Use \"continue\" if ANY part of the original request is incomplete\n- Use \"complete\" ONLY when every part of the request is fully done\n- When continuing, next_action must be a specific command, not a description\n- Execute ALL steps of the request autonomously without asking user\n\nExamples:\n- Request: \"open google and search for dogs\" â†’ Opened Google â†’ status: \"continue\", next_action: \"search for dogs\"\n- Request: \"navigate to github.com and take screenshot\" â†’ Navigated â†’ status: \"continue\", next_action: \"take screenshot\"  \n- Request: \"search for cars\" â†’ Already searched and on results â†’ status: \"complete\"\n\nDO NOT ask the user to continue - execute next steps autonomously.\"\"\"\n                    },\n                    *self.conversation_history\n                ],\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            try:\n                decision = json.loads(decision_response.choices[0].message.content or \"{}\")\n                status = decision.get(\"status\", \"complete\")\n                summary = decision.get(\"summary\", \"Task completed\")\n                next_action = decision.get(\"next_action\")\n                \n                logger.success(f\"Status: {status} - {summary}\")\n                \n                # Return result with continuation info and Playwright code\n                return {\n                    \"status\": status,\n                    \"summary\": summary,\n                    \"next_action\": next_action,\n                    \"should_continue\": status == \"continue\",\n                    \"playwright_code\": playwright_code\n                }\n            except:\n                # Fallback to simple summary\n                return {\n                    \"status\": \"complete\",\n                    \"summary\": \"Task completed\",\n                    \"should_continue\": False,\n                    \"playwright_code\": playwright_code\n                }\n        else:\n            # This should never happen with tool_choice=\"required\"\n            logger.warning(\"No tool calls executed (should not happen)\")\n            return {\n                \"status\": \"error\", \n                \"summary\": \"No actions executed\",\n                \"should_continue\": False,\n                \"playwright_code\": None\n            }\n    \n    def _generate_playwright_code(self, tool_execution_log: List[Dict[str, Any]], instruction: str) -> Optional[str]:\n        \"\"\"Generate Playwright Python code from successful tool executions.\n        \n        IMPORTANT: Uses ACTUAL WORKING SELECTORS from execution, not AI's initial guesses!\n        - If initial selector failed, the retry mechanism found the working one\n        - All selectors in this code are VERIFIED to work on the target page\n        \"\"\"\n        successful_steps = [step for step in tool_execution_log if step.get(\"success\")]\n        \n        if not successful_steps:\n            return None\n        \n        code_lines = [\n            \"# Generated Playwright code with VERIFIED WORKING SELECTORS\",\n            f\"# Original instruction: {instruction}\",\n            \"# NOTE: All selectors below were tested and confirmed working on the page\",\n            \"\",\n            \"from playwright.async_api import async_playwright\",\n            \"\",\n            \"async def run():\",\n            \"    async with async_playwright() as p:\",\n            \"        browser = await p.chromium.launch(headless=True)\",\n            \"        page = await browser.new_page()\",\n            \"\"\n        ]\n        \n        for step in successful_steps:\n            tool = step.get(\"tool\", \"\")\n            args = step.get(\"args\", {})\n            \n            if tool == \"browser_navigate\":\n                url = args.get(\"url\", \"\")\n                code_lines.append(f\"        # Navigate to {url}\")\n                code_lines.append(f\"        await page.goto('{url}')\")\n                \n            elif tool == \"browser_click\":\n                selector = args.get(\"selector\", \"\")\n                was_retry = step.get(\"retry\", False)\n                comment = \"Click element (working selector)\" if was_retry else \"Click element\"\n                code_lines.append(f\"        # {comment}\")\n                code_lines.append(f\"        await page.locator('{selector}').click()\")\n                \n            elif tool == \"browser_type\":\n                selector = args.get(\"selector\", \"\")\n                text = args.get(\"text\", \"\")\n                was_retry = step.get(\"retry\", False)\n                comment = \"Type text (working selector)\" if was_retry else \"Type text into element\"\n                code_lines.append(f\"        # {comment}\")\n                code_lines.append(f\"        await page.locator('{selector}').fill('{text}')\")\n                \n            elif tool == \"browser_fill_form\":\n                form_data = args.get(\"formData\", {})\n                code_lines.append(f\"        # Fill form\")\n                for field_selector, value in form_data.items():\n                    code_lines.append(f\"        await page.locator('{field_selector}').fill('{value}')\")\n                    \n            elif tool == \"browser_press_key\":\n                key = args.get(\"key\", \"\")\n                code_lines.append(f\"        # Press key: {key}\")\n                code_lines.append(f\"        await page.keyboard.press('{key}')\")\n                \n            elif tool == \"browser_take_screenshot\":\n                path = args.get(\"path\", \"screenshot.png\")\n                code_lines.append(f\"        # Take screenshot\")\n                code_lines.append(f\"        await page.screenshot(path='{path}')\")\n                \n            elif tool == \"browser_evaluate\":\n                script = args.get(\"script\", \"\")\n                code_lines.append(f\"        # Execute JavaScript\")\n                code_lines.append(f\"        result = await page.evaluate('''{script}''')\")\n                \n            elif tool == \"browser_wait_for\":\n                selector = args.get(\"selector\", \"\")\n                code_lines.append(f\"        # Wait for element\")\n                code_lines.append(f\"        await page.locator('{selector}').wait_for()\")\n                \n            elif tool == \"browser_select_option\":\n                selector = args.get(\"selector\", \"\")\n                value = args.get(\"value\", \"\")\n                code_lines.append(f\"        # Select dropdown option\")\n                code_lines.append(f\"        await page.locator('{selector}').select_option('{value}')\")\n                \n            elif tool == \"browser_hover\":\n                selector = args.get(\"selector\", \"\")\n                code_lines.append(f\"        # Hover over element\")\n                code_lines.append(f\"        await page.locator('{selector}').hover()\")\n            \n            code_lines.append(\"\")\n        \n        code_lines.extend([\n            \"        await browser.close()\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            \"    import asyncio\",\n            \"    asyncio.run(run())\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    async def _recording_maintenance_loop(self):\n        \"\"\"Background task to keep recorder script injected and pull events frequently.\"\"\"\n        while self.recorder.is_recording:\n            try:\n                await self.recorder.maintain_recording(self.mcp)\n                await asyncio.sleep(0.2)  # Poll every 200ms to minimize cross-origin loss\n            except asyncio.CancelledError:\n                break\n            except Exception:\n                pass  # Continue even if injection fails\n    \n    def start_recording_maintenance(self):\n        \"\"\"Start background task to maintain recording across navigations.\"\"\"\n        if self._recording_task is None or self._recording_task.done():\n            self._recording_task = asyncio.create_task(self._recording_maintenance_loop())\n    \n    def stop_recording_maintenance(self):\n        \"\"\"Stop the recording maintenance background task.\"\"\"\n        if self._recording_task and not self._recording_task.done():\n            self._recording_task.cancel()\n            self._recording_task = None\n    \n    async def cleanup(self):\n        \"\"\"Clean up resources.\"\"\"\n        self.stop_recording_maintenance()\n        await self.mcp.close()\n        logger.info(\"MCP automation cleaned up successfully\")\n\n\nasync def main():\n    \"\"\"Main entry point for enhanced MCP automation.\"\"\"\n    from src.automation.config_loader import get_config\n    \n    # Load configuration from config.ini\n    config = get_config()\n    \n    # Get OpenAI API key from config\n    api_key = config.openai_api_key\n    if not api_key:\n        logger.error(\"OPENAI_API_KEY not set in config.ini or environment!\")\n        logger.error(\"Please set it in config.ini or as an environment variable\")\n        sys.exit(1)\n    \n    # Display configuration banner\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸš€ ENHANCED Playwright MCP Natural Language Automation\")\n    print(\"=\"*70)\n    print(\"\\nConfiguration:\")\n    print(f\"  â€¢ Config file: config.ini\")\n    print(f\"  â€¢ AI Model: {config.openai_model}\")\n    print(f\"  â€¢ Browser: {config.browser_type} (headless: {config.browser_headless})\")\n    print(f\"  â€¢ Vision: {'Enabled' if config.enable_vision else 'Disabled'}\")\n    print(f\"  â€¢ Screenshots: {config.screenshots_dir}/\")\n    print(f\"  â€¢ Max Retries: {config.max_retries}\")\n    print(\"\\nFeatures:\")\n    print(\"  âœ“ Vision-based intelligent page analysis\")\n    print(\"  âœ“ Smart error recovery with automatic retries\")\n    print(\"  âœ“ Session memory learns from successful patterns\")\n    print(\"  âœ“ Advanced web handling (forms, tables, iframes, dynamic content)\")\n    print(\"  âœ“ Multi-strategy element detection\")\n    print(\"  âœ“ Auto-refresh DOM context after navigation\")\n    print(\"  âœ“ Autonomous multi-step execution without interruptions\")\n    print(f\"  âœ“ Screenshots automatically saved to {config.screenshots_dir}/ folder\")\n    print(\"=\"*70)\n    \n    # Create automation instance with config settings\n    automation = EnhancedMCPAutomation(\n        api_key=api_key,\n        enable_vision=config.enable_vision,\n        max_retries=config.max_retries,\n        screenshots_dir=config.screenshots_dir\n    )\n    \n    try:\n        # Initialize MCP\n        logger.info(\"Initializing Enhanced Playwright MCP server...\")\n        await automation.initialize(\n            browser=config.browser_type,\n            headless=config.browser_headless\n        )\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"ðŸ’¡ POWERFUL AUTOMATION EXAMPLES:\")\n        print(\"=\"*70)\n        print(\"\\nðŸŒ Navigation & Search:\")\n        print(\"  â€¢ Go to google.com and search for Python tutorials\")\n        print(\"  â€¢ Navigate to news.ycombinator.com and get top 5 stories\")\n        print(\"  â€¢ Visit github.com and click on the trending repositories\")\n        \n        print(\"\\nðŸ“ Forms & Data Entry:\")\n        print(\"  â€¢ Fill out the contact form with name John and email john@example.com\")\n        print(\"  â€¢ Search for apartments in New York on realtor.com\")\n        print(\"  â€¢ Login with username testuser and password testpass\")\n        \n        print(\"\\nðŸ“Š Data Extraction:\")\n        print(\"  â€¢ Extract all product names and prices from this page\")\n        print(\"  â€¢ Get all the article headlines from this news site\")\n        print(\"  â€¢ Scrape the table data and export it\")\n        \n        print(\"\\nðŸ”§ Complex Tasks:\")\n        print(\"  â€¢ Take a screenshot of the current page\")\n        print(\"  â€¢ Click all 'Accept' buttons on this page\")\n        print(\"  â€¢ Navigate through the pagination and collect all items\")\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"Type 'quit', 'exit', or 'q' to stop.\\n\")\n        \n        # Interactive mode with autonomous continuation\n        while True:\n            try:\n                command = input(\"ðŸ’¬ Command: \").strip()\n                \n                if command.lower() in ['quit', 'exit', 'q']:\n                    print(\"\\nðŸ‘‹ Goodbye!\")\n                    break\n                \n                if not command:\n                    continue\n                \n                # Execute command and check if we should continue autonomously\n                while True:\n                    result = await automation.execute_command(command)\n                    \n                    # Handle result (could be string or dict)\n                    if isinstance(result, dict):\n                        summary = result.get(\"summary\", \"\")\n                        should_continue = result.get(\"should_continue\", False)\n                        next_action = result.get(\"next_action\")\n                        playwright_code = result.get(\"playwright_code\")\n                        \n                        # Show progress without interrupting\n                        if should_continue and next_action:\n                            print(f\"  âš¡ {summary}\")\n                            command = next_action  # Continue with next action\n                            await asyncio.sleep(0.5)  # Brief pause\n                        else:\n                            print(f\"\\nâœ… {summary}\\n\")\n                            \n                            # Display generated Playwright code\n                            if playwright_code:\n                                print(\"=\" * 70)\n                                print(\"ðŸ“ GENERATED PLAYWRIGHT CODE (with working locators):\")\n                                print(\"=\" * 70)\n                                print(playwright_code)\n                                print(\"=\" * 70)\n                                print()\n                            \n                            break\n                    else:\n                        print(f\"\\nâœ… {result}\\n\")\n                        break\n                \n            except KeyboardInterrupt:\n                print(\"\\n\\nðŸ‘‹ Interrupted. Goodbye!\")\n                break\n            except Exception as e:\n                logger.error(f\"Error: {e}\")\n                print(f\"\\nâŒ Error: {e}\\n\")\n    \n    finally:\n        await automation.cleanup()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":44561},"src/automation/recorder.py":{"content":"\"\"\"\nBrowser Action Recorder\nCaptures user interactions and generates natural language commands + Playwright code\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom openai import AsyncOpenAI\n\n\n@dataclass\nclass RecordedAction:\n    \"\"\"Represents a single recorded browser action.\"\"\"\n    timestamp: str\n    action_type: str  # click, type, navigate, select, etc.\n    selector: Optional[str] = None\n    element_text: Optional[str] = None\n    element_tag: Optional[str] = None\n    value: Optional[str] = None  # For typing, selecting\n    url: Optional[str] = None  # For navigation\n    metadata: Optional[Dict[str, Any]] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\n\nclass BrowserRecorder:\n    \"\"\"Records browser interactions and generates automation code.\"\"\"\n    \n    def __init__(self, openai_api_key: str):\n        self.is_recording = False\n        self.recorded_actions: List[RecordedAction] = []\n        self.session_start_time: Optional[datetime] = None\n        self.client = AsyncOpenAI(api_key=openai_api_key)\n        self._fetched_count = 0  # Track how many events we've already fetched\n        \n        # JavaScript code to inject into browser for event capture\n        self.recorder_script = \"\"\"\n        (function() {\n            // Use sessionStorage to persist events across page loads\n            const STORAGE_KEY_EVENTS = '__recordedEvents';\n            const STORAGE_KEY_LAST_URL = '__lastRecordedUrl';\n            \n            // Load existing events from sessionStorage\n            let events = [];\n            try {\n                const stored = sessionStorage.getItem(STORAGE_KEY_EVENTS);\n                if (stored) {\n                    events = JSON.parse(stored);\n                }\n            } catch (e) {}\n            window.__recordedEvents = events;\n            \n            // Get last URL from storage\n            const lastUrl = sessionStorage.getItem(STORAGE_KEY_LAST_URL) || '';\n            const currentUrl = window.location.href;\n            \n            // If URL changed (full page load), record navigation\n            if (lastUrl && currentUrl !== lastUrl) {\n                window.__recordedEvents.push({\n                    type: 'navigate',\n                    url: currentUrl,\n                    timestamp: Date.now()\n                });\n                // Save immediately\n                try {\n                    sessionStorage.setItem(STORAGE_KEY_EVENTS, JSON.stringify(window.__recordedEvents));\n                } catch (e) {}\n            }\n            \n            // Update last URL in storage\n            try {\n                sessionStorage.setItem(STORAGE_KEY_LAST_URL, currentUrl);\n            } catch (e) {}\n            \n            // Helper to save events to sessionStorage\n            function saveEvents() {\n                try {\n                    sessionStorage.setItem(STORAGE_KEY_EVENTS, JSON.stringify(window.__recordedEvents));\n                } catch (e) {}\n            }\n            \n            // Prevent duplicate listener registration\n            if (window.__recorderInjected) return;\n            window.__recorderInjected = true;\n            \n            // Helper to get unique selector for element\n            function getSelector(el) {\n                if (!el) return null;\n                \n                // Try ID first\n                if (el.id) return '#' + el.id;\n                \n                // Try name attribute\n                if (el.name) return `[name=\"${el.name}\"]`;\n                \n                // Try aria-label\n                if (el.getAttribute('aria-label')) {\n                    return `[aria-label=\"${el.getAttribute('aria-label')}\"]`;\n                }\n                \n                // Try placeholder\n                if (el.placeholder) return `[placeholder=\"${el.placeholder}\"]`;\n                \n                // Try text content for buttons/links\n                if (['BUTTON', 'A'].includes(el.tagName)) {\n                    const text = el.innerText?.trim();\n                    if (text && text.length < 50) {\n                        return `text=${text}`;\n                    }\n                }\n                \n                // Try role\n                const role = el.getAttribute('role');\n                if (role) return `[role=\"${role}\"]`;\n                \n                // Fallback to tag + nth-child\n                let selector = el.tagName.toLowerCase();\n                if (el.className) {\n                    const classes = el.className.split(' ').filter(c => c).slice(0, 2);\n                    if (classes.length) {\n                        selector += '.' + classes.join('.');\n                    }\n                }\n                \n                return selector;\n            }\n            \n            // Track navigation events\n            function recordNavigation(url) {\n                const lastUrl = sessionStorage.getItem(STORAGE_KEY_LAST_URL) || '';\n                if (url !== lastUrl) {\n                    window.__recordedEvents.push({\n                        type: 'navigate',\n                        url: url,\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                    try {\n                        sessionStorage.setItem(STORAGE_KEY_LAST_URL, url);\n                    } catch (e) {}\n                }\n            }\n            \n            // Listen for URL changes (SPA navigation)\n            window.addEventListener('popstate', function() {\n                recordNavigation(window.location.href);\n            });\n            \n            // Intercept pushState and replaceState\n            const originalPushState = history.pushState;\n            const originalReplaceState = history.replaceState;\n            \n            history.pushState = function() {\n                originalPushState.apply(this, arguments);\n                recordNavigation(window.location.href);\n            };\n            \n            history.replaceState = function() {\n                originalReplaceState.apply(this, arguments);\n                recordNavigation(window.location.href);\n            };\n            \n            // Record click events\n            document.addEventListener('click', function(e) {\n                const el = e.target;\n                window.__recordedEvents.push({\n                    type: 'click',\n                    selector: getSelector(el),\n                    text: el.innerText?.trim().substring(0, 100) || null,\n                    tag: el.tagName.toLowerCase(),\n                    timestamp: Date.now()\n                });\n                saveEvents();\n            }, true);\n            \n            // Record input events (text, email, password, search, etc.)\n            document.addEventListener('input', function(e) {\n                const el = e.target;\n                if (['INPUT', 'TEXTAREA'].includes(el.tagName)) {\n                    window.__recordedEvents.push({\n                        type: 'type',\n                        selector: getSelector(el),\n                        value: el.value,\n                        tag: el.tagName.toLowerCase(),\n                        inputType: el.type || 'text',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                }\n            }, true);\n            \n            // Record change events (checkboxes, radios, selects)\n            document.addEventListener('change', function(e) {\n                const el = e.target;\n                \n                if (el.tagName === 'SELECT') {\n                    window.__recordedEvents.push({\n                        type: 'select',\n                        selector: getSelector(el),\n                        value: el.value,\n                        text: el.options[el.selectedIndex]?.text,\n                        tag: 'select',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                } else if (el.type === 'checkbox') {\n                    window.__recordedEvents.push({\n                        type: 'check',\n                        selector: getSelector(el),\n                        checked: el.checked,\n                        tag: 'checkbox',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                } else if (el.type === 'radio') {\n                    window.__recordedEvents.push({\n                        type: 'radio',\n                        selector: getSelector(el),\n                        value: el.value,\n                        tag: 'radio',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                }\n            }, true);\n            \n            // Record form submissions\n            document.addEventListener('submit', function(e) {\n                const form = e.target;\n                window.__recordedEvents.push({\n                    type: 'submit',\n                    selector: getSelector(form),\n                    tag: 'form',\n                    timestamp: Date.now()\n                });\n                saveEvents();\n            }, true);\n            \n            console.log('ðŸŽ¥ Browser recorder activated - all interactions are being captured');\n        })();\n        \"\"\"\n    \n    async def start_recording(self, mcp_client) -> str:\n        \"\"\"Start recording browser interactions.\"\"\"\n        self.is_recording = True\n        self.recorded_actions = []\n        self._fetched_count = 0  # Reset offset\n        self.session_start_time = datetime.now()\n        \n        # Clear any stale sessionStorage data from previous sessions\n        try:\n            await mcp_client.evaluate(\"\"\"\n                sessionStorage.removeItem('__recordedEvents');\n                sessionStorage.removeItem('__lastRecordedUrl');\n                window.__recordedEvents = [];\n            \"\"\")\n        except Exception:\n            pass\n        \n        return \"Recording started - perform your actions in the browser\"\n    \n    def stop_recording(self) -> str:\n        \"\"\"Stop recording browser interactions.\"\"\"\n        self.is_recording = False\n        action_count = len(self.recorded_actions)\n        return f\"Recording stopped - captured {action_count} actions\"\n    \n    async def maintain_recording(self, mcp_client) -> None:\n        \"\"\"Periodically reinject recorder script and pull events to Python.\n        This ensures events are persisted even across cross-origin navigations.\n        Should be called in a background loop while recording is active.\n        \"\"\"\n        if not self.is_recording:\n            return\n        \n        try:\n            # Reinject the script to capture any new page loads\n            await mcp_client.evaluate(self.recorder_script)\n            \n            # Pull events from browser to Python (backup for cross-origin navigation)\n            await self.fetch_recorded_events(mcp_client, clear_after_fetch=False)\n        except Exception:\n            pass  # Silently fail if page is not ready\n    \n    def get_recorder_script(self) -> str:\n        \"\"\"Get the JavaScript to inject for recording.\"\"\"\n        return self.recorder_script\n    \n    async def fetch_recorded_events(self, mcp_client, clear_after_fetch: bool = True) -> List[RecordedAction]:\n        \"\"\"Fetch NEW events from browser and convert to RecordedAction objects.\n        \n        Args:\n            mcp_client: The MCP client to use for evaluation\n            clear_after_fetch: If True, clears events from browser after fetching (default)\n                             If False, only fetches new events since last fetch (for periodic backups)\n        \"\"\"\n        try:\n            # Get events from browser\n            if clear_after_fetch:\n                # Final fetch - only get NEW events we haven't fetched yet, then clear\n                result = await mcp_client.evaluate(f\"\"\"\n                    (function() {{\n                        const allEvents = window.__recordedEvents || [];\n                        const newEvents = allEvents.slice({self._fetched_count});\n                        window.__recordedEvents = [];  // Clear after fetching\n                        sessionStorage.removeItem('__recordedEvents');  // Clear storage too\n                        return newEvents;\n                    }})();\n                \"\"\")\n                self._fetched_count = 0  # Reset offset\n            else:\n                # Periodic fetch - only get new events since last fetch\n                result = await mcp_client.evaluate(f\"\"\"\n                    (function() {{\n                        const allEvents = window.__recordedEvents || [];\n                        const newEvents = allEvents.slice({self._fetched_count});\n                        return newEvents;\n                    }})();\n                \"\"\")\n            \n            if isinstance(result, list) and len(result) > 0:\n                # Convert events to RecordedAction objects\n                for event in result:\n                    metadata = {}\n                    if event.get('inputType'):\n                        metadata['inputType'] = event['inputType']\n                    if 'checked' in event:\n                        metadata['checked'] = event['checked']\n                    \n                    action = RecordedAction(\n                        timestamp=datetime.fromtimestamp(event.get('timestamp', 0) / 1000).isoformat(),\n                        action_type=event.get('type', 'unknown'),\n                        selector=event.get('selector'),\n                        element_text=event.get('text'),\n                        element_tag=event.get('tag'),\n                        value=event.get('value'),\n                        url=event.get('url'),\n                        metadata=metadata if metadata else None\n                    )\n                    self.recorded_actions.append(action)\n                \n                # Update fetched count if doing periodic fetch\n                if not clear_after_fetch:\n                    self._fetched_count += len(result)\n            \n            return self.recorded_actions\n        except Exception as e:\n            print(f\"Error fetching recorded events: {e}\")\n            return []\n    \n    def _deduplicate_actions(self, actions: List[RecordedAction]) -> List[RecordedAction]:\n        \"\"\"Remove duplicate/redundant actions (e.g., multiple type events for same field).\"\"\"\n        if not actions:\n            return []\n        \n        deduplicated = []\n        i = 0\n        \n        while i < len(actions):\n            current = actions[i]\n            \n            # For 'type' actions, merge consecutive types on same element\n            if current.action_type == 'type':\n                # Look ahead for more type actions on same selector\n                j = i + 1\n                while j < len(actions) and actions[j].action_type == 'type' and actions[j].selector == current.selector:\n                    # Use the last value (final text)\n                    current.value = actions[j].value\n                    j += 1\n                i = j\n            else:\n                i += 1\n            \n            deduplicated.append(current)\n        \n        return deduplicated\n    \n    async def generate_natural_language(self, actions: List[RecordedAction]) -> str:\n        \"\"\"Use AI to generate natural language description of recorded actions.\"\"\"\n        if not actions:\n            return \"No actions recorded\"\n        \n        # Deduplicate first\n        actions = self._deduplicate_actions(actions)\n        \n        # Create a summary of actions\n        action_summary = []\n        for action in actions:\n            if action.action_type == 'navigate':\n                action_summary.append(f\"Navigated to {action.url}\")\n            elif action.action_type == 'click':\n                desc = f\"Clicked {action.element_tag}\"\n                if action.element_text:\n                    desc += f\" with text '{action.element_text[:50]}'\"\n                action_summary.append(desc)\n            elif action.action_type == 'type':\n                desc = f\"Typed '{action.value}' into {action.element_tag}\"\n                if action.selector:\n                    desc += f\" ({action.selector})\"\n                action_summary.append(desc)\n            elif action.action_type == 'select':\n                action_summary.append(f\"Selected '{action.value}' from dropdown\")\n            elif action.action_type == 'check':\n                action_summary.append(f\"{'Checked' if action.metadata and action.metadata.get('checked') else 'Unchecked'} checkbox\")\n            elif action.action_type == 'radio':\n                action_summary.append(f\"Selected radio button '{action.value}'\")\n            elif action.action_type == 'submit':\n                action_summary.append(\"Submitted form\")\n        \n        # Use AI to create natural language command\n        prompt = f\"\"\"Convert these browser actions into a single, clear natural language automation command:\n\nActions performed:\n{chr(10).join(f'{i+1}. {a}' for i, a in enumerate(action_summary))}\n\nGenerate a concise natural language command that describes this workflow (1-2 sentences max).\nFocus on the user's intent, not technical details.\n\nExamples:\n- \"Search for Python tutorials on Google\"\n- \"Fill out contact form and submit\"\n- \"Login with credentials and navigate to dashboard\"\n\nNatural language command:\"\"\"\n\n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.7,\n                max_tokens=100\n            )\n            content = response.choices[0].message.content\n            return content.strip() if content else \"\"\n        except Exception as e:\n            # Fallback to simple concatenation\n            return \" and \".join(action_summary[:5])\n    \n    def generate_playwright_code(self, actions: List[RecordedAction]) -> str:\n        \"\"\"Generate clean Playwright Python code from recorded actions.\"\"\"\n        if not actions:\n            return \"# No actions recorded\"\n        \n        # Deduplicate actions\n        actions = self._deduplicate_actions(actions)\n        \n        code_lines = [\n            \"# Generated from recorded browser interactions\",\n            f\"# Recorded: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\",\n            \"\",\n            \"from playwright.async_api import async_playwright\",\n            \"\",\n            \"async def recorded_workflow():\",\n            \"    async with async_playwright() as p:\",\n            \"        browser = await p.chromium.launch(headless=True)\",\n            \"        page = await browser.new_page()\",\n            \"\"\n        ]\n        \n        for action in actions:\n            if action.action_type == 'navigate':\n                code_lines.append(f\"        # Navigate to page\")\n                code_lines.append(f\"        await page.goto('{action.url}')\")\n                \n            elif action.action_type == 'click':\n                code_lines.append(f\"        # Click element\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').click()\")\n                else:\n                    code_lines.append(f\"        # TODO: Add proper selector for click\")\n                    \n            elif action.action_type == 'type':\n                code_lines.append(f\"        # Type into field\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').fill('{action.value}')\")\n                else:\n                    code_lines.append(f\"        # TODO: Add proper selector for input\")\n                    \n            elif action.action_type == 'select':\n                code_lines.append(f\"        # Select dropdown option\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').select_option('{action.value}')\")\n                    \n            elif action.action_type == 'check':\n                checked = action.metadata and action.metadata.get('checked', False)\n                code_lines.append(f\"        # {'Check' if checked else 'Uncheck'} checkbox\")\n                if action.selector:\n                    if checked:\n                        code_lines.append(f\"        await page.locator('{action.selector}').check()\")\n                    else:\n                        code_lines.append(f\"        await page.locator('{action.selector}').uncheck()\")\n                        \n            elif action.action_type == 'radio':\n                code_lines.append(f\"        # Select radio button\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').check()\")\n                    \n            elif action.action_type == 'submit':\n                code_lines.append(f\"        # Submit form\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').press('Enter')\")\n            \n            code_lines.append(\"\")\n        \n        code_lines.extend([\n            \"        await browser.close()\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            \"    import asyncio\",\n            \"    asyncio.run(recorded_workflow())\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    def export_recording(self, actions: List[RecordedAction], format: str = 'json') -> str:\n        \"\"\"Export recorded actions in various formats.\"\"\"\n        if format == 'json':\n            return json.dumps([a.to_dict() for a in actions], indent=2)\n        else:\n            return str(actions)\n    \n    def clear_recording(self):\n        \"\"\"Clear all recorded actions.\"\"\"\n        self.recorded_actions = []\n        self.session_start_time = None\n","size_bytes":22053},"src/automation/advanced_tools.py":{"content":"import base64\nimport asyncio\nfrom typing import Optional, Dict, Any, List, Union\nfrom pathlib import Path\nfrom dataclasses import dataclass\n\nfrom playwright.async_api import Page, Frame, ElementHandle\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass PageContext:\n    \"\"\"Rich context about the current page state.\"\"\"\n    url: str\n    title: str\n    has_iframes: bool\n    has_popups: bool\n    has_alerts: bool\n    visible_elements: List[str]\n    dom_snapshot: Optional[str] = None\n    screenshot_base64: Optional[str] = None\n\n\nclass AdvancedPlaywrightTools:\n    \"\"\"\n    Advanced Playwright tools with intelligent capabilities:\n    - Vision-based element detection\n    - Dynamic content handling\n    - iframe/popup management\n    - File upload/download\n    - Smart waiting strategies\n    - DOM inspection\n    \"\"\"\n    \n    def __init__(self, page: Page):\n        self.page = page\n        self.frames: List[Frame] = []\n        self.context_history: List[PageContext] = []\n    \n    async def get_page_context(self, include_screenshot: bool = False, \n                               include_dom: bool = False) -> PageContext:\n        \"\"\"\n        Get comprehensive context about the current page.\n        \"\"\"\n        try:\n            url = self.page.url\n            title = await self.page.title()\n            \n            frames = self.page.frames\n            has_iframes = len(frames) > 1\n            \n            has_alerts = False\n            has_popups = len(self.page.context.pages) > 1\n            \n            visible_elements = await self._get_visible_elements()\n            \n            dom_snapshot = None\n            if include_dom:\n                dom_snapshot = await self._get_dom_snapshot()\n            \n            screenshot_base64 = None\n            if include_screenshot:\n                screenshot_base64 = await self._capture_screenshot_base64()\n            \n            context = PageContext(\n                url=url,\n                title=title,\n                has_iframes=has_iframes,\n                has_popups=has_popups,\n                has_alerts=has_alerts,\n                visible_elements=visible_elements,\n                dom_snapshot=dom_snapshot,\n                screenshot_base64=screenshot_base64\n            )\n            \n            self.context_history.append(context)\n            if len(self.context_history) > 10:\n                self.context_history.pop(0)\n            \n            return context\n            \n        except Exception as e:\n            logger.error(f\"Error getting page context: {e}\")\n            return PageContext(\n                url=\"unknown\",\n                title=\"unknown\",\n                has_iframes=False,\n                has_popups=False,\n                has_alerts=False,\n                visible_elements=[]\n            )\n    \n    async def _get_visible_elements(self) -> List[str]:\n        \"\"\"Get list of visible interactive elements on the page.\"\"\"\n        script = \"\"\"\n        () => {\n            const elements = [];\n            const selectors = [\n                'button', 'a', 'input', 'textarea', 'select',\n                '[role=\"button\"]', '[onclick]', '[href]',\n                'h1', 'h2', 'h3', 'form', 'nav'\n            ];\n            \n            selectors.forEach(selector => {\n                document.querySelectorAll(selector).forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        const text = el.textContent?.trim().substring(0, 50) || '';\n                        const id = el.id ? `#${el.id}` : '';\n                        const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                        elements.push({\n                            tag: el.tagName.toLowerCase(),\n                            id: id,\n                            class: className,\n                            text: text,\n                            type: el.type || '',\n                            visible: true\n                        });\n                    }\n                });\n            });\n            \n            return elements.slice(0, 50);\n        }\n        \"\"\"\n        \n        try:\n            elements = await self.page.evaluate(script)\n            return [\n                f\"{el['tag']}{el['id']}{el['class']} - {el['text']}\"\n                for el in elements\n            ]\n        except Exception as e:\n            logger.error(f\"Error getting visible elements: {e}\")\n            return []\n    \n    async def _get_dom_snapshot(self) -> str:\n        \"\"\"Get simplified DOM snapshot for AI analysis.\"\"\"\n        script = \"\"\"\n        () => {\n            const getSnapshot = (el, depth = 0, maxDepth = 3) => {\n                if (depth > maxDepth) return '';\n                \n                const indent = '  '.repeat(depth);\n                const tag = el.tagName.toLowerCase();\n                const id = el.id ? `#${el.id}` : '';\n                const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                const text = el.childNodes.length === 1 && el.childNodes[0].nodeType === 3\n                    ? ` \"${el.textContent.trim().substring(0, 30)}\"`\n                    : '';\n                \n                let result = `${indent}<${tag}${id}${className}${text}>\\\\n`;\n                \n                for (const child of el.children) {\n                    result += getSnapshot(child, depth + 1, maxDepth);\n                }\n                \n                return result;\n            };\n            \n            return getSnapshot(document.body);\n        }\n        \"\"\"\n        \n        try:\n            snapshot = await self.page.evaluate(script)\n            return snapshot[:5000]\n        except Exception as e:\n            logger.error(f\"Error getting DOM snapshot: {e}\")\n            return \"\"\n    \n    async def _capture_screenshot_base64(self) -> str:\n        \"\"\"Capture screenshot as base64 for vision analysis.\"\"\"\n        try:\n            screenshot_bytes = await self.page.screenshot(full_page=False)\n            return base64.b64encode(screenshot_bytes).decode('utf-8')\n        except Exception as e:\n            logger.error(f\"Error capturing screenshot: {e}\")\n            return \"\"\n    \n    async def smart_find_element(self, description: str) -> Optional[str]:\n        \"\"\"\n        Find element using intelligent strategies based on natural language description.\n        Returns the best selector found.\n        \"\"\"\n        logger.info(f\"Smart finding element: {description}\")\n        \n        # Order strategies from most specific to least specific\n        strategies = [\n            self._find_by_aria_label(description),\n            self._find_by_placeholder(description),\n            self._find_by_id_or_class(description),\n            self._find_by_type(description),\n            self._find_by_text(description)\n        ]\n        \n        for strategy in strategies:\n            try:\n                selector = await strategy\n                if selector and await self._element_exists(selector):\n                    logger.success(f\"Found element using {strategy.__name__}: {selector}\")\n                    return selector\n            except Exception as e:\n                logger.debug(f\"Strategy {strategy.__name__} failed: {e}\")\n                continue\n        \n        logger.warning(f\"Could not find element: {description}\")\n        return None\n    \n    async def _find_by_text(self, description: str) -> Optional[str]:\n        \"\"\"Find element by visible text content.\"\"\"\n        keywords = description.lower().split()\n        \n        for keyword in keywords:\n            if len(keyword) < 3:\n                continue\n            \n            selector = f\"text={keyword}\"\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_aria_label(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ARIA label.\"\"\"\n        selector = f\"[aria-label*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_placeholder(self, description: str) -> Optional[str]:\n        \"\"\"Find input by placeholder text.\"\"\"\n        selector = f\"[placeholder*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_id_or_class(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ID or class name.\"\"\"\n        clean_desc = description.lower().replace(' ', '-')\n        \n        selectors = [\n            f\"#{clean_desc}\",\n            f\".{clean_desc}\",\n            f\"[id*='{clean_desc}']\",\n            f\"[class*='{clean_desc}']\"\n        ]\n        \n        for selector in selectors:\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_type(self, description: str) -> Optional[str]:\n        \"\"\"Find element by type (button, link, input, etc.).\"\"\"\n        type_map = {\n            'button': 'button, [role=\"button\"], input[type=\"submit\"]',\n            'link': 'a[href]',\n            'search': 'input[type=\"search\"], input[name*=\"search\"], input[name*=\"q\"], textarea[name*=\"search\"]',\n            'input': 'input:not([type=\"submit\"]):not([type=\"button\"]):not([type=\"hidden\"]), textarea',\n            'text': 'input[type=\"text\"], input:not([type]), textarea',\n            'email': 'input[type=\"email\"], input[name*=\"email\"]',\n            'password': 'input[type=\"password\"]',\n            'submit': 'button[type=\"submit\"], input[type=\"submit\"]',\n            'form': 'form',\n            'heading': 'h1, h2, h3, h4, h5, h6'\n        }\n        \n        desc_lower = description.lower()\n        \n        # Prioritize search-specific selectors\n        if 'search' in desc_lower or 'query' in desc_lower:\n            if await self._element_exists(type_map['search']):\n                return type_map['search']\n        \n        for keyword, selector in type_map.items():\n            if keyword in desc_lower:\n                if await self._element_exists(selector):\n                    return selector\n        \n        return None\n    \n    async def _element_exists(self, selector: str) -> bool:\n        \"\"\"Check if element exists and is visible.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                is_visible = await element.is_visible()\n                return is_visible\n            return False\n        except Exception:\n            return False\n    \n    async def handle_iframe(self, iframe_selector: Optional[str] = None) -> Optional[Frame]:\n        \"\"\"Switch context to iframe for automation.\"\"\"\n        try:\n            if iframe_selector:\n                frame_element = await self.page.query_selector(iframe_selector)\n                if frame_element:\n                    frame = await frame_element.content_frame()\n                    if frame:\n                        logger.info(f\"Switched to iframe: {iframe_selector}\")\n                        return frame\n            else:\n                frames = self.page.frames\n                if len(frames) > 1:\n                    logger.info(f\"Found {len(frames)} frames\")\n                    return frames[1]\n            \n            return None\n        except Exception as e:\n            logger.error(f\"Error handling iframe: {e}\")\n            return None\n    \n    async def handle_popup(self) -> Optional[Page]:\n        \"\"\"Handle popup windows.\"\"\"\n        try:\n            pages = self.page.context.pages\n            if len(pages) > 1:\n                popup = pages[-1]\n                logger.info(f\"Switched to popup: {popup.url}\")\n                return popup\n            return None\n        except Exception as e:\n            logger.error(f\"Error handling popup: {e}\")\n            return None\n    \n    async def wait_for_dynamic_content(self, timeout: int = 10000):\n        \"\"\"Wait for dynamic content to load (AJAX, lazy loading, etc.).\"\"\"\n        try:\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            \n            await self.page.wait_for_function(\n                \"\"\"() => {\n                    return document.readyState === 'complete' &&\n                           performance.timing.loadEventEnd > 0;\n                }\"\"\",\n                timeout=timeout\n            )\n            \n            logger.info(\"Dynamic content loaded\")\n        except Exception as e:\n            logger.warning(f\"Timeout waiting for dynamic content: {e}\")\n    \n    async def scroll_to_element(self, selector: str):\n        \"\"\"Scroll element into view.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.scroll_into_view_if_needed()\n                logger.info(f\"Scrolled to element: {selector}\")\n        except Exception as e:\n            logger.error(f\"Error scrolling to element: {e}\")\n    \n    async def handle_file_upload(self, selector: str, file_path: str):\n        \"\"\"Handle file upload.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.set_input_files(file_path)\n                logger.success(f\"File uploaded: {file_path}\")\n                return True\n            return False\n        except Exception as e:\n            logger.error(f\"Error uploading file: {e}\")\n            return False\n    \n    async def extract_table_data(self, table_selector: str = \"table\") -> List[Dict[str, Any]]:\n        \"\"\"Extract structured data from HTML tables.\"\"\"\n        script = f\"\"\"\n        (selector) => {{\n            const table = document.querySelector(selector);\n            if (!table) return [];\n            \n            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());\n            const rows = Array.from(table.querySelectorAll('tbody tr'));\n            \n            return rows.map(row => {{\n                const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());\n                const rowData = {{}};\n                headers.forEach((header, i) => {{\n                    rowData[header] = cells[i] || '';\n                }});\n                return rowData;\n            }});\n        }}\n        \"\"\"\n        \n        try:\n            data = await self.page.evaluate(script, table_selector)\n            logger.info(f\"Extracted {len(data)} rows from table\")\n            return data\n        except Exception as e:\n            logger.error(f\"Error extracting table data: {e}\")\n            return []\n    \n    async def extract_links(self, filter_text: Optional[str] = None) -> List[Dict[str, str]]:\n        \"\"\"Extract all links from page, optionally filtered by text.\"\"\"\n        script = \"\"\"\n        (filterText) => {\n            const links = Array.from(document.querySelectorAll('a[href]'));\n            return links\n                .filter(a => !filterText || a.textContent.toLowerCase().includes(filterText.toLowerCase()))\n                .map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    title: a.title || ''\n                }))\n                .slice(0, 100);\n        }\n        \"\"\"\n        \n        try:\n            links = await self.page.evaluate(script, filter_text)\n            logger.info(f\"Extracted {len(links)} links\")\n            return links\n        except Exception as e:\n            logger.error(f\"Error extracting links: {e}\")\n            return []\n    \n    async def wait_for_navigation_complete(self, timeout: int = 30000):\n        \"\"\"Wait for page navigation to complete fully.\"\"\"\n        try:\n            await self.page.wait_for_load_state('domcontentloaded', timeout=timeout)\n            await self.page.wait_for_load_state('load', timeout=timeout)\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            logger.info(\"Navigation completed\")\n        except Exception as e:\n            logger.warning(f\"Navigation timeout: {e}\")\n","size_bytes":16127},"main.py":{"content":"import asyncio\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.automation import BrowserEngine, TaskExecutor, AITaskGenerator, AI_AVAILABLE\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger, console\nfrom rich.prompt import Prompt, Confirm\nfrom rich.table import Table\nfrom rich.panel import Panel\n\nlogger = get_logger()\n\n\nasync def run_web_automation_demo():\n    console.print(Panel.fit(\"Web Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to automate\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        page_title = await browser.get_text(\"h1\")\n        if page_title:\n            logger.success(f\"Page heading: {page_title}\")\n        \n        links = await browser.get_all_text(\"a\")\n        if links:\n            console.print(f\"\\n[cyan]Found {len(links)} links on the page[/cyan]\")\n            \n            table = Table(title=\"First 10 Links\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=3)\n            table.add_column(\"Link Text\", style=\"cyan\")\n            \n            for i, link_text in enumerate(links[:10], 1):\n                if link_text.strip():\n                    table.add_row(str(i), link_text.strip()[:80])\n            \n            console.print(table)\n        \n        screenshot_path = await browser.screenshot(\"web_automation_demo\")\n        logger.success(f\"Screenshot saved to {screenshot_path}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_ai_code_generation():\n    console.print(Panel.fit(\"AI Code Generation Demo\", style=\"bold cyan\"))\n    \n    if not AI_AVAILABLE:\n        console.print(\"[red]AI code generation is not available due to package compatibility issues.[/red]\")\n        console.print(\"[yellow]The core automation framework works without AI features.[/yellow]\")\n        return\n    \n    task_description = Prompt.ask(\n        \"Describe the automation task\"\n    )\n    \n    config = AutomationConfig(openai_model=\"gpt-4o-mini\", mcp_timeout=300)\n    generator = AITaskGenerator(config)\n    \n    console.print(\"\\n[yellow]Generating code... This may take a moment.[/yellow]\\n\")\n    \n    code = await generator.generate_playwright_code(task_description)\n    \n    if code:\n        console.print(Panel(code, title=\"Generated Code\", border_style=\"green\"))\n        \n        if Confirm.ask(\"Save to file?\", default=True):\n            filename = Prompt.ask(\"Filename\", default=\"generated_automation.py\")\n            with open(filename, 'w') as f:\n                f.write(code)\n            logger.success(f\"Code saved to {filename}\")\n    else:\n        logger.error(\"Failed to generate code. Make sure OPENAI_API_KEY is set.\")\n\n\nasync def run_form_automation_demo():\n    console.print(Panel.fit(\"Form Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter form URL\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        console.print(\"\\n[yellow]You can now define form fields to fill[/yellow]\")\n        console.print(\"[dim]Example: input[name='email'] = test@example.com[/dim]\\n\")\n        \n        form_data = {}\n        \n        while True:\n            selector = Prompt.ask(\"Enter CSS selector (or press Enter to finish)\", default=\"\")\n            if not selector:\n                break\n            \n            value = Prompt.ask(f\"Enter value for '{selector}'\")\n            form_data[selector] = value\n        \n        if form_data:\n            success = await executor.fill_form(form_data)\n            if success:\n                logger.success(\"Form filled successfully!\")\n                \n                screenshot_path = await browser.screenshot(\"form_filled\")\n                logger.success(f\"Screenshot saved to {screenshot_path}\")\n        else:\n            logger.info(\"No form data provided\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_data_extraction_demo():\n    console.print(Panel.fit(\"Data Extraction Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to extract data from\")\n    selector = Prompt.ask(\"Enter CSS selector for elements to extract\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        texts = await browser.get_all_text(selector)\n        \n        if texts:\n            console.print(f\"\\n[cyan]Found {len(texts)} elements matching '{selector}'[/cyan]\\n\")\n            \n            table = Table(title=\"Extracted Data\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=5)\n            table.add_column(\"Content\", style=\"green\")\n            \n            for i, text in enumerate(texts[:20], 1):\n                if text.strip():\n                    table.add_row(str(i), text.strip()[:100])\n            \n            console.print(table)\n            \n            if Confirm.ask(\"\\nSave to file?\", default=False):\n                filename = Prompt.ask(\"Filename\", default=\"extracted_data.txt\")\n                with open(filename, 'w') as f:\n                    for text in texts:\n                        f.write(f\"{text}\\n\")\n                logger.success(f\"Data saved to {filename}\")\n        else:\n            logger.warning(f\"No elements found matching selector: {selector}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def main():\n    console.print(Panel.fit(\n        \"[bold cyan]Browser Automation Framework[/bold cyan]\\n\"\n        \"[dim]Universal web automation for any site[/dim]\",\n        border_style=\"cyan\"\n    ))\n    \n    options = {\n        \"1\": (\"Web Automation Demo\", run_web_automation_demo),\n        \"2\": (\"Form Automation Demo\", run_form_automation_demo),\n        \"3\": (\"Data Extraction Demo\", run_data_extraction_demo),\n        \"4\": (f\"AI Code Generation {'[dim](unavailable)[/dim]' if not AI_AVAILABLE else ''}\", run_ai_code_generation),\n        \"5\": (\"Exit\", None)\n    }\n    \n    while True:\n        console.print(\"\\n[bold]Available Demos:[/bold]\")\n        for key, (name, _) in options.items():\n            console.print(f\"  {key}. {name}\")\n        \n        choice = Prompt.ask(\"\\nSelect an option\", choices=list(options.keys()), default=\"1\")\n        \n        if choice == \"5\":\n            console.print(\"\\n[cyan]Goodbye![/cyan]\")\n            break\n        \n        _, func = options[choice]\n        if func:\n            try:\n                await func()\n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Operation cancelled[/yellow]\")\n            except Exception as e:\n                logger.exception(f\"Unexpected error: {e}\")\n        \n        console.print()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Program terminated[/yellow]\")\n","size_bytes":8117},"src/automation/selectors.py":{"content":"from typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom playwright.async_api import Page, Locator\nfrom .config import SelectorStrategy\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass SelectorOptions:\n    strategy: SelectorStrategy = SelectorStrategy.AUTO\n    timeout: int = 10000\n    state: str = \"visible\"\n    strict: bool = False\n\n\nclass SmartSelector:\n    \n    @staticmethod\n    async def find_element(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[Locator]:\n        if options is None:\n            options = SelectorOptions()\n        \n        if options.strategy == SelectorStrategy.AUTO:\n            return await SmartSelector._auto_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.CSS:\n            return await SmartSelector._css_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.XPATH:\n            return await SmartSelector._xpath_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.TEXT:\n            return await SmartSelector._text_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.ARIA:\n            return await SmartSelector._aria_select(page, selector, options)\n    \n    @staticmethod\n    async def _auto_select(page: Page, selector: str, options: SelectorOptions) -> Optional[Locator]:\n        strategies = [\n            (SelectorStrategy.CSS, SmartSelector._css_select),\n            (SelectorStrategy.XPATH, SmartSelector._xpath_select),\n            (SelectorStrategy.TEXT, SmartSelector._text_select),\n            (SelectorStrategy.ARIA, SmartSelector._aria_select),\n        ]\n        \n        for strategy_type, strategy_func in strategies:\n            try:\n                logger.debug(f\"Trying {strategy_type.value} selector: {selector}\")\n                element = await strategy_func(page, selector, options)\n                if element:\n                    count = await element.count()\n                    if count > 0:\n                        logger.success(f\"Found element using {strategy_type.value} selector\")\n                        return element\n            except Exception as e:\n                logger.debug(f\"{strategy_type.value} selector failed: {str(e)}\")\n                continue\n        \n        logger.warning(f\"Could not find element with any strategy: {selector}\")\n        return None\n    \n    @staticmethod\n    async def _css_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.locator(selector)\n    \n    @staticmethod\n    async def _xpath_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        if not selector.startswith('//') and not selector.startswith('('):\n            selector = f\"//{selector}\"\n        return page.locator(f\"xpath={selector}\")\n    \n    @staticmethod\n    async def _text_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_text(selector)\n    \n    @staticmethod\n    async def _aria_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_role(selector)\n    \n    @staticmethod\n    async def find_all(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> List[Locator]:\n        locator = await SmartSelector.find_element(page, selector, options)\n        if locator:\n            count = await locator.count()\n            return [locator.nth(i) for i in range(count)]\n        return []\n    \n    @staticmethod\n    async def safe_click(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.click(timeout=options.timeout if options else 10000)\n                logger.success(f\"Clicked element: {selector}\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to click element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def safe_fill(\n        page: Page,\n        selector: str,\n        value: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.fill(value, timeout=options.timeout if options else 10000)\n                logger.success(f\"Filled element {selector} with value\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to fill element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def get_text(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                text = await element.first.text_content(timeout=options.timeout if options else 10000)\n                return text\n        except Exception as e:\n            logger.error(f\"Failed to get text from {selector}: {str(e)}\")\n        return None\n    \n    @staticmethod\n    async def get_attribute(\n        page: Page,\n        selector: str,\n        attribute: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                attr_value = await element.first.get_attribute(attribute, timeout=options.timeout if options else 10000)\n                return attr_value\n        except Exception as e:\n            logger.error(f\"Failed to get attribute {attribute} from {selector}: {str(e)}\")\n        return None\n","size_bytes":5951},"src/automation/vision_analyzer.py":{"content":"import os\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\n\ntry:\n    from openai import AsyncOpenAI\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .advanced_tools import PageContext\n\nlogger = get_logger()\n\n\n@dataclass\nclass ElementLocation:\n    \"\"\"Location and description of an element found via vision.\"\"\"\n    description: str\n    suggested_selector: str\n    confidence: float\n    position: str  # e.g., \"top-left\", \"center\", \"bottom-right\"\n    element_type: str  # e.g., \"button\", \"link\", \"input\"\n\n\nclass VisionPageAnalyzer:\n    \"\"\"\n    Uses GPT-4 Vision to understand page structure and locate elements.\n    Provides intelligent element detection when traditional selectors fail.\n    \"\"\"\n    \n    def __init__(self):\n        self.client = None\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n        elif not api_key:\n            logger.warning(\"OPENAI_API_KEY not set for vision analysis\")\n        else:\n            self.client = AsyncOpenAI(api_key=api_key)\n    \n    async def analyze_page_structure(self, context: PageContext) -> Dict[str, Any]:\n        \"\"\"\n        Analyze page structure using vision to understand layout and elements.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            logger.warning(\"Vision analysis not available\")\n            return {}\n        \n        logger.info(\"Analyzing page structure with vision...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",  # Using mini for cost efficiency, upgrade to gpt-4o for better vision\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots.\nIdentify all interactive elements, their types, positions, and suggest CSS selectors.\nDescribe the page layout and main sections.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Analyze this web page screenshot. \n\nPage URL: {context.url}\nPage Title: {context.title}\nVisible Elements Count: {len(context.visible_elements)}\n\nProvide:\n1. Page layout description\n2. Main sections identified\n3. All interactive elements (buttons, links, forms, inputs)\n4. Suggested selectors for key elements\n5. Any notable UI patterns or frameworks detected\n\nFormat as JSON.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=1500,\n                temperature=0.3\n            )\n            \n            content = response.choices[0].message.content\n            logger.success(\"Vision analysis completed\")\n            \n            return {\"analysis\": content, \"model_used\": \"gpt-4o-mini\"}\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n    \n    async def find_element_by_description(self, context: PageContext, \n                                         description: str) -> Optional[ElementLocation]:\n        \"\"\"\n        Find an element on the page using visual analysis and natural language description.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Finding element by vision: {description}\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at locating elements in web page screenshots.\nGiven a description, identify the element's position and suggest the best CSS selector.\nRespond in JSON format with: description, selector, confidence, position, type.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Find this element: \"{description}\"\n\nPage context:\n- URL: {context.url}\n- Title: {context.title}\n- Visible elements: {len(context.visible_elements)}\n\nProvide JSON with:\n- description: what you found\n- suggested_selector: CSS selector to locate it\n- confidence: 0.0 to 1.0\n- position: where on page (top-left, center, etc)\n- element_type: button, link, input, etc.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            import json\n            content = response.choices[0].message.content\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            data = json.loads(content)\n            \n            location = ElementLocation(\n                description=data.get(\"description\", description),\n                suggested_selector=data.get(\"suggested_selector\", \"\"),\n                confidence=float(data.get(\"confidence\", 0.5)),\n                position=data.get(\"position\", \"unknown\"),\n                element_type=data.get(\"element_type\", \"unknown\")\n            )\n            \n            logger.success(f\"Vision found element: {location.suggested_selector} (confidence: {location.confidence})\")\n            return location\n            \n        except Exception as e:\n            logger.error(f\"Vision element finding error: {e}\")\n            return None\n    \n    async def suggest_next_action(self, context: PageContext, goal: str) -> Optional[str]:\n        \"\"\"\n        Use vision to suggest the next best action to achieve a goal.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Getting vision suggestion for goal: {goal}\")\n        \n        try:\n            dom_context = \"\"\n            if context.visible_elements:\n                dom_context = \"Visible elements:\\n\" + \"\\n\".join(context.visible_elements[:20])\n            \n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at browser automation.\nAnalyze the page and suggest the next action to achieve the user's goal.\nBe specific about which element to interact with and what action to take.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Goal: {goal}\n\nCurrent page:\n- URL: {context.url}\n- Title: {context.title}\n\n{dom_context}\n\nWhat should be the next action? Suggest one specific action with element selector.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=200,\n                temperature=0.3\n            )\n            \n            suggestion = response.choices[0].message.content\n            logger.info(f\"Vision suggestion: {suggestion}\")\n            return suggestion\n            \n        except Exception as e:\n            logger.error(f\"Vision suggestion error: {e}\")\n            return None\n    \n    async def diagnose_error(self, context: PageContext, error_message: str, \n                            failed_selector: str) -> Optional[str]:\n        \"\"\"\n        Use vision to diagnose why an action failed and suggest corrections.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(\"Using vision to diagnose error...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at debugging browser automation failures.\nAnalyze the screenshot and error to determine what went wrong and suggest a fix.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"An automation action failed:\n\nError: {error_message}\nFailed selector: {failed_selector}\nPage URL: {context.url}\nPage Title: {context.title}\n\nWhy did it fail? What selector should be used instead?\nProvide a corrected selector and explanation.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.3\n            )\n            \n            diagnosis = response.choices[0].message.content\n            logger.info(f\"Vision diagnosis: {diagnosis}\")\n            return diagnosis\n            \n        except Exception as e:\n            logger.error(f\"Vision diagnosis error: {e}\")\n            return None\n\n\nclass VisionAnalyzer:\n    \"\"\"Simplified vision analyzer for MCP automation.\"\"\"\n    \n    def __init__(self, api_key: str):\n        self.client = None\n        try:\n            from openai import AsyncOpenAI\n            self.client = AsyncOpenAI(api_key=api_key)\n        except ImportError:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n    \n    async def analyze_page(self, screenshot_b64: str, instruction: str) -> Dict[str, Any]:\n        \"\"\"Analyze page screenshot and suggest selectors for the given instruction.\"\"\"\n        if not self.client:\n            return {}\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots for automation.\nGiven a user instruction, analyze the screenshot and suggest the best CSS selector to use.\nRespond with JSON containing: {\"suggested_selector\": \"...\", \"element_type\": \"...\", \"confidence\": 0.0-1.0}\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"image_url\",\n                                \"image_url\": {\n                                    \"url\": f\"data:image/png;base64,{screenshot_b64}\"\n                                }\n                            },\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"Task: {instruction}\\n\\nWhat selector should be used to accomplish this task?\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            content = response.choices[0].message.content or \"{}\"\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            import json\n            return json.loads(content)\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n","size_bytes":11998},"src/automation/logger.py":{"content":"import logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\nfrom rich.console import Console\nfrom rich.logging import RichHandler\nfrom rich.theme import Theme\n\n\ncustom_theme = Theme({\n    \"info\": \"cyan\",\n    \"warning\": \"yellow\",\n    \"error\": \"red bold\",\n    \"success\": \"green bold\",\n})\n\nconsole = Console(theme=custom_theme)\n\n\nclass AutomationLogger:\n    def __init__(self, name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        \n        if not self.logger.handlers:\n            console_handler = RichHandler(\n                console=console,\n                rich_tracebacks=True,\n                tracebacks_show_locals=True,\n                show_time=True,\n                show_path=True\n            )\n            console_handler.setLevel(getattr(logging, log_level.upper()))\n            self.logger.addHandler(console_handler)\n            \n            if log_file:\n                log_path = Path(log_file)\n                log_path.parent.mkdir(parents=True, exist_ok=True)\n                file_handler = logging.FileHandler(log_file)\n                file_handler.setLevel(logging.DEBUG)\n                formatter = logging.Formatter(\n                    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n                )\n                file_handler.setFormatter(formatter)\n                self.logger.addHandler(file_handler)\n    \n    def info(self, message: str):\n        self.logger.info(message)\n    \n    def success(self, message: str):\n        console.print(f\"âœ… {message}\", style=\"success\")\n        self.logger.info(message)\n    \n    def warning(self, message: str):\n        self.logger.warning(message)\n    \n    def error(self, message: str):\n        self.logger.error(message)\n    \n    def debug(self, message: str):\n        self.logger.debug(message)\n    \n    def exception(self, message: str):\n        self.logger.exception(message)\n\n\ndef get_logger(name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None) -> AutomationLogger:\n    return AutomationLogger(name, log_level, log_file)\n","size_bytes":2198},"src/automation/browser_engine.py":{"content":"import asyncio\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom playwright.async_api import async_playwright, Browser, BrowserContext, Page, Playwright\nfrom tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nimport json\nfrom datetime import datetime\n\nfrom .config import BrowserConfig, AutomationConfig\nfrom .logger import get_logger\nfrom .selectors import SmartSelector, SelectorOptions\n\nlogger = get_logger()\n\n\nclass BrowserEngine:\n    \n    def __init__(\n        self,\n        browser_config: Optional[BrowserConfig] = None,\n        automation_config: Optional[AutomationConfig] = None\n    ):\n        self.browser_config = browser_config or BrowserConfig()\n        self.automation_config = automation_config or AutomationConfig()\n        \n        self.playwright: Optional[Playwright] = None\n        self.browser: Optional[Browser] = None\n        self.context: Optional[BrowserContext] = None\n        self.page: Optional[Page] = None\n        \n        self._setup_directories()\n    \n    def _setup_directories(self):\n        for dir_path in [\n            self.automation_config.screenshot_dir,\n            self.automation_config.video_dir,\n            self.automation_config.session_dir\n        ]:\n            Path(dir_path).mkdir(parents=True, exist_ok=True)\n    \n    async def start(self):\n        logger.info(f\"Starting browser engine with {self.browser_config.browser_type.value}\")\n        \n        self.playwright = await async_playwright().start()\n        \n        browser_type = getattr(self.playwright, self.browser_config.browser_type.value)\n        \n        launch_options = {\n            \"headless\": self.browser_config.headless,\n            \"slow_mo\": self.browser_config.slow_mo,\n        }\n        \n        if self.browser_config.proxy:\n            launch_options[\"proxy\"] = self.browser_config.proxy\n        \n        if self.browser_config.downloads_path:\n            Path(self.browser_config.downloads_path).mkdir(parents=True, exist_ok=True)\n        \n        self.browser = await browser_type.launch(**launch_options)\n        \n        context_options = {\n            \"viewport\": {\n                \"width\": self.browser_config.viewport_width,\n                \"height\": self.browser_config.viewport_height\n            },\n            \"locale\": self.browser_config.locale,\n            \"timezone_id\": self.browser_config.timezone,\n            \"ignore_https_errors\": self.browser_config.ignore_https_errors,\n        }\n        \n        if self.browser_config.user_agent:\n            context_options[\"user_agent\"] = self.browser_config.user_agent\n        \n        if self.browser_config.video_recording:\n            context_options[\"record_video_dir\"] = self.automation_config.video_dir\n        \n        if self.automation_config.save_session:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            if session_file.exists():\n                with open(session_file, 'r') as f:\n                    storage_state = json.load(f)\n                    context_options[\"storage_state\"] = storage_state\n                    logger.info(f\"Loaded session from {session_file}\")\n        \n        self.context = await self.browser.new_context(**context_options)\n        \n        if self.browser_config.trace_recording:\n            await self.context.tracing.start(screenshots=True, snapshots=True)\n        \n        self.page = await self.context.new_page()\n        \n        self.page.set_default_timeout(self.browser_config.timeout)\n        \n        logger.success(\"Browser engine started successfully\")\n    \n    async def stop(self):\n        logger.info(\"Stopping browser engine\")\n        \n        if self.automation_config.save_session and self.context:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            storage_state = await self.context.storage_state()\n            with open(session_file, 'w') as f:\n                json.dump(storage_state, f)\n            logger.info(f\"Saved session to {session_file}\")\n        \n        if self.browser_config.trace_recording and self.context:\n            trace_file = f\"traces/trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip\"\n            Path(\"traces\").mkdir(parents=True, exist_ok=True)\n            await self.context.tracing.stop(path=trace_file)\n            logger.info(f\"Saved trace to {trace_file}\")\n        \n        if self.page:\n            await self.page.close()\n        \n        if self.context:\n            await self.context.close()\n        \n        if self.browser:\n            await self.browser.close()\n        \n        if self.playwright:\n            await self.playwright.stop()\n        \n        logger.success(\"Browser engine stopped successfully\")\n    \n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=2, max=10),\n        retry=retry_if_exception_type(Exception)\n    )\n    async def navigate(self, url: str, wait_until: str = None) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started. Call start() first.\")\n        \n        wait_until = wait_until or self.automation_config.wait_strategy\n        \n        try:\n            logger.info(f\"Navigating to {url}\")\n            await self.page.goto(url, wait_until=wait_until, timeout=self.browser_config.timeout)\n            logger.success(f\"Successfully navigated to {url}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Navigation failed: {str(e)}\")\n            if self.browser_config.screenshot_on_error:\n                await self.screenshot(f\"error_navigate_{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n            raise\n    \n    async def screenshot(self, name: str = None) -> str:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        if name is None:\n            name = f\"screenshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        \n        screenshot_path = Path(self.automation_config.screenshot_dir) / f\"{name}.png\"\n        await self.page.screenshot(path=str(screenshot_path), full_page=True)\n        logger.info(f\"Screenshot saved to {screenshot_path}\")\n        return str(screenshot_path)\n    \n    async def wait_for_selector(\n        self,\n        selector: str,\n        timeout: Optional[int] = None,\n        state: str = \"visible\"\n    ) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        try:\n            options = SelectorOptions(timeout=timeout or self.browser_config.timeout, state=state)\n            element = await SmartSelector.find_element(self.page, selector, options)\n            if element:\n                await element.first.wait_for(state=state, timeout=timeout or self.browser_config.timeout)\n                return True\n        except Exception as e:\n            logger.error(f\"Wait for selector failed: {str(e)}\")\n        return False\n    \n    async def click(self, selector: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_click(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def fill(self, selector: str, value: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_fill(self.page, selector, value, SelectorOptions(**kwargs))\n    \n    async def get_text(self, selector: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_text(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def get_attribute(self, selector: str, attribute: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_attribute(self.page, selector, attribute, SelectorOptions(**kwargs))\n    \n    async def get_all_text(self, selector: str, **kwargs) -> List[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        elements = await SmartSelector.find_all(self.page, selector, SelectorOptions(**kwargs))\n        texts = []\n        for element in elements:\n            text = await element.text_content()\n            if text:\n                texts.append(text.strip())\n        return texts\n    \n    async def execute_script(self, script: str) -> Any:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.page.evaluate(script)\n    \n    async def wait_for_load(self, timeout: Optional[int] = None):\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.page.wait_for_load_state(\"networkidle\", timeout=timeout or self.browser_config.timeout)\n    \n    async def new_page(self) -> Page:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        page = await self.context.new_page()\n        page.set_default_timeout(self.browser_config.timeout)\n        return page\n    \n    async def get_cookies(self) -> List[Dict[str, Any]]:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.context.cookies()\n    \n    async def set_cookies(self, cookies: List[Dict[str, Any]]):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.add_cookies(cookies)\n        logger.info(f\"Set {len(cookies)} cookies\")\n    \n    async def clear_cookies(self):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.clear_cookies()\n        logger.info(\"Cleared all cookies\")\n","size_bytes":9914},"src/automation/task_executor.py":{"content":"from typing import Optional, Dict, Any, List\nfrom enum import Enum\nimport asyncio\nfrom dataclasses import dataclass\n\nfrom .browser_engine import BrowserEngine\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass TaskType(Enum):\n    NAVIGATE = \"navigate\"\n    CLICK = \"click\"\n    FILL = \"fill\"\n    EXTRACT_TEXT = \"extract_text\"\n    EXTRACT_LINKS = \"extract_links\"\n    SCREENSHOT = \"screenshot\"\n    WAIT = \"wait\"\n    SCROLL = \"scroll\"\n    EXECUTE_SCRIPT = \"execute_script\"\n\n\n@dataclass\nclass TaskResult:\n    success: bool\n    data: Any = None\n    error: Optional[str] = None\n\n\nclass TaskExecutor:\n    \n    def __init__(self, browser_engine: BrowserEngine):\n        self.browser = browser_engine\n    \n    async def execute_task(self, task_type: TaskType, params: Dict[str, Any]) -> TaskResult:\n        try:\n            if task_type == TaskType.NAVIGATE:\n                return await self._navigate(params)\n            elif task_type == TaskType.CLICK:\n                return await self._click(params)\n            elif task_type == TaskType.FILL:\n                return await self._fill(params)\n            elif task_type == TaskType.EXTRACT_TEXT:\n                return await self._extract_text(params)\n            elif task_type == TaskType.EXTRACT_LINKS:\n                return await self._extract_links(params)\n            elif task_type == TaskType.SCREENSHOT:\n                return await self._screenshot(params)\n            elif task_type == TaskType.WAIT:\n                return await self._wait(params)\n            elif task_type == TaskType.SCROLL:\n                return await self._scroll(params)\n            elif task_type == TaskType.EXECUTE_SCRIPT:\n                return await self._execute_script(params)\n            else:\n                return TaskResult(success=False, error=f\"Unknown task type: {task_type}\")\n        except Exception as e:\n            logger.error(f\"Task execution failed: {str(e)}\")\n            return TaskResult(success=False, error=str(e))\n    \n    async def _navigate(self, params: Dict[str, Any]) -> TaskResult:\n        url = params.get(\"url\")\n        if not url:\n            return TaskResult(success=False, error=\"URL is required\")\n        \n        success = await self.browser.navigate(url, params.get(\"wait_until\"))\n        return TaskResult(success=success)\n    \n    async def _click(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        success = await self.browser.click(selector)\n        return TaskResult(success=success)\n    \n    async def _fill(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        value = params.get(\"value\")\n        \n        if not selector or value is None:\n            return TaskResult(success=False, error=\"Selector and value are required\")\n        \n        success = await self.browser.fill(selector, str(value))\n        return TaskResult(success=success)\n    \n    async def _extract_text(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        all_elements = params.get(\"all\", False)\n        \n        if all_elements:\n            texts = await self.browser.get_all_text(selector)\n            return TaskResult(success=True, data=texts)\n        else:\n            text = await self.browser.get_text(selector)\n            return TaskResult(success=text is not None, data=text)\n    \n    async def _extract_links(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\", \"a\")\n        \n        links = []\n        elements = await self.browser.get_all_text(selector)\n        \n        for i, _ in enumerate(elements):\n            href = await self.browser.get_attribute(f\"{selector}:nth-of-type({i+1})\", \"href\")\n            text = await self.browser.get_text(f\"{selector}:nth-of-type({i+1})\")\n            if href:\n                links.append({\"url\": href, \"text\": text or \"\"})\n        \n        return TaskResult(success=True, data=links)\n    \n    async def _screenshot(self, params: Dict[str, Any]) -> TaskResult:\n        name = params.get(\"name\")\n        path = await self.browser.screenshot(name)\n        return TaskResult(success=True, data=path)\n    \n    async def _wait(self, params: Dict[str, Any]) -> TaskResult:\n        wait_type = params.get(\"type\", \"time\")\n        \n        if wait_type == \"time\":\n            duration = params.get(\"duration\", 1000)\n            await asyncio.sleep(duration / 1000)\n            return TaskResult(success=True)\n        elif wait_type == \"selector\":\n            selector = params.get(\"selector\")\n            if not selector:\n                return TaskResult(success=False, error=\"Selector is required for selector wait\")\n            success = await self.browser.wait_for_selector(selector, params.get(\"timeout\"))\n            return TaskResult(success=success)\n        elif wait_type == \"load\":\n            await self.browser.wait_for_load(params.get(\"timeout\"))\n            return TaskResult(success=True)\n        else:\n            return TaskResult(success=False, error=f\"Unknown wait type: {wait_type}\")\n    \n    async def _scroll(self, params: Dict[str, Any]) -> TaskResult:\n        direction = params.get(\"direction\", \"down\")\n        amount = params.get(\"amount\", 500)\n        \n        script = f\"window.scrollBy(0, {amount if direction == 'down' else -amount})\"\n        await self.browser.execute_script(script)\n        \n        return TaskResult(success=True)\n    \n    async def _execute_script(self, params: Dict[str, Any]) -> TaskResult:\n        script = params.get(\"script\")\n        if not script:\n            return TaskResult(success=False, error=\"Script is required\")\n        \n        result = await self.browser.execute_script(script)\n        return TaskResult(success=True, data=result)\n    \n    async def fill_form(self, form_data: Dict[str, str]) -> bool:\n        logger.info(\"Filling form with provided data\")\n        \n        for selector, value in form_data.items():\n            success = await self.browser.fill(selector, value)\n            if not success:\n                logger.error(f\"Failed to fill field: {selector}\")\n                return False\n        \n        logger.success(\"Form filled successfully\")\n        return True\n    \n    async def scrape_table(self, table_selector: str) -> List[Dict[str, Any]]:\n        logger.info(f\"Scraping table: {table_selector}\")\n        \n        headers_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('th'))\n            .map(th => th.textContent.trim())\n        \"\"\"\n        headers = await self.browser.execute_script(headers_script)\n        \n        rows_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('tbody tr'))\n            .map(tr => Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim()))\n        \"\"\"\n        rows = await self.browser.execute_script(rows_script)\n        \n        table_data = []\n        for row in rows:\n            row_dict = dict(zip(headers, row))\n            table_data.append(row_dict)\n        \n        logger.success(f\"Scraped {len(table_data)} rows from table\")\n        return table_data\n","size_bytes":7377},"src/automation/ai_generator.py":{"content":"import os\nfrom typing import Optional\ntry:\n    from openai import AsyncOpenAI, OpenAIError\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .config import AutomationConfig\n\nlogger = get_logger()\n\n\nclass AITaskGenerator:\n    \n    def __init__(self, automation_config: Optional[AutomationConfig] = None):\n        self.config = automation_config or AutomationConfig()\n        self.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.client = None\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available. Install with: pip install openai\")\n        elif not self.api_key:\n            logger.warning(\"OPENAI_API_KEY not set. AI code generation will not be available.\")\n        else:\n            self.client = AsyncOpenAI(api_key=self.api_key)\n    \n    async def generate_playwright_code(self, task_description: str) -> Optional[str]:\n        if not OPENAI_AVAILABLE:\n            logger.error(\"Cannot generate code: OpenAI package not installed\")\n            return None\n        \n        if not self.client:\n            logger.error(\"Cannot generate code: OPENAI_API_KEY not set\")\n            return None\n        \n        logger.info(f\"Generating Playwright code for: {task_description}\")\n        \n        try:\n            system_prompt = \"\"\"You are an expert Python developer and Playwright automation engineer.\nGenerate complete, runnable Python scripts using Playwright.\nUse realistic and working CSS or XPath selectors.\nProvide only valid code with proper imports, async functions, and browser handling.\nMake the code robust with error handling and logging.\nUse best practices for browser automation.\nReturn ONLY the Python code, no explanations or markdown formatting.\"\"\"\n\n            user_prompt = f\"\"\"Generate a complete Python Playwright script for this task:\n\n{task_description}\n\nRequirements:\n- Use async/await with Playwright\n- Include proper imports\n- Add error handling\n- Use realistic selectors\n- Make it production-ready\n- Add logging where appropriate\"\"\"\n\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.7,\n                max_tokens=2000\n            )\n            \n            code = response.choices[0].message.content\n            logger.success(\"Code generation completed\")\n            return code\n            \n        except Exception as e:\n            logger.error(f\"Error during code generation: {e}\")\n            return None\n    \n    async def generate_scraping_code(self, url: str, data_description: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to scrape data from {url}. \"\n            f\"Extract the following data: {data_description}. \"\n            f\"Return the data as a list of dictionaries and print it in JSON format.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_form_filling_code(self, url: str, form_fields: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to fill out a form at {url}. \"\n            f\"The form has these fields: {form_fields}. \"\n            f\"Fill the form with appropriate test data and submit it.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_login_code(self, url: str, username_field: str, password_field: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to log in to {url}. \"\n            f\"Username field selector: {username_field}, Password field selector: {password_field}. \"\n            f\"Include error handling and session management.\"\n        )\n        return await self.generate_playwright_code(task)\n","size_bytes":3944}},"version":2}