{"file_contents":{"examples/ai_code_generation_example.py":{"content":"import asyncio\nimport sys\nimport os\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom src.automation import AITaskGenerator\nfrom src.automation.config import AutomationConfig\nfrom src.automation.logger import get_logger\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nlogger = get_logger()\n\n\nasync def main():\n    config = AutomationConfig(\n        openai_model=\"gpt-4o-mini\",\n        mcp_timeout=300\n    )\n    \n    generator = AITaskGenerator(config)\n    \n    logger.info(\"Generating Playwright code using AI\")\n    \n    import sys\n    \n    if len(sys.argv) < 2:\n        print(\"Usage: python ai_code_generation_example.py '<task description>'\")\n        print(\"Example: python ai_code_generation_example.py 'Navigate to a news site and extract article titles'\")\n        sys.exit(1)\n    \n    task_description = sys.argv[1]\n    \n    code = await generator.generate_playwright_code(task_description)\n    \n    if code:\n        logger.success(\"\\n=== Generated Code ===\")\n        print(code)\n        \n        output_file = \"generated_code.py\"\n        with open(output_file, 'w') as f:\n            f.write(code)\n        logger.success(f\"\\nCode saved to {output_file}\")\n    else:\n        logger.error(\"Failed to generate code. Make sure OPENAI_API_KEY is set.\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":1345},"src/automation/logger.py":{"content":"import logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\nfrom rich.console import Console\nfrom rich.logging import RichHandler\nfrom rich.theme import Theme\n\n\ncustom_theme = Theme({\n    \"info\": \"cyan\",\n    \"warning\": \"yellow\",\n    \"error\": \"red bold\",\n    \"success\": \"green bold\",\n})\n\nconsole = Console(theme=custom_theme)\n\n\nclass AutomationLogger:\n    def __init__(self, name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        \n        if not self.logger.handlers:\n            console_handler = RichHandler(\n                console=console,\n                rich_tracebacks=True,\n                tracebacks_show_locals=True,\n                show_time=True,\n                show_path=True\n            )\n            console_handler.setLevel(getattr(logging, log_level.upper()))\n            self.logger.addHandler(console_handler)\n            \n            if log_file:\n                log_path = Path(log_file)\n                log_path.parent.mkdir(parents=True, exist_ok=True)\n                file_handler = logging.FileHandler(log_file)\n                file_handler.setLevel(logging.DEBUG)\n                formatter = logging.Formatter(\n                    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n                )\n                file_handler.setFormatter(formatter)\n                self.logger.addHandler(file_handler)\n    \n    def info(self, message: str):\n        self.logger.info(message)\n    \n    def success(self, message: str):\n        console.print(f\"âœ… {message}\", style=\"success\")\n        self.logger.info(message)\n    \n    def warning(self, message: str):\n        self.logger.warning(message)\n    \n    def error(self, message: str):\n        self.logger.error(message)\n    \n    def debug(self, message: str):\n        self.logger.debug(message)\n    \n    def exception(self, message: str):\n        self.logger.exception(message)\n\n\ndef get_logger(name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None) -> AutomationLogger:\n    return AutomationLogger(name, log_level, log_file)\n","size_bytes":2198},"README.md":{"content":"# ðŸŽ­ Browser Automation Framework with Playwright MCP\n\nA powerful Python-based browser automation framework powered by **Playwright** and **AI**. Build robust browser automation for **any website** using natural language instructions via **Model Context Protocol (MCP)** or traditional code. Features intelligent error handling, learning capabilities, and automatic retry with corrections.\n\n## Features\n\n### ðŸš€ ENHANCED MCP-Powered Automation (PRIMARY - MOST POWERFUL!)\n- **Microsoft's Official Playwright MCP Server**: Standardized browser automation via Model Context Protocol\n- **21+ Browser Automation Tools**: AI intelligently selects and chains tools for complex tasks\n- **Vision-Based Intelligence**: GPT-4 Vision analyzes pages when selectors fail, providing smart corrections\n- **Smart Retry System**: Automatically recovers from failures with intelligent dual-strategy approach:\n  1. **Vision-First**: GPT-4 Vision analyzes screenshot and suggests better selectors\n  2. **Element Catalog Matching**: Builds catalog of all interactive elements (buttons, links, inputs, selects) and fuzzy-matches against instruction keywords to find the right target\n- **Session Memory**: Learns from successful patterns and remembers what works\n- **Page Context Awareness**: Analyzes page structure before taking actions\n- **Multi-Strategy Element Detection**: Tries CSS, text, role, placeholder, and label selectors\n- **Just describe what you want**: \"Go to google.com and search for Python tutorials\"\n- **No coding or selectors needed**: AI handles everything intelligently\n- **Production-ready**: Secure JSON parsing, comprehensive error handling, intelligent retry logic\n\n### ðŸŽ¯ Enhanced Natural Language Automation (ADVANCED)\n- **Vision-based intelligence**: Optional GPT-4 Vision analysis for complex pages\n- **Smart element detection**: Multiple fallback strategies to find elements\n- **Advanced web handling**: Supports iframes, popups, dynamic content, file uploads\n- **Intelligent error recovery**: Analyzes failures with vision and retries with corrections\n- **Session memory**: Learns from successful patterns to improve over time\n- **No coding or selectors needed**: Perfect for non-technical users\n\n### ðŸš€ Core Browser Automation\n- **Multi-browser support**: Chromium, Firefox, WebKit\n- **Smart selectors**: Automatic fallback between CSS, XPath, text, and ARIA strategies\n- **Robust error handling**: Built-in retry logic with exponential backoff\n- **Session management**: Cookie and state persistence across runs\n- **Debugging tools**: Screenshots, video recording, and trace files\n\n### ðŸ¤– AI-Powered Features\n- Generate Playwright automation code from natural language descriptions\n- Intelligent error analysis and automatic corrections\n- Context-aware action generation\n- Uses OpenAI GPT-4 for intelligent automation\n\n### ðŸ“¦ Task Execution Library\n- Pre-built automation patterns:\n  - Form filling (any website)\n  - Table scraping\n  - Link extraction\n  - Screenshot capture\n  - Custom JavaScript execution\n  - Scroll automation\n  - Wait strategies\n\n### âš™ï¸ Flexible Configuration\n- Environment-based configuration\n- Customizable timeouts and retries\n- Headless and headed browser modes\n- Detailed logging with Rich console output\n\n## Quick Start\n\n### ENHANCED MCP-Powered Natural Language Automation (Recommended - Most Powerful!)\n\nThe most powerful and easiest way to automate **any website** using AI with vision, memory, and smart retry:\n\n```bash\n# Set your OpenAI API key\nexport OPENAI_API_KEY='your-api-key'\n\n# Run enhanced MCP automation\nuv run python nl_automation_mcp.py\n```\n\nThen simply type natural language commands and watch the magic:\n- **Navigation & Search**: \"Go to google.com and search for Python tutorials\"\n- **Complex Forms**: \"Fill out the contact form with name John and email john@example.com\"\n- **Data Extraction**: \"Navigate to news.ycombinator.com and get the top 5 story titles\"\n- **E-commerce**: \"Find and extract all product names and prices from this page\"\n- **Authentication**: \"Click the login button and enter credentials\"\n\n**How it works (ENHANCED):**\n1. **GPT-4** understands your command with page context awareness\n2. **Session Memory** checks for similar successful patterns from history\n3. **AI selects** appropriate MCP browser automation tools (from 21+ available)\n4. **Smart Execution** with automatic retry on failures:\n   - First attempt with AI-selected selectors\n   - Vision analysis if failure (GPT-4 Vision analyzes screenshot)\n   - Text-based selector fallback\n   - Role-based selector fallback\n5. **Learns & Remembers** successful patterns for future use\n6. **Provides feedback** on progress, retries, and results\n\n**Available MCP Tools:**\n- Navigation: `browser_navigate`, `browser_navigate_back`\n- Interaction: `browser_click`, `browser_type`, `browser_fill_form`, `browser_select_option`\n- Advanced: `browser_drag`, `browser_hover`, `browser_file_upload`\n- Analysis: `browser_snapshot`, `browser_take_screenshot`, `browser_console_messages`\n- Network: `browser_network_requests`\n- Management: `browser_tabs`, `browser_close`, `browser_resize`\n- Utilities: `browser_evaluate`, `browser_press_key`, `browser_wait_for`, `browser_handle_dialog`\n\n### Enhanced Natural Language Automation (Advanced - Vision Mode)\n\nFor more advanced automation with vision capabilities:\n\n```bash\n# Run enhanced NL automation\npython nl_automation.py\n```\n\nThe AI will:\n1. Convert your instruction into browser actions\n2. Use vision to understand page structure (optional)\n3. Intelligently find elements with multiple fallback strategies\n4. Handle complex scenarios (iframes, dynamic content, popups)\n5. Learn from any errors and retry automatically with better selectors\n6. Remember successful patterns for future use\n\n**Advanced Features:**\n- Vision-based page analysis for difficult-to-automate pages\n- Smart element finding (no need to know exact selectors)\n- Dynamic content waiting\n- Multi-page navigation\n- Table and link extraction\n- Error diagnosis with screenshots\n\n### Basic Usage (Code)\n\n```python\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\n\nasync def main():\n    # Configure browser\n    browser_config = BrowserConfig(headless=True)\n    automation_config = AutomationConfig()\n    \n    # Create browser engine\n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    # Start browser\n    await browser.start()\n    \n    # Navigate to any website\n    await browser.navigate(\"https://example.com\")\n    \n    # Extract data\n    headings = await browser.get_all_text(\"h1, h2\")\n    links = await browser.get_all_text(\"a\")\n    \n    # Take screenshot\n    await browser.screenshot(\"page_screenshot\")\n    \n    # Stop browser\n    await browser.stop()\n```\n\n### Run Interactive Demos\n\n**MCP-Powered Natural Language Automation** (Primary - Recommended):\n```bash\nuv run python nl_automation_mcp.py\n```\n\n**Enhanced Natural Language Automation** (Advanced):\n```bash\npython nl_automation.py\n```\n\n**Traditional Demo Menu**:\n```bash\npython main.py\n```\n\nThis will launch an interactive menu with demos for:\n1. **Web Automation Demo** - Navigate and extract data from any site\n2. **Form Automation Demo** - Fill and submit forms on any website\n3. **Data Extraction Demo** - Extract specific data from any page\n4. **AI Code Generation** - Generate automation code from descriptions\n\n### Run Examples\n\n```bash\n# Web scraping any site\npython examples/web_scraping_example.py\n\n# Form filling automation\npython examples/form_filling_example.py\n\n# AI code generation (requires OPENAI_API_KEY)\npython examples/ai_code_generation_example.py\n\n# Advanced automation patterns\npython examples/advanced_automation_example.py\n```\n\n## Environment Variables\n\nConfiguration via environment variables:\n\n```bash\n# AI Features (REQUIRED for natural language automation)\nOPENAI_API_KEY=your_openai_api_key\n\n# Browser Configuration\nBROWSER_TYPE=chromium          # chromium, firefox, or webkit\nHEADLESS=true                  # true or false\nTIMEOUT=30000                  # Default timeout in milliseconds\n\n# Automation Settings\nMAX_RETRIES=3                  # Number of retry attempts\nLOG_LEVEL=INFO                 # DEBUG, INFO, WARNING, ERROR\n```\n\n## Use Cases\n\n### Natural Language Web Scraping\nThe easiest way - just describe what you want:\n\n```\nInstruction: \"Go to news.ycombinator.com and extract the top 10 story titles\"\nâ†’ AI converts to actions and executes automatically\nâ†’ Returns: List of story titles\n```\n\n### Traditional Web Scraping\nScrape data from any website - e-commerce, news sites, job boards, etc.\n\n```python\nawait browser.navigate(\"https://any-website.com\")\nproducts = await browser.get_all_text(\".product-title\")\nprices = await browser.get_all_text(\".price\")\n```\n\n### Form Automation\nFill and submit forms on any website automatically.\n\n```python\nform_data = {\n    \"input[name='email']\": \"user@example.com\",\n    \"input[name='password']\": \"password123\",\n    \"#country\": \"USA\"\n}\nawait executor.fill_form(form_data)\nawait browser.click(\"button[type='submit']\")\n```\n\n### Testing\nAutomated testing for any web application.\n\n```python\nawait browser.navigate(\"https://your-app.com\")\nawait browser.click(\"#login-button\")\nawait browser.fill(\"#username\", \"testuser\")\nawait browser.fill(\"#password\", \"testpass\")\nawait browser.click(\"#submit\")\nassert await browser.get_text(\".welcome-message\")\n```\n\n### Data Monitoring\nMonitor prices, availability, or any data changes.\n\n```python\nawait browser.navigate(\"https://target-site.com\")\ncurrent_price = await browser.get_text(\".price\")\n# Compare with previous price, send alerts, etc.\n```\n\n## Project Structure\n\n```\n.\nâ”œâ”€â”€ src/automation/              # Core automation framework\nâ”‚   â”œâ”€â”€ mcp_client.py           # Playwright MCP client (NEW)\nâ”‚   â”œâ”€â”€ browser_engine.py       # Main browser automation engine\nâ”‚   â”œâ”€â”€ enhanced_nl_executor.py # Enhanced NL automation with vision\nâ”‚   â”œâ”€â”€ advanced_tools.py       # Advanced Playwright tools\nâ”‚   â”œâ”€â”€ vision_analyzer.py      # GPT-4 Vision analysis\nâ”‚   â”œâ”€â”€ selectors.py            # Smart selector system\nâ”‚   â”œâ”€â”€ task_executor.py        # Task execution framework\nâ”‚   â”œâ”€â”€ ai_generator.py         # AI code generation\nâ”‚   â”œâ”€â”€ config.py               # Configuration management\nâ”‚   â””â”€â”€ logger.py               # Enhanced logging\nâ”œâ”€â”€ nl_automation_mcp.py        # MCP-powered automation (PRIMARY)\nâ”œâ”€â”€ nl_automation.py            # Enhanced NL automation\nâ”œâ”€â”€ examples/                    # Example scripts\nâ”œâ”€â”€ main.py                     # Interactive demo\nâ””â”€â”€ README.md                   # This file\n```\n\n## API Reference\n\n### BrowserEngine\n\nMain browser automation engine with Playwright integration.\n\n```python\nbrowser = BrowserEngine(browser_config, automation_config)\n\n# Core methods\nawait browser.start()                          # Start browser\nawait browser.stop()                           # Stop browser\nawait browser.navigate(url)                    # Navigate to URL\nawait browser.click(selector)                  # Click element\nawait browser.fill(selector, value)            # Fill input\nawait browser.get_text(selector)               # Get element text\nawait browser.get_all_text(selector)           # Get all matching elements\nawait browser.screenshot(name)                 # Take screenshot\nawait browser.wait_for_load()                  # Wait for page load\nawait browser.execute_script(script)           # Run JavaScript\n```\n\n### TaskExecutor\n\nPre-built automation tasks and patterns.\n\n```python\nexecutor = TaskExecutor(browser)\n\n# Common tasks\nawait executor.fill_form({\"selector\": \"value\", ...})\ntable_data = await executor.scrape_table(\"table.data\")\n\n# Or use task-based execution\nfrom src.automation.task_executor import TaskType\nresult = await executor.execute_task(TaskType.EXTRACT_TEXT, {\"selector\": \"h1\"})\n```\n\n### AITaskGenerator\n\nAI-powered code generation (requires OPENAI_API_KEY).\n\n```python\ngenerator = AITaskGenerator()\n\ncode = await generator.generate_playwright_code(\"Your automation task description\")\ncode = await generator.generate_scraping_code(url, \"data to extract\")\ncode = await generator.generate_form_filling_code(url, \"form fields description\")\n```\n\n## Configuration\n\n### BrowserConfig\n\n```python\nfrom src.automation.config import BrowserConfig, BrowserType\n\nconfig = BrowserConfig(\n    browser_type=BrowserType.CHROMIUM,    # Browser type\n    headless=True,                         # Headless mode\n    timeout=30000,                         # Default timeout (ms)\n    viewport_width=1920,                   # Viewport width\n    viewport_height=1080,                  # Viewport height\n    screenshot_on_error=True,              # Auto screenshot on error\n    video_recording=False,                 # Record video\n    user_agent=\"custom UA\",                # Custom user agent\n)\n```\n\n### AutomationConfig\n\n```python\nfrom src.automation.config import AutomationConfig\n\nconfig = AutomationConfig(\n    max_retries=3,                         # Retry attempts\n    retry_delay=2,                         # Delay between retries\n    screenshot_dir=\"screenshots\",          # Screenshot directory\n    save_session=True,                     # Save browser session\n    session_name=\"my_session\",             # Session name\n    log_level=\"INFO\",                      # Logging level\n)\n```\n\n## Advanced Features\n\n### Session Persistence\n\nSave and restore browser sessions (cookies, local storage):\n\n```python\nconfig = AutomationConfig(\n    save_session=True,\n    session_name=\"my_app_session\"\n)\n\n# Session is automatically saved on browser.stop()\n# and restored on browser.start()\n```\n\n### Smart Selectors\n\nAutomatic fallback between different selector strategies:\n\n```python\nfrom src.automation.selectors import SmartSelector, SelectorOptions\n\noptions = SelectorOptions(strategy=SelectorStrategy.AUTO)\nelement = await SmartSelector.find_element(page, \"button\", options)\n```\n\n### Error Handling\n\nBuilt-in retry logic with exponential backoff:\n\n```python\n# Automatic retries on navigation failures\nawait browser.navigate(url)  # Retries up to 3 times\n\n# Custom retry configuration\nconfig = AutomationConfig(max_retries=5, retry_delay=3)\n```\n\n## Troubleshooting\n\n### Browser Won't Start\n- Ensure Playwright browsers are installed: `python -m playwright install chromium`\n- For system dependencies: Run `playwright install-deps` (local) or contact support (cloud)\n\n### AI Code Generation Not Working\n- Set OPENAI_API_KEY environment variable\n- Verify OpenAI API key is valid\n- Check API quota and usage limits\n\n### Selectors Not Working\n- Use AUTO strategy for automatic fallback: `SelectorOptions(strategy=SelectorStrategy.AUTO)`\n- Enable debug logging: `AutomationConfig(log_level=\"DEBUG\")`\n- Take screenshots to inspect page state\n\n## Why This Framework?\n\nâœ… **Universal** - Works with any website, no site-specific code  \nâœ… **Robust** - Smart selectors with automatic fallback  \nâœ… **Production-ready** - Comprehensive error handling  \nâœ… **Flexible** - Easy to customize for any use case  \nâœ… **AI-powered** - Generate code from natural language  \n\n---\n\n**Built with â¤ï¸ using Playwright, OpenAI, and Python**\n","size_bytes":15319},"src/automation/session_memory.py":{"content":"import json\nimport os\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass SessionMemory:\n    \"\"\"\n    Persistent storage for automation execution history.\n    Tracks successful patterns and failures to improve future executions.\n    \"\"\"\n    \n    def __init__(self, session_dir: str = \"sessions\"):\n        self.session_dir = Path(session_dir)\n        self.session_dir.mkdir(exist_ok=True)\n        self.memory_file = self.session_dir / \"execution_memory.json\"\n        self.memory: Dict[str, Any] = self._load_memory()\n    \n    def _load_memory(self) -> Dict[str, Any]:\n        \"\"\"Load execution memory from disk.\"\"\"\n        if self.memory_file.exists():\n            try:\n                with open(self.memory_file, 'r') as f:\n                    data = json.load(f)\n                    logger.debug(f\"Loaded {len(data.get('executions', []))} executions from memory\")\n                    return data\n            except Exception as e:\n                logger.error(f\"Failed to load memory: {e}\")\n                return {\"executions\": [], \"patterns\": {}}\n        return {\"executions\": [], \"patterns\": {}}\n    \n    def _save_memory(self):\n        \"\"\"Save execution memory to disk.\"\"\"\n        try:\n            with open(self.memory_file, 'w') as f:\n                json.dump(self.memory, f, indent=2)\n            logger.debug(\"Memory saved to disk\")\n        except Exception as e:\n            logger.error(f\"Failed to save memory: {e}\")\n    \n    def record_execution(self, instruction: str, success: bool, \n                        steps: List[Dict[str, Any]], error: Optional[str] = None):\n        \"\"\"Record an execution attempt.\"\"\"\n        execution = {\n            \"instruction\": instruction,\n            \"success\": success,\n            \"steps\": steps,\n            \"error\": error,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        self.memory[\"executions\"].append(execution)\n        \n        if len(self.memory[\"executions\"]) > 100:\n            self.memory[\"executions\"] = self.memory[\"executions\"][-100:]\n        \n        if success:\n            self._update_patterns(instruction, steps)\n        \n        self._save_memory()\n        logger.info(f\"Recorded {'successful' if success else 'failed'} execution\")\n    \n    def _update_patterns(self, instruction: str, steps: List[Dict[str, Any]]):\n        \"\"\"Learn from successful patterns.\"\"\"\n        instruction_lower = instruction.lower()\n        \n        key_phrases = [\"search\", \"login\", \"click\", \"fill\", \"navigate\", \"extract\", \"scrape\"]\n        \n        for phrase in key_phrases:\n            if phrase in instruction_lower:\n                if phrase not in self.memory[\"patterns\"]:\n                    self.memory[\"patterns\"][phrase] = []\n                \n                pattern = {\n                    \"instruction\": instruction,\n                    \"steps\": steps,\n                    \"timestamp\": datetime.now().isoformat()\n                }\n                \n                self.memory[\"patterns\"][phrase].append(pattern)\n                \n                if len(self.memory[\"patterns\"][phrase]) > 5:\n                    self.memory[\"patterns\"][phrase] = self.memory[\"patterns\"][phrase][-5:]\n    \n    def get_similar_patterns(self, instruction: str) -> List[Dict[str, Any]]:\n        \"\"\"Get similar successful patterns based on instruction.\"\"\"\n        instruction_lower = instruction.lower()\n        similar = []\n        \n        for phrase, patterns in self.memory[\"patterns\"].items():\n            if phrase in instruction_lower:\n                similar.extend(patterns)\n        \n        return similar\n    \n    def get_recent_successes(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent successful executions.\"\"\"\n        successes = [e for e in self.memory[\"executions\"] if e[\"success\"]]\n        return successes[-limit:]\n    \n    def get_recent_failures(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent failed executions.\"\"\"\n        failures = [e for e in self.memory[\"executions\"] if not e[\"success\"]]\n        return failures[-limit:]\n    \n    def get_context_for_instruction(self, instruction: str) -> str:\n        \"\"\"Build context string for similar instructions.\"\"\"\n        similar = self.get_similar_patterns(instruction)\n        \n        if not similar:\n            return \"\"\n        \n        context_parts = [\"Similar successful patterns:\"]\n        for pattern in similar[-3:]:\n            context_parts.append(f\"- {pattern['instruction']}: {len(pattern['steps'])} steps\")\n        \n        return \"\\n\".join(context_parts)\n    \n    def clear_memory(self):\n        \"\"\"Clear all execution memory.\"\"\"\n        self.memory = {\"executions\": [], \"patterns\": {}}\n        self._save_memory()\n        logger.info(\"Memory cleared\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about executions.\"\"\"\n        total = len(self.memory[\"executions\"])\n        successes = len([e for e in self.memory[\"executions\"] if e[\"success\"]])\n        failures = total - successes\n        \n        return {\n            \"total_executions\": total,\n            \"successes\": successes,\n            \"failures\": failures,\n            \"success_rate\": (successes / total * 100) if total > 0 else 0,\n            \"learned_patterns\": len(self.memory[\"patterns\"])\n        }\n","size_bytes":5397},"nl_automation.py":{"content":"import asyncio\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.automation import BrowserEngine, EnhancedNaturalLanguageExecutor, AI_AVAILABLE\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger, console\nfrom rich.prompt import Prompt, Confirm\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich import print as rprint\n\nlogger = get_logger()\n\n\nasync def run_natural_language_automation():\n    \"\"\"\n    Run browser automation using natural language instructions.\n    \"\"\"\n    console.print(Panel.fit(\n        \"[bold cyan]Natural Language Browser Automation[/bold cyan]\\n\"\n        \"[dim]Describe what you want to automate, and AI will do it[/dim]\",\n        border_style=\"cyan\"\n    ))\n    \n    if not AI_AVAILABLE:\n        console.print(\"[red]AI features not available. Please ensure OpenAI package is installed.[/red]\")\n        return\n    \n    import os\n    if not os.getenv(\"OPENAI_API_KEY\"):\n        console.print(\"[red]OPENAI_API_KEY not set. Please set your OpenAI API key.[/red]\")\n        console.print(\"[yellow]You can set it with: export OPENAI_API_KEY='your-api-key'[/yellow]\")\n        return\n    \n    browser_config = BrowserConfig(\n        headless=True,\n        screenshot_on_error=True,\n        timeout=30000\n    )\n    automation_config = AutomationConfig(\n        log_level=\"INFO\",\n        max_retries=3,\n        retry_delay=2\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    nl_executor = EnhancedNaturalLanguageExecutor(browser, automation_config)\n    \n    try:\n        await browser.start()\n        logger.success(\"Browser started successfully\")\n        \n        console.print(\"\\n[bold cyan]Enhanced Natural Language Automation Mode[/bold cyan]\")\n        console.print(\"[green]âœ¨ Powered by vision-based intelligence and advanced automation[/green]\\n\")\n        console.print(\"[dim]Examples:[/dim]\")\n        console.print(\"  â€¢ Go to google.com and search for 'browser automation'\")\n        console.print(\"  â€¢ Navigate to example.com and extract all headings\")\n        console.print(\"  â€¢ Open github.com and click the login button\")\n        console.print(\"  â€¢ Visit news.ycombinator.com and get the top 5 story titles\")\n        console.print(\"  â€¢ Find all product prices on this page and save them\")\n        console.print(\"  â€¢ Fill in the contact form and submit it\\n\")\n        \n        stats = nl_executor.get_memory_stats()\n        if stats[\"total_executions\"] > 0:\n            console.print(f\"[dim]Memory: {stats['total_executions']} executions, \"\n                        f\"{stats['success_rate']:.1f}% success rate[/dim]\\n\")\n        \n        while True:\n            instruction = Prompt.ask(\"\\n[bold green]What would you like to automate?[/bold green]\", default=\"\")\n            \n            if not instruction:\n                if Confirm.ask(\"No instruction provided. Exit?\", default=True):\n                    break\n                continue\n            \n            if instruction.lower() in [\"exit\", \"quit\", \"q\"]:\n                console.print(\"[cyan]Goodbye![/cyan]\")\n                break\n            \n            if instruction.lower() == \"stats\":\n                show_stats(nl_executor)\n                continue\n            \n            starting_url = Prompt.ask(\"Starting URL (optional, press Enter to skip)\", default=\"\")\n            url = starting_url if starting_url else None\n            \n            use_vision = Confirm.ask(\"Use vision-based analysis? (slower but more intelligent)\", default=False)\n            \n            console.print(f\"\\n[yellow]Executing: {instruction}[/yellow]\")\n            if use_vision:\n                console.print(\"[cyan]âœ¨ Vision mode enabled - AI will analyze page structure[/cyan]\")\n            console.print(\"[dim]The AI will convert this to browser actions and execute them...[/dim]\\n\")\n            \n            try:\n                result = await nl_executor.execute_instruction(instruction, url, use_vision=use_vision)\n                \n                if result.success:\n                    console.print(f\"\\n[bold green]âœ“ Success![/bold green] \"\n                                f\"Completed {result.steps_completed}/{result.total_steps} steps\")\n                    \n                    if result.data:\n                        console.print(\"\\n[bold]Extracted Data:[/bold]\")\n                        if isinstance(result.data, list):\n                            if len(result.data) > 10:\n                                console.print(f\"[dim]Showing first 10 of {len(result.data)} items[/dim]\")\n                            for i, item in enumerate(result.data[:10], 1):\n                                console.print(f\"  {i}. {str(item)[:100]}\")\n                        else:\n                            console.print(f\"  {result.data}\")\n                    \n                    if Confirm.ask(\"\\nTake a screenshot?\", default=False):\n                        screenshot_path = await browser.screenshot(\"nl_automation\")\n                        logger.success(f\"Screenshot saved to {screenshot_path}\")\n                \n                else:\n                    console.print(f\"\\n[bold red]âœ— Failed[/bold red] after {result.steps_completed}/{result.total_steps} steps\")\n                    console.print(f\"[red]Error: {result.error}[/red]\")\n                    \n                    if Confirm.ask(\"Take error screenshot for debugging?\", default=True):\n                        screenshot_path = await browser.screenshot(\"nl_automation_error\")\n                        logger.info(f\"Error screenshot saved to {screenshot_path}\")\n            \n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Execution cancelled[/yellow]\")\n            except Exception as e:\n                logger.exception(f\"Error during execution: {e}\")\n            \n            if not Confirm.ask(\"\\nRun another automation?\", default=True):\n                break\n    \n    except Exception as e:\n        logger.exception(f\"Fatal error: {e}\")\n    \n    finally:\n        await browser.stop()\n        logger.info(\"Browser stopped\")\n        \n        final_stats = nl_executor.get_memory_stats()\n        console.print(f\"\\n[dim]Session complete. Total executions: {final_stats['total_executions']}, \"\n                    f\"Success rate: {final_stats['success_rate']:.1f}%[/dim]\")\n\n\ndef show_stats(nl_executor: EnhancedNaturalLanguageExecutor):\n    \"\"\"Display execution statistics.\"\"\"\n    stats = nl_executor.get_memory_stats()\n    \n    table = Table(title=\"Execution Statistics\", show_header=True, header_style=\"bold magenta\")\n    table.add_column(\"Metric\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n    \n    table.add_row(\"Total Executions\", str(stats[\"total_executions\"]))\n    table.add_row(\"Successes\", str(stats[\"successes\"]))\n    table.add_row(\"Failures\", str(stats[\"failures\"]))\n    table.add_row(\"Success Rate\", f\"{stats['success_rate']:.1f}%\")\n    table.add_row(\"Learned Patterns\", str(stats[\"learned_patterns\"]))\n    \n    console.print(table)\n\n\nasync def main():\n    try:\n        await run_natural_language_automation()\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Program terminated[/yellow]\")\n    except Exception as e:\n        logger.exception(f\"Unexpected error: {e}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":7377},"src/automation/enhanced_nl_executor.py":{"content":"import json\nimport asyncio\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\n\ntry:\n    from openai import AsyncOpenAI\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .browser_engine import BrowserEngine\nfrom .task_executor import TaskExecutor, TaskType, TaskResult\nfrom .advanced_tools import AdvancedPlaywrightTools, PageContext\nfrom .vision_analyzer import VisionPageAnalyzer, ElementLocation\nfrom .session_memory import SessionMemory\nfrom .logger import get_logger\nfrom .config import AutomationConfig\n\nlogger = get_logger()\n\n\n@dataclass\nclass ExecutionStep:\n    action: str\n    params: Dict[str, Any]\n    description: str\n    use_vision: bool = False\n\n\n@dataclass\nclass ExecutionResult:\n    success: bool\n    steps_completed: int\n    total_steps: int\n    error: Optional[str] = None\n    data: Any = None\n\n\nclass EnhancedNaturalLanguageExecutor:\n    \"\"\"\n    Highly intelligent executor with advanced capabilities:\n    - Vision-based element detection\n    - Smart selector fallback strategies  \n    - Dynamic content handling\n    - iframe/popup support\n    - Intelligent error recovery\n    - Learning from execution patterns\n    \"\"\"\n    \n    def __init__(self, browser_engine: BrowserEngine, automation_config: Optional[AutomationConfig] = None):\n        self.browser = browser_engine\n        self.task_executor = TaskExecutor(browser_engine)\n        self.config = automation_config or AutomationConfig()\n        self.client = None\n        self.memory = SessionMemory(session_dir=self.config.session_dir)\n        self.advanced_tools: Optional[AdvancedPlaywrightTools] = None\n        self.vision_analyzer = VisionPageAnalyzer()\n        \n        import os\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available. Natural language execution requires OpenAI.\")\n        elif not api_key:\n            logger.warning(\"OPENAI_API_KEY not set. Natural language execution will not be available.\")\n        else:\n            self.client = AsyncOpenAI(api_key=api_key)\n    \n    async def execute_instruction(self, instruction: str, url: Optional[str] = None,\n                                 use_vision: bool = False) -> ExecutionResult:\n        \"\"\"\n        Execute a natural language instruction with advanced capabilities.\n        \n        Args:\n            instruction: Natural language instruction\n            url: Optional starting URL\n            use_vision: Whether to use vision-based analysis\n            \n        Returns:\n            ExecutionResult with success status and any extracted data\n        \"\"\"\n        if not self.client:\n            logger.error(\"Cannot execute instruction: OpenAI client not initialized\")\n            return ExecutionResult(success=False, steps_completed=0, total_steps=0, \n                                 error=\"OpenAI API not available\")\n        \n        if self.browser.page and not self.advanced_tools:\n            self.advanced_tools = AdvancedPlaywrightTools(self.browser.page)\n        \n        logger.info(f\"Processing instruction with enhanced capabilities: {instruction}\")\n        \n        max_retries = self.config.max_retries\n        attempt = 0\n        page_context = None\n        \n        while attempt < max_retries:\n            try:\n                if use_vision and self.advanced_tools:\n                    page_context = await self.advanced_tools.get_page_context(\n                        include_screenshot=True,\n                        include_dom=True\n                    )\n                \n                steps = await self._convert_instruction_to_steps(instruction, url, page_context)\n                \n                if not steps:\n                    return ExecutionResult(success=False, steps_completed=0, total_steps=0,\n                                         error=\"Could not convert instruction to actions\")\n                \n                logger.info(f\"Generated {len(steps)} steps (vision-enhanced: {use_vision})\")\n                \n                result = await self._execute_steps_with_intelligence(steps, page_context)\n                \n                if result.success:\n                    self._record_execution(instruction, steps, True)\n                    return result\n                \n                logger.warning(f\"Execution failed on attempt {attempt + 1}: {result.error}\")\n                \n                if attempt < max_retries - 1:\n                    logger.info(\"Analyzing error with vision and retrying...\")\n                    \n                    corrected_steps = await self._intelligent_error_correction(\n                        instruction, steps, result.error, attempt, page_context\n                    )\n                    \n                    if corrected_steps:\n                        attempt += 1\n                        logger.info(f\"Retrying with corrected steps (attempt {attempt + 1})...\")\n                        steps = corrected_steps\n                        result = await self._execute_steps_with_intelligence(steps, page_context)\n                        \n                        if result.success:\n                            self._record_execution(instruction, steps, True)\n                            return result\n                        \n                        logger.warning(f\"Corrected execution also failed: {result.error}\")\n                \n                attempt += 1\n            \n            except Exception as e:\n                logger.error(f\"Unexpected error during execution: {e}\")\n                attempt += 1\n                await asyncio.sleep(self.config.retry_delay)\n        \n        error_msg = \"Max retries exceeded\"\n        if 'steps' in locals() and steps:\n            self._record_execution(instruction, steps, False, error_msg)\n        \n        return ExecutionResult(success=False, steps_completed=0, total_steps=len(steps) if steps else 0,\n                             error=error_msg)\n    \n    async def _convert_instruction_to_steps(self, instruction: str, url: Optional[str] = None,\n                                           context: Optional[PageContext] = None) -> List[ExecutionStep]:\n        \"\"\"\n        Convert instruction to steps with enhanced context awareness.\n        \"\"\"\n        memory_context = self.memory.get_context_for_instruction(instruction)\n        \n        page_info = \"\"\n        if context:\n            page_info = f\"\"\"\nCurrent page context:\n- URL: {context.url}\n- Title: {context.title}\n- Has iframes: {context.has_iframes}\n- Has popups: {context.has_popups}\n- Visible elements: {len(context.visible_elements)}\n\"\"\"\n            if context.visible_elements:\n                page_info += \"\\nKey visible elements:\\n\" + \"\\n\".join(context.visible_elements[:15])\n        \n        system_prompt = \"\"\"You are an expert browser automation assistant with advanced capabilities.\n\nAvailable actions:\n- navigate: Go to a URL {\"action\": \"navigate\", \"params\": {\"url\": \"https://example.com\"}}\n- click: Click an element {\"action\": \"click\", \"params\": {\"selector\": \"button.submit\", \"description\": \"submit button\"}}\n- fill: Fill input {\"action\": \"fill\", \"params\": {\"selector\": \"input[name='q']\", \"value\": \"search term\", \"description\": \"search box\"}}\n- extract_text: Extract text {\"action\": \"extract_text\", \"params\": {\"selector\": \"h1\", \"all\": false, \"description\": \"page title\"}}\n- wait: Wait {\"action\": \"wait\", \"params\": {\"type\": \"time\", \"duration\": 2000}}\n- wait_dynamic: Wait for dynamic content {\"action\": \"wait_dynamic\", \"params\": {}}\n- scroll_to: Scroll to element {\"action\": \"scroll_to\", \"params\": {\"selector\": \"div.content\"}}\n- handle_iframe: Switch to iframe {\"action\": \"handle_iframe\", \"params\": {\"selector\": \"iframe#content\"}}\n- screenshot: Screenshot {\"action\": \"screenshot\", \"params\": {\"name\": \"screenshot\"}}\n- extract_links: Get all links {\"action\": \"extract_links\", \"params\": {\"filter_text\": \"optional filter\"}}\n- extract_table: Get table data {\"action\": \"extract_table\", \"params\": {\"selector\": \"table.data\"}}\n\nIMPORTANT SELECTOR GUIDELINES:\n1. Always include a human-readable \"description\" in params for click/fill/extract actions\n2. Use generic, flexible selectors (prefer classes over ids)\n3. Consider multiple fallback strategies\n4. For buttons/links, include descriptive text when possible\n5. Account for dynamic content - add wait_dynamic when needed\n6. If iframe detected, add handle_iframe step before interacting with iframe content\n\nReturn ONLY a JSON array of steps. Be specific but flexible with selectors.\"\"\"\n\n        user_prompt = f\"\"\"Instruction: {instruction}\n\n{page_info}\n\"\"\"\n        \n        if url:\n            user_prompt += f\"\\nStarting URL: {url}\"\n        \n        if memory_context:\n            user_prompt += f\"\\n\\n{memory_context}\"\n        \n        user_prompt += \"\\n\\nGenerate the automation steps as a JSON array:\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.3,\n                max_tokens=2500\n            )\n            \n            content = response.choices[0].message.content.strip()\n            \n            if content.startswith(\"```json\"):\n                content = content[7:]\n            if content.startswith(\"```\"):\n                content = content[3:]\n            if content.endswith(\"```\"):\n                content = content[:-3]\n            content = content.strip()\n            \n            steps_data = json.loads(content)\n            \n            steps = [\n                ExecutionStep(\n                    action=step[\"action\"],\n                    params=step[\"params\"],\n                    description=step.get(\"description\", step[\"action\"]),\n                    use_vision=step.get(\"use_vision\", False)\n                )\n                for step in steps_data\n            ]\n            \n            return steps\n            \n        except Exception as e:\n            logger.error(f\"Error converting instruction to steps: {e}\")\n            return []\n    \n    async def _execute_steps_with_intelligence(self, steps: List[ExecutionStep],\n                                               context: Optional[PageContext] = None) -> ExecutionResult:\n        \"\"\"\n        Execute steps with intelligent element finding and error handling.\n        \"\"\"\n        total_steps = len(steps)\n        completed = 0\n        last_data = None\n        current_context = context\n        \n        for i, step in enumerate(steps):\n            logger.info(f\"Step {i+1}/{total_steps}: {step.description}\")\n            \n            try:\n                if step.action in [\"click\", \"fill\", \"extract_text\", \"scroll_to\"]:\n                    if \"selector\" in step.params and \"description\" in step.params:\n                        original_selector = step.params[\"selector\"]\n                        description = step.params[\"description\"]\n                        \n                        selector = await self._intelligent_find_selector(\n                            description, original_selector, step.use_vision, current_context\n                        )\n                        \n                        if selector:\n                            step.params[\"selector\"] = selector\n                        else:\n                            logger.warning(f\"Could not find element for: {description}, using original\")\n                \n                if step.action == \"wait_dynamic\":\n                    if self.advanced_tools:\n                        await self.advanced_tools.wait_for_dynamic_content()\n                        completed += 1\n                        continue\n                \n                if step.action == \"handle_iframe\":\n                    if self.advanced_tools:\n                        frame = await self.advanced_tools.handle_iframe(step.params.get(\"selector\"))\n                        if frame:\n                            logger.info(\"Successfully switched to iframe\")\n                        completed += 1\n                        continue\n                \n                if step.action == \"extract_links\":\n                    if self.advanced_tools:\n                        links = await self.advanced_tools.extract_links(step.params.get(\"filter_text\"))\n                        last_data = links\n                        completed += 1\n                        continue\n                \n                if step.action == \"extract_table\":\n                    if self.advanced_tools:\n                        table_data = await self.advanced_tools.extract_table_data(step.params.get(\"selector\", \"table\"))\n                        last_data = table_data\n                        completed += 1\n                        continue\n                \n                if step.action == \"scroll_to\":\n                    if self.advanced_tools:\n                        await self.advanced_tools.scroll_to_element(step.params[\"selector\"])\n                        completed += 1\n                        continue\n                \n                task_type = TaskType(step.action)\n                result = await self.task_executor.execute_task(task_type, step.params)\n                \n                if not result.success:\n                    error_msg = f\"Step {i+1} failed: {result.error or 'Unknown error'}\"\n                    logger.error(error_msg)\n                    return ExecutionResult(\n                        success=False,\n                        steps_completed=completed,\n                        total_steps=total_steps,\n                        error=error_msg\n                    )\n                \n                # Refresh page context after successful navigation for DOM analysis\n                if step.action == \"navigate\" and result.success and self.advanced_tools and step.use_vision:\n                    await asyncio.sleep(1)  # Give page time to load\n                    current_context = await self.advanced_tools.get_page_context(\n                        include_screenshot=True,\n                        include_dom=True\n                    )\n                    logger.info(f\"ðŸ“Š Refreshed DOM context after navigation to {current_context.url}\")\n                \n                if result.data is not None:\n                    last_data = result.data\n                    if isinstance(result.data, list) and len(result.data) <= 10:\n                        logger.info(f\"Step result: {result.data}\")\n                    else:\n                        logger.info(f\"Step result: {str(result.data)[:100]}...\")\n                \n                completed += 1\n                await asyncio.sleep(0.5)\n                \n            except ValueError:\n                error_msg = f\"Invalid action type: {step.action}\"\n                logger.error(error_msg)\n                return ExecutionResult(\n                    success=False,\n                    steps_completed=completed,\n                    total_steps=total_steps,\n                    error=error_msg\n                )\n            except Exception as e:\n                error_msg = f\"Step {i+1} error: {str(e)}\"\n                logger.error(error_msg)\n                return ExecutionResult(\n                    success=False,\n                    steps_completed=completed,\n                    total_steps=total_steps,\n                    error=error_msg\n                )\n        \n        logger.success(f\"Successfully completed all {total_steps} steps\")\n        return ExecutionResult(\n            success=True,\n            steps_completed=completed,\n            total_steps=total_steps,\n            data=last_data\n        )\n    \n    async def _intelligent_find_selector(self, description: str, fallback_selector: str,\n                                        use_vision: bool, context: Optional[PageContext]) -> str:\n        \"\"\"\n        Intelligently find the best selector using multiple strategies.\n        \"\"\"\n        if self.advanced_tools:\n            smart_selector = await self.advanced_tools.smart_find_element(description)\n            if smart_selector:\n                return smart_selector\n        \n        if use_vision and context and self.vision_analyzer.client:\n            location = await self.vision_analyzer.find_element_by_description(context, description)\n            if location and location.confidence > 0.7:\n                logger.info(f\"Vision found selector: {location.suggested_selector}\")\n                return location.suggested_selector\n        \n        return fallback_selector\n    \n    async def _intelligent_error_correction(self, instruction: str, failed_steps: List[ExecutionStep],\n                                           error: str, attempt: int,\n                                           context: Optional[PageContext]) -> Optional[List[ExecutionStep]]:\n        \"\"\"\n        Use vision and AI to correct errors intelligently.\n        \"\"\"\n        logger.info(\"Performing intelligent error correction...\")\n        \n        if context and self.vision_analyzer.client:\n            failed_step = None\n            for step in failed_steps:\n                if \"selector\" in step.params:\n                    failed_step = step\n                    break\n            \n            if failed_step:\n                diagnosis = await self.vision_analyzer.diagnose_error(\n                    context, error, failed_step.params.get(\"selector\", \"\")\n                )\n                if diagnosis:\n                    logger.info(f\"Vision diagnosis: {diagnosis}\")\n        \n        system_prompt = \"\"\"You are an expert at debugging and correcting browser automation failures.\nAnalyze the error and generate corrected steps using better selectors and strategies.\n\nCommon fixes:\n- Use more flexible selectors\n- Add wait_dynamic for dynamic content\n- Add scroll_to before clicking elements\n- Use text-based selectors when CSS fails\n- Handle iframes if present\n- Try alternative element descriptions\n\nReturn ONLY corrected JSON array of steps.\"\"\"\n\n        failed_steps_json = json.dumps([\n            {\"action\": s.action, \"params\": s.params, \"description\": s.description}\n            for s in failed_steps\n        ], indent=2)\n        \n        context_info = \"\"\n        if context:\n            context_info = f\"\"\"\nPage context:\n- URL: {context.url}\n- Title: {context.title}\n- Has iframes: {context.has_iframes}\n- Visible elements: {len(context.visible_elements)}\n\"\"\"\n        \n        user_prompt = f\"\"\"Original instruction: {instruction}\n\nFailed steps:\n{failed_steps_json}\n\nError: {error}\n\n{context_info}\n\nGenerate corrected steps with better selectors and strategies:\"\"\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.4,\n                max_tokens=2500\n            )\n            \n            content = response.choices[0].message.content.strip()\n            \n            if content.startswith(\"```json\"):\n                content = content[7:]\n            if content.startswith(\"```\"):\n                content = content[3:]\n            if content.endswith(\"```\"):\n                content = content[:-3]\n            content = content.strip()\n            \n            steps_data = json.loads(content)\n            \n            corrected_steps = [\n                ExecutionStep(\n                    action=step[\"action\"],\n                    params=step[\"params\"],\n                    description=step.get(\"description\", step[\"action\"]),\n                    use_vision=step.get(\"use_vision\", False)\n                )\n                for step in steps_data\n            ]\n            \n            logger.info(f\"Generated {len(corrected_steps)} corrected steps\")\n            return corrected_steps\n            \n        except Exception as e:\n            logger.error(f\"Error generating corrections: {e}\")\n            return None\n    \n    def _record_execution(self, instruction: str, steps: List[ExecutionStep],\n                         success: bool, error: Optional[str] = None):\n        \"\"\"Record execution in persistent memory.\"\"\"\n        steps_data = [\n            {\"action\": s.action, \"params\": s.params, \"description\": s.description}\n            for s in steps\n        ]\n        self.memory.record_execution(instruction, success, steps_data, error)\n    \n    def get_memory_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about execution memory.\"\"\"\n        return self.memory.get_stats()\n","size_bytes":20722},"examples/form_filling_example.py":{"content":"import asyncio\nimport sys\nimport os\nimport json\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def fill_and_submit_form(url: str, form_config_file: str = None):\n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\"\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        if form_config_file:\n            with open(form_config_file, 'r') as f:\n                config = json.load(f)\n                form_data = config.get('form_data', {})\n                submit_selector = config.get('submit_selector')\n        else:\n            logger.info(\"Interactive mode: Define form fields\")\n            form_data = {}\n            \n            print(\"\\nEnter form fields (CSS selector = value)\")\n            print(\"Examples:\")\n            print(\"  input[name='email'] = user@example.com\")\n            print(\"  #username = myusername\")\n            print(\"  textarea[name='message'] = Hello World\")\n            print(\"\\nPress Enter with empty selector to finish\\n\")\n            \n            while True:\n                selector = input(\"CSS Selector (or press Enter to finish): \").strip()\n                if not selector:\n                    break\n                \n                value = input(f\"Value for '{selector}': \").strip()\n                form_data[selector] = value\n            \n            submit_selector = input(\"\\nSubmit button CSS selector (or press Enter to skip): \").strip()\n            if not submit_selector:\n                submit_selector = None\n        \n        if not form_data:\n            logger.warning(\"No form data provided\")\n            return\n        \n        logger.info(\"Filling form fields...\")\n        success = await executor.fill_form(form_data)\n        \n        if not success:\n            logger.error(\"Failed to fill form\")\n            return\n        \n        await browser.screenshot(\"form_before_submit\")\n        logger.success(\"Form filled successfully\")\n        \n        if submit_selector:\n            logger.info(f\"Clicking submit button: {submit_selector}\")\n            await browser.click(submit_selector)\n            await browser.wait_for_load()\n            await browser.screenshot(\"form_after_submit\")\n            logger.success(\"Form submitted successfully!\")\n        else:\n            logger.info(\"No submit button specified - form filled but not submitted\")\n        \n    except Exception as e:\n        logger.exception(f\"Error during form automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage:\")\n        print(\"  Interactive mode: python form_filling_example.py <url>\")\n        print(\"  Config file mode: python form_filling_example.py <url> <config.json>\")\n        print(\"\\nExample config.json:\")\n        print(json.dumps({\n            \"form_data\": {\n                \"input[name='email']\": \"test@example.com\",\n                \"input[name='password']\": \"password123\"\n            },\n            \"submit_selector\": \"button[type='submit']\"\n        }, indent=2))\n        sys.exit(1)\n    \n    url = sys.argv[1]\n    config_file = sys.argv[2] if len(sys.argv) > 2 else None\n    \n    asyncio.run(fill_and_submit_form(url, config_file))\n","size_bytes":3789},"src/automation/selectors.py":{"content":"from typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom playwright.async_api import Page, Locator\nfrom .config import SelectorStrategy\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass SelectorOptions:\n    strategy: SelectorStrategy = SelectorStrategy.AUTO\n    timeout: int = 10000\n    state: str = \"visible\"\n    strict: bool = False\n\n\nclass SmartSelector:\n    \n    @staticmethod\n    async def find_element(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[Locator]:\n        if options is None:\n            options = SelectorOptions()\n        \n        if options.strategy == SelectorStrategy.AUTO:\n            return await SmartSelector._auto_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.CSS:\n            return await SmartSelector._css_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.XPATH:\n            return await SmartSelector._xpath_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.TEXT:\n            return await SmartSelector._text_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.ARIA:\n            return await SmartSelector._aria_select(page, selector, options)\n    \n    @staticmethod\n    async def _auto_select(page: Page, selector: str, options: SelectorOptions) -> Optional[Locator]:\n        strategies = [\n            (SelectorStrategy.CSS, SmartSelector._css_select),\n            (SelectorStrategy.XPATH, SmartSelector._xpath_select),\n            (SelectorStrategy.TEXT, SmartSelector._text_select),\n            (SelectorStrategy.ARIA, SmartSelector._aria_select),\n        ]\n        \n        for strategy_type, strategy_func in strategies:\n            try:\n                logger.debug(f\"Trying {strategy_type.value} selector: {selector}\")\n                element = await strategy_func(page, selector, options)\n                if element:\n                    count = await element.count()\n                    if count > 0:\n                        logger.success(f\"Found element using {strategy_type.value} selector\")\n                        return element\n            except Exception as e:\n                logger.debug(f\"{strategy_type.value} selector failed: {str(e)}\")\n                continue\n        \n        logger.warning(f\"Could not find element with any strategy: {selector}\")\n        return None\n    \n    @staticmethod\n    async def _css_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.locator(selector)\n    \n    @staticmethod\n    async def _xpath_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        if not selector.startswith('//') and not selector.startswith('('):\n            selector = f\"//{selector}\"\n        return page.locator(f\"xpath={selector}\")\n    \n    @staticmethod\n    async def _text_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_text(selector)\n    \n    @staticmethod\n    async def _aria_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_role(selector)\n    \n    @staticmethod\n    async def find_all(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> List[Locator]:\n        locator = await SmartSelector.find_element(page, selector, options)\n        if locator:\n            count = await locator.count()\n            return [locator.nth(i) for i in range(count)]\n        return []\n    \n    @staticmethod\n    async def safe_click(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.click(timeout=options.timeout if options else 10000)\n                logger.success(f\"Clicked element: {selector}\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to click element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def safe_fill(\n        page: Page,\n        selector: str,\n        value: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.fill(value, timeout=options.timeout if options else 10000)\n                logger.success(f\"Filled element {selector} with value\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to fill element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def get_text(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                text = await element.first.text_content(timeout=options.timeout if options else 10000)\n                return text\n        except Exception as e:\n            logger.error(f\"Failed to get text from {selector}: {str(e)}\")\n        return None\n    \n    @staticmethod\n    async def get_attribute(\n        page: Page,\n        selector: str,\n        attribute: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                attr_value = await element.first.get_attribute(attribute, timeout=options.timeout if options else 10000)\n                return attr_value\n        except Exception as e:\n            logger.error(f\"Failed to get attribute {attribute} from {selector}: {str(e)}\")\n        return None\n","size_bytes":5951},"src/automation/task_executor.py":{"content":"from typing import Optional, Dict, Any, List\nfrom enum import Enum\nimport asyncio\nfrom dataclasses import dataclass\n\nfrom .browser_engine import BrowserEngine\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass TaskType(Enum):\n    NAVIGATE = \"navigate\"\n    CLICK = \"click\"\n    FILL = \"fill\"\n    EXTRACT_TEXT = \"extract_text\"\n    EXTRACT_LINKS = \"extract_links\"\n    SCREENSHOT = \"screenshot\"\n    WAIT = \"wait\"\n    SCROLL = \"scroll\"\n    EXECUTE_SCRIPT = \"execute_script\"\n\n\n@dataclass\nclass TaskResult:\n    success: bool\n    data: Any = None\n    error: Optional[str] = None\n\n\nclass TaskExecutor:\n    \n    def __init__(self, browser_engine: BrowserEngine):\n        self.browser = browser_engine\n    \n    async def execute_task(self, task_type: TaskType, params: Dict[str, Any]) -> TaskResult:\n        try:\n            if task_type == TaskType.NAVIGATE:\n                return await self._navigate(params)\n            elif task_type == TaskType.CLICK:\n                return await self._click(params)\n            elif task_type == TaskType.FILL:\n                return await self._fill(params)\n            elif task_type == TaskType.EXTRACT_TEXT:\n                return await self._extract_text(params)\n            elif task_type == TaskType.EXTRACT_LINKS:\n                return await self._extract_links(params)\n            elif task_type == TaskType.SCREENSHOT:\n                return await self._screenshot(params)\n            elif task_type == TaskType.WAIT:\n                return await self._wait(params)\n            elif task_type == TaskType.SCROLL:\n                return await self._scroll(params)\n            elif task_type == TaskType.EXECUTE_SCRIPT:\n                return await self._execute_script(params)\n            else:\n                return TaskResult(success=False, error=f\"Unknown task type: {task_type}\")\n        except Exception as e:\n            logger.error(f\"Task execution failed: {str(e)}\")\n            return TaskResult(success=False, error=str(e))\n    \n    async def _navigate(self, params: Dict[str, Any]) -> TaskResult:\n        url = params.get(\"url\")\n        if not url:\n            return TaskResult(success=False, error=\"URL is required\")\n        \n        success = await self.browser.navigate(url, params.get(\"wait_until\"))\n        return TaskResult(success=success)\n    \n    async def _click(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        success = await self.browser.click(selector)\n        return TaskResult(success=success)\n    \n    async def _fill(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        value = params.get(\"value\")\n        \n        if not selector or value is None:\n            return TaskResult(success=False, error=\"Selector and value are required\")\n        \n        success = await self.browser.fill(selector, str(value))\n        return TaskResult(success=success)\n    \n    async def _extract_text(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        all_elements = params.get(\"all\", False)\n        \n        if all_elements:\n            texts = await self.browser.get_all_text(selector)\n            return TaskResult(success=True, data=texts)\n        else:\n            text = await self.browser.get_text(selector)\n            return TaskResult(success=text is not None, data=text)\n    \n    async def _extract_links(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\", \"a\")\n        \n        links = []\n        elements = await self.browser.get_all_text(selector)\n        \n        for i, _ in enumerate(elements):\n            href = await self.browser.get_attribute(f\"{selector}:nth-of-type({i+1})\", \"href\")\n            text = await self.browser.get_text(f\"{selector}:nth-of-type({i+1})\")\n            if href:\n                links.append({\"url\": href, \"text\": text or \"\"})\n        \n        return TaskResult(success=True, data=links)\n    \n    async def _screenshot(self, params: Dict[str, Any]) -> TaskResult:\n        name = params.get(\"name\")\n        path = await self.browser.screenshot(name)\n        return TaskResult(success=True, data=path)\n    \n    async def _wait(self, params: Dict[str, Any]) -> TaskResult:\n        wait_type = params.get(\"type\", \"time\")\n        \n        if wait_type == \"time\":\n            duration = params.get(\"duration\", 1000)\n            await asyncio.sleep(duration / 1000)\n            return TaskResult(success=True)\n        elif wait_type == \"selector\":\n            selector = params.get(\"selector\")\n            if not selector:\n                return TaskResult(success=False, error=\"Selector is required for selector wait\")\n            success = await self.browser.wait_for_selector(selector, params.get(\"timeout\"))\n            return TaskResult(success=success)\n        elif wait_type == \"load\":\n            await self.browser.wait_for_load(params.get(\"timeout\"))\n            return TaskResult(success=True)\n        else:\n            return TaskResult(success=False, error=f\"Unknown wait type: {wait_type}\")\n    \n    async def _scroll(self, params: Dict[str, Any]) -> TaskResult:\n        direction = params.get(\"direction\", \"down\")\n        amount = params.get(\"amount\", 500)\n        \n        script = f\"window.scrollBy(0, {amount if direction == 'down' else -amount})\"\n        await self.browser.execute_script(script)\n        \n        return TaskResult(success=True)\n    \n    async def _execute_script(self, params: Dict[str, Any]) -> TaskResult:\n        script = params.get(\"script\")\n        if not script:\n            return TaskResult(success=False, error=\"Script is required\")\n        \n        result = await self.browser.execute_script(script)\n        return TaskResult(success=True, data=result)\n    \n    async def fill_form(self, form_data: Dict[str, str]) -> bool:\n        logger.info(\"Filling form with provided data\")\n        \n        for selector, value in form_data.items():\n            success = await self.browser.fill(selector, value)\n            if not success:\n                logger.error(f\"Failed to fill field: {selector}\")\n                return False\n        \n        logger.success(\"Form filled successfully\")\n        return True\n    \n    async def scrape_table(self, table_selector: str) -> List[Dict[str, Any]]:\n        logger.info(f\"Scraping table: {table_selector}\")\n        \n        headers_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('th'))\n            .map(th => th.textContent.trim())\n        \"\"\"\n        headers = await self.browser.execute_script(headers_script)\n        \n        rows_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('tbody tr'))\n            .map(tr => Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim()))\n        \"\"\"\n        rows = await self.browser.execute_script(rows_script)\n        \n        table_data = []\n        for row in rows:\n            row_dict = dict(zip(headers, row))\n            table_data.append(row_dict)\n        \n        logger.success(f\"Scraped {len(table_data)} rows from table\")\n        return table_data\n","size_bytes":7377},"test_automation.py":{"content":"import asyncio\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def test_basic_automation():\n    logger.info(\"Testing basic browser automation framework\")\n    \n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\"\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        logger.info(\"Starting browser...\")\n        await browser.start()\n        logger.success(\"Browser started successfully!\")\n        \n        logger.info(\"Navigating to Python.org...\")\n        await browser.navigate(\"https://www.python.org\")\n        await browser.wait_for_load()\n        logger.success(\"Navigation successful!\")\n        \n        logger.info(\"Extracting page title...\")\n        title = await browser.get_text(\"h1\")\n        logger.success(f\"Page title: {title}\")\n        \n        logger.info(\"Taking screenshot...\")\n        screenshot_path = await browser.screenshot(\"test_python_org\")\n        logger.success(f\"Screenshot saved to: {screenshot_path}\")\n        \n        logger.info(\"\\n\" + \"=\"*50)\n        logger.success(\"âœ… All tests passed! Framework is working correctly.\")\n        logger.info(\"=\"*50 + \"\\n\")\n        \n    except Exception as e:\n        logger.exception(f\"âŒ Test failed: {e}\")\n        return False\n    finally:\n        logger.info(\"Stopping browser...\")\n        await browser.stop()\n        logger.success(\"Browser stopped successfully!\")\n    \n    return True\n\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_basic_automation())\n    exit(0 if success else 1)\n","size_bytes":1858},"main.py":{"content":"import asyncio\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.automation import BrowserEngine, TaskExecutor, AITaskGenerator, AI_AVAILABLE\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger, console\nfrom rich.prompt import Prompt, Confirm\nfrom rich.table import Table\nfrom rich.panel import Panel\n\nlogger = get_logger()\n\n\nasync def run_web_automation_demo():\n    console.print(Panel.fit(\"Web Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to automate\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        page_title = await browser.get_text(\"h1\")\n        if page_title:\n            logger.success(f\"Page heading: {page_title}\")\n        \n        links = await browser.get_all_text(\"a\")\n        if links:\n            console.print(f\"\\n[cyan]Found {len(links)} links on the page[/cyan]\")\n            \n            table = Table(title=\"First 10 Links\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=3)\n            table.add_column(\"Link Text\", style=\"cyan\")\n            \n            for i, link_text in enumerate(links[:10], 1):\n                if link_text.strip():\n                    table.add_row(str(i), link_text.strip()[:80])\n            \n            console.print(table)\n        \n        screenshot_path = await browser.screenshot(\"web_automation_demo\")\n        logger.success(f\"Screenshot saved to {screenshot_path}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_ai_code_generation():\n    console.print(Panel.fit(\"AI Code Generation Demo\", style=\"bold cyan\"))\n    \n    if not AI_AVAILABLE:\n        console.print(\"[red]AI code generation is not available due to package compatibility issues.[/red]\")\n        console.print(\"[yellow]The core automation framework works without AI features.[/yellow]\")\n        return\n    \n    task_description = Prompt.ask(\n        \"Describe the automation task\"\n    )\n    \n    config = AutomationConfig(openai_model=\"gpt-4o-mini\", mcp_timeout=300)\n    generator = AITaskGenerator(config)\n    \n    console.print(\"\\n[yellow]Generating code... This may take a moment.[/yellow]\\n\")\n    \n    code = await generator.generate_playwright_code(task_description)\n    \n    if code:\n        console.print(Panel(code, title=\"Generated Code\", border_style=\"green\"))\n        \n        if Confirm.ask(\"Save to file?\", default=True):\n            filename = Prompt.ask(\"Filename\", default=\"generated_automation.py\")\n            with open(filename, 'w') as f:\n                f.write(code)\n            logger.success(f\"Code saved to {filename}\")\n    else:\n        logger.error(\"Failed to generate code. Make sure OPENAI_API_KEY is set.\")\n\n\nasync def run_form_automation_demo():\n    console.print(Panel.fit(\"Form Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter form URL\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        console.print(\"\\n[yellow]You can now define form fields to fill[/yellow]\")\n        console.print(\"[dim]Example: input[name='email'] = test@example.com[/dim]\\n\")\n        \n        form_data = {}\n        \n        while True:\n            selector = Prompt.ask(\"Enter CSS selector (or press Enter to finish)\", default=\"\")\n            if not selector:\n                break\n            \n            value = Prompt.ask(f\"Enter value for '{selector}'\")\n            form_data[selector] = value\n        \n        if form_data:\n            success = await executor.fill_form(form_data)\n            if success:\n                logger.success(\"Form filled successfully!\")\n                \n                screenshot_path = await browser.screenshot(\"form_filled\")\n                logger.success(f\"Screenshot saved to {screenshot_path}\")\n        else:\n            logger.info(\"No form data provided\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_data_extraction_demo():\n    console.print(Panel.fit(\"Data Extraction Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to extract data from\")\n    selector = Prompt.ask(\"Enter CSS selector for elements to extract\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        texts = await browser.get_all_text(selector)\n        \n        if texts:\n            console.print(f\"\\n[cyan]Found {len(texts)} elements matching '{selector}'[/cyan]\\n\")\n            \n            table = Table(title=\"Extracted Data\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=5)\n            table.add_column(\"Content\", style=\"green\")\n            \n            for i, text in enumerate(texts[:20], 1):\n                if text.strip():\n                    table.add_row(str(i), text.strip()[:100])\n            \n            console.print(table)\n            \n            if Confirm.ask(\"\\nSave to file?\", default=False):\n                filename = Prompt.ask(\"Filename\", default=\"extracted_data.txt\")\n                with open(filename, 'w') as f:\n                    for text in texts:\n                        f.write(f\"{text}\\n\")\n                logger.success(f\"Data saved to {filename}\")\n        else:\n            logger.warning(f\"No elements found matching selector: {selector}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def main():\n    console.print(Panel.fit(\n        \"[bold cyan]Browser Automation Framework[/bold cyan]\\n\"\n        \"[dim]Universal web automation for any site[/dim]\",\n        border_style=\"cyan\"\n    ))\n    \n    options = {\n        \"1\": (\"Web Automation Demo\", run_web_automation_demo),\n        \"2\": (\"Form Automation Demo\", run_form_automation_demo),\n        \"3\": (\"Data Extraction Demo\", run_data_extraction_demo),\n        \"4\": (f\"AI Code Generation {'[dim](unavailable)[/dim]' if not AI_AVAILABLE else ''}\", run_ai_code_generation),\n        \"5\": (\"Exit\", None)\n    }\n    \n    while True:\n        console.print(\"\\n[bold]Available Demos:[/bold]\")\n        for key, (name, _) in options.items():\n            console.print(f\"  {key}. {name}\")\n        \n        choice = Prompt.ask(\"\\nSelect an option\", choices=list(options.keys()), default=\"1\")\n        \n        if choice == \"5\":\n            console.print(\"\\n[cyan]Goodbye![/cyan]\")\n            break\n        \n        _, func = options[choice]\n        if func:\n            try:\n                await func()\n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Operation cancelled[/yellow]\")\n            except Exception as e:\n                logger.exception(f\"Unexpected error: {e}\")\n        \n        console.print()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Program terminated[/yellow]\")\n","size_bytes":8117},"src/automation/browser_engine.py":{"content":"import asyncio\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom playwright.async_api import async_playwright, Browser, BrowserContext, Page, Playwright\nfrom tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nimport json\nfrom datetime import datetime\n\nfrom .config import BrowserConfig, AutomationConfig\nfrom .logger import get_logger\nfrom .selectors import SmartSelector, SelectorOptions\n\nlogger = get_logger()\n\n\nclass BrowserEngine:\n    \n    def __init__(\n        self,\n        browser_config: Optional[BrowserConfig] = None,\n        automation_config: Optional[AutomationConfig] = None\n    ):\n        self.browser_config = browser_config or BrowserConfig()\n        self.automation_config = automation_config or AutomationConfig()\n        \n        self.playwright: Optional[Playwright] = None\n        self.browser: Optional[Browser] = None\n        self.context: Optional[BrowserContext] = None\n        self.page: Optional[Page] = None\n        \n        self._setup_directories()\n    \n    def _setup_directories(self):\n        for dir_path in [\n            self.automation_config.screenshot_dir,\n            self.automation_config.video_dir,\n            self.automation_config.session_dir\n        ]:\n            Path(dir_path).mkdir(parents=True, exist_ok=True)\n    \n    async def start(self):\n        logger.info(f\"Starting browser engine with {self.browser_config.browser_type.value}\")\n        \n        self.playwright = await async_playwright().start()\n        \n        browser_type = getattr(self.playwright, self.browser_config.browser_type.value)\n        \n        launch_options = {\n            \"headless\": self.browser_config.headless,\n            \"slow_mo\": self.browser_config.slow_mo,\n        }\n        \n        if self.browser_config.proxy:\n            launch_options[\"proxy\"] = self.browser_config.proxy\n        \n        if self.browser_config.downloads_path:\n            Path(self.browser_config.downloads_path).mkdir(parents=True, exist_ok=True)\n        \n        self.browser = await browser_type.launch(**launch_options)\n        \n        context_options = {\n            \"viewport\": {\n                \"width\": self.browser_config.viewport_width,\n                \"height\": self.browser_config.viewport_height\n            },\n            \"locale\": self.browser_config.locale,\n            \"timezone_id\": self.browser_config.timezone,\n            \"ignore_https_errors\": self.browser_config.ignore_https_errors,\n        }\n        \n        if self.browser_config.user_agent:\n            context_options[\"user_agent\"] = self.browser_config.user_agent\n        \n        if self.browser_config.video_recording:\n            context_options[\"record_video_dir\"] = self.automation_config.video_dir\n        \n        if self.automation_config.save_session:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            if session_file.exists():\n                with open(session_file, 'r') as f:\n                    storage_state = json.load(f)\n                    context_options[\"storage_state\"] = storage_state\n                    logger.info(f\"Loaded session from {session_file}\")\n        \n        self.context = await self.browser.new_context(**context_options)\n        \n        if self.browser_config.trace_recording:\n            await self.context.tracing.start(screenshots=True, snapshots=True)\n        \n        self.page = await self.context.new_page()\n        \n        self.page.set_default_timeout(self.browser_config.timeout)\n        \n        logger.success(\"Browser engine started successfully\")\n    \n    async def stop(self):\n        logger.info(\"Stopping browser engine\")\n        \n        if self.automation_config.save_session and self.context:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            storage_state = await self.context.storage_state()\n            with open(session_file, 'w') as f:\n                json.dump(storage_state, f)\n            logger.info(f\"Saved session to {session_file}\")\n        \n        if self.browser_config.trace_recording and self.context:\n            trace_file = f\"traces/trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip\"\n            Path(\"traces\").mkdir(parents=True, exist_ok=True)\n            await self.context.tracing.stop(path=trace_file)\n            logger.info(f\"Saved trace to {trace_file}\")\n        \n        if self.page:\n            await self.page.close()\n        \n        if self.context:\n            await self.context.close()\n        \n        if self.browser:\n            await self.browser.close()\n        \n        if self.playwright:\n            await self.playwright.stop()\n        \n        logger.success(\"Browser engine stopped successfully\")\n    \n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=2, max=10),\n        retry=retry_if_exception_type(Exception)\n    )\n    async def navigate(self, url: str, wait_until: str = None) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started. Call start() first.\")\n        \n        wait_until = wait_until or self.automation_config.wait_strategy\n        \n        try:\n            logger.info(f\"Navigating to {url}\")\n            await self.page.goto(url, wait_until=wait_until, timeout=self.browser_config.timeout)\n            logger.success(f\"Successfully navigated to {url}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Navigation failed: {str(e)}\")\n            if self.browser_config.screenshot_on_error:\n                await self.screenshot(f\"error_navigate_{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n            raise\n    \n    async def screenshot(self, name: str = None) -> str:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        if name is None:\n            name = f\"screenshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        \n        screenshot_path = Path(self.automation_config.screenshot_dir) / f\"{name}.png\"\n        await self.page.screenshot(path=str(screenshot_path), full_page=True)\n        logger.info(f\"Screenshot saved to {screenshot_path}\")\n        return str(screenshot_path)\n    \n    async def wait_for_selector(\n        self,\n        selector: str,\n        timeout: Optional[int] = None,\n        state: str = \"visible\"\n    ) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        try:\n            options = SelectorOptions(timeout=timeout or self.browser_config.timeout, state=state)\n            element = await SmartSelector.find_element(self.page, selector, options)\n            if element:\n                await element.first.wait_for(state=state, timeout=timeout or self.browser_config.timeout)\n                return True\n        except Exception as e:\n            logger.error(f\"Wait for selector failed: {str(e)}\")\n        return False\n    \n    async def click(self, selector: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_click(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def fill(self, selector: str, value: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_fill(self.page, selector, value, SelectorOptions(**kwargs))\n    \n    async def get_text(self, selector: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_text(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def get_attribute(self, selector: str, attribute: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_attribute(self.page, selector, attribute, SelectorOptions(**kwargs))\n    \n    async def get_all_text(self, selector: str, **kwargs) -> List[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        elements = await SmartSelector.find_all(self.page, selector, SelectorOptions(**kwargs))\n        texts = []\n        for element in elements:\n            text = await element.text_content()\n            if text:\n                texts.append(text.strip())\n        return texts\n    \n    async def execute_script(self, script: str) -> Any:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.page.evaluate(script)\n    \n    async def wait_for_load(self, timeout: Optional[int] = None):\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.page.wait_for_load_state(\"networkidle\", timeout=timeout or self.browser_config.timeout)\n    \n    async def new_page(self) -> Page:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        page = await self.context.new_page()\n        page.set_default_timeout(self.browser_config.timeout)\n        return page\n    \n    async def get_cookies(self) -> List[Dict[str, Any]]:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.context.cookies()\n    \n    async def set_cookies(self, cookies: List[Dict[str, Any]]):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.add_cookies(cookies)\n        logger.info(f\"Set {len(cookies)} cookies\")\n    \n    async def clear_cookies(self):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.clear_cookies()\n        logger.info(\"Cleared all cookies\")\n","size_bytes":9914},"src/automation/ai_generator.py":{"content":"import os\nfrom typing import Optional\ntry:\n    from openai import AsyncOpenAI, OpenAIError\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .config import AutomationConfig\n\nlogger = get_logger()\n\n\nclass AITaskGenerator:\n    \n    def __init__(self, automation_config: Optional[AutomationConfig] = None):\n        self.config = automation_config or AutomationConfig()\n        self.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.client = None\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available. Install with: pip install openai\")\n        elif not self.api_key:\n            logger.warning(\"OPENAI_API_KEY not set. AI code generation will not be available.\")\n        else:\n            self.client = AsyncOpenAI(api_key=self.api_key)\n    \n    async def generate_playwright_code(self, task_description: str) -> Optional[str]:\n        if not OPENAI_AVAILABLE:\n            logger.error(\"Cannot generate code: OpenAI package not installed\")\n            return None\n        \n        if not self.client:\n            logger.error(\"Cannot generate code: OPENAI_API_KEY not set\")\n            return None\n        \n        logger.info(f\"Generating Playwright code for: {task_description}\")\n        \n        try:\n            system_prompt = \"\"\"You are an expert Python developer and Playwright automation engineer.\nGenerate complete, runnable Python scripts using Playwright.\nUse realistic and working CSS or XPath selectors.\nProvide only valid code with proper imports, async functions, and browser handling.\nMake the code robust with error handling and logging.\nUse best practices for browser automation.\nReturn ONLY the Python code, no explanations or markdown formatting.\"\"\"\n\n            user_prompt = f\"\"\"Generate a complete Python Playwright script for this task:\n\n{task_description}\n\nRequirements:\n- Use async/await with Playwright\n- Include proper imports\n- Add error handling\n- Use realistic selectors\n- Make it production-ready\n- Add logging where appropriate\"\"\"\n\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.7,\n                max_tokens=2000\n            )\n            \n            code = response.choices[0].message.content\n            logger.success(\"Code generation completed\")\n            return code\n            \n        except Exception as e:\n            logger.error(f\"Error during code generation: {e}\")\n            return None\n    \n    async def generate_scraping_code(self, url: str, data_description: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to scrape data from {url}. \"\n            f\"Extract the following data: {data_description}. \"\n            f\"Return the data as a list of dictionaries and print it in JSON format.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_form_filling_code(self, url: str, form_fields: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to fill out a form at {url}. \"\n            f\"The form has these fields: {form_fields}. \"\n            f\"Fill the form with appropriate test data and submit it.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_login_code(self, url: str, username_field: str, password_field: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to log in to {url}. \"\n            f\"Username field selector: {username_field}, Password field selector: {password_field}. \"\n            f\"Include error handling and session management.\"\n        )\n        return await self.generate_playwright_code(task)\n","size_bytes":3944},"examples/web_scraping_example.py":{"content":"import asyncio\nimport sys\nimport os\nimport json\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def scrape_website(url: str, selectors: dict):\n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\"\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        extracted_data = {}\n        \n        for key, selector in selectors.items():\n            logger.info(f\"Extracting {key} using selector: {selector}\")\n            texts = await browser.get_all_text(selector)\n            extracted_data[key] = texts\n            logger.success(f\"Found {len(texts)} {key}\")\n        \n        logger.info(\"\\n=== Extracted Data ===\")\n        print(json.dumps(extracted_data, indent=2))\n        \n        await browser.screenshot(\"scraped_page\")\n        \n        return extracted_data\n        \n    except Exception as e:\n        logger.exception(f\"Error during scraping: {e}\")\n        return None\n    finally:\n        await browser.stop()\n\n\nasync def main():\n    import sys\n    \n    if len(sys.argv) < 2:\n        print(\"Usage: python web_scraping_example.py <url>\")\n        print(\"Example: python web_scraping_example.py https://news.ycombinator.com\")\n        sys.exit(1)\n    \n    url = sys.argv[1]\n    \n    selectors = {\n        \"headings\": \"h1, h2\",\n        \"paragraphs\": \"p\",\n        \"links\": \"a\"\n    }\n    \n    logger.info(f\"Scraping {url} with selectors: {selectors}\")\n    data = await scrape_website(url, selectors)\n    \n    if data:\n        with open(\"scraped_data.json\", \"w\") as f:\n            json.dump(data, f, indent=2)\n        logger.success(\"Data saved to scraped_data.json\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":2257},"replit.md":{"content":"# Browser Automation Framework\n\n## Overview\nA comprehensive Python-based browser automation framework powered by Playwright and AI. This framework enables powerful browser automation for **any website** using natural language instructions via Model Context Protocol (MCP). Features intelligent error handling, learning capabilities, and automatic retry with corrections. Completely generic with no site-specific dependencies.\n\n## Project Status\n**âœ… FULLY OPERATIONAL + MCP INTEGRATED** - Successfully configured in Replit environment\n- All dependencies installed and verified\n- Playwright browser (Chromium) configured with system dependencies\n- **NEW: Playwright MCP Server integration (@playwright/mcp) âœ¨**\n- OpenAI API integration active\n- Natural language automation tested and working via MCP\n\n## Recent Changes (October 17, 2025)\n\n**ðŸš€ ENHANCED MCP Automation - MOST POWERFUL VERSION:**\n- **Vision-Based Intelligence**: Integrated GPT-4 Vision for intelligent page analysis when selectors fail\n- **Smart Retry System**: Intelligent dual-strategy retry with element catalog:\n  1. **Vision-First Strategy**: GPT-4 Vision analyzes screenshot to suggest better selectors\n  2. **Element Catalog Strategy**: Builds complete catalog of interactive elements (buttons, links, inputs, selects) with metadata (text, placeholder, name, id, aria-label), then fuzzy-matches instruction keywords to find correct target\n- **Robust Element Discovery**: Cataloging avoids selector-parsing issues and works reliably across any website structure\n- **Session Memory Integration**: Learns from successful patterns and failures\n  - Tracks execution history in sessions/execution_memory.json\n  - Retrieves similar patterns for new commands\n  - Improves automation over time through learning\n- **Page Context Awareness**: Analyzes page structure before executing actions\n- **Enhanced MCP Client**: Added 15+ utility methods for complex automation:\n  - extract_text, extract_all_text, wait_for_selector\n  - type_text, select_dropdown, hover, press_key\n  - get_console_messages, get_network_requests\n  - upload_file, handle_dialog, go_back, resize_viewport\n  - get_tabs, close_browser\n- **Intelligent AI Prompting**: Enhanced system prompt with:\n  - Current page context injection\n  - Session memory patterns\n  - Multi-strategy selector guidance\n  - Complex scenario handling instructions\n- **Lower Temperature (0.3)**: More consistent and reliable automation decisions\n- **Comprehensive Error Handling**: Tracks success/failure, logs retries, saves learnings\n\n**Previous MCP Integration:**\n- Integrated Microsoft's official Playwright MCP server (@playwright/mcp@latest)\n- Created PlaywrightMCPClient for standardized browser automation via Model Context Protocol\n- Built MCP-powered natural language automation (nl_automation_mcp.py)\n- 21 browser automation tools available\n- AI (GPT-4) automatically selects and chains appropriate MCP tools for complex tasks\n- Fixed NixOS environment issues for npx/MCP server compatibility\n\n**Import to Replit Completed + Bug Fixes:**\n- Successfully migrated browser automation framework to Replit environment\n- Installed Playwright Chromium browser and system dependencies\n- Configured OpenAI API key via Replit Secrets\n- Installed required system packages: nspr, nss, dbus, atk, cups, mesa, cairo, pango, xorg libraries\n- Fixed smart selector bug: Now properly excludes submit buttons when searching for text inputs\n- Enhanced search selector: Added Google-specific patterns (input[name=\"q\"]) and prioritization\n- Improved strategy order: More specific selectors (aria-label, placeholder) run before generic type matching\n- Verified all features are operational\n- Workflow configured and tested\n\n**Major Enhancement - Intelligent & Powerful Automation:**\n- **Vision-Based Intelligence**: Added GPT-4 Vision for page structure analysis and element detection\n- **Advanced Playwright Tools**: Comprehensive toolkit for complex web automation\n  - Smart element finding with DOM inspection\n  - Dynamic content handling (AJAX, lazy loading)\n  - iframe and popup management\n  - File upload/download support\n  - Table and link extraction\n  - Intelligent waiting strategies\n- **Enhanced Natural Language Executor**: Upgraded with vision and advanced capabilities\n  - Vision-based error diagnosis with screenshot analysis\n  - Multi-strategy element finding (text, ARIA, CSS, XPath)\n  - Context-aware action generation\n  - Intelligent error correction with better selectors\n- **Session Memory**: Persistent learning from successful patterns and failures\n- **Interactive Enhanced Interface**: nl_automation.py with vision mode option\n\n**Earlier Today:**\n- Created NaturalLanguageExecutor for instruction-to-action conversion\n- Added SessionMemory for tracking successful patterns\n- Enhanced retry logic with AI-powered error analysis\n\n## Previous Changes (October 16, 2025)\n- Created modular browser automation framework with Python 3.11\n- Implemented core BrowserEngine with multi-browser support (Chromium, Firefox, WebKit)\n- Built SmartSelector system with automatic fallback strategies (CSS, XPath, text, ARIA)\n- Added TaskExecutor for common automation patterns (scraping, forms, navigation)\n- Integrated AI-powered code generation using OpenAI GPT-4 with MCP server\n- Implemented robust error handling with retry logic using tenacity\n- Added session management with cookie and state persistence\n- Created logging system with Rich console output\n- Built example scripts for various automation scenarios\n- Set up configuration management system\n\n## Architecture\n\n### Core Components\n\n**src/automation/**\n- `browser_engine.py` - Main browser automation engine with Playwright integration\n- `selectors.py` - Smart selector system with automatic strategy fallback\n- `task_executor.py` - Task execution framework for common automation patterns\n- `mcp_client.py` - **NEW** Playwright MCP server client for standardized automation\n- `enhanced_nl_executor.py` - **ENHANCED** Advanced NL executor with vision & intelligence\n- `nl_executor.py` - Basic natural language instruction executor\n- `advanced_tools.py` - **NEW** Advanced Playwright tools (iframes, dynamic content, smart finding)\n- `vision_analyzer.py` - **NEW** GPT-4 Vision-based page analysis and element detection\n- `session_memory.py` - **NEW** Persistent memory for learning from executions\n- `ai_generator.py` - AI-powered Playwright code generation using OpenAI\n- `config.py` - Configuration management (browser, automation settings)\n- `logger.py` - Enhanced logging with Rich console output\n\n**Entry Points**\n- `nl_automation_mcp.py` - **NEW** MCP-powered natural language automation (recommended)\n- `nl_automation.py` - **ENHANCED** Interactive NL automation with vision mode\n- `main.py` - Traditional demo menu with code-based automation\n\n### Features\n\n**ðŸŽ­ MCP-Powered Automation (Primary Approach)**\n- Uses Microsoft's official Playwright MCP server for standardized automation\n- AI (GPT-4) intelligently selects and chains 21+ browser automation tools\n- Model Context Protocol ensures robust, reliable browser control\n- Convert plain English to automated browser actions via MCP tools\n- No coding or selectors required - AI handles everything\n- More stable than direct Playwright API calls\n\n**Enhanced Natural Language Automation**\n- Convert plain English instructions to browser actions\n- **Vision-based page understanding** for complex sites\n- **Smart element detection** with multiple fallback strategies\n- **Advanced web features**: iframes, popups, dynamic content, file uploads\n- Intelligent error analysis with visual diagnosis\n- Automatic corrections with better selectors\n- Learn from successful patterns\n- Persistent session memory across runs\n- Context-aware action generation\n- No coding or selectors required - just describe what you want\n\n**Browser Automation**\n- Multi-browser support (Chromium, Firefox, WebKit)\n- Headless and headed modes\n- Smart selector strategies with automatic fallback\n- Robust error handling and retry logic\n- Screenshot and video recording\n- Session and cookie management\n- Trace recording for debugging\n\n**Task Execution**\n- Pre-built tasks: navigate, click, fill, extract text/links, screenshot, wait, scroll\n- Form filling automation (any website)\n- Table scraping (any website)\n- Data extraction (any website)\n- Custom JavaScript execution\n\n**AI-Powered Features**\n- Generate Playwright code from natural language descriptions\n- Intelligent error correction with retry logic\n- Pre-built templates for scraping, form filling, login automation\n- Context-aware automation based on execution history\n\n**Configuration**\n- Environment-based configuration\n- Customizable timeouts and retries\n- Session persistence\n- Screenshot/video directories\n- Logging levels\n\n## Dependencies\n\n**Core**\n- Python 3.11\n- playwright (browser automation)\n- openai (AI code generation)\n- mcp (Model Context Protocol client)\n- @playwright/mcp (Playwright MCP server - npm package)\n- Node.js 20 (for MCP server)\n\n**Utilities**\n- python-dotenv (environment management)\n- tenacity (retry logic)\n- rich (console output)\n- pydantic (data validation)\n\n## Usage Examples\n\n### MCP-Powered Natural Language Automation (Recommended)\n```bash\n# Run the MCP-powered automation:\nuv run python nl_automation_mcp.py\n\n# Then type natural language commands:\n# \"Go to google.com and search for Python tutorials\"\n# \"Navigate to github.com and click the login button\"\n# \"Visit news.ycombinator.com and get the top 5 story titles\"\n\n# The AI will:\n# 1. Use GPT-4 to understand your command\n# 2. Select appropriate MCP browser automation tools\n# 3. Chain multiple tools for complex tasks\n# 4. Execute via Playwright MCP server\n# 5. Provide clear feedback on progress\n```\n\n### Enhanced Natural Language Automation (Vision Mode)\n```python\n# Just run nl_automation.py and type instructions like:\n# \"Go to news.ycombinator.com and get the top 5 story titles\"\n# \"Navigate to github.com and click the login button\"\n# \"Visit example.com and extract all headings\"\n\n# The AI will:\n# 1. Convert your instruction to browser actions\n# 2. Execute them step by step\n# 3. Learn from errors and retry automatically\n# 4. Remember successful patterns for future use\n```\n\n### Basic Web Automation (Code)\n```python\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\n\nbrowser = BrowserEngine(BrowserConfig(), AutomationConfig())\nexecutor = TaskExecutor(browser)\n\nawait browser.start()\nawait browser.navigate(\"https://any-website.com\")\nheadings = await browser.get_all_text(\"h1, h2, h3\")\nlinks = await browser.get_all_text(\"a\")\nawait browser.stop()\n```\n\n### AI Code Generation\n```python\nfrom src.automation import AITaskGenerator\n\ngenerator = AITaskGenerator()\ncode = await generator.generate_playwright_code(\"Navigate to any website and extract all headings\")\n```\n\n### Custom Automation (Any Website)\n```python\nbrowser = BrowserEngine()\nawait browser.start()\nawait browser.navigate(\"https://any-site.com\")\nawait browser.fill(\"input[name='email']\", \"user@example.com\")\nawait browser.click(\"button.submit\")\ndata = await browser.get_all_text(\".data-item\")\nawait browser.stop()\n```\n\n## Environment Variables\n\nSet environment variables using Replit Secrets:\n- `OPENAI_API_KEY` - Optional, required only for AI code generation features\n- Other settings can be configured via BrowserConfig and AutomationConfig classes\n\n## Known Limitations in Replit\n\n- Playwright browser automation requires system dependencies that may need manual installation in cloud environments\n- The framework code is fully functional, but actual browser execution may require additional setup\n- All features work correctly in local development environments with Playwright dependencies installed\n- AI code generation works if OPENAI_API_KEY is provided\n\n## Project Structure\n```\n.\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ automation/\nâ”‚       â”œâ”€â”€ __init__.py\nâ”‚       â”œâ”€â”€ browser_engine.py\nâ”‚       â”œâ”€â”€ selectors.py\nâ”‚       â”œâ”€â”€ task_executor.py\nâ”‚       â”œâ”€â”€ ai_generator.py\nâ”‚       â”œâ”€â”€ config.py\nâ”‚       â””â”€â”€ logger.py\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ web_scraping_example.py\nâ”‚   â”œâ”€â”€ form_filling_example.py\nâ”‚   â”œâ”€â”€ ai_code_generation_example.py\nâ”‚   â””â”€â”€ advanced_automation_example.py\nâ”œâ”€â”€ main.py\nâ”œâ”€â”€ README.md\nâ””â”€â”€ replit.md\n```\n\n## User Preferences\n- Prefers comprehensive, production-ready solutions\n- Values robust error handling and logging\n- Wants flexibility for any automation use case\n","size_bytes":12575},"examples/advanced_automation_example.py":{"content":"import asyncio\nimport sys\nimport os\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.task_executor import TaskType\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def advanced_automation_demo(url: str):\n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True,\n        video_recording=False\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\",\n        save_session=False\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(\"Example 1: Basic navigation and data extraction\")\n        \n        result = await executor.execute_task(\n            TaskType.NAVIGATE,\n            {\"url\": url}\n        )\n        logger.info(f\"Navigation result: {result.success}\")\n        \n        result = await executor.execute_task(\n            TaskType.WAIT,\n            {\"type\": \"load\"}\n        )\n        \n        result = await executor.execute_task(\n            TaskType.EXTRACT_TEXT,\n            {\"selector\": \"h1\", \"all\": False}\n        )\n        logger.info(f\"Page heading: {result.data}\")\n        \n        result = await executor.execute_task(\n            TaskType.EXTRACT_LINKS,\n            {\"selector\": \"a\"}\n        )\n        logger.info(f\"Found {len(result.data) if result.data else 0} links\")\n        \n        result = await executor.execute_task(\n            TaskType.SCREENSHOT,\n            {\"name\": \"example_page\"}\n        )\n        logger.info(f\"Screenshot saved: {result.data}\")\n        \n        logger.info(\"\\nExample 2: Scrolling and JavaScript execution\")\n        \n        result = await executor.execute_task(\n            TaskType.SCROLL,\n            {\"direction\": \"down\", \"amount\": 500}\n        )\n        logger.info(\"Scrolled down 500px\")\n        \n        result = await executor.execute_task(\n            TaskType.EXECUTE_SCRIPT,\n            {\"script\": \"return document.title\"}\n        )\n        logger.info(f\"Page title from JS: {result.data}\")\n        \n        result = await executor.execute_task(\n            TaskType.EXECUTE_SCRIPT,\n            {\"script\": \"return document.querySelectorAll('p').length\"}\n        )\n        logger.info(f\"Number of paragraphs: {result.data}\")\n        \n        logger.info(\"\\nExample 3: Table scraping (if table exists)\")\n        \n        try:\n            table_data = await executor.scrape_table(\"table\")\n            logger.info(f\"Scraped table with {len(table_data)} rows\")\n            for row in table_data[:3]:\n                logger.info(f\"Row: {row}\")\n        except Exception as e:\n            logger.debug(f\"No table found or error scraping: {e}\")\n        \n        logger.success(\"Advanced automation examples completed successfully\")\n        \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nif __name__ == \"__main__\":\n    import sys\n    \n    if len(sys.argv) < 2:\n        print(\"Usage: python advanced_automation_example.py <url>\")\n        print(\"Example: python advanced_automation_example.py https://news.ycombinator.com\")\n        sys.exit(1)\n    \n    url = sys.argv[1]\n    asyncio.run(advanced_automation_demo(url))\n","size_bytes":3488},"src/automation/__init__.py":{"content":"from .browser_engine import BrowserEngine\nfrom .task_executor import TaskExecutor\nfrom .ai_generator import AITaskGenerator\nfrom .nl_executor import NaturalLanguageExecutor\nfrom .enhanced_nl_executor import EnhancedNaturalLanguageExecutor\nfrom .advanced_tools import AdvancedPlaywrightTools\nfrom .vision_analyzer import VisionPageAnalyzer\nfrom .mcp_client import PlaywrightMCPClient\nfrom .config_loader import ConfigLoader, get_config\n\ntry:\n    from openai import AsyncOpenAI\n    AI_AVAILABLE = True\nexcept ImportError:\n    AI_AVAILABLE = False\n\n__all__ = [\n    'BrowserEngine', \n    'TaskExecutor', \n    'AITaskGenerator', \n    'NaturalLanguageExecutor',\n    'EnhancedNaturalLanguageExecutor',\n    'AdvancedPlaywrightTools',\n    'VisionPageAnalyzer',\n    'PlaywrightMCPClient',\n    'ConfigLoader',\n    'get_config',\n    'AI_AVAILABLE'\n]\n","size_bytes":838},"src/automation/config.py":{"content":"from dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Dict, Any\nimport os\n\n\nclass BrowserType(Enum):\n    CHROMIUM = \"chromium\"\n    FIREFOX = \"firefox\"\n    WEBKIT = \"webkit\"\n\n\nclass SelectorStrategy(Enum):\n    CSS = \"css\"\n    XPATH = \"xpath\"\n    TEXT = \"text\"\n    ARIA = \"aria\"\n    AUTO = \"auto\"\n\n\n@dataclass\nclass BrowserConfig:\n    browser_type: BrowserType = BrowserType.CHROMIUM\n    headless: bool = True\n    timeout: int = 30000\n    viewport_width: int = 1920\n    viewport_height: int = 1080\n    user_agent: Optional[str] = None\n    locale: str = \"en-US\"\n    timezone: str = \"America/New_York\"\n    \n    screenshot_on_error: bool = True\n    video_recording: bool = False\n    trace_recording: bool = False\n    \n    slow_mo: int = 0\n    \n    proxy: Optional[Dict[str, str]] = None\n    \n    ignore_https_errors: bool = True\n    \n    downloads_path: Optional[str] = None\n\n\n@dataclass\nclass AutomationConfig:\n    max_retries: int = 3\n    retry_delay: int = 2\n    wait_strategy: str = \"networkidle\"\n    \n    screenshot_dir: str = \"screenshots\"\n    video_dir: str = \"videos\"\n    session_dir: str = \"sessions\"\n    \n    log_level: str = \"INFO\"\n    log_file: Optional[str] = \"automation.log\"\n    \n    save_session: bool = False\n    session_name: str = \"default\"\n    \n    openai_model: str = \"gpt-4o-mini\"\n    mcp_timeout: int = 300\n\n\ndef load_config_from_env() -> Dict[str, Any]:\n    return {\n        \"browser_type\": BrowserType(os.getenv(\"BROWSER_TYPE\", \"chromium\")),\n        \"headless\": os.getenv(\"HEADLESS\", \"true\").lower() == \"true\",\n        \"timeout\": int(os.getenv(\"TIMEOUT\", \"30000\")),\n        \"max_retries\": int(os.getenv(\"MAX_RETRIES\", \"3\")),\n        \"log_level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),\n    }\n","size_bytes":1735},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"mcp>=1.18.0\",\n    \"openai>=2.4.0\",\n    \"playwright>=1.55.0\",\n    \"pydantic>=2.12.2\",\n    \"python-dotenv>=1.1.1\",\n    \"rich>=14.2.0\",\n    \"tenacity>=9.1.2\",\n]\n","size_bytes":305},"src/automation/advanced_tools.py":{"content":"import base64\nimport asyncio\nfrom typing import Optional, Dict, Any, List, Union\nfrom pathlib import Path\nfrom dataclasses import dataclass\n\nfrom playwright.async_api import Page, Frame, ElementHandle\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass PageContext:\n    \"\"\"Rich context about the current page state.\"\"\"\n    url: str\n    title: str\n    has_iframes: bool\n    has_popups: bool\n    has_alerts: bool\n    visible_elements: List[str]\n    dom_snapshot: Optional[str] = None\n    screenshot_base64: Optional[str] = None\n\n\nclass AdvancedPlaywrightTools:\n    \"\"\"\n    Advanced Playwright tools with intelligent capabilities:\n    - Vision-based element detection\n    - Dynamic content handling\n    - iframe/popup management\n    - File upload/download\n    - Smart waiting strategies\n    - DOM inspection\n    \"\"\"\n    \n    def __init__(self, page: Page):\n        self.page = page\n        self.frames: List[Frame] = []\n        self.context_history: List[PageContext] = []\n    \n    async def get_page_context(self, include_screenshot: bool = False, \n                               include_dom: bool = False) -> PageContext:\n        \"\"\"\n        Get comprehensive context about the current page.\n        \"\"\"\n        try:\n            url = self.page.url\n            title = await self.page.title()\n            \n            frames = self.page.frames\n            has_iframes = len(frames) > 1\n            \n            has_alerts = False\n            has_popups = len(self.page.context.pages) > 1\n            \n            visible_elements = await self._get_visible_elements()\n            \n            dom_snapshot = None\n            if include_dom:\n                dom_snapshot = await self._get_dom_snapshot()\n            \n            screenshot_base64 = None\n            if include_screenshot:\n                screenshot_base64 = await self._capture_screenshot_base64()\n            \n            context = PageContext(\n                url=url,\n                title=title,\n                has_iframes=has_iframes,\n                has_popups=has_popups,\n                has_alerts=has_alerts,\n                visible_elements=visible_elements,\n                dom_snapshot=dom_snapshot,\n                screenshot_base64=screenshot_base64\n            )\n            \n            self.context_history.append(context)\n            if len(self.context_history) > 10:\n                self.context_history.pop(0)\n            \n            return context\n            \n        except Exception as e:\n            logger.error(f\"Error getting page context: {e}\")\n            return PageContext(\n                url=\"unknown\",\n                title=\"unknown\",\n                has_iframes=False,\n                has_popups=False,\n                has_alerts=False,\n                visible_elements=[]\n            )\n    \n    async def _get_visible_elements(self) -> List[str]:\n        \"\"\"Get list of visible interactive elements on the page.\"\"\"\n        script = \"\"\"\n        () => {\n            const elements = [];\n            const selectors = [\n                'button', 'a', 'input', 'textarea', 'select',\n                '[role=\"button\"]', '[onclick]', '[href]',\n                'h1', 'h2', 'h3', 'form', 'nav'\n            ];\n            \n            selectors.forEach(selector => {\n                document.querySelectorAll(selector).forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        const text = el.textContent?.trim().substring(0, 50) || '';\n                        const id = el.id ? `#${el.id}` : '';\n                        const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                        elements.push({\n                            tag: el.tagName.toLowerCase(),\n                            id: id,\n                            class: className,\n                            text: text,\n                            type: el.type || '',\n                            visible: true\n                        });\n                    }\n                });\n            });\n            \n            return elements.slice(0, 50);\n        }\n        \"\"\"\n        \n        try:\n            elements = await self.page.evaluate(script)\n            return [\n                f\"{el['tag']}{el['id']}{el['class']} - {el['text']}\"\n                for el in elements\n            ]\n        except Exception as e:\n            logger.error(f\"Error getting visible elements: {e}\")\n            return []\n    \n    async def _get_dom_snapshot(self) -> str:\n        \"\"\"Get simplified DOM snapshot for AI analysis.\"\"\"\n        script = \"\"\"\n        () => {\n            const getSnapshot = (el, depth = 0, maxDepth = 3) => {\n                if (depth > maxDepth) return '';\n                \n                const indent = '  '.repeat(depth);\n                const tag = el.tagName.toLowerCase();\n                const id = el.id ? `#${el.id}` : '';\n                const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                const text = el.childNodes.length === 1 && el.childNodes[0].nodeType === 3\n                    ? ` \"${el.textContent.trim().substring(0, 30)}\"`\n                    : '';\n                \n                let result = `${indent}<${tag}${id}${className}${text}>\\\\n`;\n                \n                for (const child of el.children) {\n                    result += getSnapshot(child, depth + 1, maxDepth);\n                }\n                \n                return result;\n            };\n            \n            return getSnapshot(document.body);\n        }\n        \"\"\"\n        \n        try:\n            snapshot = await self.page.evaluate(script)\n            return snapshot[:5000]\n        except Exception as e:\n            logger.error(f\"Error getting DOM snapshot: {e}\")\n            return \"\"\n    \n    async def _capture_screenshot_base64(self) -> str:\n        \"\"\"Capture screenshot as base64 for vision analysis.\"\"\"\n        try:\n            screenshot_bytes = await self.page.screenshot(full_page=False)\n            return base64.b64encode(screenshot_bytes).decode('utf-8')\n        except Exception as e:\n            logger.error(f\"Error capturing screenshot: {e}\")\n            return \"\"\n    \n    async def smart_find_element(self, description: str) -> Optional[str]:\n        \"\"\"\n        Find element using intelligent strategies based on natural language description.\n        Returns the best selector found.\n        \"\"\"\n        logger.info(f\"Smart finding element: {description}\")\n        \n        # Order strategies from most specific to least specific\n        strategies = [\n            self._find_by_aria_label(description),\n            self._find_by_placeholder(description),\n            self._find_by_id_or_class(description),\n            self._find_by_type(description),\n            self._find_by_text(description)\n        ]\n        \n        for strategy in strategies:\n            try:\n                selector = await strategy\n                if selector and await self._element_exists(selector):\n                    logger.success(f\"Found element using {strategy.__name__}: {selector}\")\n                    return selector\n            except Exception as e:\n                logger.debug(f\"Strategy {strategy.__name__} failed: {e}\")\n                continue\n        \n        logger.warning(f\"Could not find element: {description}\")\n        return None\n    \n    async def _find_by_text(self, description: str) -> Optional[str]:\n        \"\"\"Find element by visible text content.\"\"\"\n        keywords = description.lower().split()\n        \n        for keyword in keywords:\n            if len(keyword) < 3:\n                continue\n            \n            selector = f\"text={keyword}\"\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_aria_label(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ARIA label.\"\"\"\n        selector = f\"[aria-label*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_placeholder(self, description: str) -> Optional[str]:\n        \"\"\"Find input by placeholder text.\"\"\"\n        selector = f\"[placeholder*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_id_or_class(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ID or class name.\"\"\"\n        clean_desc = description.lower().replace(' ', '-')\n        \n        selectors = [\n            f\"#{clean_desc}\",\n            f\".{clean_desc}\",\n            f\"[id*='{clean_desc}']\",\n            f\"[class*='{clean_desc}']\"\n        ]\n        \n        for selector in selectors:\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_type(self, description: str) -> Optional[str]:\n        \"\"\"Find element by type (button, link, input, etc.).\"\"\"\n        type_map = {\n            'button': 'button, [role=\"button\"], input[type=\"submit\"]',\n            'link': 'a[href]',\n            'search': 'input[type=\"search\"], input[name*=\"search\"], input[name*=\"q\"], textarea[name*=\"search\"]',\n            'input': 'input:not([type=\"submit\"]):not([type=\"button\"]):not([type=\"hidden\"]), textarea',\n            'text': 'input[type=\"text\"], input:not([type]), textarea',\n            'email': 'input[type=\"email\"], input[name*=\"email\"]',\n            'password': 'input[type=\"password\"]',\n            'submit': 'button[type=\"submit\"], input[type=\"submit\"]',\n            'form': 'form',\n            'heading': 'h1, h2, h3, h4, h5, h6'\n        }\n        \n        desc_lower = description.lower()\n        \n        # Prioritize search-specific selectors\n        if 'search' in desc_lower or 'query' in desc_lower:\n            if await self._element_exists(type_map['search']):\n                return type_map['search']\n        \n        for keyword, selector in type_map.items():\n            if keyword in desc_lower:\n                if await self._element_exists(selector):\n                    return selector\n        \n        return None\n    \n    async def _element_exists(self, selector: str) -> bool:\n        \"\"\"Check if element exists and is visible.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                is_visible = await element.is_visible()\n                return is_visible\n            return False\n        except Exception:\n            return False\n    \n    async def handle_iframe(self, iframe_selector: Optional[str] = None) -> Optional[Frame]:\n        \"\"\"Switch context to iframe for automation.\"\"\"\n        try:\n            if iframe_selector:\n                frame_element = await self.page.query_selector(iframe_selector)\n                if frame_element:\n                    frame = await frame_element.content_frame()\n                    if frame:\n                        logger.info(f\"Switched to iframe: {iframe_selector}\")\n                        return frame\n            else:\n                frames = self.page.frames\n                if len(frames) > 1:\n                    logger.info(f\"Found {len(frames)} frames\")\n                    return frames[1]\n            \n            return None\n        except Exception as e:\n            logger.error(f\"Error handling iframe: {e}\")\n            return None\n    \n    async def handle_popup(self) -> Optional[Page]:\n        \"\"\"Handle popup windows.\"\"\"\n        try:\n            pages = self.page.context.pages\n            if len(pages) > 1:\n                popup = pages[-1]\n                logger.info(f\"Switched to popup: {popup.url}\")\n                return popup\n            return None\n        except Exception as e:\n            logger.error(f\"Error handling popup: {e}\")\n            return None\n    \n    async def wait_for_dynamic_content(self, timeout: int = 10000):\n        \"\"\"Wait for dynamic content to load (AJAX, lazy loading, etc.).\"\"\"\n        try:\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            \n            await self.page.wait_for_function(\n                \"\"\"() => {\n                    return document.readyState === 'complete' &&\n                           performance.timing.loadEventEnd > 0;\n                }\"\"\",\n                timeout=timeout\n            )\n            \n            logger.info(\"Dynamic content loaded\")\n        except Exception as e:\n            logger.warning(f\"Timeout waiting for dynamic content: {e}\")\n    \n    async def scroll_to_element(self, selector: str):\n        \"\"\"Scroll element into view.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.scroll_into_view_if_needed()\n                logger.info(f\"Scrolled to element: {selector}\")\n        except Exception as e:\n            logger.error(f\"Error scrolling to element: {e}\")\n    \n    async def handle_file_upload(self, selector: str, file_path: str):\n        \"\"\"Handle file upload.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.set_input_files(file_path)\n                logger.success(f\"File uploaded: {file_path}\")\n                return True\n            return False\n        except Exception as e:\n            logger.error(f\"Error uploading file: {e}\")\n            return False\n    \n    async def extract_table_data(self, table_selector: str = \"table\") -> List[Dict[str, Any]]:\n        \"\"\"Extract structured data from HTML tables.\"\"\"\n        script = f\"\"\"\n        (selector) => {{\n            const table = document.querySelector(selector);\n            if (!table) return [];\n            \n            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());\n            const rows = Array.from(table.querySelectorAll('tbody tr'));\n            \n            return rows.map(row => {{\n                const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());\n                const rowData = {{}};\n                headers.forEach((header, i) => {{\n                    rowData[header] = cells[i] || '';\n                }});\n                return rowData;\n            }});\n        }}\n        \"\"\"\n        \n        try:\n            data = await self.page.evaluate(script, table_selector)\n            logger.info(f\"Extracted {len(data)} rows from table\")\n            return data\n        except Exception as e:\n            logger.error(f\"Error extracting table data: {e}\")\n            return []\n    \n    async def extract_links(self, filter_text: Optional[str] = None) -> List[Dict[str, str]]:\n        \"\"\"Extract all links from page, optionally filtered by text.\"\"\"\n        script = \"\"\"\n        (filterText) => {\n            const links = Array.from(document.querySelectorAll('a[href]'));\n            return links\n                .filter(a => !filterText || a.textContent.toLowerCase().includes(filterText.toLowerCase()))\n                .map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    title: a.title || ''\n                }))\n                .slice(0, 100);\n        }\n        \"\"\"\n        \n        try:\n            links = await self.page.evaluate(script, filter_text)\n            logger.info(f\"Extracted {len(links)} links\")\n            return links\n        except Exception as e:\n            logger.error(f\"Error extracting links: {e}\")\n            return []\n    \n    async def wait_for_navigation_complete(self, timeout: int = 30000):\n        \"\"\"Wait for page navigation to complete fully.\"\"\"\n        try:\n            await self.page.wait_for_load_state('domcontentloaded', timeout=timeout)\n            await self.page.wait_for_load_state('load', timeout=timeout)\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            logger.info(\"Navigation completed\")\n        except Exception as e:\n            logger.warning(f\"Navigation timeout: {e}\")\n","size_bytes":16127},"src/automation/nl_executor.py":{"content":"import json\nimport asyncio\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\ntry:\n    from openai import AsyncOpenAI\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .browser_engine import BrowserEngine\nfrom .task_executor import TaskExecutor, TaskType, TaskResult\nfrom .logger import get_logger\nfrom .config import AutomationConfig\nfrom .session_memory import SessionMemory\n\nlogger = get_logger()\n\n\n@dataclass\nclass ExecutionStep:\n    action: str\n    params: Dict[str, Any]\n    description: str\n\n\n@dataclass\nclass ExecutionResult:\n    success: bool\n    steps_completed: int\n    total_steps: int\n    error: Optional[str] = None\n    data: Any = None\n\n\nclass NaturalLanguageExecutor:\n    \"\"\"\n    Intelligent executor that converts natural language instructions into browser automation.\n    Learns from errors and retries with corrections.\n    \"\"\"\n    \n    def __init__(self, browser_engine: BrowserEngine, automation_config: Optional[AutomationConfig] = None):\n        self.browser = browser_engine\n        self.task_executor = TaskExecutor(browser_engine)\n        self.config = automation_config or AutomationConfig()\n        self.client = None\n        self.memory = SessionMemory(session_dir=self.config.session_dir)\n        \n        import os\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available. Natural language execution requires OpenAI.\")\n        elif not api_key:\n            logger.warning(\"OPENAI_API_KEY not set. Natural language execution will not be available.\")\n        else:\n            self.client = AsyncOpenAI(api_key=api_key)\n    \n    async def execute_instruction(self, instruction: str, url: Optional[str] = None) -> ExecutionResult:\n        \"\"\"\n        Execute a natural language instruction by converting it to browser actions.\n        \n        Args:\n            instruction: Natural language instruction (e.g., \"go to google and search for playwright\")\n            url: Optional starting URL\n            \n        Returns:\n            ExecutionResult with success status and any extracted data\n        \"\"\"\n        if not self.client:\n            logger.error(\"Cannot execute instruction: OpenAI client not initialized\")\n            return ExecutionResult(success=False, steps_completed=0, total_steps=0, \n                                 error=\"OpenAI API not available\")\n        \n        logger.info(f\"Processing instruction: {instruction}\")\n        \n        max_retries = self.config.max_retries\n        attempt = 0\n        \n        while attempt < max_retries:\n            try:\n                steps = await self._convert_instruction_to_steps(instruction, url)\n                \n                if not steps:\n                    return ExecutionResult(success=False, steps_completed=0, total_steps=0,\n                                         error=\"Could not convert instruction to actions\")\n                \n                logger.info(f\"Generated {len(steps)} steps to execute\")\n                \n                result = await self._execute_steps(steps)\n                \n                if result.success:\n                    self._record_execution(instruction, steps, True)\n                    return result\n                \n                logger.warning(f\"Execution failed on attempt {attempt + 1}: {result.error}\")\n                \n                if attempt < max_retries - 1:\n                    logger.info(\"Analyzing error and retrying with corrections...\")\n                    \n                    corrected_steps = await self._analyze_and_correct(\n                        instruction, steps, result.error, attempt\n                    )\n                    \n                    if corrected_steps:\n                        attempt += 1\n                        logger.info(f\"Retrying with corrected steps (attempt {attempt + 1})...\")\n                        steps = corrected_steps\n                        result = await self._execute_steps(steps)\n                        \n                        if result.success:\n                            self._record_execution(instruction, steps, True)\n                            return result\n                        \n                        logger.warning(f\"Corrected execution also failed: {result.error}\")\n                \n                attempt += 1\n            \n            except Exception as e:\n                logger.error(f\"Unexpected error during execution: {e}\")\n                attempt += 1\n                await asyncio.sleep(self.config.retry_delay)\n        \n        error_msg = \"Max retries exceeded\"\n        if 'steps' in locals() and steps:\n            self._record_execution(instruction, steps, False, error_msg)\n        \n        return ExecutionResult(success=False, steps_completed=0, total_steps=len(steps) if steps else 0,\n                             error=error_msg)\n    \n    async def _convert_instruction_to_steps(self, instruction: str, url: Optional[str] = None) -> List[ExecutionStep]:\n        \"\"\"\n        Use AI to convert natural language instruction into actionable steps.\n        \"\"\"\n        context = self.memory.get_context_for_instruction(instruction)\n        \n        system_prompt = \"\"\"You are an expert browser automation assistant. Convert natural language instructions into a sequence of browser automation actions.\n\nAvailable actions:\n- navigate: Go to a URL {\"action\": \"navigate\", \"params\": {\"url\": \"https://example.com\"}}\n- click: Click an element {\"action\": \"click\", \"params\": {\"selector\": \"button.submit\"}}\n- fill: Fill an input field {\"action\": \"fill\", \"params\": {\"selector\": \"input[name='search']\", \"value\": \"search term\"}}\n- extract_text: Extract text from elements {\"action\": \"extract_text\", \"params\": {\"selector\": \"h1\", \"all\": false}}\n- wait: Wait for something {\"action\": \"wait\", \"params\": {\"type\": \"time\", \"duration\": 2000}}\n- scroll: Scroll the page {\"action\": \"scroll\", \"params\": {\"direction\": \"down\", \"amount\": 500}}\n- screenshot: Take a screenshot {\"action\": \"screenshot\", \"params\": {\"name\": \"screenshot\"}}\n\nReturn ONLY a JSON array of steps. Each step must have:\n- action: The action type\n- params: Parameters for the action\n- description: Human-readable description of what this step does\n\nUse realistic CSS selectors. Be specific and practical.\nConsider common web patterns (forms use input/button, links use a, etc.)\"\"\"\n\n        user_prompt = f\"\"\"Instruction: {instruction}\"\"\"\n        \n        if url:\n            user_prompt += f\"\\nStarting URL: {url}\"\n        \n        if context:\n            user_prompt += f\"\\n\\nContext from previous executions:\\n{context}\"\n        \n        user_prompt += \"\\n\\nGenerate the steps as a JSON array:\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.3,\n                max_tokens=2000\n            )\n            \n            content = response.choices[0].message.content.strip()\n            \n            if content.startswith(\"```json\"):\n                content = content[7:]\n            if content.startswith(\"```\"):\n                content = content[3:]\n            if content.endswith(\"```\"):\n                content = content[:-3]\n            content = content.strip()\n            \n            steps_data = json.loads(content)\n            \n            steps = [\n                ExecutionStep(\n                    action=step[\"action\"],\n                    params=step[\"params\"],\n                    description=step.get(\"description\", step[\"action\"])\n                )\n                for step in steps_data\n            ]\n            \n            return steps\n            \n        except json.JSONDecodeError as e:\n            logger.error(f\"Failed to parse AI response as JSON: {e}\")\n            logger.debug(f\"Response content: {content}\")\n            return []\n        except Exception as e:\n            logger.error(f\"Error converting instruction to steps: {e}\")\n            return []\n    \n    async def _execute_steps(self, steps: List[ExecutionStep]) -> ExecutionResult:\n        \"\"\"\n        Execute a sequence of steps.\n        \"\"\"\n        total_steps = len(steps)\n        completed = 0\n        last_data = None\n        \n        for i, step in enumerate(steps):\n            logger.info(f\"Step {i+1}/{total_steps}: {step.description}\")\n            \n            try:\n                task_type = TaskType(step.action)\n                result = await self.task_executor.execute_task(task_type, step.params)\n                \n                if not result.success:\n                    error_msg = f\"Step {i+1} failed: {result.error or 'Unknown error'}\"\n                    logger.error(error_msg)\n                    return ExecutionResult(\n                        success=False,\n                        steps_completed=completed,\n                        total_steps=total_steps,\n                        error=error_msg\n                    )\n                \n                if result.data is not None:\n                    last_data = result.data\n                    logger.info(f\"Step result: {str(result.data)[:100]}\")\n                \n                completed += 1\n                await asyncio.sleep(0.5)\n                \n            except ValueError:\n                error_msg = f\"Invalid action type: {step.action}\"\n                logger.error(error_msg)\n                return ExecutionResult(\n                    success=False,\n                    steps_completed=completed,\n                    total_steps=total_steps,\n                    error=error_msg\n                )\n            except Exception as e:\n                error_msg = f\"Step {i+1} error: {str(e)}\"\n                logger.error(error_msg)\n                return ExecutionResult(\n                    success=False,\n                    steps_completed=completed,\n                    total_steps=total_steps,\n                    error=error_msg\n                )\n        \n        logger.success(f\"Successfully completed all {total_steps} steps\")\n        return ExecutionResult(\n            success=True,\n            steps_completed=completed,\n            total_steps=total_steps,\n            data=last_data\n        )\n    \n    async def _analyze_and_correct(self, instruction: str, failed_steps: List[ExecutionStep], \n                                   error: str, attempt: int) -> Optional[List[ExecutionStep]]:\n        \"\"\"\n        Analyze the error and generate corrected steps.\n        \"\"\"\n        logger.info(f\"Analyzing error and generating corrections (attempt {attempt + 1})...\")\n        \n        system_prompt = \"\"\"You are an expert at debugging browser automation scripts. \nGiven a failed automation sequence, analyze the error and generate corrected steps.\n\nCommon issues:\n- Wrong selectors: Try more generic selectors, text-based selectors, or ARIA labels\n- Timing: Add wait steps before interactions\n- Page navigation: Ensure page is loaded before interactions\n- Dynamic content: Wait for elements to appear\n\nReturn ONLY a JSON array of corrected steps.\"\"\"\n\n        failed_steps_json = json.dumps([\n            {\"action\": s.action, \"params\": s.params, \"description\": s.description}\n            for s in failed_steps\n        ], indent=2)\n        \n        user_prompt = f\"\"\"Original instruction: {instruction}\n\nFailed steps:\n{failed_steps_json}\n\nError: {error}\n\nGenerate corrected steps that will work:\"\"\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.4,\n                max_tokens=2000\n            )\n            \n            content = response.choices[0].message.content.strip()\n            \n            if content.startswith(\"```json\"):\n                content = content[7:]\n            if content.startswith(\"```\"):\n                content = content[3:]\n            if content.endswith(\"```\"):\n                content = content[:-3]\n            content = content.strip()\n            \n            steps_data = json.loads(content)\n            \n            corrected_steps = [\n                ExecutionStep(\n                    action=step[\"action\"],\n                    params=step[\"params\"],\n                    description=step.get(\"description\", step[\"action\"])\n                )\n                for step in steps_data\n            ]\n            \n            logger.info(f\"Generated {len(corrected_steps)} corrected steps\")\n            return corrected_steps\n            \n        except Exception as e:\n            logger.error(f\"Error generating corrections: {e}\")\n            return None\n    \n    def _record_execution(self, instruction: str, steps: List[ExecutionStep], \n                         success: bool, error: Optional[str] = None):\n        \"\"\"\n        Record execution in persistent memory.\n        \"\"\"\n        steps_data = [\n            {\"action\": s.action, \"params\": s.params, \"description\": s.description}\n            for s in steps\n        ]\n        self.memory.record_execution(instruction, success, steps_data, error)\n    \n    def get_memory_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about execution memory.\"\"\"\n        return self.memory.get_stats()\n","size_bytes":13613},"src/automation/vision_analyzer.py":{"content":"import os\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\n\ntry:\n    from openai import AsyncOpenAI\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .advanced_tools import PageContext\n\nlogger = get_logger()\n\n\n@dataclass\nclass ElementLocation:\n    \"\"\"Location and description of an element found via vision.\"\"\"\n    description: str\n    suggested_selector: str\n    confidence: float\n    position: str  # e.g., \"top-left\", \"center\", \"bottom-right\"\n    element_type: str  # e.g., \"button\", \"link\", \"input\"\n\n\nclass VisionPageAnalyzer:\n    \"\"\"\n    Uses GPT-4 Vision to understand page structure and locate elements.\n    Provides intelligent element detection when traditional selectors fail.\n    \"\"\"\n    \n    def __init__(self):\n        self.client = None\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n        elif not api_key:\n            logger.warning(\"OPENAI_API_KEY not set for vision analysis\")\n        else:\n            self.client = AsyncOpenAI(api_key=api_key)\n    \n    async def analyze_page_structure(self, context: PageContext) -> Dict[str, Any]:\n        \"\"\"\n        Analyze page structure using vision to understand layout and elements.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            logger.warning(\"Vision analysis not available\")\n            return {}\n        \n        logger.info(\"Analyzing page structure with vision...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",  # Using mini for cost efficiency, upgrade to gpt-4o for better vision\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots.\nIdentify all interactive elements, their types, positions, and suggest CSS selectors.\nDescribe the page layout and main sections.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Analyze this web page screenshot. \n\nPage URL: {context.url}\nPage Title: {context.title}\nVisible Elements Count: {len(context.visible_elements)}\n\nProvide:\n1. Page layout description\n2. Main sections identified\n3. All interactive elements (buttons, links, forms, inputs)\n4. Suggested selectors for key elements\n5. Any notable UI patterns or frameworks detected\n\nFormat as JSON.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=1500,\n                temperature=0.3\n            )\n            \n            content = response.choices[0].message.content\n            logger.success(\"Vision analysis completed\")\n            \n            return {\"analysis\": content, \"model_used\": \"gpt-4o-mini\"}\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n    \n    async def find_element_by_description(self, context: PageContext, \n                                         description: str) -> Optional[ElementLocation]:\n        \"\"\"\n        Find an element on the page using visual analysis and natural language description.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Finding element by vision: {description}\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at locating elements in web page screenshots.\nGiven a description, identify the element's position and suggest the best CSS selector.\nRespond in JSON format with: description, selector, confidence, position, type.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Find this element: \"{description}\"\n\nPage context:\n- URL: {context.url}\n- Title: {context.title}\n- Visible elements: {len(context.visible_elements)}\n\nProvide JSON with:\n- description: what you found\n- suggested_selector: CSS selector to locate it\n- confidence: 0.0 to 1.0\n- position: where on page (top-left, center, etc)\n- element_type: button, link, input, etc.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            import json\n            content = response.choices[0].message.content\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            data = json.loads(content)\n            \n            location = ElementLocation(\n                description=data.get(\"description\", description),\n                suggested_selector=data.get(\"suggested_selector\", \"\"),\n                confidence=float(data.get(\"confidence\", 0.5)),\n                position=data.get(\"position\", \"unknown\"),\n                element_type=data.get(\"element_type\", \"unknown\")\n            )\n            \n            logger.success(f\"Vision found element: {location.suggested_selector} (confidence: {location.confidence})\")\n            return location\n            \n        except Exception as e:\n            logger.error(f\"Vision element finding error: {e}\")\n            return None\n    \n    async def suggest_next_action(self, context: PageContext, goal: str) -> Optional[str]:\n        \"\"\"\n        Use vision to suggest the next best action to achieve a goal.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Getting vision suggestion for goal: {goal}\")\n        \n        try:\n            dom_context = \"\"\n            if context.visible_elements:\n                dom_context = \"Visible elements:\\n\" + \"\\n\".join(context.visible_elements[:20])\n            \n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at browser automation.\nAnalyze the page and suggest the next action to achieve the user's goal.\nBe specific about which element to interact with and what action to take.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Goal: {goal}\n\nCurrent page:\n- URL: {context.url}\n- Title: {context.title}\n\n{dom_context}\n\nWhat should be the next action? Suggest one specific action with element selector.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=200,\n                temperature=0.3\n            )\n            \n            suggestion = response.choices[0].message.content\n            logger.info(f\"Vision suggestion: {suggestion}\")\n            return suggestion\n            \n        except Exception as e:\n            logger.error(f\"Vision suggestion error: {e}\")\n            return None\n    \n    async def diagnose_error(self, context: PageContext, error_message: str, \n                            failed_selector: str) -> Optional[str]:\n        \"\"\"\n        Use vision to diagnose why an action failed and suggest corrections.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(\"Using vision to diagnose error...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at debugging browser automation failures.\nAnalyze the screenshot and error to determine what went wrong and suggest a fix.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"An automation action failed:\n\nError: {error_message}\nFailed selector: {failed_selector}\nPage URL: {context.url}\nPage Title: {context.title}\n\nWhy did it fail? What selector should be used instead?\nProvide a corrected selector and explanation.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.3\n            )\n            \n            diagnosis = response.choices[0].message.content\n            logger.info(f\"Vision diagnosis: {diagnosis}\")\n            return diagnosis\n            \n        except Exception as e:\n            logger.error(f\"Vision diagnosis error: {e}\")\n            return None\n\n\nclass VisionAnalyzer:\n    \"\"\"Simplified vision analyzer for MCP automation.\"\"\"\n    \n    def __init__(self, api_key: str):\n        self.client = None\n        try:\n            from openai import AsyncOpenAI\n            self.client = AsyncOpenAI(api_key=api_key)\n        except ImportError:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n    \n    async def analyze_page(self, screenshot_b64: str, instruction: str) -> Dict[str, Any]:\n        \"\"\"Analyze page screenshot and suggest selectors for the given instruction.\"\"\"\n        if not self.client:\n            return {}\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots for automation.\nGiven a user instruction, analyze the screenshot and suggest the best CSS selector to use.\nRespond with JSON containing: {\"suggested_selector\": \"...\", \"element_type\": \"...\", \"confidence\": 0.0-1.0}\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"image_url\",\n                                \"image_url\": {\n                                    \"url\": f\"data:image/png;base64,{screenshot_b64}\"\n                                }\n                            },\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"Task: {instruction}\\n\\nWhat selector should be used to accomplish this task?\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            content = response.choices[0].message.content or \"{}\"\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            import json\n            return json.loads(content)\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n","size_bytes":11998},"nl_automation_mcp.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nEnhanced Natural Language Browser Automation using Playwright MCP Server\nFeatures: Vision-based intelligence, smart error recovery, session memory, advanced web handling\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nimport base64\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\nfrom src.automation.mcp_client import PlaywrightMCPClient\nfrom src.automation.logger import get_logger\nfrom src.automation.vision_analyzer import VisionAnalyzer\nfrom src.automation.session_memory import SessionMemory\nfrom openai import AsyncOpenAI\n\nlogger = get_logger()\n\n\nclass EnhancedMCPAutomation:\n    \"\"\"Enhanced natural language automation with vision, memory, and intelligent error recovery.\"\"\"\n    \n    def __init__(self, api_key: str, enable_vision: bool = True, max_retries: int = 3, screenshots_dir: str = \"screenshots\"):\n        self.client = AsyncOpenAI(api_key=api_key)\n        self.mcp = PlaywrightMCPClient()\n        self.conversation_history = []\n        self.enable_vision = enable_vision\n        self.vision_analyzer = VisionAnalyzer(api_key) if enable_vision else None\n        self.session_memory = SessionMemory()\n        self.max_retries = max_retries\n        self.screenshot_count = 0\n        self.screenshots_dir = screenshots_dir\n    \n    async def initialize(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"Initialize MCP connection.\"\"\"\n        # Create screenshots folder if it doesn't exist\n        Path(self.screenshots_dir).mkdir(parents=True, exist_ok=True)\n        logger.info(f\"Created screenshots folder: {self.screenshots_dir}\")\n        \n        await self.mcp.connect(browser=browser, headless=headless)\n        logger.success(\"Enhanced MCP automation initialized with vision and memory!\")\n    \n    async def _take_screenshot(self, context: str = \"debug\") -> Optional[str]:\n        \"\"\"Take a screenshot and return base64 encoded image.\"\"\"\n        try:\n            self.screenshot_count += 1\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            screenshot_path = f\"screenshots/mcp_{context}_{timestamp}_{self.screenshot_count}.png\"\n            \n            result = await self.mcp.call_tool(\"browser_take_screenshot\", {\"path\": screenshot_path})\n            \n            if Path(screenshot_path).exists():\n                with open(screenshot_path, \"rb\") as f:\n                    return base64.b64encode(f.read()).decode()\n            return None\n        except Exception as e:\n            logger.error(f\"Screenshot failed: {e}\")\n            return None\n    \n    async def _analyze_page_with_vision(self, instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Use vision to analyze the page and get better selectors.\"\"\"\n        if not self.vision_analyzer:\n            return None\n        \n        try:\n            screenshot_b64 = await self._take_screenshot(\"vision_analysis\")\n            if not screenshot_b64:\n                return None\n            \n            analysis = await self.vision_analyzer.analyze_page(screenshot_b64, instruction)\n            logger.info(f\"Vision analysis: {analysis}\")\n            return analysis\n        except Exception as e:\n            logger.error(f\"Vision analysis failed: {e}\")\n            return None\n    \n    async def _get_page_context(self) -> str:\n        \"\"\"Get current page context for better decision making.\"\"\"\n        try:\n            snapshot = await self.mcp.call_tool(\"browser_snapshot\", {})\n            if isinstance(snapshot, str):\n                return snapshot[:5000]  # Limit size\n            return \"\"\n        except Exception as e:\n            logger.error(f\"Failed to get page context: {e}\")\n            return \"\"\n    \n    async def _get_page_elements_catalog(self) -> Dict[str, List[Dict[str, str]]]:\n        \"\"\"Get catalog of interactive elements on the page for smart retries.\"\"\"\n        try:\n            js_code = \"\"\"\n            (function() {\n                const elements = {\n                    buttons: [],\n                    links: [],\n                    inputs: [],\n                    selects: []\n                };\n                \n                // Catalog buttons\n                document.querySelectorAll('button, input[type=\"submit\"], input[type=\"button\"]').forEach(el => {\n                    elements.buttons.push({\n                        text: (el.innerText || el.value || '').trim().substring(0, 50),\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || '',\n                        type: el.type || 'button'\n                    });\n                });\n                \n                // Catalog links\n                document.querySelectorAll('a[href]').forEach(el => {\n                    elements.links.push({\n                        text: (el.innerText || '').trim().substring(0, 50),\n                        href: el.href || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog inputs\n                document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], input[type=\"search\"], textarea').forEach(el => {\n                    elements.inputs.push({\n                        type: el.type || 'text',\n                        placeholder: el.placeholder || '',\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog selects\n                document.querySelectorAll('select').forEach(el => {\n                    elements.selects.push({\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                return elements;\n            })()\n            \"\"\"\n            result = await self.mcp.evaluate(js_code)\n            return result if isinstance(result, dict) else {}\n        except Exception as e:\n            logger.debug(f\"Could not get elements catalog: {e}\")\n            return {}\n    \n    async def _smart_retry_with_vision(self, tool_name: str, tool_args: Dict[str, Any], error: str, instruction: str) -> Any:\n        \"\"\"Retry failed action with vision-based correction and intelligent catalog matching.\"\"\"\n        logger.info(f\"Attempting smart retry for {tool_name} using vision and element catalog...\")\n        \n        # Strategy 1: Vision-based selector correction (PRIMARY)\n        vision_analysis = await self._analyze_page_with_vision(instruction)\n        \n        if vision_analysis and vision_analysis.get(\"suggested_selector\"):\n            new_selector = vision_analysis[\"suggested_selector\"]\n            logger.info(f\"Vision suggests selector: {new_selector}\")\n            \n            if \"selector\" in tool_args:\n                tool_args[\"selector\"] = new_selector\n                try:\n                    return await self.mcp.call_tool(tool_name, tool_args)\n                except Exception as e:\n                    logger.debug(f\"Vision selector failed: {e}\")\n        \n        # Strategy 2: Use element catalog based on TOOL TYPE\n        elements_catalog = await self._get_page_elements_catalog()\n        original_selector = tool_args.get(\"selector\", \"\")\n        \n        # Extract keywords from both instruction and original selector\n        search_keywords = set(instruction.lower().split() + original_selector.lower().split())\n        \n        # Determine element type from tool name\n        if tool_name in [\"browser_click\"]:\n            # Try buttons first, then links\n            logger.info(\"Retrying click action - searching buttons and links\")\n            \n            for btn in elements_catalog.get(\"buttons\", []):\n                if btn.get(\"text\") and any(word in btn[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={btn['text']}\", f\"role=button[name=/{btn['text']}/i]\"]\n                    if btn.get(\"id\"):\n                        selectors.append(f\"#{btn['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying button selector: {sel}\")\n                            return await self.mcp.call_tool(tool_name, tool_args)\n                        except:\n                            continue\n            \n            for link in elements_catalog.get(\"links\", []):\n                if link.get(\"text\") and any(word in link[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={link['text']}\", f\"role=link[name=/{link['text']}/i]\"]\n                    if link.get(\"id\"):\n                        selectors.append(f\"#{link['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying link selector: {sel}\")\n                            return await self.mcp.call_tool(tool_name, tool_args)\n                        except:\n                            continue\n        \n        elif tool_name in [\"browser_type\", \"browser_fill_form\"]:\n            # Looking for input fields\n            logger.info(\"Retrying fill/type action - searching inputs\")\n            \n            for inp in elements_catalog.get(\"inputs\", []):\n                selectors = []\n                # Match by placeholder, name, or keywords\n                if inp.get(\"placeholder\") and any(word in inp[\"placeholder\"].lower() for word in search_keywords):\n                    selectors.append(f\"[placeholder*='{inp['placeholder']}']\")\n                if inp.get(\"name\"):\n                    selectors.append(f\"[name='{inp['name']}']\")\n                    # Also try text matching on name\n                    if any(word in inp[\"name\"].lower() for word in search_keywords):\n                        selectors.insert(0, f\"[name='{inp['name']}']\")\n                if inp.get(\"id\"):\n                    selectors.append(f\"#{inp['id']}\")\n                if inp.get(\"ariaLabel\") and any(word in inp[\"ariaLabel\"].lower() for word in search_keywords):\n                    selectors.insert(0, f\"[aria-label='{inp['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying input selector: {sel}\")\n                        return await self.mcp.call_tool(tool_name, tool_args)\n                    except:\n                        continue\n        \n        elif tool_name in [\"browser_select_option\"]:\n            # Looking for select elements\n            logger.info(\"Retrying select action - searching selects\")\n            \n            for sel_elem in elements_catalog.get(\"selects\", []):\n                selectors = []\n                if sel_elem.get(\"name\"):\n                    selectors.append(f\"[name='{sel_elem['name']}']\")\n                if sel_elem.get(\"id\"):\n                    selectors.append(f\"#{sel_elem['id']}\")\n                if sel_elem.get(\"ariaLabel\"):\n                    selectors.append(f\"[aria-label='{sel_elem['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying select selector: {sel}\")\n                        return await self.mcp.call_tool(tool_name, tool_args)\n                    except:\n                        continue\n        \n        else:\n            # For other tools, try generic matching\n            logger.info(f\"Retrying {tool_name} - trying generic element matching\")\n            all_elements = (\n                elements_catalog.get(\"buttons\", []) + \n                elements_catalog.get(\"links\", []) + \n                elements_catalog.get(\"inputs\", [])\n            )\n            \n            for elem in all_elements:\n                if elem.get(\"id\") and any(word in elem[\"id\"].lower() for word in search_keywords):\n                    tool_args[\"selector\"] = f\"#{elem['id']}\"\n                    try:\n                        return await self.mcp.call_tool(tool_name, tool_args)\n                    except:\n                        continue\n        \n        raise Exception(f\"All vision and element catalog strategies exhausted for {tool_name}\")\n    \n    async def execute_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language command using AI + MCP with enhanced capabilities.\n        \n        Args:\n            command: Natural language instruction\n            \n        Returns:\n            Dict with status, summary, and continuation info\n        \"\"\"\n        logger.info(f\"Processing command: {command}\")\n        \n        # Check session memory for similar successful patterns\n        similar_patterns = self.session_memory.get_similar_patterns(command)\n        memory_context = self.session_memory.get_context_for_instruction(command)\n        if similar_patterns:\n            logger.info(f\"Found {len(similar_patterns)} similar patterns from memory\")\n        \n        # Get page context for better decisions\n        page_context = await self._get_page_context()\n        \n        # Get available MCP tools\n        tools = self.mcp.get_available_tools()\n        \n        # Format tools for OpenAI\n        openai_tools: list = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool[\"description\"],\n                    \"parameters\": tool[\"input_schema\"]\n                }\n            }\n            for tool in tools\n        ]\n        \n        # Enhanced system prompt with context\n        system_prompt = f\"\"\"You are an advanced browser automation assistant using Playwright MCP tools.\n\nCAPABILITIES:\n- 21+ Playwright MCP tools for comprehensive browser control\n- Vision-based page analysis for difficult elements\n- Smart element detection with multiple fallback strategies\n- Session memory to learn from past successes\n- Handles complex scenarios: forms, tables, dynamic content, iframes, popups\n\nSTRATEGY:\n1. Break complex tasks into logical steps\n2. Use browser_snapshot first to understand page structure\n3. For element interactions, try multiple selector strategies:\n   - CSS selectors (.class, #id)\n   - Text selectors (text=Login)\n   - Role selectors (role=button)\n   - Placeholder/label selectors\n4. For data extraction, use browser_evaluate with JavaScript\n5. Wait for elements with browser_wait_for when needed\n6. Handle forms with browser_fill_form for efficiency\n7. Screenshots are automatically saved to screenshots/ folder with unique timestamped names\n\nCURRENT PAGE CONTEXT:\n{page_context[:1000] if page_context else 'No context available'}\n\nMEMORY:\n{memory_context if memory_context else 'No similar patterns found'}\n\nExecute the user's command intelligently, adapting to any website structure.\"\"\"\n\n        # Add to conversation history\n        self.conversation_history.append({\n            \"role\": \"user\",\n            \"content\": command\n        })\n        \n        # Call OpenAI to determine which tools to use\n        response = await self.client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                *self.conversation_history\n            ],\n            tools=openai_tools,\n            tool_choice=\"auto\",\n            temperature=0.3  # Lower temperature for more consistent automation\n        )\n        \n        message = response.choices[0].message\n        results = []\n        tool_execution_log = []\n        \n        # Execute tool calls with smart retry\n        if message.tool_calls:\n            for tool_call in message.tool_calls:\n                if hasattr(tool_call, 'function'):\n                    tool_name = tool_call.function.name  # type: ignore\n                    try:\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                    except json.JSONDecodeError as e:\n                        logger.error(f\"Failed to parse tool arguments: {e}\")\n                        continue\n                else:\n                    continue\n                \n                logger.info(f\"Executing: {tool_name}({tool_args})\")\n                \n                # Ensure screenshots go to screenshots folder with unique names\n                if tool_name == \"browser_take_screenshot\":\n                    self.screenshot_count += 1\n                    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                    filename = tool_args.get(\"filename\", f\"screenshot_{timestamp}_{self.screenshot_count}.png\")\n                    # Ensure it's saved in screenshots folder\n                    if not filename.startswith(f\"{self.screenshots_dir}/\"):\n                        filename = f\"{self.screenshots_dir}/{filename}\"\n                    tool_args[\"path\"] = filename\n                    logger.info(f\"Screenshot will be saved to: {filename}\")\n                \n                # Try executing with retries\n                retry_count = 0\n                while retry_count < self.max_retries:\n                    try:\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        results.append(f\"âœ“ {tool_name}: {result}\")\n                        \n                        # Log successful execution\n                        tool_execution_log.append({\n                            \"tool\": tool_name,\n                            \"args\": tool_args,\n                            \"success\": True\n                        })\n                        \n                        # Add tool result to conversation\n                        self.conversation_history.append({\n                            \"role\": \"assistant\",\n                            \"content\": None,\n                            \"tool_calls\": [tool_call]\n                        })\n                        self.conversation_history.append({\n                            \"role\": \"tool\",\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": str(result)\n                        })\n                        \n                        # Auto-refresh DOM context after navigation\n                        if tool_name in [\"browser_navigate\", \"browser_navigate_back\", \"browser_navigate_forward\"]:\n                            await asyncio.sleep(1)  # Give page time to load\n                            fresh_context = await self._get_page_context()\n                            if fresh_context:\n                                logger.info(f\"ðŸ“Š Refreshed DOM context after navigation\")\n                                # Update conversation with fresh context\n                                self.conversation_history.append({\n                                    \"role\": \"system\",\n                                    \"content\": f\"Page context updated after navigation: {fresh_context[:500]}\"\n                                })\n                        \n                        # Inform AI about screenshot location\n                        if tool_name == \"browser_take_screenshot\":\n                            screenshot_path = tool_args.get(\"path\", \"unknown\")\n                            self.conversation_history.append({\n                                \"role\": \"system\",\n                                \"content\": f\"Screenshot saved to: {screenshot_path}\"\n                            })\n                            logger.success(f\"ðŸ“¸ Screenshot saved to: {screenshot_path}\")\n                        \n                        break  # Success, exit retry loop\n                        \n                    except Exception as e:\n                        retry_count += 1\n                        error_msg = f\"âœ— {tool_name} failed (attempt {retry_count}/{self.max_retries}): {e}\"\n                        logger.warning(error_msg)\n                        \n                        if retry_count < self.max_retries:\n                            # Try smart retry with vision\n                            try:\n                                result = await self._smart_retry_with_vision(tool_name, tool_args.copy(), str(e), command)\n                                results.append(f\"âœ“ {tool_name} (retry): {result}\")\n                                \n                                # Log successful retry\n                                tool_execution_log.append({\n                                    \"tool\": tool_name,\n                                    \"args\": tool_args,\n                                    \"success\": True,\n                                    \"retry\": True\n                                })\n                                \n                                break\n                            except Exception as retry_error:\n                                if retry_count == self.max_retries - 1:\n                                    results.append(error_msg)\n                                    tool_execution_log.append({\n                                        \"tool\": tool_name,\n                                        \"args\": tool_args,\n                                        \"success\": False,\n                                        \"error\": str(retry_error)\n                                    })\n                        else:\n                            results.append(error_msg)\n                            tool_execution_log.append({\n                                \"tool\": tool_name,\n                                \"args\": tool_args,\n                                \"success\": False,\n                                \"error\": str(e)\n                            })\n        \n        # Save execution to memory\n        success = any(log[\"success\"] for log in tool_execution_log)\n        error_msg = None\n        if not success:\n            failed_logs = [log for log in tool_execution_log if not log[\"success\"]]\n            if failed_logs:\n                error_msg = failed_logs[0].get(\"error\", \"Unknown error\")\n        \n        self.session_memory.record_execution(\n            instruction=command,\n            success=success,\n            steps=tool_execution_log,\n            error=error_msg\n        )\n        \n        # Determine if we need to continue autonomously or ask user\n        if results:\n            # Ask AI if task is complete or needs more steps\n            decision_response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": f\"\"\"Analyze the ORIGINAL user request against what has been accomplished so far.\n\nORIGINAL REQUEST: \"{command}\"\n\nCompare this against the conversation history to determine if ALL parts of the request are complete.\n\nRespond with JSON:\n{{\n  \"status\": \"complete\" | \"continue\",\n  \"summary\": \"brief summary of current progress\",\n  \"next_action\": \"specific next command to execute (required if status is continue)\"\n}}\n\nRules:\n- Use \"continue\" if ANY part of the original request is incomplete\n- Use \"complete\" ONLY when every part of the request is fully done\n- When continuing, next_action must be a specific command, not a description\n- Execute ALL steps of the request autonomously without asking user\n\nExamples:\n- Request: \"open google and search for dogs\" â†’ Opened Google â†’ status: \"continue\", next_action: \"search for dogs\"\n- Request: \"navigate to github.com and take screenshot\" â†’ Navigated â†’ status: \"continue\", next_action: \"take screenshot\"  \n- Request: \"search for cars\" â†’ Already searched and on results â†’ status: \"complete\"\n\nDO NOT ask the user to continue - execute next steps autonomously.\"\"\"\n                    },\n                    *self.conversation_history\n                ],\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            try:\n                decision = json.loads(decision_response.choices[0].message.content or \"{}\")\n                status = decision.get(\"status\", \"complete\")\n                summary = decision.get(\"summary\", \"Task completed\")\n                next_action = decision.get(\"next_action\")\n                \n                logger.success(f\"Status: {status} - {summary}\")\n                \n                # Return result with continuation info\n                return {\n                    \"status\": status,\n                    \"summary\": summary,\n                    \"next_action\": next_action,\n                    \"should_continue\": status == \"continue\"\n                }\n            except:\n                # Fallback to simple summary\n                return {\n                    \"status\": \"complete\",\n                    \"summary\": \"Task completed\",\n                    \"should_continue\": False\n                }\n        else:\n            return {\n                \"status\": \"complete\", \n                \"summary\": message.content or \"Command executed\",\n                \"should_continue\": False\n            }\n    \n    async def cleanup(self):\n        \"\"\"Clean up resources.\"\"\"\n        await self.mcp.close()\n        logger.info(\"MCP automation cleaned up successfully\")\n\n\nasync def main():\n    \"\"\"Main entry point for enhanced MCP automation.\"\"\"\n    from src.automation.config_loader import get_config\n    \n    # Load configuration from config.ini\n    config = get_config()\n    \n    # Get OpenAI API key from config\n    api_key = config.openai_api_key\n    if not api_key:\n        logger.error(\"OPENAI_API_KEY not set in config.ini or environment!\")\n        logger.error(\"Please set it in config.ini or as an environment variable\")\n        sys.exit(1)\n    \n    # Display configuration banner\n    print(\"\\n\" + \"=\"*70)\n    print(\"ðŸš€ ENHANCED Playwright MCP Natural Language Automation\")\n    print(\"=\"*70)\n    print(\"\\nConfiguration:\")\n    print(f\"  â€¢ Config file: config.ini\")\n    print(f\"  â€¢ AI Model: {config.openai_model}\")\n    print(f\"  â€¢ Browser: {config.browser_type} (headless: {config.browser_headless})\")\n    print(f\"  â€¢ Vision: {'Enabled' if config.enable_vision else 'Disabled'}\")\n    print(f\"  â€¢ Screenshots: {config.screenshots_dir}/\")\n    print(f\"  â€¢ Max Retries: {config.max_retries}\")\n    print(\"\\nFeatures:\")\n    print(\"  âœ“ Vision-based intelligent page analysis\")\n    print(\"  âœ“ Smart error recovery with automatic retries\")\n    print(\"  âœ“ Session memory learns from successful patterns\")\n    print(\"  âœ“ Advanced web handling (forms, tables, iframes, dynamic content)\")\n    print(\"  âœ“ Multi-strategy element detection\")\n    print(\"  âœ“ Auto-refresh DOM context after navigation\")\n    print(\"  âœ“ Autonomous multi-step execution without interruptions\")\n    print(f\"  âœ“ Screenshots automatically saved to {config.screenshots_dir}/ folder\")\n    print(\"=\"*70)\n    \n    # Create automation instance with config settings\n    automation = EnhancedMCPAutomation(\n        api_key=api_key,\n        enable_vision=config.enable_vision,\n        max_retries=config.max_retries,\n        screenshots_dir=config.screenshots_dir\n    )\n    \n    try:\n        # Initialize MCP\n        logger.info(\"Initializing Enhanced Playwright MCP server...\")\n        await automation.initialize(\n            browser=config.browser_type,\n            headless=config.browser_headless\n        )\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"ðŸ’¡ POWERFUL AUTOMATION EXAMPLES:\")\n        print(\"=\"*70)\n        print(\"\\nðŸŒ Navigation & Search:\")\n        print(\"  â€¢ Go to google.com and search for Python tutorials\")\n        print(\"  â€¢ Navigate to news.ycombinator.com and get top 5 stories\")\n        print(\"  â€¢ Visit github.com and click on the trending repositories\")\n        \n        print(\"\\nðŸ“ Forms & Data Entry:\")\n        print(\"  â€¢ Fill out the contact form with name John and email john@example.com\")\n        print(\"  â€¢ Search for apartments in New York on realtor.com\")\n        print(\"  â€¢ Login with username testuser and password testpass\")\n        \n        print(\"\\nðŸ“Š Data Extraction:\")\n        print(\"  â€¢ Extract all product names and prices from this page\")\n        print(\"  â€¢ Get all the article headlines from this news site\")\n        print(\"  â€¢ Scrape the table data and export it\")\n        \n        print(\"\\nðŸ”§ Complex Tasks:\")\n        print(\"  â€¢ Take a screenshot of the current page\")\n        print(\"  â€¢ Click all 'Accept' buttons on this page\")\n        print(\"  â€¢ Navigate through the pagination and collect all items\")\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"Type 'quit', 'exit', or 'q' to stop.\\n\")\n        \n        # Interactive mode with autonomous continuation\n        while True:\n            try:\n                command = input(\"ðŸ’¬ Command: \").strip()\n                \n                if command.lower() in ['quit', 'exit', 'q']:\n                    print(\"\\nðŸ‘‹ Goodbye!\")\n                    break\n                \n                if not command:\n                    continue\n                \n                # Execute command and check if we should continue autonomously\n                while True:\n                    result = await automation.execute_command(command)\n                    \n                    # Handle result (could be string or dict)\n                    if isinstance(result, dict):\n                        summary = result.get(\"summary\", \"\")\n                        should_continue = result.get(\"should_continue\", False)\n                        next_action = result.get(\"next_action\")\n                        \n                        # Show progress without interrupting\n                        if should_continue and next_action:\n                            print(f\"  âš¡ {summary}\")\n                            command = next_action  # Continue with next action\n                            await asyncio.sleep(0.5)  # Brief pause\n                        else:\n                            print(f\"\\nâœ… {summary}\\n\")\n                            break\n                    else:\n                        print(f\"\\nâœ… {result}\\n\")\n                        break\n                \n            except KeyboardInterrupt:\n                print(\"\\n\\nðŸ‘‹ Interrupted. Goodbye!\")\n                break\n            except Exception as e:\n                logger.error(f\"Error: {e}\")\n                print(f\"\\nâŒ Error: {e}\\n\")\n    \n    finally:\n        await automation.cleanup()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":30796},"src/automation/mcp_client.py":{"content":"import asyncio\nimport os\nfrom contextlib import AsyncExitStack\nfrom typing import Optional, Dict, Any, List\nimport json\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass PlaywrightMCPClient:\n    \"\"\"\n    Client for communicating with Playwright MCP server.\n    Provides browser automation capabilities via Model Context Protocol.\n    \"\"\"\n    \n    def __init__(self):\n        self.session: Optional[ClientSession] = None\n        self.exit_stack = AsyncExitStack()\n        self.tools: List[Dict[str, Any]] = []\n        \n    async def connect(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"\n        Connect to Playwright MCP server.\n        \n        Args:\n            browser: Browser type (chromium, firefox, webkit)\n            headless: Whether to run in headless mode\n        \"\"\"\n        try:\n            logger.info(f\"Connecting to Playwright MCP server (browser={browser}, headless={headless})\")\n            \n            # Set up environment for npx command (fix NixOS env issues)\n            env = os.environ.copy()\n            env.setdefault(\"XDG_CONFIG_HOME\", os.path.expanduser(\"~/.config\"))\n            env.setdefault(\"XDG_DATA_HOME\", os.path.expanduser(\"~/.local/share\"))\n            env.setdefault(\"XDG_CACHE_HOME\", os.path.expanduser(\"~/.cache\"))\n            \n            # Build args (only add --headless if headless mode is enabled)\n            args = [\"@playwright/mcp@latest\", \"--browser\", browser]\n            if headless:\n                args.append(\"--headless\")\n            \n            server_params = StdioServerParameters(\n                command=\"npx\",\n                args=args,\n                env=env\n            )\n            \n            stdio_transport = await self.exit_stack.enter_async_context(\n                stdio_client(server_params)\n            )\n            read_stream, write_stream = stdio_transport\n            \n            self.session = await self.exit_stack.enter_async_context(\n                ClientSession(read_stream, write_stream)\n            )\n            \n            await self.session.initialize()\n            \n            response = await self.session.list_tools()\n            self.tools = [\n                {\n                    \"name\": tool.name,\n                    \"description\": tool.description,\n                    \"input_schema\": tool.inputSchema\n                }\n                for tool in response.tools\n            ]\n            \n            logger.success(f\"Connected to Playwright MCP! Available tools: {[t['name'] for t in self.tools]}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to connect to Playwright MCP: {e}\")\n            raise\n    \n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:\n        \"\"\"\n        Call a Playwright MCP tool.\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Tool arguments\n            \n        Returns:\n            Tool result\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(\"Not connected to MCP server. Call connect() first.\")\n        \n        try:\n            logger.info(f\"Calling MCP tool: {tool_name} with args: {arguments}\")\n            \n            result = await self.session.call_tool(tool_name, arguments)\n            \n            if result.content:\n                content = result.content[0]\n                if hasattr(content, 'text'):\n                    return_value = content.text\n                    try:\n                        return_value = json.loads(return_value)\n                    except json.JSONDecodeError:\n                        pass\n                    logger.success(f\"Tool {tool_name} completed successfully\")\n                    return return_value\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Tool {tool_name} failed: {e}\")\n            raise\n    \n    async def navigate(self, url: str) -> Dict[str, Any]:\n        \"\"\"Navigate to a URL.\"\"\"\n        return await self.call_tool(\"browser_navigate\", {\"url\": url})\n    \n    async def click(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Click an element.\"\"\"\n        return await self.call_tool(\"browser_click\", {\"selector\": selector})\n    \n    async def fill(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Fill an input field.\"\"\"\n        return await self.call_tool(\"browser_fill_form\", {\n            \"selector\": selector,\n            \"value\": value\n        })\n    \n    async def screenshot(self, path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Take a screenshot.\"\"\"\n        args = {}\n        if path:\n            args[\"path\"] = path\n        return await self.call_tool(\"browser_take_screenshot\", args)\n    \n    async def evaluate(self, expression: str) -> Any:\n        \"\"\"Execute JavaScript in the browser.\"\"\"\n        return await self.call_tool(\"browser_evaluate\", {\"expression\": expression})\n    \n    async def get_page_content(self) -> str:\n        \"\"\"Get the current page HTML content.\"\"\"\n        result = await self.call_tool(\"browser_snapshot\", {})\n        return result if isinstance(result, str) else \"\"\n    \n    async def extract_text(self, selector: str) -> str:\n        \"\"\"Extract text from an element using JavaScript.\"\"\"\n        js_code = f\"document.querySelector('{selector}')?.innerText || ''\"\n        result = await self.evaluate(js_code)\n        return str(result) if result else \"\"\n    \n    async def extract_all_text(self, selector: str) -> List[str]:\n        \"\"\"Extract text from multiple elements.\"\"\"\n        js_code = f\"Array.from(document.querySelectorAll('{selector}')).map(el => el.innerText)\"\n        result = await self.evaluate(js_code)\n        return result if isinstance(result, list) else []\n    \n    async def wait_for_selector(self, selector: str, timeout: int = 30000) -> Dict[str, Any]:\n        \"\"\"Wait for a selector to appear on the page.\"\"\"\n        return await self.call_tool(\"browser_wait_for\", {\n            \"selector\": selector,\n            \"timeout\": timeout\n        })\n    \n    async def type_text(self, selector: str, text: str, delay: int = 50) -> Dict[str, Any]:\n        \"\"\"Type text into an element with delay between keystrokes.\"\"\"\n        return await self.call_tool(\"browser_type\", {\n            \"selector\": selector,\n            \"text\": text,\n            \"delay\": delay\n        })\n    \n    async def select_dropdown(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Select a dropdown option.\"\"\"\n        return await self.call_tool(\"browser_select_option\", {\n            \"selector\": selector,\n            \"value\": value\n        })\n    \n    async def hover(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Hover over an element.\"\"\"\n        return await self.call_tool(\"browser_hover\", {\"selector\": selector})\n    \n    async def press_key(self, key: str) -> Dict[str, Any]:\n        \"\"\"Press a keyboard key.\"\"\"\n        return await self.call_tool(\"browser_press_key\", {\"key\": key})\n    \n    async def get_console_messages(self) -> List[str]:\n        \"\"\"Get browser console messages.\"\"\"\n        result = await self.call_tool(\"browser_console_messages\", {})\n        return result if isinstance(result, list) else []\n    \n    async def get_network_requests(self) -> List[Dict[str, Any]]:\n        \"\"\"Get network requests made by the page.\"\"\"\n        result = await self.call_tool(\"browser_network_requests\", {})\n        return result if isinstance(result, list) else []\n    \n    async def upload_file(self, selector: str, file_path: str) -> Dict[str, Any]:\n        \"\"\"Upload a file to an input element.\"\"\"\n        return await self.call_tool(\"browser_file_upload\", {\n            \"selector\": selector,\n            \"filePath\": file_path\n        })\n    \n    async def handle_dialog(self, action: str = \"accept\", text: str = \"\") -> Dict[str, Any]:\n        \"\"\"Handle browser dialog (alert, confirm, prompt).\"\"\"\n        args: Dict[str, Any] = {\"action\": action}\n        if text:\n            args[\"text\"] = text\n        return await self.call_tool(\"browser_handle_dialog\", args)\n    \n    async def go_back(self) -> Dict[str, Any]:\n        \"\"\"Navigate back in browser history.\"\"\"\n        return await self.call_tool(\"browser_navigate_back\", {})\n    \n    async def resize_viewport(self, width: int, height: int) -> Dict[str, Any]:\n        \"\"\"Resize browser viewport.\"\"\"\n        return await self.call_tool(\"browser_resize\", {\n            \"width\": width,\n            \"height\": height\n        })\n    \n    async def get_tabs(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of open browser tabs.\"\"\"\n        result = await self.call_tool(\"browser_tabs\", {})\n        return result if isinstance(result, list) else []\n    \n    async def close_browser(self) -> Dict[str, Any]:\n        \"\"\"Close the browser.\"\"\"\n        return await self.call_tool(\"browser_close\", {})\n    \n    async def close(self):\n        \"\"\"Close the MCP client connection.\"\"\"\n        try:\n            await self.exit_stack.aclose()\n            logger.info(\"MCP client connection closed\")\n        except Exception as e:\n            logger.error(f\"Error closing MCP client: {e}\")\n    \n    def get_available_tools(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of available MCP tools.\"\"\"\n        return self.tools\n","size_bytes":9367},".local/state/replit/agent/progress_tracker.md":{"content":"[x] 1. Install the required packages\n[x] 2. Install Playwright browser (chromium)\n[x] 3. Set up workflow to run nl_automation.py\n[x] 4. Configure OpenAI API key for AI features\n[x] 5. Install system dependencies for Playwright\n[x] 6. Test the project is working - VERIFIED âœ…\n[x] 7. Enhanced with natural language automation feature\n[x] 8. Updated documentation and README\n[x] 9. Fixed smart selector issue - now excludes submit buttons from input search\n[x] 10. Enhanced search selector to include Google-specific patterns (name=\"q\")\n[x] 11. Fixed DOM analysis timing - now refreshes page context AFTER navigation\n[x] 12. Import completed successfully - ALL SYSTEMS OPERATIONAL ðŸš€\n[x] 13. Fixed VisionAnalyzer import error - class now properly defined\n[x] 14. Verified workflow configuration - ready for use with OPENAI_API_KEY\n[x] 15. OpenAI API key configured successfully via Replit Secrets\n[x] 16. Switched from MCP to direct Playwright automation (simpler, no Node.js required)\n[x] 17. Installed Playwright Chromium browser successfully\n[x] 18. Workflow running perfectly - browser started and ready for commands\n[x] 19. **IMPORT COMPLETE - ALL SYSTEMS FULLY OPERATIONAL** âœ…ðŸš€\n[x] 20. Node.js 20 installed with npx support\n[x] 21. Playwright MCP package (@playwright/mcp) installed successfully\n[x] 22. MCP automation workflow configured and running\n[x] 23. **MCP VERSION NOW ACTIVE - ENHANCED FEATURES ENABLED** ðŸš€âœ¨\n[x] 24. Updated to use GPT-4o-mini for cost-efficient automation\n[x] 25. OpenAI API key securely configured via Replit Secrets (not .env for security)\n[x] 26. Workflow verified running successfully with API key access\n[x] 27. **PROJECT IMPORT FULLY COMPLETE - READY TO USE** âœ…ðŸŽ‰\n[x] 28. Created comprehensive SETUP.md guide for local installation\n[x] 29. Created requirements.txt for easy Python dependency installation\n[x] 30. **ALL DOCUMENTATION COMPLETE - PROJECT READY FOR LOCAL & REPLIT USE** ðŸš€ðŸ“š\n","size_bytes":1945},"SETUP.md":{"content":"# ðŸš€ Local Setup Guide\n\nComplete guide to set up and run the Browser Automation Framework on your local machine.\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed:\n\n1. **Python 3.11 or higher**\n   - Download from: https://www.python.org/downloads/\n   - Verify: `python --version` or `python3 --version`\n\n2. **Node.js 18 or higher** (required for Playwright MCP)\n   - Download from: https://nodejs.org/\n   - Verify: `node --version`\n\n3. **uv (Python package installer)** - Recommended\n   - Install: `pip install uv`\n   - Or use pip/pip3 instead\n\n4. **Git** (to clone the repository)\n   - Download from: https://git-scm.com/\n\n## Installation Steps\n\n### 1. Clone or Download the Project\n\n```bash\n# If using git\ngit clone <your-repository-url>\ncd <project-directory>\n\n# Or download and extract the ZIP file\n```\n\n### 2. Install Python Dependencies\n\n**Option A: Using uv (Recommended - Faster)**\n```bash\n# Install uv if you haven't\npip install uv\n\n# Install Python dependencies\nuv pip install -r requirements.txt\n```\n\n**Option B: Using pip**\n```bash\n# Create virtual environment (optional but recommended)\npython -m venv venv\n\n# Activate virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n```\n\nIf `requirements.txt` doesn't exist, install manually:\n```bash\npip install mcp>=1.18.0 openai>=2.4.0 playwright>=1.55.0 pydantic>=2.12.2 python-dotenv>=1.1.1 rich>=14.2.0 tenacity>=9.1.2\n```\n\n### 3. Install Node.js Dependencies (for MCP)\n\n```bash\nnpm install\n```\n\nThis installs the Playwright MCP package (`@playwright/mcp`).\n\n### 4. Install Playwright Browsers\n\n```bash\n# Install Chromium browser\npython -m playwright install chromium\n\n# Or install all browsers (chromium, firefox, webkit)\npython -m playwright install\n\n# Install system dependencies (may require sudo on Linux)\n# On Ubuntu/Debian:\nsudo python -m playwright install-deps\n\n# On macOS (using Homebrew):\n# Dependencies usually install automatically\n```\n\n### 5. Set Up Environment Variables\n\nCreate a `.env` file in the project root:\n\n```bash\n# Create .env file\ntouch .env\n```\n\nAdd your OpenAI API key to `.env`:\n\n```bash\n# OpenAI API Configuration (REQUIRED)\nOPENAI_API_KEY=your-actual-api-key-here\n\n# Browser Configuration (Optional)\nBROWSER_TYPE=chromium\nHEADLESS=true\nTIMEOUT=30000\nMAX_RETRIES=3\n\n# Logging Configuration (Optional)\nLOG_LEVEL=INFO\n```\n\n**Get your OpenAI API Key:**\n1. Go to https://platform.openai.com/api-keys\n2. Create a new API key\n3. Copy it to the `.env` file\n\n### 6. Create Required Directories\n\n```bash\n# Create directories for screenshots and sessions\nmkdir -p screenshots sessions cookies\n```\n\n## Running the Project\n\n### ðŸŒŸ Enhanced MCP-Powered Automation (Recommended)\n\nThe most powerful way - uses Playwright MCP with AI:\n\n```bash\n# Using uv\nuv run python nl_automation_mcp.py\n\n# Using python directly\npython nl_automation_mcp.py\n```\n\n**What you'll see:**\n1. Prompt to enable vision mode (recommended: `y`)\n2. Interactive console to type natural language commands\n3. AI automatically selects tools and executes\n\n**Example commands:**\n- \"Go to google.com and search for Python tutorials\"\n- \"Navigate to news.ycombinator.com and extract top 5 story titles\"\n- \"Fill the contact form with name John and email john@example.com\"\n\n### ðŸŽ¯ Enhanced Natural Language Automation\n\nAlternative automation with vision capabilities:\n\n```bash\npython nl_automation.py\n```\n\n### ðŸŽ® Interactive Demo Menu\n\nTraditional demo with various automation examples:\n\n```bash\npython main.py\n```\n\nChoose from:\n1. Web Automation Demo\n2. Form Automation Demo\n3. Data Extraction Demo\n4. AI Code Generation\n\n### ðŸ“š Run Individual Examples\n\n```bash\n# Web scraping\npython examples/web_scraping_example.py\n\n# Form filling\npython examples/form_filling_example.py\n\n# AI code generation\npython examples/ai_code_generation_example.py\n\n# Advanced automation\npython examples/advanced_automation_example.py\n```\n\n## Troubleshooting\n\n### Issue: Playwright browsers not installed\n```bash\n# Error: \"Executable doesn't exist at...\"\n# Solution:\npython -m playwright install chromium\n```\n\n### Issue: OPENAI_API_KEY not found\n```bash\n# Error: \"OPENAI_API_KEY environment variable not set\"\n# Solution:\n# 1. Verify .env file exists\n# 2. Check API key is set correctly\n# 3. Try exporting directly:\nexport OPENAI_API_KEY='your-key-here'  # macOS/Linux\nset OPENAI_API_KEY=your-key-here       # Windows CMD\n$env:OPENAI_API_KEY='your-key-here'    # Windows PowerShell\n```\n\n### Issue: Module not found errors\n```bash\n# Error: \"ModuleNotFoundError: No module named 'mcp'\"\n# Solution:\npip install --upgrade pip\npip install -r requirements.txt\n# Or install missing module directly:\npip install mcp openai playwright rich\n```\n\n### Issue: Permission errors on Linux/Mac\n```bash\n# Error: Permission denied\n# Solution:\nsudo python -m playwright install-deps\n# Or run Python scripts with appropriate permissions\n```\n\n### Issue: Node.js/npm not found\n```bash\n# Error: \"npm: command not found\"\n# Solution:\n# Install Node.js from https://nodejs.org/\n# Verify installation:\nnode --version\nnpm --version\n```\n\n### Issue: Browser won't start in headless mode\n```bash\n# Solution: Try headed mode\n# Edit .env file:\nHEADLESS=false\n# Or modify code to set headless=False\n```\n\n## Project Structure\n\n```\n.\nâ”œâ”€â”€ src/automation/              # Core automation framework\nâ”‚   â”œâ”€â”€ mcp_client.py           # Playwright MCP client\nâ”‚   â”œâ”€â”€ browser_engine.py       # Browser automation engine\nâ”‚   â”œâ”€â”€ enhanced_nl_executor.py # Enhanced NL automation\nâ”‚   â”œâ”€â”€ vision_analyzer.py      # GPT-4 Vision analysis\nâ”‚   â”œâ”€â”€ session_memory.py       # Learning system\nâ”‚   â”œâ”€â”€ selectors.py            # Smart selector system\nâ”‚   â”œâ”€â”€ task_executor.py        # Task execution\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ examples/                    # Example scripts\nâ”œâ”€â”€ nl_automation_mcp.py        # MCP automation (PRIMARY)\nâ”œâ”€â”€ nl_automation.py            # Enhanced NL automation\nâ”œâ”€â”€ main.py                     # Interactive demo\nâ”œâ”€â”€ .env                        # Environment variables (create this)\nâ”œâ”€â”€ pyproject.toml              # Python dependencies\nâ”œâ”€â”€ package.json                # Node.js dependencies\nâ””â”€â”€ README.md                   # Documentation\n```\n\n## Verification Checklist\n\nBefore running, verify:\n\n- [ ] Python 3.11+ installed: `python --version`\n- [ ] Node.js 18+ installed: `node --version`\n- [ ] Python packages installed: `pip list | grep playwright`\n- [ ] Node packages installed: `npm list`\n- [ ] Playwright browsers installed: `python -m playwright install chromium`\n- [ ] `.env` file created with `OPENAI_API_KEY`\n- [ ] Required directories exist: `screenshots/`, `sessions/`\n\n## Quick Start Command Sequence\n\nCopy-paste these commands for a fresh setup:\n\n```bash\n# 1. Install Python dependencies\npip install uv\nuv pip install mcp openai playwright pydantic python-dotenv rich tenacity\n\n# 2. Install Node.js dependencies\nnpm install\n\n# 3. Install Playwright browsers\npython -m playwright install chromium\n\n# 4. Create .env file\necho \"OPENAI_API_KEY=your-key-here\" > .env\n\n# 5. Create required directories\nmkdir -p screenshots sessions cookies\n\n# 6. Run the MCP automation\npython nl_automation_mcp.py\n```\n\n## Getting Your OpenAI API Key\n\n1. Visit https://platform.openai.com/\n2. Sign up or log in\n3. Go to API Keys section: https://platform.openai.com/api-keys\n4. Click \"Create new secret key\"\n5. Copy the key (you won't see it again!)\n6. Add to `.env` file\n\n## System Requirements\n\n- **OS:** Windows 10/11, macOS 10.15+, or Linux (Ubuntu 20.04+)\n- **RAM:** 4GB minimum, 8GB recommended\n- **Disk Space:** ~500MB for browsers and dependencies\n- **Internet:** Required for AI features and web automation\n\n## Support\n\nFor issues or questions:\n1. Check the Troubleshooting section above\n2. Review the main README.md\n3. Check Playwright docs: https://playwright.dev/\n4. Check OpenAI docs: https://platform.openai.com/docs\n\n---\n\n**Happy Automating! ðŸŽ­âœ¨**\n","size_bytes":8087},"src/automation/config_loader.py":{"content":"\"\"\"\nConfiguration loader for reading from config.ini file\n\"\"\"\nimport configparser\nimport os\nfrom pathlib import Path\nfrom typing import Optional\n\n\nclass ConfigLoader:\n    \"\"\"Load and manage configuration from config.ini file\"\"\"\n    \n    def __init__(self, config_file: str = \"config.ini\"):\n        self.config_file = config_file\n        self.config = configparser.ConfigParser()\n        self._load_config()\n    \n    def _load_config(self):\n        \"\"\"Load configuration from .ini file\"\"\"\n        if not Path(self.config_file).exists():\n            raise FileNotFoundError(f\"Configuration file {self.config_file} not found!\")\n        \n        self.config.read(self.config_file)\n    \n    def _get_value(self, section: str, key: str, fallback: Optional[str] = None) -> Optional[str]:\n        \"\"\"Get a value from config, supporting environment variable substitution\"\"\"\n        value = self.config.get(section, key, fallback=fallback)\n        \n        if value and value.startswith(\"${\") and value.endswith(\"}\"):\n            # Environment variable substitution\n            env_var = value[2:-1]\n            return os.getenv(env_var, fallback)\n        \n        return value\n    \n    def _get_bool(self, section: str, key: str, fallback: bool = False) -> bool:\n        \"\"\"Get a boolean value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        return value.lower() in ('true', 'yes', '1', 'on') if value else fallback\n    \n    def _get_int(self, section: str, key: str, fallback: int = 0) -> int:\n        \"\"\"Get an integer value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        try:\n            return int(value) if value else fallback\n        except ValueError:\n            return fallback\n    \n    # OpenAI Configuration\n    @property\n    def openai_api_key(self) -> Optional[str]:\n        return self._get_value('OpenAI', 'api_key')\n    \n    @property\n    def openai_model(self) -> str:\n        return self._get_value('OpenAI', 'model', 'gpt-4o-mini') or 'gpt-4o-mini'\n    \n    # Browser Configuration\n    @property\n    def browser_type(self) -> str:\n        return self._get_value('Browser', 'browser_type', 'chromium') or 'chromium'\n    \n    @property\n    def browser_headless(self) -> bool:\n        return self._get_bool('Browser', 'headless', False)\n    \n    @property\n    def browser_timeout(self) -> int:\n        return self._get_int('Browser', 'timeout', 30000)\n    \n    @property\n    def screenshot_on_error(self) -> bool:\n        return self._get_bool('Browser', 'screenshot_on_error', True)\n    \n    # Automation Configuration\n    @property\n    def max_retries(self) -> int:\n        return self._get_int('Automation', 'max_retries', 3)\n    \n    @property\n    def retry_delay(self) -> int:\n        return self._get_int('Automation', 'retry_delay', 2)\n    \n    @property\n    def log_level(self) -> str:\n        return self._get_value('Automation', 'log_level', 'INFO') or 'INFO'\n    \n    @property\n    def enable_vision(self) -> bool:\n        return self._get_bool('Automation', 'enable_vision', True)\n    \n    # Paths Configuration\n    @property\n    def screenshots_dir(self) -> str:\n        return self._get_value('Paths', 'screenshots_dir', 'screenshots') or 'screenshots'\n    \n    @property\n    def logs_dir(self) -> str:\n        return self._get_value('Paths', 'logs_dir', 'logs') or 'logs'\n    \n    # MCP Configuration\n    @property\n    def auto_refresh_dom(self) -> bool:\n        return self._get_bool('MCP', 'auto_refresh_dom', True)\n    \n    @property\n    def autonomous_execution(self) -> bool:\n        return self._get_bool('MCP', 'autonomous_execution', True)\n\n\n# Singleton instance\n_config_instance: Optional[ConfigLoader] = None\n\n\ndef get_config() -> ConfigLoader:\n    \"\"\"Get the global configuration instance\"\"\"\n    global _config_instance\n    if _config_instance is None:\n        _config_instance = ConfigLoader()\n    return _config_instance\n","size_bytes":3929},"nrw.py":{"content":"import tenacity\nprint(tenacity.__version__)","size_bytes":43}},"version":2}