{"file_contents":{"scripts/port_terminator.py":{"content":"import psutil\nfrom typing import List\n\ndef terminate_ports(ports: List[int]):\n    \"\"\"\n    Terminates all processes using the specified ports.\n    Args:\n        ports (List[int]): List of port numbers to terminate connections for.\n    \"\"\"\n    for port in ports:\n        found = False\n        for conn in psutil.net_connections(kind='inet'):\n            if conn.laddr.port == port:\n                found = True\n                pid = conn.pid\n                if pid:\n                    try:\n                        p = psutil.Process(pid)\n                        print(f\"Terminating process {pid} on port {port}...\")\n                        p.terminate()\n                        p.wait(timeout=3)\n                        print(f\"Process {pid} terminated.\")\n                    except Exception as e:\n                        print(f\"Error terminating process {pid} on port {port}: {e}\")\n                else:\n                    print(f\"No PID found for connection on port {port}.\")\n        if not found:\n            print(f\"No process found using port {port}.\")\n\nif __name__ == \"__main__\":\n    # Example usage: terminate ports 8080 and 5000\n    terminate_ports([7890, 5000])\n\n","size_bytes":1174},"visionvault/core/models.py":{"content":"import sqlite3\nimport json\nfrom datetime import datetime\n\nclass Database:\n    def __init__(self, db_path='data/automation.db'):\n        self.db_path = db_path\n        self.init_db()\n    \n    def init_db(self):\n        \"\"\"Initialize all database tables.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        \n        # Existing test_history table\n        c.execute('''CREATE TABLE IF NOT EXISTS test_history\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      command TEXT NOT NULL,\n                      generated_code TEXT NOT NULL,\n                      healed_code TEXT,\n                      browser TEXT,\n                      mode TEXT,\n                      execution_location TEXT,\n                      status TEXT,\n                      logs TEXT,\n                      screenshot_path TEXT,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # New learned_tasks table for persistent learning\n        c.execute('''CREATE TABLE IF NOT EXISTS learned_tasks\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT UNIQUE NOT NULL,\n                      task_name TEXT NOT NULL,\n                      description TEXT,\n                      steps TEXT,\n                      playwright_code TEXT NOT NULL,\n                      tags TEXT,\n                      embedding_vector BLOB,\n                      version INTEGER DEFAULT 1,\n                      parent_task_id TEXT,\n                      success_count INTEGER DEFAULT 0,\n                      failure_count INTEGER DEFAULT 0,\n                      last_executed TIMESTAMP,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # Task execution history for feedback loop\n        c.execute('''CREATE TABLE IF NOT EXISTS task_executions\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT NOT NULL,\n                      execution_result TEXT,\n                      success BOOLEAN,\n                      error_message TEXT,\n                      execution_time_ms INTEGER,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      FOREIGN KEY (task_id) REFERENCES learned_tasks(task_id))''')\n        \n        # Create indices for faster queries\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_id ON learned_tasks(task_id)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_name ON learned_tasks(task_name)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_created_at ON learned_tasks(created_at)')\n        \n        conn.commit()\n        conn.close()\n\n\nclass LearnedTask:\n    \"\"\"Model for a learned automation task.\"\"\"\n    \n    def __init__(self, task_id, task_name, playwright_code, description='', steps=None, \n                 tags=None, embedding_vector=None, version=1, parent_task_id=None):\n        self.task_id = task_id\n        self.task_name = task_name\n        self.description = description\n        self.steps = steps or []\n        self.playwright_code = playwright_code\n        self.tags = tags or []\n        self.embedding_vector = embedding_vector\n        self.version = version\n        self.parent_task_id = parent_task_id\n        self.success_count = 0\n        self.failure_count = 0\n        self.last_executed = None\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n    \n    def to_dict(self):\n        \"\"\"Convert task to dictionary.\"\"\"\n        return {\n            'task_id': self.task_id,\n            'task_name': self.task_name,\n            'description': self.description,\n            'steps': self.steps,\n            'playwright_code': self.playwright_code,\n            'tags': self.tags,\n            'version': self.version,\n            'parent_task_id': self.parent_task_id,\n            'success_count': self.success_count,\n            'failure_count': self.failure_count,\n            'last_executed': self.last_executed.isoformat() if self.last_executed else None,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save task to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Serialize complex fields\n        steps_json = json.dumps(self.steps)\n        tags_json = json.dumps(self.tags)\n        \n        # Serialize embedding vector if present\n        embedding_blob = None\n        if self.embedding_vector is not None:\n            import numpy as np\n            embedding_blob = self.embedding_vector.tobytes()\n        \n        c.execute('''INSERT OR REPLACE INTO learned_tasks \n                     (task_id, task_name, description, steps, playwright_code, tags, \n                      embedding_vector, version, parent_task_id, success_count, \n                      failure_count, last_executed, updated_at)\n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',\n                  (self.task_id, self.task_name, self.description, steps_json, \n                   self.playwright_code, tags_json, embedding_blob, self.version,\n                   self.parent_task_id, self.success_count, self.failure_count,\n                   self.last_executed, datetime.now()))\n        \n        conn.commit()\n        conn.close()\n    \n    @staticmethod\n    def get_by_id(task_id, db_path='data/automation.db'):\n        \"\"\"Retrieve task by ID.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks WHERE task_id=?', (task_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return None\n        \n        return LearnedTask._from_row(row)\n    \n    @staticmethod\n    def get_all(db_path='data/automation.db', limit=100):\n        \"\"\"Retrieve all tasks.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks ORDER BY created_at DESC LIMIT ?', (limit,))\n        rows = c.fetchall()\n        conn.close()\n        \n        return [LearnedTask._from_row(row) for row in rows]\n    \n    @staticmethod\n    def search_by_tags(tags, db_path='data/automation.db'):\n        \"\"\"Search tasks by tags.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Simple tag search - checks if any tag is present in the tags JSON\n        tasks = []\n        c.execute('SELECT * FROM learned_tasks')\n        rows = c.fetchall()\n        \n        for row in rows:\n            task_tags = json.loads(row[6]) if row[6] else []\n            if any(tag in task_tags for tag in tags):\n                tasks.append(LearnedTask._from_row(row))\n        \n        conn.close()\n        return tasks\n    \n    @staticmethod\n    def _from_row(row):\n        \"\"\"Create LearnedTask from database row.\"\"\"\n        import numpy as np\n        \n        task = LearnedTask(\n            task_id=row[1],\n            task_name=row[2],\n            description=row[3],\n            steps=json.loads(row[4]) if row[4] else [],\n            playwright_code=row[5],\n            tags=json.loads(row[6]) if row[6] else [],\n            version=row[8],\n            parent_task_id=row[9]\n        )\n        \n        # Deserialize embedding vector\n        if row[7]:\n            task.embedding_vector = np.frombuffer(row[7], dtype=np.float32)\n        \n        task.success_count = row[10] or 0\n        task.failure_count = row[11] or 0\n        task.last_executed = datetime.fromisoformat(row[12]) if row[12] else None\n        task.created_at = datetime.fromisoformat(row[13]) if row[13] else datetime.now()\n        task.updated_at = datetime.fromisoformat(row[14]) if row[14] else datetime.now()\n        \n        return task\n\n\nclass TaskExecution:\n    \"\"\"Model for task execution record.\"\"\"\n    \n    def __init__(self, task_id, execution_result, success, error_message=None, execution_time_ms=0):\n        self.task_id = task_id\n        self.execution_result = execution_result\n        self.success = success\n        self.error_message = error_message\n        self.execution_time_ms = execution_time_ms\n        self.created_at = datetime.now()\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save execution record to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        c.execute('''INSERT INTO task_executions \n                     (task_id, execution_result, success, error_message, execution_time_ms)\n                     VALUES (?, ?, ?, ?, ?)''',\n                  (self.task_id, self.execution_result, self.success, \n                   self.error_message, self.execution_time_ms))\n        \n        conn.commit()\n        conn.close()\n","size_bytes":8928},"scripts/run_both.py":{"content":"import subprocess\nimport sys\nimport os\nimport time\n\n# Paths to scripts\nmain_script = os.path.join(os.path.dirname(__file__), 'main.py')\nagent_script = os.path.join(os.path.dirname(__file__), 'local_agent.py')\n\n# Set environment variable for both processes\nenv = os.environ.copy()\nenv['AGENT_SERVER_URL'] = 'http://127.0.0.1:7890'\n\nprocesses = []\n\ntry:\n    # Start main.py\n    p1 = subprocess.Popen([sys.executable, main_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started main.py with PID {p1.pid}\")\n    processes.append((p1, 'main.py'))\n\n    # Start local_agent.py\n    p2 = subprocess.Popen([sys.executable, agent_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started local_agent.py with PID {p2.pid}\")\n    processes.append((p2, 'local_agent.py'))\n\n    # Print output from both processes\n    while True:\n        for proc, name in processes:\n            # Print all available lines from stdout\n            while True:\n                out = proc.stdout.readline()\n                if not out:\n                    break\n                print(f\"[{name}] {out.decode().rstrip()}\")\n            # Print all available lines from stderr\n            while True:\n                err = proc.stderr.readline()\n                if not err:\n                    break\n                print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n        # Check if any process has exited\n        for proc, name in processes[:]:\n            if proc.poll() is not None:\n                print(f\"Process {proc.pid} ({name}) exited.\")\n                # Print any remaining output after exit\n                for out in proc.stdout:\n                    print(f\"[{name}] {out.decode().rstrip()}\")\n                for err in proc.stderr:\n                    print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n                processes.remove((proc, name))\n        if not processes:\n            print(\"All processes exited.\")\n            break\n        time.sleep(0.2)\nexcept KeyboardInterrupt:\n    print(\"Stopping processes...\")\n    for proc, _ in processes:\n        proc.terminate()\n","size_bytes":2108},"visionvault/core/__init__.py":{"content":"","size_bytes":0},"visionvault/agents/main.py":{"content":"import asyncio\nimport time\nfrom .config import AGENT_ID, SERVER_URL\nfrom .socket_client import SocketClient\nfrom .test_executor import TestExecutor\nfrom .healing_engine import HealingEngine\nfrom .recording_session import CodegenRecordingSessionManager\nimport os\n\nclass VisionVaultAgent:\n    def __init__(self):\n        self.socket_client = SocketClient()\n        self.test_executor = TestExecutor(self.socket_client)\n        self.healing_engine = HealingEngine(self.socket_client)\n        self.recording_manager = CodegenRecordingSessionManager(self.socket_client)\n\n        # Set up event handlers\n        self._setup_event_handlers()\n\n    def _setup_event_handlers(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.socket_client.sio.on('execute_on_agent')\n        def handle_execute(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.test_executor.execute_test(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode']\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('start_recording')\n        def handle_start_recording(data):\n            if self.socket_client.event_loop:\n                session_id = data['session_id']\n                start_url = data.get('start_url', '')\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.start_recording_session(\n                        session_id=session_id,\n                        start_url=start_url  # No output_file here\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('execute_healing_attempt')\n        def handle_healing_attempt(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.execute_healing_attempt(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode'],\n                        data.get('attempt', 1)\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('element_selector_needed')\n        def handle_element_selector_needed(data):\n            mode = data.get('mode', 'headless')\n            if mode == 'headful' and self.healing_engine.active_page and self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.inject_element_selector(\n                        data['test_id'],\n                        data['failed_locator']\n                    ),\n                    self.socket_client.event_loop\n                )\n            else:\n                print(f\"❌ Cannot inject widget (mode={mode}, page={'yes' if self.healing_engine.active_page else 'no'})\")\n\n        @self.socket_client.sio.on('stop_recording')\n        def handle_stop_recording(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.stop_recording_session(data['session_id']),\n                    self.socket_client.event_loop\n                )\n\n    async def send_heartbeat(self):\n        while True:\n            try:\n                if self.socket_client.connected:\n                    browser_status = \"available\"\n                    active_sessions = len(getattr(self.recording_manager, 'sessions', {}))\n                    if active_sessions > 0:\n                        browser_status = f\"recording_{active_sessions}_sessions\"\n\n                    self.socket_client.emit('heartbeat', {\n                        'agent_id': AGENT_ID,\n                        'timestamp': time.time(),\n                        'browser_status': browser_status,\n                        'capabilities': {\n                            'recording': True,\n                            'comprehensive_recording': True,\n                            'test_execution': True,\n                            'healing': True\n                        }\n                    })\n                await asyncio.sleep(30)\n            except Exception as e:\n                print(f\"Heartbeat error: {e}\")\n                await asyncio.sleep(30)\n\n    async def initialize_agent(self):\n        try:\n            self.socket_client.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'capabilities': {\n                    'browsers': ['chromium'],\n                    'recording': True,\n                    'comprehensive_recording': True,\n                    'test_execution': True,\n                    'healing': True,\n                    'event_types': [\n                        'click', 'input', 'keypress', 'navigation',\n                        'form_submit', 'network_request', 'network_response',\n                        'console', 'page_error', 'page_created'\n                    ]\n                },\n                'status': 'ready'\n            })\n            print(\"✅ Agent registered with comprehensive recording capabilities\")\n        except Exception as e:\n            print(f\"❌ Agent initialization failed: {e}\")\n\n    def run(self):\n        print(\"=\" * 60)\n        print(\"  VisionVault Browser Automation Agent\")\n        print(\"=\" * 60)\n        print(f\"  Agent ID: {AGENT_ID}\")\n        print(f\"  Server URL: {SERVER_URL}\")\n        print()\n\n        try:\n            print(\"Connecting to server...\")\n            self.socket_client.connect()\n            print(\"Connection established! Initializing agent...\")\n\n            self.socket_client.event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.socket_client.event_loop)\n\n            self.socket_client.event_loop.run_until_complete(self.initialize_agent())\n            self.socket_client.event_loop.create_task(self.send_heartbeat())\n\n            print(\"✅ Agent ready! Waiting for tasks...\\n\")\n            self.socket_client.event_loop.run_forever()\n\n        except KeyboardInterrupt:\n            print(\"\\n🛑 Shutting down agent...\")\n            try:\n                for session_id in list(getattr(self.recording_manager, 'sessions', {}).keys()):\n                    print(f\"🛑 Stopping recording session: {session_id}\")\n                    asyncio.run_coroutine_threadsafe(\n                        self.recording_manager.stop_recording_session(session_id),\n                        self.socket_client.event_loop\n                    )\n            except Exception as e:\n                print(f\"⚠️ Error stopping recordings: {e}\")\n\n            self.socket_client.disconnect()\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n        except Exception as e:\n            print(f\"❌ Connection error: {e}\")\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n\ndef main():\n    agent = VisionVaultAgent()\n    agent.run()\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":7179},"visionvault/agents/healing_engine.py":{"content":"import re\nimport asyncio\nfrom .browser_manager import BrowserManager\nfrom .utils import extract_failed_locator_local\n\n\nclass HealingEngine(BrowserManager):\n    def __init__(self, socket_client):\n        super().__init__()\n        self.socket_client = socket_client\n\n    def modify_code_for_healing(self, code):\n        \"\"\"Transform code to keep browser open by removing async with context manager\"\"\"\n        import re\n\n        # Step 1: Find the async with line and its indentation\n        lines = code.split('\\n')\n        new_lines = []\n        in_async_with_block = False\n        async_with_indent = 0\n        block_indent = 0\n\n        for i, line in enumerate(lines):\n            # Check if this line contains 'async with async_playwright() as var:'\n            async_with_match = re.match(r'^(\\s*)async with async_playwright\\(\\) as (\\w+):\\s*$', line)\n\n            if async_with_match and not in_async_with_block:\n                # Found the async with line - replace it\n                indent = async_with_match.group(1)\n                var_name = async_with_match.group(2)\n                async_with_indent = len(indent)\n\n                # Replace with two lines at the same indentation\n                new_lines.append(f'{indent}{var_name} = await async_playwright().start()')\n                new_lines.append(f'{indent}globals()[\"__p_instance__\"] = {var_name}')\n\n                in_async_with_block = True\n                # Determine the block indentation\n                if i + 1 < len(lines) and lines[i + 1].strip():\n                    block_indent = len(lines[i + 1]) - len(lines[i + 1].lstrip())\n                else:\n                    block_indent = async_with_indent + 4\n\n            elif in_async_with_block:\n                # Check if this line is still part of the async with block\n                if line.strip():\n                    current_indent = len(line) - len(line.lstrip())\n\n                    # If indentation decreased to or below async_with level, we've exited the block\n                    if current_indent <= async_with_indent:\n                        in_async_with_block = False\n                        new_lines.append(line)\n                    else:\n                        # Dedent by one level\n                        dedent_amount = block_indent - async_with_indent\n                        if current_indent >= block_indent:\n                            dedented_line = line[dedent_amount:]\n                            new_lines.append(dedented_line)\n                        else:\n                            new_lines.append(line)\n                else:\n                    new_lines.append(line)\n            else:\n                new_lines.append(line)\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 2: Inject page capture after page creation\n        lines = modified_code.split('\\n')\n        new_lines = []\n        page_captured = False\n\n        for line in lines:\n            new_lines.append(line)\n            # Match any variable name pattern: var = await browser.new_page()\n            if re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line) and not page_captured:\n                indent = len(line) - len(line.lstrip())\n                var_match = re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line)\n                if var_match:\n                    var_name = var_match.group(1)\n                    new_lines.append(f'{\" \" * indent}globals()[\"__healing_page__\"] = {var_name}')\n                    page_captured = True\n                    print(f\"✅ Added page capture injection for variable '{var_name}'\")\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 3: Replace browser.close() with pass to keep browser open for healing\n        modified_code = re.sub(\n            r'^(\\s*)(await\\s+)?browser\\.close\\(\\)',\n            r'\\1pass  # browser.close() commented for healing',\n            modified_code,\n            flags=re.MULTILINE\n        )\n\n        print(\"✅ Code transformation: async with removed, body dedented, browser stays open for healing\")\n        return modified_code\n\n    async def execute_healing_attempt(self, test_id, code, browser_name, mode, attempt):\n        \"\"\"Execute a healing attempt with widget injection on failure\"\"\"\n        headless = mode == 'headless'\n\n        try:\n            print(\n                f\"🎯 Starting healing attempt {attempt} for test {test_id} in {'headless' if headless else 'headful'} mode\")\n\n            # Clean up any previous instances\n            await self.cleanup_browser()\n\n            # Use original code for headless, modified for headful\n            if headless:\n                modified_code = code\n            else:\n                modified_code = self.modify_code_for_healing(code)\n                print(\"✅ Code modified for headful healing mode\")\n\n            global_vars = {'__healing_page__': None, '__p_instance__': None}\n            local_vars = {}\n\n            # Execute the code\n            exec(modified_code, global_vars, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('healing_attempt_result',\n                                        {'test_id': test_id, 'success': False, 'logs': ['Error: run_test missing'],\n                                         'screenshot': None})\n                return\n\n            run_test = local_vars['run_test']\n\n            # Execute with timeout\n            try:\n                result = await asyncio.wait_for(\n                    run_test(browser_name=browser_name, headless=headless),\n                    timeout=60.0\n                )\n            except asyncio.TimeoutError:\n                print(f\"⏱️  Execution timeout for test {test_id}\")\n                result = {\n                    'success': False,\n                    'logs': ['Execution timeout - browser took too long to respond'],\n                    'screenshot': None\n                }\n\n            # Store page reference for headful mode\n            if not headless and global_vars.get('__healing_page__'):\n                self.set_active_page(global_vars['__healing_page__'])\n                if self.active_page and hasattr(self.active_page, 'url') and hasattr(self.active_page, 'is_closed'):\n                    print(\n                        f\"✅ Page captured for healing - URL: {self.active_page.url if not self.active_page.is_closed() else 'CLOSED'}\")\n                else:\n                    print(f\"✅ Page captured for healing - but no valid URL or is_closed method\")\n            else:\n                print(\n                    f\"ℹ️  No page captured (headless: {headless}, page available: {bool(global_vars.get('__healing_page__'))})\")\n\n            # Handle screenshot\n            from .utils import encode_screenshot\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            print(f\"Healing attempt {attempt} for test {test_id}: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n            # Emit result to server for tracking\n            self.socket_client.emit('healing_attempt_result', {\n                'test_id': test_id,\n                'success': result.get('success', False),\n                'logs': result.get('logs', []),\n                'screenshot': screenshot_b64\n            })\n\n            # LOCAL-FIRST HEALING: Detect failure and inject widget immediately\n            if not headless and not result.get('success') and self.active_page:\n                # Extract failed locator from error message\n                error_msg = ' '.join(result.get('logs', []))\n                failed_locator = extract_failed_locator_local(error_msg)\n\n                if failed_locator:\n                    print(f\"🎯 LOCAL: Failed locator detected: {failed_locator}\")\n                    print(f\"🚀 LOCAL: Injecting widget immediately (no server delay)\")\n\n                    # Inject widget immediately - no waiting for server\n                    self.set_widget_event(asyncio.Event())\n\n                    try:\n                        # Inject widget NOW\n                        await self.inject_element_selector(test_id, failed_locator)\n\n                        # Wait for user interaction (5 minutes timeout)\n                        print(f\"⏳ Waiting for user to select element (300s timeout)...\")\n                        try:\n                            await asyncio.wait_for(self.widget_injection_complete.wait(), timeout=300.0)\n                            print(f\"✅ User selection completed\")\n                        except asyncio.TimeoutError:\n                            print(f\"⏱️  User selection timeout (300s)\")\n                    finally:\n                        # Always cleanup browser after widget interaction or timeout\n                        self.set_widget_event(None)\n                        print(f\"🧹 Cleaning up browser after widget interaction...\")\n                        await self.cleanup_browser()\n                else:\n                    print(f\"ℹ️  No locator error detected in headful mode - browser will close normally\")\n\n        except Exception as e:\n            print(f\"💥 Healing attempt error: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.socket_client.emit('healing_attempt_result',\n                                    {'test_id': test_id, 'success': False, 'logs': [str(e)], 'screenshot': None})\n            await self.cleanup_browser()\n\n    async def inject_element_selector(self, test_id, failed_locator):\n        \"\"\"Inject element selector widget into the page\"\"\"\n        if not self.active_page:\n            print(f\"❌ No active page for element selection (test {test_id})\")\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()\n            return\n\n        try:\n            if hasattr(self.active_page, 'is_closed') and self.active_page.is_closed():\n                print(f\"❌ Page already closed for test {test_id}\")\n                self.set_active_page(None)\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            if hasattr(self.active_page, 'url'):\n                print(f\"🎯 Injecting element selector widget for test {test_id} on page: {self.active_page.url}\")\n            else:\n                print(f\"🎯 Injecting element selector widget for test {test_id} on page: [no url]\")\n\n            # JavaScript to inject element selector overlay\n            selector_script = \"\"\"\n            (failedLocator) => {\n                console.log('🔧 Injecting element selector for locator:', failedLocator);\n                \n                // Remove any existing overlays first\n                const existingOverlay = document.getElementById('playwright-element-selector-overlay');\n                if (existingOverlay) {\n                    existingOverlay.remove();\n                }\n                \n                // Create overlay (non-blocking)\n                const overlay = document.createElement('div');\n                overlay.id = 'playwright-element-selector-overlay';\n                overlay.style.cssText = `\n                    position: fixed !important;\n                    top: 0 !important;\n                    left: 0 !important;\n                    width: 100% !important;\n                    height: 100% !important;\n                    background: rgba(0, 0, 0, 0.3) !important;\n                    z-index: 2147483647 !important;\n                    cursor: crosshair !important;\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;\n                    pointer-events: none !important;\n                `;\n                \n                // Create draggable header with instructions\n                const header = document.createElement('div');\n                header.style.cssText = `\n                    position: fixed !important;\n                    top: 20px !important;\n                    left: 50% !important;\n                    transform: translateX(-50%) !important;\n                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;\n                    color: white !important;\n                    padding: 16px 24px !important;\n                    border-radius: 12px !important;\n                    font-size: 15px !important;\n                    font-weight: 600 !important;\n                    z-index: 2147483648 !important;\n                    box-shadow: 0 8px 24px rgba(0,0,0,0.4) !important;\n                    text-align: left !important;\n                    cursor: move !important;\n                    user-select: none !important;\n                    pointer-events: auto !important;\n                    backdrop-filter: blur(10px) !important;\n                    border: 1px solid rgba(255,255,255,0.1) !important;\n                `;\n                header.innerHTML = `\n                    <div style=\"display: flex; align-items: center; gap: 12px; margin-bottom: 8px;\">\n                        <span style=\"font-size: 20px;\">🎯</span>\n                        <span style=\"font-size: 16px;\">Element Selector Mode</span>\n                    </div>\n                    <div style=\"font-size: 13px; font-weight: normal; opacity: 0.95; line-height: 1.5;\">\n                        <div style=\"margin-bottom: 4px;\">Failed locator: <code style=\"background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px; font-family: monospace;\">${failedLocator}</code></div>\n                        <div style=\"opacity: 0.85;\">Click on the element you want to select</div>\n                        <div style=\"font-size: 11px; opacity: 0.7; margin-top: 6px;\">💡 Drag this panel to move it</div>\n                    </div>\n                `;\n                \n                // Make header draggable\n                let isDragging = false;\n                let currentX;\n                let currentY;\n                let initialX;\n                let initialY;\n                \n                header.addEventListener('mousedown', (e) => {\n                    if (e.target.tagName !== 'BUTTON') {\n                        isDragging = true;\n                        initialX = e.clientX - (parseInt(header.style.left) || e.clientX);\n                        initialY = e.clientY - (parseInt(header.style.top) || 20);\n                        header.style.transition = 'none';\n                    }\n                });\n                \n                document.addEventListener('mousemove', (e) => {\n                    if (isDragging) {\n                        e.preventDefault();\n                        currentX = e.clientX - initialX;\n                        currentY = e.clientY - initialY;\n                        header.style.left = currentX + 'px';\n                        header.style.top = currentY + 'px';\n                        header.style.transform = 'none';\n                    }\n                });\n                \n                document.addEventListener('mouseup', () => {\n                    isDragging = false;\n                });\n                \n                // Create cancel button inside header\n                const cancelBtn = document.createElement('button');\n                cancelBtn.textContent = '✕';\n                cancelBtn.style.cssText = `\n                    position: absolute !important;\n                    top: 12px !important;\n                    right: 12px !important;\n                    background: rgba(255,255,255,0.2) !important;\n                    color: white !important;\n                    border: none !important;\n                    width: 28px !important;\n                    height: 28px !important;\n                    border-radius: 50% !important;\n                    cursor: pointer !important;\n                    font-size: 16px !important;\n                    font-weight: bold !important;\n                    display: flex !important;\n                    align-items: center !important;\n                    justify-content: center !important;\n                    transition: background 0.2s !important;\n                    pointer-events: auto !important;\n                `;\n                cancelBtn.onmouseover = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.3)';\n                };\n                cancelBtn.onmouseout = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.2)';\n                };\n                cancelBtn.onclick = (e) => {\n                    e.stopPropagation();\n                    overlay.remove();\n                    header.remove();\n                    window.__selectedSelector = null;\n                };\n                header.appendChild(cancelBtn);\n                \n                // Track highlighted element\n                let highlightedElement = null;\n                let highlightBox = null;\n                \n                // Mouse move handler to highlight elements\n                document.addEventListener('mousemove', (e) => {\n                    if (!isDragging) {\n                        const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (elementUnderCursor && elementUnderCursor !== overlay && !header.contains(elementUnderCursor)) {\n                            if (highlightedElement !== elementUnderCursor) {\n                                highlightedElement = elementUnderCursor;\n                                \n                                // Remove old highlight box\n                                if (highlightBox) {\n                                    highlightBox.remove();\n                                }\n                                \n                                // Create new highlight box\n                                const rect = highlightedElement.getBoundingClientRect();\n                                highlightBox = document.createElement('div');\n                                highlightBox.style.cssText = `\n                                    position: fixed !important;\n                                    top: ${rect.top}px !important;\n                                    left: ${rect.left}px !important;\n                                    width: ${rect.width}px !important;\n                                    height: ${rect.height}px !important;\n                                    border: 2px solid #667eea !important;\n                                    background: rgba(102, 126, 234, 0.1) !important;\n                                    z-index: 2147483646 !important;\n                                    pointer-events: none !important;\n                                    box-shadow: 0 0 20px rgba(102, 126, 234, 0.4) !important;\n                                    border-radius: 4px !important;\n                                `;\n                                document.body.appendChild(highlightBox);\n                            }\n                        }\n                    }\n                });\n                \n                // Click handler to select element\n                document.addEventListener('click', function selectHandler(e) {\n                    if (!header.contains(e.target)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        \n                        const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (elementUnderCursor && elementUnderCursor !== overlay && !header.contains(elementUnderCursor)) {\n                            // Generate selector for the element\n                            let selector = null;\n                            \n                            // Try ID first\n                            if (elementUnderCursor.id) {\n                                selector = '#' + elementUnderCursor.id;\n                            }\n                            // Try unique class combinations\n                            else if (elementUnderCursor.className && typeof elementUnderCursor.className === 'string') {\n                                const classes = elementUnderCursor.className.trim().split(/\\\\s+/).filter(c => c);\n                                if (classes.length > 0) {\n                                    selector = '.' + classes.join('.');\n                                }\n                            }\n                            // Fall back to tag name with nth-child\n                            if (!selector) {\n                                const tag = elementUnderCursor.tagName.toLowerCase();\n                                const parent = elementUnderCursor.parentElement;\n                                if (parent) {\n                                    const siblings = Array.from(parent.children).filter(e => e.tagName === elementUnderCursor.tagName);\n                                    const index = siblings.indexOf(elementUnderCursor);\n                                    selector = `${tag}:nth-of-type(${index + 1})`;\n                                } else {\n                                    selector = tag;\n                                }\n                            }\n                            \n                            console.log('✅ Element selected:', selector);\n                            window.__selectedSelector = selector;\n                            \n                            // Clean up\n                            overlay.remove();\n                            header.remove();\n                            if (highlightBox) {\n                                highlightBox.remove();\n                            }\n                            document.removeEventListener('click', selectHandler);\n                        }\n                    }\n                }, true);\n                \n                // Add to DOM\n                document.body.appendChild(overlay);\n                document.body.appendChild(header);\n                \n                console.log('✅ Element selector widget injected successfully');\n            }\n            \"\"\"\n\n            # Inject the script\n            if hasattr(self.active_page, 'evaluate'):\n                await self.active_page.evaluate(selector_script, failed_locator)\n                print(\"✅ Element selector widget injected successfully\")\n            else:\n                print(\"❌ Cannot inject selector widget: active_page has no evaluate method\")\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            # Poll for user selection\n            print(\"⏳ Polling for user element selection...\")\n            for i in range(600):\n                await asyncio.sleep(0.2)\n                selected = None\n                if hasattr(self.active_page, 'evaluate'):\n                    selected = await self.active_page.evaluate('() => window.__selectedSelector')\n                if selected:\n                    print(f\"✅ User selected element: {selected}\")\n                    self.socket_client.emit('element_selected', {\n                        'test_id': test_id,\n                        'selector': selected,\n                        'failed_locator': failed_locator\n                    })\n                    if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                        self.widget_injection_complete.set()\n                    return\n            print(\"⏱️  Element selection polling complete (300s)\")\n        except Exception as e:\n            print(f\"❌ Element selector injection error: {e}\")\n        finally:\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()","size_bytes":23997},"visionvault/services/executor.py":{"content":"import asyncio\nimport sys\nfrom io import StringIO\nfrom visionvault.services.code_validator import CodeValidator\n\nclass ServerExecutor:\n    def execute(self, code, browser_name='chromium', headless=True):\n        try:\n            validator = CodeValidator()\n            if not validator.validate(code):\n                return {\n                    'success': False,\n                    'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                    'screenshot': None\n                }\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True,\n                    'False': False,\n                    'None': None,\n                    'dict': dict,\n                    'list': list,\n                    'str': str,\n                    'int': int,\n                    'float': float,\n                    'bool': bool,\n                    'len': len,\n                    'range': range,\n                    'enumerate': enumerate,\n                    'zip': zip,\n                    'Exception': Exception,\n                    'ValueError': ValueError,\n                    'TypeError': TypeError,\n                    'KeyError': KeyError,\n                    'AttributeError': AttributeError,\n                    'getattr': getattr,\n                    'setattr': setattr,\n                    'hasattr': hasattr,\n                    'print': print,\n                    '__import__': __import__,\n\n                }\n            }\n            \n            local_vars = {}\n            exec(code, restricted_globals, local_vars)\n            \n            if 'run_test' not in local_vars:\n                return {\n                    'success': False,\n                    'logs': ['Error: Generated code must contain a run_test function'],\n                    'screenshot': None\n                }\n            \n            run_test = local_vars['run_test']\n            \n            result = asyncio.run(run_test(browser_name=browser_name, headless=headless))\n            \n            return result\n        except Exception as e:\n            return {\n                'success': False,\n                'logs': [f'Execution error: {str(e)}'],\n                'screenshot': None\n            }\n","size_bytes":2270},"visionvault/agents/utils.py":{"content":"import os\nimport sys\nimport subprocess\nimport re\nimport base64\n\n\ndef detect_browsers():\n    \"\"\"Detect available browsers on the system\"\"\"\n    browsers = []\n    try:\n        if sys.platform == 'win32':\n            paths = [\n                r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\",\n                r\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"\n            ]\n            if any(os.path.exists(p) for p in paths):\n                browsers.append('chromium')\n        elif sys.platform == 'darwin':\n            if os.path.exists('/Applications/Google Chrome.app'):\n                browsers.append('chromium')\n            if os.path.exists('/Applications/Firefox.app'):\n                browsers.append('firefox')\n            if os.path.exists('/Applications/Safari.app'):\n                browsers.append('webkit')\n        else:\n            if subprocess.run(['which', 'google-chrome'], capture_output=True).returncode == 0:\n                browsers.append('chromium')\n            if subprocess.run(['which', 'firefox'], capture_output=True).returncode == 0:\n                browsers.append('firefox')\n        if not browsers:\n            browsers = ['chromium']\n    except Exception as e:\n        print(f\"Browser detection error: {e}\")\n        browsers = ['chromium']\n\n    print(f\"Detected browsers: {browsers}\")\n    return browsers\n\n\ndef extract_failed_locator_local(error_message):\n    \"\"\"Extract the failed locator from Playwright error messages.\"\"\"\n    patterns = [\n        r'locator\\([\"\\']([^\"\\']+)[\"\\']\\)',\n        r'waiting for locator\\([\"\\']([^\"\\']+)[\"\\']\\)',\n        r'waiting for ([^\\s]+)',\n        r'Timeout.*?locator\\([\"\\']([^\"\\']+)[\"\\']\\)',\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, error_message)\n        if match:\n            return match.group(1)\n\n    return None\n\n\ndef encode_screenshot(screenshot_bytes):\n    \"\"\"Encode screenshot to base64 string\"\"\"\n    if screenshot_bytes:\n        return base64.b64encode(screenshot_bytes).decode('utf-8')\n    return None","size_bytes":2030},"visionvault/services/healing_executor.py":{"content":"import asyncio\nimport json\nimport re\nfrom visionvault.services.code_validator import CodeValidator\nfrom openai import OpenAI\nimport os\n\nclass HealingExecutor:\n    def __init__(self, socketio, api_key=None):\n        self.socketio = socketio\n        # Use provided API key or fallback to environment variable\n        openai_key = api_key or os.environ.get('OPENAI_API_KEY')\n        self.client = OpenAI(api_key=openai_key) if openai_key else None\n        self.healed_script = None\n        self.failed_locators = []\n        self.retry_count = 0\n        self.max_retries = 3\n        self.user_selector_event = None\n        self.user_selected_selector = None\n        self.execution_mode = 'server'  # 'server' or 'agent'\n        self.agent_result = None\n        self.agent_result_event = None\n        self.agent_sid = None  # Agent session ID for targeted emits\n        \n    def improve_locator_with_ai(self, failed_locator, error_message, page_html_snippet=''):\n        \"\"\"Use AI to suggest better locator strategies.\"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at web automation and CSS/XPath selectors.\nWhen a locator fails, suggest better, more robust alternatives. Consider:\n1. Using text content locators when possible\n2. Using data-testid or aria-labels\n3. Using role-based selectors\n4. Creating more specific CSS selectors\n5. Using XPath as last resort\n\nReturn ONLY the improved locator string, nothing else.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed locator: {failed_locator}\nError: {error_message}\nPage context: {page_html_snippet[:500] if page_html_snippet else 'Not available'}\n\nSuggest a better locator:\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            improved = response.choices[0].message.content.strip()\n            if improved.startswith('```'):\n                improved = improved.split('\\n')[1]\n            if improved.endswith('```'):\n                improved = improved.rsplit('\\n', 1)[0]\n                \n            return improved.strip('\"\\'')\n        except Exception as e:\n            print(f\"AI locator improvement error: {e}\")\n            return failed_locator\n    \n    def heal_script(self, original_code, failed_locator, healed_locator):\n        \"\"\"Replace failed locator with healed one in the script.\"\"\"\n        print(f\"\\n🔧 HEALING SCRIPT:\")\n        print(f\"  Failed locator: '{failed_locator}'\")\n        print(f\"  Healed locator: '{healed_locator}'\")\n        print(f\"  Searching for '{failed_locator}' in code...\")\n        print(f\"  Found: {failed_locator in original_code}\")\n        \n        healed = original_code.replace(failed_locator, healed_locator)\n        self.healed_script = healed\n        \n        print(f\"  Replacement successful: {healed != original_code}\")\n        if healed != original_code:\n            print(f\"  Code changed from {len(original_code)} to {len(healed)} chars\")\n        else:\n            print(f\"  ⚠️  WARNING: Code unchanged after replacement!\")\n        \n        return healed\n    \n    async def wait_for_user_selector(self, timeout=300):\n        \"\"\"Wait for user to select an element interactively.\"\"\"\n        self.user_selector_event = asyncio.Event()\n        self.user_selected_selector = None\n        \n        try:\n            await asyncio.wait_for(self.user_selector_event.wait(), timeout=timeout)\n            return self.user_selected_selector\n        except asyncio.TimeoutError:\n            return None\n    \n    def set_user_selector(self, selector):\n        \"\"\"Called when user selects an element.\"\"\"\n        self.user_selected_selector = selector\n        if self.user_selector_event:\n            self.user_selector_event.set()\n    \n    def set_agent_result(self, result):\n        \"\"\"Called when agent returns result.\"\"\"\n        self.agent_result = result\n        if self.agent_result_event:\n            self.agent_result_event.set()\n\n    async def _execute_on_agent(self, code, browser_name, headless, test_id, attempt_num, logs):\n        \"\"\"Execute code on agent and wait for result.\"\"\"\n        import base64\n\n        # Setup event to wait for agent result\n        self.agent_result_event = asyncio.Event()\n        self.agent_result = None\n\n        # For headful mode, use modified code that keeps browser open\n        execution_code = code\n        if not headless:\n            # Add a small delay to ensure browser is ready for widget injection\n            execution_code = code.replace(\n                \"async def run_test(browser_name='chromium', headless=True):\",\n                \"async def run_test(browser_name='chromium', headless=True):\\n    import asyncio\\n    await asyncio.sleep(1)  # Ensure browser is ready\"\n            )\n\n        # Emit execution request to agent (targeted to specific agent)\n        mode = 'headless' if headless else 'headful'\n        if self.agent_sid:\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            }, to=self.agent_sid)\n        else:\n            # Fallback to broadcast if no specific agent\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            })\n\n        # Wait for agent result with extended timeout for headful mode\n        timeout = 180 if not headless else 120  # 3 minutes for headful, 2 for headless\n        try:\n            await asyncio.wait_for(self.agent_result_event.wait(), timeout=timeout)\n        except asyncio.TimeoutError:\n            return {\n                'success': False,\n                'logs': logs + ['❌ Agent execution timeout'],\n                'screenshot': None,\n                'can_heal': False\n            }\n\n        result = self.agent_result\n        if not result:\n            return {\n                'success': False,\n                'logs': logs + ['❌ No result from agent'],\n                'screenshot': None,\n                'can_heal': False\n            }\n        \n        # Decode screenshot if present\n        screenshot = None\n        if result.get('screenshot'):\n            try:\n                screenshot = base64.b64decode(result['screenshot'])\n            except:\n                pass\n        \n        logs.extend(result.get('logs', []))\n        \n        if result.get('success'):\n            logs.append(\"✅ Execution completed successfully\")\n            return {\n                'success': True,\n                'logs': logs,\n                'screenshot': screenshot\n            }\n        else:\n            # Extract failed locator from error\n            error_msg = ' '.join(result.get('logs', []))\n            failed_locator = self.extract_failed_locator(error_msg)\n            \n            if failed_locator:\n                self.failed_locators.append({\n                    'locator': failed_locator,\n                    'error': error_msg,\n                    'attempt': attempt_num + 1\n                })\n                \n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': True,\n                    'failed_locator': failed_locator,\n                    'error_message': error_msg,\n                    'page_content': ''\n                }\n            else:\n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': False\n                }\n    \n    async def execute_with_healing(self, code, browser_name, headless, test_id):\n        \"\"\"Execute code with automatic healing and retry on failures.\"\"\"\n        validator = CodeValidator()\n        if not validator.validate(code):\n            return {\n                'success': False,\n                'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                'screenshot': None,\n                'healed_script': None\n            }\n        \n        self.healed_script = code\n        current_code = code\n        \n        for attempt in range(self.max_retries):\n            result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt)\n            \n            if result['success']:\n                final_result = {\n                    'success': True,\n                    'logs': result['logs'],\n                    'screenshot': result['screenshot'],\n                    'healed_script': self.healed_script if self.healed_script != code else None,\n                    'failed_locators': self.failed_locators\n                }\n                \n                if self.failed_locators:\n                    await self.report_failures_to_ai(test_id)\n                    final_result['logs'].append(\"📊 AI analysis complete - check insights for improvement recommendations\")\n                \n                return final_result\n            \n            if not result.get('can_heal'):\n                return result\n            \n            failed_locator = result.get('failed_locator')\n            import sys\n            print(f\"🔍 DEBUG: failed_locator={failed_locator}, headless={headless}, execution_mode={self.execution_mode}\", flush=True)\n            sys.stdout.flush()\n            \n            if failed_locator:\n                improved_locator = None\n                \n                if not headless:\n                    mode = 'headful' if not headless else 'headless'\n                    # Emit to specific agent\n                    print(f\"🔔 SERVER: Emitting element_selector_needed event for test {test_id}, locator: {failed_locator}, mode: {mode}\", flush=True)\n                    sys.stdout.flush()\n                    \n                    if self.agent_sid:\n                        self.socketio.emit('element_selector_needed', {\n                            'test_id': test_id,\n                            'failed_locator': failed_locator,\n                            'error': result.get('error_message', ''),\n                            'attempt': attempt + 1,\n                            'mode': mode\n                        }, to=self.agent_sid)\n                    else:\n                        # Fallback to broadcast\n                        self.socketio.emit('element_selector_needed', {\n                            'test_id': test_id,\n                            'failed_locator': failed_locator,\n                            'error': result.get('error_message', ''),\n                            'attempt': attempt + 1,\n                            'mode': mode\n                        })\n                    \n                    print(f\"✅ SERVER: element_selector_needed event emitted successfully\", flush=True)\n                    sys.stdout.flush()\n                    \n                    result['logs'].append(f\"👆 Waiting for user to select element (failed locator: {failed_locator})...\")\n                    \n                    user_selector = await self.wait_for_user_selector(timeout=300)\n                    \n                    if user_selector:\n                        improved_locator = user_selector\n                        print(f\"\\n✅ USER SELECTED: '{improved_locator}'\", flush=True)\n                        result['logs'].append(f\"✅ User selected element: {improved_locator}\")\n                    else:\n                        result['logs'].append(f\"⏱️  User selection timeout, falling back to AI...\")\n                        improved_locator = self.improve_locator_with_ai(\n                            failed_locator, \n                            result.get('error_message', ''),\n                            result.get('page_content', '')\n                        )\n                        result['logs'].append(f\"🤖 AI suggested locator: {improved_locator}\")\n                else:\n                    self.socketio.emit('healing_required', {\n                        'test_id': test_id,\n                        'failed_locator': failed_locator,\n                        'error': result.get('error_message', ''),\n                        'attempt': attempt + 1,\n                        'headless': headless\n                    })\n                    \n                    improved_locator = self.improve_locator_with_ai(\n                        failed_locator, \n                        result.get('error_message', ''),\n                        result.get('page_content', '')\n                    )\n                    \n                    result['logs'].append(f\"🔧 Healing attempt {attempt + 1}: AI suggested locator: {improved_locator}\")\n                \n                current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                \n                print(f\"\\n📤 EMITTING script_healed event:\")\n                print(f\"  test_id: {test_id}\")\n                print(f\"  failed_locator: '{failed_locator}'\")\n                print(f\"  healed_locator: '{improved_locator}'\")\n                print(f\"  healed_script length: {len(current_code)}\", flush=True)\n                \n                self.socketio.emit('script_healed', {\n                    'test_id': test_id,\n                    'healed_script': current_code,\n                    'failed_locator': failed_locator,\n                    'healed_locator': improved_locator,\n                    'attempt': attempt + 1\n                })\n                \n                await asyncio.sleep(0.5)\n            else:\n                return result\n        \n        print(f\"\\n❌ HEALING FAILED after {self.max_retries} attempts\")\n        print(f\"  self.healed_script is None: {self.healed_script is None}\")\n        print(f\"  self.healed_script length: {len(self.healed_script) if self.healed_script else 0}\", flush=True)\n        \n        final_result = {\n            'success': False,\n            'logs': result.get('logs', []) + [f'❌ Failed after {self.max_retries} healing attempts'],\n            'screenshot': result.get('screenshot'),\n            'healed_script': self.healed_script,\n            'failed_locators': self.failed_locators\n        }\n        \n        if self.failed_locators:\n            await self.report_failures_to_ai(test_id)\n        \n        return final_result\n    \n    async def _execute_single_attempt(self, code, browser_name, headless, test_id, attempt_num):\n        \"\"\"Execute a single attempt of the automation code.\"\"\"\n        logs = [f\"▶️  Attempt {attempt_num + 1}: Executing automation...\"]\n        screenshot = None\n        page_content = ''\n        \n        # If agent execution mode, delegate to agent\n        if self.execution_mode == 'agent':\n            return await self._execute_on_agent(code, browser_name, headless, test_id, attempt_num, logs)\n        \n        try:\n            from playwright.async_api import TimeoutError as PlaywrightTimeout\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True, 'False': False, 'None': None,\n                    'dict': dict, 'list': list, 'str': str, 'int': int,\n                    'float': float, 'bool': bool, 'len': len,\n                    'Exception': Exception, '__import__': __import__,\n                }\n            }\n            \n            local_vars = {}\n            \n            try:\n                exec(code, restricted_globals, local_vars)\n                \n                if 'run_test' not in local_vars:\n                    logs.append(\"❌ Error: Generated code must contain a run_test function\")\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': None,\n                        'can_heal': False\n                    }\n                \n                result = await local_vars['run_test'](browser_name=browser_name, headless=headless)\n                logs.extend(result.get('logs', []))\n                screenshot = result.get('screenshot')\n                \n                if result.get('success'):\n                    logs.append(\"✅ Execution completed successfully\")\n                    return {\n                        'success': True,\n                        'logs': logs,\n                        'screenshot': screenshot\n                    }\n                else:\n                    error_msg = ' '.join(result.get('logs', []))\n                    failed_locator = self.extract_failed_locator(error_msg)\n                    \n                    if failed_locator:\n                        self.failed_locators.append({\n                            'locator': failed_locator,\n                            'error': error_msg,\n                            'attempt': attempt_num + 1\n                        })\n                        \n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': True,\n                            'failed_locator': failed_locator,\n                            'error_message': error_msg,\n                            'page_content': page_content\n                        }\n                    else:\n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': False\n                        }\n                        \n            except PlaywrightTimeout as e:\n                error_msg = str(e)\n                logs.append(f\"⏱️  Timeout error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n            except Exception as e:\n                error_msg = str(e)\n                logs.append(f\"❌ Execution error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n        except Exception as e:\n            logs.append(f'💥 Fatal error: {str(e)}')\n            return {\n                'success': False,\n                'logs': logs,\n                'screenshot': screenshot,\n                'can_heal': False\n            }\n    \n    def extract_failed_locator(self, error_message):\n        \"\"\"Extract the failed locator from error message.\"\"\"\n        patterns = [\n            r'locator\\(\"([^\"]+)\"\\)',\n            r'selector \"([^\"]+)\"',\n            r'element \"([^\"]+)\"',\n            r'get_by_text\\(\"([^\"]+)\"\\)',\n            r'get_by_role\\(\"([^\"]+)\"\\)',\n            r\"locator\\('([^']+)'\\)\",\n            r\"selector '([^']+)'\",\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        \n        return None\n    \n    async def report_failures_to_ai(self, test_id):\n        \"\"\"Report all failures and healing attempts to AI for continuous improvement.\"\"\"\n        if not self.failed_locators or not self.client:\n            return\n        \n        try:\n            failure_report = {\n                'test_id': test_id,\n                'total_failures': len(self.failed_locators),\n                'failures': self.failed_locators,\n                'healed_script': self.healed_script\n            }\n            \n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an automation quality analyst. \nAnalyze the failures and healing attempts to provide insights for improving automation scripts.\nIdentify patterns, suggest best practices, and recommend preventive measures.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Analyze these automation failures and healing attempts:\n\nTest ID: {test_id}\nTotal Failures: {len(self.failed_locators)}\n\nFailures:\n{json.dumps(self.failed_locators, indent=2)}\n\nFinal Healed Script:\n{self.healed_script[:500] if self.healed_script else 'None'}\n\nProvide:\n1. Key insights about failure patterns\n2. Recommendations for better locator strategies\n3. Preventive measures for future scripts\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            insights = response.choices[0].message.content.strip()\n            \n            self.socketio.emit('ai_insights', {\n                'test_id': test_id,\n                'insights': insights,\n                'failure_count': len(self.failed_locators)\n            })\n            \n            return insights\n        except Exception as e:\n            print(f\"AI feedback error: {e}\")\n            return None\n","size_bytes":22898},"visionvault/agents/__init__.py":{"content":"\"\"\"VisionVault Browser Automation Agent\"\"\"\n\n__version__ = \"1.0.0\"","size_bytes":65},"visionvault/agents/config.py":{"content":"import os\nimport uuid\nimport socket\n\n\ndef get_server_url():\n    \"\"\"Auto-detect server URL based on environment\"\"\"\n    # Priority 1: User-specified environment variable\n    if os.environ.get('AGENT_SERVER_URL'):\n        return os.environ.get('AGENT_SERVER_URL')\n\n    # Priority 2: Check if running in same environment as server\n    # Look for common local development ports\n    local_ports = [7890, 5000, 8000, 3000]\n\n    for port in local_ports:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(0.5)\n            result = sock.connect_ex(('127.0.0.1', port))\n            sock.close()\n            if result == 0:  # Port is open\n                print(f\"✓ Detected local server on port {port}\")\n                return f'http://127.0.0.1:{port}'\n        except:\n            pass\n\n    # Priority 3: Default to standard port 5000\n    print(\"ℹ No server detected. Using default: http://127.0.0.1:5000\")\n    print(\"  Set AGENT_SERVER_URL environment variable to override\")\n    return 'http://127.0.0.1:5000'\n\n\n# Global configuration\nSERVER_URL = 'http://127.0.0.1:7890'\nAGENT_ID = str(uuid.uuid4())","size_bytes":1155},"visionvault/agents/recording_session.py":{"content":"import asyncio\nimport os\nimport subprocess\nfrom .config import AGENT_ID, SERVER_URL\n\nclass CodegenRecordingSessionManager:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n        self.sessions = {}  # session_id -> subprocess info\n\n    async def start_recording_session(self, session_id: str, start_url: str = \"\"):\n        \"\"\"Start a Playwright codegen session in a subprocess.\"\"\"\n        if session_id in self.sessions:\n            print(f\"Session {session_id} is already running\")\n            return\n\n        os.makedirs(\"recordings\", exist_ok=True)\n        output_file = os.path.join(\"recordings\", f\"{session_id}.py\")\n\n        cmd = [\n            \"playwright\",\n            \"codegen\",\n            \"--target=python\",\n            \"--output\", output_file\n        ]\n        if start_url:\n            cmd.append(start_url)\n\n        print(f\"🎬 Starting codegen session {session_id}\")\n        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        self.sessions[session_id] = {\n            \"process\": process,\n            \"output_file\": output_file,\n            \"start_url\": start_url\n        }\n\n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"started\",\n            \"output_file\": output_file\n        })\n        \n        asyncio.create_task(self._monitor_process(session_id))\n\n    async def _monitor_process(self, session_id: str):\n        \"\"\"Monitor the recording process and auto-stop when browser closes.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            return\n        \n        process = session[\"process\"]\n        \n        await asyncio.get_event_loop().run_in_executor(None, process.wait)\n        \n        print(f\"🔔 Browser closed for session {session_id}. Auto-stopping recording...\")\n        await self.stop_recording_session(session_id, auto_stopped=True)\n\n    async def stop_recording_session(self, session_id: str, auto_stopped: bool = False):\n        \"\"\"Stop the codegen subprocess and read the generated file.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            print(f\"Session {session_id} not found\")\n            return\n\n        process = session[\"process\"]\n        output_file = session[\"output_file\"]\n        \n        if process.poll() is None:\n            process.terminate()\n            try:\n                await asyncio.get_event_loop().run_in_executor(None, lambda: process.wait(timeout=5))\n            except subprocess.TimeoutExpired:\n                process.kill()\n        \n        await asyncio.sleep(0.5)\n        \n        playwright_code = None\n        actions = []\n        \n        if os.path.exists(output_file):\n            try:\n                with open(output_file, 'r') as f:\n                    playwright_code = f.read()\n                \n                actions = self._extract_actions_from_code(playwright_code)\n                print(f\"✅ Extracted {len(actions)} actions from recording\")\n            except Exception as e:\n                print(f\"⚠️ Error reading recording file: {e}\")\n        \n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"stopped\",\n            \"output_file\": output_file,\n            \"playwright_code\": playwright_code,\n            \"actions\": actions,\n            \"auto_stopped\": auto_stopped\n        })\n\n        print(f\"✅ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped. Output: {output_file}\")\n        del self.sessions[session_id]\n    \n    def _extract_actions_from_code(self, code: str) -> list:\n        \"\"\"Extract human-readable actions with locators from generated Playwright code.\"\"\"\n        actions = []\n        lines = code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            if 'page.goto(' in line:\n                import re\n                match = re.search(r'page\\.goto\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Navigate',\n                        'locator': match.group(1),\n                        'description': f'Navigate to {match.group(1)}'\n                    })\n            \n            elif 'page.click(' in line:\n                import re\n                match = re.search(r'page\\.click\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Click',\n                        'locator': match.group(1),\n                        'description': f'Click element: {match.group(1)}'\n                    })\n            \n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r'page\\.fill\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Type',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Type \"{match.group(2)}\" into {match.group(1)}'\n                    })\n            \n            elif 'page.select_option(' in line:\n                import re\n                match = re.search(r'page\\.select_option\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Select',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Select option \"{match.group(2)}\" in {match.group(1)}'\n                    })\n            \n            elif 'page.check(' in line:\n                import re\n                match = re.search(r'page\\.check\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Check',\n                        'locator': match.group(1),\n                        'description': f'Check checkbox: {match.group(1)}'\n                    })\n            \n            elif 'page.press(' in line or 'page.keyboard.press(' in line:\n                import re\n                match = re.search(r'press\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Press Key',\n                        'locator': match.group(1),\n                        'description': f'Press key: {match.group(1)}'\n                    })\n        \n        return actions\n","size_bytes":6586},"run_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"Entry point for running the VisionVault server.\"\"\"\n\nfrom visionvault.web.app import app, socketio\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 5000))\n    socketio.run(app, host='0.0.0.0', port=port, debug=False, allow_unsafe_werkzeug=True)\n","size_bytes":301},"visionvault/services/action_recorder.py":{"content":"import asyncio\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Browser, async_playwright\nimport uuid\n\n\nclass ActionRecorder:\n    \"\"\"Records browser actions for teaching mode.\"\"\"\n    \n    def __init__(self):\n        self.actions: List[Dict] = []\n        self.is_recording = False\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright_instance = None\n    \n    async def start_recording(self, browser_name='chromium', headless=False):\n        \"\"\"Start recording browser actions.\"\"\"\n        self.actions = []\n        self.is_recording = True\n        self.playwright_instance = await async_playwright().start()\n        browser_type = getattr(self.playwright_instance, browser_name)\n        self.browser = await browser_type.launch(headless=headless)\n        self.page = await self.browser.new_page()\n\n        # Use add_init_script for persistent listeners\n        await self.page.add_init_script(self._get_event_listener_js())\n        await self.page.expose_function('recordUserAction', self._handle_user_action)\n        self.page.on('framenavigated', lambda frame: asyncio.create_task(self._on_navigation(frame)))\n        self.page.on('close', lambda: self._on_page_close())\n        return self.page\n\n    def _get_event_listener_js(self):\n        # JS to listen for click, input, change, keyboard events and call recordUserAction\n        return '''\n        (function() {\n            // Use WeakMap to track debounce timers by element identity, not selector\n            const inputTimers = new WeakMap();\n            const DEBOUNCE_DELAY = 500; // Wait 500ms after last keystroke\n            \n            function getSelector(el) {\n                let selector = el.tagName.toLowerCase();\n                if (el.id) {\n                    selector += '#' + el.id;\n                } else if (el.className && typeof el.className === 'string') {\n                    const classes = el.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            function sendAction(type, selector, value, text, key) {\n                if (window.recordUserAction) {\n                    const action = {type, selector, value, text, timestamp: new Date().toISOString()};\n                    if (key) action.key = key;\n                    window.recordUserAction(action);\n                }\n            }\n            \n            // Record clicks\n            document.addEventListener('click', function(e) {\n                const selector = getSelector(e.target);\n                const text = e.target.innerText ? e.target.innerText.substring(0, 50) : null;\n                sendAction('click', selector, null, text);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                // Clear existing timer for THIS SPECIFIC element\n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                // Set new timer - will only fire if user stops typing for DEBOUNCE_DELAY ms\n                const timer = setTimeout(() => {\n                    sendAction('fill', selector, el.value, null);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record change events (for selects, checkboxes, radios)\n            document.addEventListener('change', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (el.type === 'checkbox' || el.type === 'radio') {\n                    sendAction('check', selector, el.checked, null);\n                } else if (el.tagName.toLowerCase() === 'select') {\n                    sendAction('select', selector, el.value, null);\n                }\n            }, true);\n            \n            // Record keyboard events (Enter, Tab, Escape, etc.)\n            document.addEventListener('keydown', function(e) {\n                // Only record special keys, not regular characters (those are captured via input)\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter key and there's a pending input timer, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        sendAction('fill', selector, el.value, null);\n                        inputTimers.delete(el);\n                    }\n                    \n                    sendAction('press', selector, null, null, e.key);\n                }\n            }, true);\n            \n            // Record form submissions\n            document.addEventListener('submit', function(e) {\n                const selector = getSelector(e.target);\n                sendAction('submit', selector, null, null);\n            }, true);\n        })();\n        '''\n\n    async def _on_navigation(self, frame):\n        \"\"\"Record navigation events.\"\"\"\n        if frame == self.page.main_frame:\n            self.record_action({\n                'type': 'navigate',\n                'url': frame.url,\n                'timestamp': datetime.now().isoformat()\n            })\n            # Re-expose function after navigation\n            try:\n                await self.page.expose_function('recordUserAction', self._handle_user_action)\n            except Exception as e:\n                pass\n\n    def _on_page_close(self):\n        self.is_recording = False\n\n    async def _handle_user_action(self, action):\n        # Receives actions from JS and records them\n        self.record_action(action)\n\n    def record_action(self, action: Dict):\n        \"\"\"Record an action with deduplication.\"\"\"\n        if self.is_recording:\n            # Deduplicate consecutive identical actions\n            if self.actions and self._is_duplicate_action(self.actions[-1], action):\n                return  # Skip duplicate\n            self.actions.append(action)\n    \n    def _is_duplicate_action(self, action1: Dict, action2: Dict) -> bool:\n        \"\"\"Check if two actions are duplicates - only deduplicate identical fills and navigation.\"\"\"\n        action_type = action1.get('type')\n        \n        # Different types are never duplicates\n        if action_type != action2.get('type'):\n            return False\n        \n        # For fill actions: same selector AND same value = duplicate\n        if action_type == 'fill':\n            return (action1.get('selector') == action2.get('selector') and \n                    action1.get('value') == action2.get('value'))\n        \n        # For navigation: same URL = duplicate\n        if action_type in ('navigate', 'goto'):\n            return action1.get('url') == action2.get('url')\n        \n        # Allow all other actions (clicks, presses, etc.) - user may intentionally repeat them\n        return False\n    \n    def record_goto(self, url: str):\n        \"\"\"Record a goto action.\"\"\"\n        self.record_action({\n            'type': 'goto',\n            'url': url,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_click(self, selector: str, text: Optional[str] = None):\n        \"\"\"Record a click action.\"\"\"\n        self.record_action({\n            'type': 'click',\n            'selector': selector,\n            'text': text,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_fill(self, selector: str, value: str):\n        \"\"\"Record a fill/input action.\"\"\"\n        self.record_action({\n            'type': 'fill',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_select(self, selector: str, value: str):\n        \"\"\"Record a select action.\"\"\"\n        self.record_action({\n            'type': 'select',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_check(self, selector: str):\n        \"\"\"Record a checkbox/radio check action.\"\"\"\n        self.record_action({\n            'type': 'check',\n            'selector': selector,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_wait(self, wait_type: str, selector: Optional[str] = None, timeout: int = 5000):\n        \"\"\"Record a wait action.\"\"\"\n        action = {\n            'type': 'wait',\n            'wait_type': wait_type,  # 'navigation', 'selector', 'timeout'\n            'timeout': timeout,\n            'timestamp': datetime.now().isoformat()\n        }\n        if selector:\n            action['selector'] = selector\n        self.record_action(action)\n    \n    async def stop_recording(self):\n        \"\"\"Stop recording and return captured actions.\"\"\"\n        self.is_recording = False\n        \n        # Close browser\n        if self.browser:\n            await self.browser.close()\n        if self.playwright_instance:\n            await self.playwright_instance.stop()\n        \n        return self.actions\n    \n    def generate_playwright_code(self, actions: Optional[List[Dict]] = None) -> str:\n        \"\"\"Generate Playwright code from recorded actions.\"\"\"\n        if actions is None:\n            actions = self.actions\n        \n        if not actions:\n            return \"\"\n        \n        # Start building the code\n        code_lines = [\n            \"async def run_test(browser_name='chromium', headless=True):\",\n            \"    from playwright.async_api import async_playwright\",\n            \"    logs = []\",\n            \"    screenshot = None\",\n            \"    \",\n            \"    try:\",\n            \"        async with async_playwright() as p:\",\n            \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n            \"            page = await browser.new_page()\",\n            \"            \",\n        ]\n        \n        # Convert actions to code\n        for i, action in enumerate(actions):\n            action_type = action.get('type')\n            \n            if action_type == 'goto' or action_type == 'navigate':\n                url = action.get('url')\n                code_lines.append(f\"            await page.goto('{url}')\")\n                code_lines.append(f\"            logs.append('Navigated to {url}')\")\n            \n            elif action_type == 'click':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.click('{selector}')\")\n                code_lines.append(f\"            logs.append('Clicked {selector}')\")\n            \n            elif action_type == 'fill':\n                selector = action.get('selector')\n                value = action.get('value', '').replace(\"'\", \"\\\\'\")\n                code_lines.append(f\"            await page.fill('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Filled {selector}')\")\n            \n            elif action_type == 'select':\n                selector = action.get('selector')\n                value = action.get('value')\n                code_lines.append(f\"            await page.select_option('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option in {selector}')\")\n            \n            elif action_type == 'check':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.check('{selector}')\")\n                code_lines.append(f\"            logs.append('Checked {selector}')\")\n            \n            elif action_type == 'wait':\n                wait_type = action.get('wait_type')\n                if wait_type == 'navigation':\n                    code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n                    code_lines.append(\"            logs.append('Waited for navigation')\")\n                elif wait_type == 'selector':\n                    selector = action.get('selector')\n                    timeout = action.get('timeout', 5000)\n                    code_lines.append(f\"            await page.wait_for_selector('{selector}', timeout={timeout})\")\n                    code_lines.append(f\"            logs.append('Waited for {selector}')\")\n                elif wait_type == 'timeout':\n                    timeout = action.get('timeout', 1000)\n                    code_lines.append(f\"            await page.wait_for_timeout({timeout})\")\n                    code_lines.append(f\"            logs.append('Waited {timeout}ms')\")\n            \n            elif action_type == 'press':\n                selector = action.get('selector')\n                key = action.get('key', 'Enter')\n                code_lines.append(f\"            await page.press('{selector}', '{key}')\")\n                code_lines.append(f\"            logs.append('Pressed {key} on {selector}')\")\n            \n            elif action_type == 'submit':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.locator('{selector}').press('Enter')\")\n                code_lines.append(f\"            logs.append('Submitted form {selector}')\")\n        \n        # Add screenshot and closing code\n        code_lines.extend([\n            \"            \",\n            \"            # Take screenshot before closing\",\n            \"            screenshot = await page.screenshot()\",\n            \"            logs.append('Screenshot captured')\",\n            \"            \",\n            \"            await browser.close()\",\n            \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n            \"    \",\n            \"    except Exception as e:\",\n            \"        logs.append(f'Error: {str(e)}')\",\n            \"        if 'page' in locals():\",\n            \"            try:\",\n            \"                screenshot = await page.screenshot()\",\n            \"            except:\",\n            \"                pass\",\n            \"        if 'browser' in locals():\",\n            \"            try:\",\n            \"                await browser.close()\",\n            \"            except:\",\n            \"                pass\",\n            \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    @staticmethod\n    def parse_code_to_actions(playwright_code: str) -> List[Dict]:\n        \"\"\"\n        Parse Playwright code to extract actions (reverse operation).\n        This is a simple parser that looks for common patterns.\n        \"\"\"\n        actions = []\n        lines = playwright_code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            # Parse goto\n            if 'page.goto(' in line:\n                import re\n                match = re.search(r\"page\\.goto\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'goto',\n                        'url': match.group(1)\n                    })\n            \n            # Parse click\n            elif 'page.click(' in line:\n                import re\n                match = re.search(r\"page\\.click\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'click',\n                        'selector': match.group(1)\n                    })\n            \n            # Parse fill\n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r\"page\\.fill\\(['\\\"](.+?)['\\\"],\\s*['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'fill',\n                        'selector': match.group(1),\n                        'value': match.group(2)\n                    })\n            \n            # Add more parsers as needed\n        \n        return actions\n\n\nclass InteractiveRecorder(ActionRecorder):\n    \"\"\"\n    Enhanced recorder that can intercept and record actual user interactions.\n    This would be used with a UI where users can click through a task.\n    \"\"\"\n    \n    async def start_interactive_recording(self, browser_name='chromium'):\n        \"\"\"Start interactive recording with visible browser.\"\"\"\n        page = await self.start_recording(browser_name, headless=False)\n        \n        # Inject improved JavaScript with debouncing and keyboard capture\n        await page.add_init_script(\"\"\"\n            window.__recordedActions = [];\n            const inputTimers = new WeakMap();  // Track by element identity, not selector\n            const DEBOUNCE_DELAY = 500;\n            \n            // Helper to generate CSS selector (must be defined first!)\n            function getSelector(element) {\n                let selector = element.tagName.toLowerCase();\n                if (element.id) {\n                    selector += '#' + element.id;\n                } else if (element.className && typeof element.className === 'string') {\n                    const classes = element.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            // Record clicks\n            document.addEventListener('click', (e) => {\n                const selector = getSelector(e.target);\n                window.__recordedActions.push({\n                    type: 'click',\n                    selector: selector,\n                    text: e.target.textContent ? e.target.textContent.trim().substring(0, 50) : '',\n                    timestamp: new Date().toISOString()\n                });\n                console.log('🎬 Recorded click:', selector);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', (e) => {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                const timer = setTimeout(() => {\n                    window.__recordedActions.push({\n                        type: 'fill',\n                        selector: selector,\n                        value: el.value,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('🎬 Recorded fill:', selector, '=', el.value);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record keyboard events\n            document.addEventListener('keydown', (e) => {\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter and there's pending input, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        window.__recordedActions.push({\n                            type: 'fill',\n                            selector: selector,\n                            value: el.value,\n                            timestamp: new Date().toISOString()\n                        });\n                        console.log('🎬 Recorded fill (Enter):', selector, '=', el.value);\n                        inputTimers.delete(el);\n                    }\n                    \n                    window.__recordedActions.push({\n                        type: 'press',\n                        selector: selector,\n                        key: e.key,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('🎬 Recorded keypress:', e.key, 'on', selector);\n                }\n            }, true);\n            \n            console.log('✅ VisionVault recording initialized - actions will be captured automatically');\n        \"\"\")\n        \n        return page\n    \n    async def get_recorded_actions_from_page(self):\n        \"\"\"Get actions recorded by JavaScript injection.\"\"\"\n        if not self.page:\n            return []\n        \n        try:\n            js_actions = await self.page.evaluate(\"window.__recordedActions || []\")\n            return js_actions\n        except:\n            return []\n","size_bytes":21461},"visionvault/services/code_validator.py":{"content":"import ast\nimport re\n\nclass CodeValidator:\n    ALLOWED_IMPORTS = {\n        'playwright.async_api',\n        'asyncio',\n        'time',\n        'datetime',\n        're',\n        'json',\n        'base64'\n    }\n    \n    DANGEROUS_MODULES = {\n        'os', 'sys', 'subprocess', 'shutil', 'eval', 'exec',\n        'compile', '__import__', 'open', 'file', 'input',\n        'execfile', 'reload', 'importlib', 'pickle', 'shelve',\n        'socket', 'urllib', 'requests', 'http', 'ftplib',\n        'telnetlib', 'smtplib', 'poplib', 'imaplib'\n    }\n    \n    def __init__(self):\n        self.errors = []\n    \n    def validate(self, code):\n        self.errors = []\n        \n        if not code or not isinstance(code, str):\n            self.errors.append(\"Code must be a non-empty string\")\n            return False\n        \n        if not self._check_function_structure(code):\n            return False\n        \n        if not self._check_dangerous_imports(code):\n            return False\n        \n        if not self._check_dangerous_patterns(code):\n            return False\n        \n        try:\n            tree = ast.parse(code)\n            if not self._validate_ast(tree):\n                return False\n        except SyntaxError as e:\n            self.errors.append(f\"Syntax error: {str(e)}\")\n            return False\n        \n        return True\n    \n    def _check_function_structure(self, code):\n        if 'async def run_test' not in code:\n            self.errors.append(\"Code must contain 'async def run_test' function\")\n            return False\n        \n        if 'playwright.async_api import async_playwright' not in code:\n            self.errors.append(\"Code must use 'from playwright.async_api import async_playwright'\")\n            return False\n        \n        return True\n    \n    def _check_dangerous_imports(self, code):\n        for module in self.DANGEROUS_MODULES:\n            patterns = [\n                f'import {module}',\n                f'from {module}',\n                f'__import__(\"{module}\")',\n                f\"__import__('{module}')\"\n            ]\n            for pattern in patterns:\n                if pattern in code:\n                    self.errors.append(f\"Dangerous import detected: {module}\")\n                    return False\n        \n        return True\n    \n    def _check_dangerous_patterns(self, code):\n        dangerous_patterns = [\n            (r'\\beval\\s*\\(', 'eval() function'),\n            (r'\\bexec\\s*\\(', 'exec() function'),\n            (r'\\b__import__\\s*\\(', '__import__() function'),\n            (r'\\bcompile\\s*\\(', 'compile() function'),\n            (r'\\bopen\\s*\\(', 'open() function (file access)'),\n            (r'\\.system\\s*\\(', 'system() call'),\n            (r'\\.popen\\s*\\(', 'popen() call'),\n            (r'\\.spawn\\s*\\(', 'spawn() call'),\n        ]\n        \n        for pattern, name in dangerous_patterns:\n            if re.search(pattern, code, re.IGNORECASE):\n                self.errors.append(f\"Dangerous pattern detected: {name}\")\n                return False\n        \n        return True\n    \n    def _validate_ast(self, tree):\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if not self._is_allowed_import(alias.name):\n                        self.errors.append(f\"Disallowed import: {alias.name}\")\n                        return False\n            \n            elif isinstance(node, ast.ImportFrom):\n                if node.module and not self._is_allowed_import(node.module):\n                    self.errors.append(f\"Disallowed import from: {node.module}\")\n                    return False\n            \n            elif isinstance(node, ast.Call):\n                if isinstance(node.func, ast.Name):\n                    if node.func.id in ['eval', 'exec', 'compile', '__import__', 'open']:\n                        self.errors.append(f\"Dangerous function call: {node.func.id}\")\n                        return False\n        \n        return True\n    \n    def _is_allowed_import(self, module_name):\n        for allowed in self.ALLOWED_IMPORTS:\n            if module_name.startswith(allowed):\n                return True\n        return False\n    \n    def get_errors(self):\n        return self.errors\n","size_bytes":4240},"visionvault/web/__init__.py":{"content":"","size_bytes":0},"visionvault/agents/test_executor.py":{"content":"import asyncio\nfrom .utils import encode_screenshot\n\n\nclass TestExecutor:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n\n    async def execute_test(self, test_id, code, browser_name, mode):\n        \"\"\"Execute a test case\"\"\"\n        headless = mode == 'headless'\n\n        try:\n            self.socket_client.emit('agent_log', {\n                'test_id': test_id,\n                'message': f'Preparing to execute test in {mode} mode...'\n            })\n\n            local_vars = {}\n            exec(code, {}, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('agent_result', {\n                    'test_id': test_id,\n                    'success': False,\n                    'logs': ['Error: run_test missing'],\n                    'screenshot': None\n                })\n                return\n\n            run_test = local_vars['run_test']\n            result = await run_test(browser_name=browser_name, headless=headless)\n\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': result.get('success', False),\n                'logs': result.get('logs', []),\n                'screenshot': screenshot_b64\n            })\n\n            print(f\"Test {test_id} completed: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n        except Exception as e:\n            print(f\"Execution error: {e}\")\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': False,\n                'logs': [str(e)],\n                'screenshot': None\n            })","size_bytes":1717},"run_agent.py":{"content":"from visionvault.agents.main import main\n\nif __name__ == '__main__':\n    main()","size_bytes":79},"visionvault/services/__init__.py":{"content":"","size_bytes":0},"config/gunicorn.conf.py":{"content":"import logging\nimport signal\n\n# Bind to 0.0.0.0:5000 (required for Replit environment)\nbind = \"0.0.0.0:5000\"\n\n# Worker class for async support with SocketIO\nworker_class = \"gevent\"\n\n# Number of workers\nworkers = 1\n\n# Set log level to WARNING to suppress SIGWINCH INFO messages\nloglevel = \"warning\"\n\n# Custom logger class to filter out SIGWINCH messages\nclass FilteredGunicornLogger(logging.Logger):\n    def log(self, level, msg, *args, **kwargs):\n        if \"Handling signal: winch\" not in str(msg):\n            super().log(level, msg, *args, **kwargs)\n\nlogconfig_dict = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'generic': {\n            'format': '%(asctime)s [%(process)d] [%(levelname)s] %(message)s',\n            'datefmt': '[%Y-%m-%d %H:%M:%S %z]',\n        },\n    },\n    'filters': {\n        'winch_filter': {\n            '()': lambda: type('WinchFilter', (), {\n                'filter': lambda self, record: 'Handling signal: winch' not in record.getMessage()\n            })()\n        }\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': 'generic',\n            'filters': ['winch_filter'],\n            'stream': 'ext://sys.stdout'\n        },\n    },\n    'root': {\n        'level': 'INFO',\n        'handlers': ['console']\n    },\n    'loggers': {\n        'gunicorn.error': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        },\n        'gunicorn.access': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        }\n    }\n}\n","size_bytes":1643},"visionvault/web/app.py":{"content":"from gevent import monkey\nmonkey.patch_all()\n\nimport os\nimport json\nimport sqlite3\nimport uuid\nimport time\nfrom datetime import datetime\nfrom flask import Flask, render_template, request, jsonify, send_from_directory, Response\nfrom flask_socketio import SocketIO, emit\nfrom flask_cors import CORS\nfrom openai import OpenAI\nfrom visionvault.services.executor import ServerExecutor\nfrom visionvault.services.healing_executor import HealingExecutor\nfrom visionvault.services.code_validator import CodeValidator\nfrom visionvault.core.models import Database, LearnedTask, TaskExecution\nfrom visionvault.services.vector_store import SemanticSearch\nimport base64\nimport asyncio\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key-change-in-production')\napp.config['UPLOAD_FOLDER'] = 'data/uploads'\napp.config['DATABASE_PATH'] = 'data/automation.db'\nCORS(app)\nsocketio = SocketIO(\n    app, \n    async_mode='gevent', \n    cors_allowed_origins=\"*\",\n    ping_timeout=60,           # 60 seconds before considering connection dead\n    ping_interval=25,          # Send ping every 25 seconds to keep connection alive\n    max_http_buffer_size=10**8,  # 100MB buffer for large payloads\n    engineio_logger=False,     # Reduce logging overhead\n    logger=False\n)\n\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'screenshots'), exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'logs'), exist_ok=True)\n\nopenai_api_key = os.environ.get('OPENAI_API_KEY')\ngemini_api_key = os.environ.get('GEMINI_API_KEY')\n\nif openai_api_key:\n    client = OpenAI(api_key=openai_api_key)\n    print(\"✅ OpenAI client initialized for code generation\")\nelse:\n    client = None\n    print(\"WARNING: OPENAI_API_KEY is not set. AI code generation will not be available.\")\n\nif gemini_api_key:\n    try:\n        semantic_search = SemanticSearch(api_key=gemini_api_key)\n        print(\"✅ Semantic search service initialized with Gemini embeddings\")\n    except Exception as e:\n        semantic_search = None\n        print(f\"⚠️ Failed to initialize semantic search: {e}\")\nelse:\n    semantic_search = None\n    print(\"WARNING: GEMINI_API_KEY is not set. Semantic search will not be available.\")\n\nconnected_agents = {}\nactive_healing_executors = {}\n\n# Initialize database with new tables\ndb = Database()\nprint(\"✅ Database initialized with persistent learning tables\")\n\n\ndef generate_playwright_code(natural_language_command, browser='chromium'):\n    if not client:\n        raise Exception(\"OpenAI API key not configured. Please set the OPENAI_API_KEY environment variable.\")\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": \"\"\"You are an expert at converting natural language commands into Playwright Python code.\nGenerate complete, executable Playwright code that:\n1. Uses async/await syntax\n2. Includes proper browser launch with the specified browser\n3. Has error handling with proper cleanup\n4. Returns a dict with 'success', 'logs', and 'screenshot' keys\n5. ALWAYS takes screenshot BEFORE closing browser (CRITICAL)\n6. The code should be a complete async function named 'run_test' that takes browser_name and headless parameters\n\nCRITICAL RULE: Always take screenshot BEFORE closing browser/page. Never close browser before screenshot.\n\nExample structure:\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    browser = None\n    page = None\n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            # Your automation code here\n            logs.append(\"Step completed\")\n            # CRITICAL: Screenshot BEFORE closing\n            screenshot = await page.screenshot()\n            await browser.close()\n            return {'success': True, 'logs': logs, 'screenshot': screenshot}\n    except Exception as e:\n        logs.append(f\"Error: {str(e)}\")\n        # Try to get screenshot even on error, BEFORE cleanup\n        if page:\n            try:\n                screenshot = await page.screenshot()\n            except:\n                pass\n        if browser:\n            try:\n                await browser.close()\n            except:\n                pass\n        return {'success': False, 'logs': logs, 'screenshot': screenshot}\n\nOnly return the function code, no explanations.\"\"\"},\n                {\"role\": \"user\", \"content\": f\"Convert this to Playwright code for {browser}: {natural_language_command}\"}\n            ],\n            temperature=0.3\n        )\n\n        code = response.choices[0].message.content.strip()\n        if code.startswith('```python'):\n            code = code[9:]\n        if code.startswith('```'):\n            code = code[3:]\n        if code.endswith('```'):\n            code = code[:-3]\n\n        return code.strip()\n    except Exception as e:\n        raise Exception(f\"OpenAI API error: {str(e)}\")\n\n\ndef generate_playwright_code_from_recording(recorded_events):\n    \"\"\"\n    Convert recorded events from ComprehensiveRecordingSessionManager to executable Playwright code.\n    This generates proper Playwright code with full browser launch, error handling, and screenshot capture.\n    \"\"\"\n    if not recorded_events or len(recorded_events) == 0:\n        raise Exception(\"No recorded events to convert to code\")\n    \n    # Start building the code\n    code_lines = [\n        \"async def run_test(browser_name='chromium', headless=True):\",\n        \"    from playwright.async_api import async_playwright\",\n        \"    logs = []\",\n        \"    screenshot = None\",\n        \"    browser = None\",\n        \"    page = None\",\n        \"    \",\n        \"    try:\",\n        \"        async with async_playwright() as p:\",\n        \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n        \"            page = await browser.new_page()\",\n        \"            \",\n    ]\n    \n    # Convert each event to Playwright code\n    for i, event in enumerate(recorded_events):\n        action = event.get('action')\n        target = event.get('target', '')\n        value = event.get('value', '')\n        description = event.get('description', '')\n        attributes = event.get('attributes', {})\n        \n        # Escape single quotes in strings\n        if value:\n            value = str(value).replace(\"'\", \"\\\\'\")\n        if target:\n            target = str(target).replace(\"'\", \"\\\\'\")\n        \n        if action == 'navigation':\n            # Navigation action\n            code_lines.append(f\"            await page.goto('{target}')\")\n            code_lines.append(f\"            logs.append('Navigated to {target}')\")\n            \n        elif action == 'click':\n            # Check if next event is navigation (click causes page change)\n            next_event = recorded_events[i + 1] if i + 1 < len(recorded_events) else None\n            is_link = attributes.get('tag') == 'a'\n            is_form_submit = attributes.get('type') == 'submit' or attributes.get('isFormSubmit')\n            causes_navigation = (next_event and next_event.get('action') == 'navigation')\n            \n            # If click causes navigation, use expect_navigation\n            if causes_navigation or is_link or is_form_submit:\n                code_lines.append(f\"            # Click that triggers navigation\")\n                code_lines.append(f\"            async with page.expect_navigation():\")\n                code_lines.append(f\"                await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target} and navigated')\")\n            else:\n                # Regular click without navigation\n                code_lines.append(f\"            await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target}')\")\n            \n        elif action == 'type':\n            # Input/fill action\n            code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n            code_lines.append(f\"            logs.append('Typed into {target}')\")\n            \n        elif action == 'change':\n            # Change action (select, checkbox, radio)\n            attributes = event.get('attributes', {})\n            tag = attributes.get('tag', 'unknown')\n            \n            if tag == 'select':\n                code_lines.append(f\"            await page.select_option('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option {value} in {target}')\")\n            elif attributes.get('type') in ['checkbox', 'radio']:\n                if value:  # If checked\n                    code_lines.append(f\"            await page.check('{target}')\")\n                    code_lines.append(f\"            logs.append('Checked {target}')\")\n                else:\n                    code_lines.append(f\"            await page.uncheck('{target}')\")\n                    code_lines.append(f\"            logs.append('Unchecked {target}')\")\n            else:\n                code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Changed {target} to {value}')\")\n                \n        elif action == 'keypress':\n            # Key press action\n            key = event.get('key', 'Enter')\n            code_lines.append(f\"            await page.keyboard.press('{key}')\")\n            code_lines.append(f\"            logs.append('Pressed {key} key')\")\n            \n        elif action == 'dialog':\n            # Dialog detection (alert, confirm, prompt)\n            dialog_type = event.get('dialog_type', 'alert')\n            dialog_message = event.get('target', '').replace(\"'\", \"\\\\'\")\n            code_lines.append(f\"            # Handle {dialog_type} dialog\")\n            code_lines.append(f\"            # Dialog will auto-accept in Playwright\")\n            code_lines.append(f\"            logs.append('Dialog appeared: {dialog_message}')\")\n        \n        elif action == 'dialog_accept':\n            # Dialog acceptance\n            dialog_type = event.get('target', 'dialog')\n            code_lines.append(f\"            logs.append('Accepted {dialog_type}')\")\n        \n        elif action == 'popup_opened':\n            # New window/popup opened\n            popup_url = target.replace(\"'\", \"\\\\'\") if target else 'popup'\n            code_lines.append(f\"            # New popup window opened\")\n            code_lines.append(f\"            # Playwright automatically tracks popup pages\")\n            code_lines.append(f\"            logs.append('Popup opened: {popup_url}')\")\n        \n        elif action == 'page_created':\n            # New tab created\n            page_url = target.replace(\"'\", \"\\\\'\") if target else 'new page'\n            code_lines.append(f\"            # New page/tab opened\")\n            code_lines.append(f\"            logs.append('New page opened: {page_url}')\")\n        \n        elif action == 'frame_attached':\n            # iFrame/widget loaded\n            frame_name = event.get('frame_name', 'widget')\n            code_lines.append(f\"            # Frame/Widget loaded: {frame_name}\")\n            code_lines.append(f\"            logs.append('Frame attached: {frame_name}')\")\n            \n        elif action == 'form_submit':\n            # Form submission - press Enter on the form\n            code_lines.append(f\"            await page.keyboard.press('Enter')\")\n            code_lines.append(f\"            logs.append('Submitted form')\")\n    \n    code_lines.extend([\n        \"            \",\n        \"            # Take screenshot before closing\",\n        \"            screenshot = await page.screenshot()\",\n        \"            logs.append('Screenshot captured')\",\n        \"            \",\n        \"            await browser.close()\",\n        \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n        \"    \",\n        \"    except Exception as e:\",\n        \"        logs.append(f'Error: {str(e)}')\",\n        \"        if 'page' in locals():\",\n        \"            try:\",\n        \"                screenshot = await page.screenshot()\",\n        \"            except:\",\n        \"                pass\",\n        \"        if 'browser' in locals():\",\n        \"            try:\",\n        \"                await browser.close()\",\n        \"            except:\",\n        \"                pass\",\n        \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n    ])\n    \n    return \"\\n\".join(code_lines)\n\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/api/history')\ndef get_history():\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT * FROM test_history ORDER BY created_at DESC LIMIT 50')\n    rows = c.fetchall()\n    conn.close()\n    \n    history = []\n    for row in rows:\n        history.append({\n            'id': row[0],\n            'command': row[1],\n            'generated_code': row[2],\n            'healed_code': row[3],\n            'browser': row[4],\n            'mode': row[5],\n            'execution_location': row[6],\n            'status': row[7],\n            'logs': row[8],\n            'screenshot_path': row[9],\n            'created_at': row[10]\n        })\n    \n    return jsonify(history)\n\n@app.route('/api/history/rerun/<int:history_id>', methods=['POST'])\ndef rerun_from_history(history_id):\n    \"\"\"Re-execute a test from history using healed code if available, otherwise generated code.\"\"\"\n    try:\n        data = request.json or {}\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT command, generated_code, healed_code, browser, mode, execution_location FROM test_history WHERE id=?', (history_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return jsonify({'error': 'History item not found'}), 404\n        \n        command, generated_code, healed_code, browser, mode, execution_location = row\n        \n        code_to_use = healed_code if healed_code else generated_code\n        code_source = 'healed' if healed_code else 'generated'\n        \n        use_healing = data.get('use_healing', True)\n        auto_save = data.get('auto_save', False)\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, healed_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, healed_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        print(f\"🔄 Re-running test from history #{history_id} as test #{test_id}\")\n        print(f\"   Using {code_source} code\")\n        print(f\"   Command: {command}\")\n        \n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if use_healing:\n                socketio.start_background_task(execute_agent_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                if agent_sid:\n                    socketio.emit('execute_on_agent', {\n                        'test_id': test_id,\n                        'code': code_to_use,\n                        'browser': browser,\n                        'mode': mode\n                    }, to=agent_sid)\n                else:\n                    return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id,\n            'code': code_to_use,\n            'code_source': code_source,\n            'original_history_id': history_id,\n            'command': command\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_test():\n    data = request.json\n    command = data.get('command')\n    browser = data.get('browser', 'chromium')\n    mode = data.get('mode', 'headless')\n    execution_location = data.get('execution_location', 'server')\n    use_healing = data.get('use_healing', True)\n    auto_save = data.get('auto_save', False)\n    \n    if not command:\n        return jsonify({'error': 'Command is required'}), 400\n    \n    try:\n        code_source = 'generated'\n        learned_task_id = None\n        learned_task_name = None\n        similarity_score = 0.0\n        \n        # OPTIMIZATION: First try to find a similar learned task\n        if semantic_search:\n            try:\n                print(f\"🔍 Searching for similar learned tasks for: '{command}'\")\n                results = semantic_search.search_tasks(command, top_k=1)\n                \n                if results and len(results) > 0:\n                    best_match = results[0]\n                    similarity_score = best_match.get('similarity_score', 0)\n                    \n                    # Use learned task if similarity is high enough (>75%)\n                    if similarity_score > 0.75:\n                        learned_task_id = best_match['task_id']\n                        learned_task_name = best_match['task_name']\n                        generated_code = best_match['playwright_code']\n                        code_source = 'learned'\n                        print(f\"✅ Using learned task '{learned_task_name}' (similarity: {similarity_score:.2%})\")\n                    else:\n                        print(f\"⚠️  Found task but similarity too low ({similarity_score:.2%}), generating new code\")\n                        generated_code = generate_playwright_code(command, browser)\n                else:\n                    print(\"ℹ️  No similar tasks found, generating new code\")\n                    generated_code = generate_playwright_code(command, browser)\n            except Exception as search_error:\n                print(f\"⚠️  Semantic search failed: {search_error}, falling back to code generation\")\n                generated_code = generate_playwright_code(command, browser)\n        else:\n            print(\"ℹ️  Semantic search not available, generating new code\")\n            generated_code = generate_playwright_code(command, browser)\n        \n        validator = CodeValidator()\n        if not validator.validate(generated_code):\n            error_msg = \"Code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute the code\n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            # Agent execution - find agent's session ID\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break  # Get the first available agent\n            \n            if use_healing:\n                socketio.start_background_task(execute_agent_with_healing, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                if agent_sid:\n                    socketio.emit('execute_on_agent', {\n                        'test_id': test_id,\n                        'code': generated_code,\n                        'browser': browser,\n                        'mode': mode\n                    }, to=agent_sid)\n                else:\n                    return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id, \n            'code': generated_code,\n            'code_source': code_source,\n            'learned_task_id': learned_task_id,\n            'learned_task_name': learned_task_name,\n            'similarity_score': similarity_score\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\ndef execute_on_server(test_id, code, browser, mode, auto_save=False, original_command=None):\n    executor = ServerExecutor()\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on server in {mode} mode...'\n    })\n    \n    result = executor.execute(code, browser, headless)\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    code = code if code else 'No code generated.'\n\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=code,\n                description=f\"Auto-saved from successful execution in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path\n    })\n\ndef execute_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing with healing in {mode} mode...'\n    })\n    \n    try:\n        result = asyncio.run(healing_executor.execute_with_healing(code, browser, headless, test_id))\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\n💾 SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ✅ Database updated successfully\", flush=True)\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from successful {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\ndef execute_agent_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    \"\"\"Execute automation on agent with server-coordinated healing.\"\"\"\n    import gevent\n    from gevent import monkey\n    \n    # Find the agent's session ID\n    agent_sid = None\n    for sid in connected_agents:\n        agent_sid = sid\n        break  # Get the first available agent\n    \n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    healing_executor.execution_mode = 'agent'  # Mark as agent execution\n    healing_executor.agent_sid = agent_sid  # Store agent session ID\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on agent with healing in {mode} mode...'\n    })\n    \n    # Run async code using asyncio.run() which creates its own event loop\n    async def _run_healing():\n        return await healing_executor.execute_with_healing(code, browser, headless, test_id)\n    \n    try:\n        # Use asyncio.run() to execute the async function\n        # This creates a new event loop specifically for this call\n        result = asyncio.run(_run_healing())\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\n💾 SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from agent {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'agent', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful agent {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    print(f\"  ✅ Database updated successfully\", flush=True)\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\n@app.route('/api/heal', methods=['POST'])\ndef heal_locator():\n    data = request.json\n    test_id = data.get('test_id')\n    failed_locator = data.get('failed_locator')\n    healed_locator = data.get('healed_locator')\n    \n    if not all([test_id, failed_locator, healed_locator]):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT generated_code, healed_code FROM test_history WHERE id=?', (test_id,))\n        row = c.fetchone()\n        \n        if not row:\n            return jsonify({'error': 'Test not found'}), 404\n        \n        original_code = row[0]\n        current_healed = row[1] or original_code\n        \n        new_healed = current_healed.replace(failed_locator, healed_locator)\n        \n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (new_healed, test_id))\n        conn.commit()\n        conn.close()\n        \n        socketio.emit('script_healed', {\n            'test_id': test_id,\n            'healed_script': new_healed,\n            'failed_locator': failed_locator,\n            'healed_locator': healed_locator\n        })\n        \n        return jsonify({'success': True, 'healed_script': new_healed})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/uploads/<path:filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\n@app.route('/api/agent/download')\ndef download_agent():\n    # Get the current server URL dynamically\n    replit_domain = os.environ.get('REPLIT_DEV_DOMAIN', 'localhost:5000')\n    server_url = f'https://{replit_domain}' if replit_domain != 'localhost:5000' else 'http://localhost:5000'\n    \n    # Read the local agent file\n    with open('visionvault/agents/local_agent.py', 'r', encoding='utf-8') as f:\n        agent_code = f.read()\n    \n    # Replace the default port in get_server_url to prioritize the current server\n    # This ensures downloaded agent connects to the right server by default\n    agent_code = agent_code.replace(\n        'local_ports = [5000, 8000, 3000, 7890]',\n        f'# Auto-configured for this server\\n    local_ports = [{replit_domain.split(\":\")[-1] if \":\" in replit_domain else \"5000\"}, 5000, 8000, 3000, 7890]'\n    )\n    \n    # Also add the server URL as a comment for reference\n    agent_code = f'# Auto-downloaded from: {server_url}\\n# This agent will automatically connect to the server\\n\\n{agent_code}'\n    \n    # Create a temporary response with the modified content\n    return Response(\n        agent_code,\n        mimetype='text/x-python',\n        headers={'Content-Disposition': 'attachment; filename=local_agent.py'}\n    )\n\n# ========== Persistent Learning API Endpoints ==========\n\n@app.route('/api/tasks', methods=['GET'])\ndef get_all_tasks():\n    \"\"\"Get all learned tasks.\"\"\"\n    try:\n        limit = request.args.get('limit', 100, type=int)\n        tasks = LearnedTask.get_all(limit=limit)\n        return jsonify([task.to_dict() for task in tasks])\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['GET'])\ndef get_task(task_id):\n    \"\"\"Get a specific learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        return jsonify(task.to_dict())\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/save', methods=['POST'])\ndef save_learned_task():\n    \"\"\"Save a new learned task or update existing one.\"\"\"\n    try:\n        data = request.json\n        \n        # Extract task data\n        task_id = data.get('task_id') or str(uuid.uuid4())\n        task_name = data.get('task_name')\n        playwright_code = data.get('playwright_code')\n        description = data.get('description', '')\n        steps = data.get('steps', [])\n        tags = data.get('tags', [])\n        \n        if not task_name or not playwright_code:\n            return jsonify({'error': 'task_name and playwright_code are required'}), 400\n        \n        # Create task object\n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags\n        )\n        \n        # Save to database\n        task.save()\n        \n        # Index for semantic search\n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"✅ Task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"⚠️ Failed to index task for search: {e}\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict()\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['DELETE'])\ndef delete_task(task_id):\n    \"\"\"Delete a learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Remove from semantic search index\n        if semantic_search:\n            semantic_search.delete_task_from_index(task_id)\n        \n        # Delete from database\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM learned_tasks WHERE task_id=?', (task_id,))\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/search', methods=['POST'])\ndef search_tasks():\n    \"\"\"Search for tasks using natural language.\"\"\"\n    try:\n        data = request.json\n        query = data.get('query')\n        top_k = data.get('top_k', 5)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Semantic search requires an OpenAI API key to generate embeddings.'\n            }), 400\n        \n        # Search for relevant tasks\n        results = semantic_search.search_tasks(query, top_k=top_k)\n        \n        return jsonify({\n            'query': query,\n            'results': results\n        })\n    except Exception as e:\n        error_msg = str(e)\n        # Check if it's an API key or embedding-related error\n        if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n            return jsonify({\n                'error': f'OPENAI_API_KEY error: {error_msg}'\n            }), 400\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>/execute', methods=['POST'])\ndef execute_learned_task(task_id):\n    \"\"\"Execute a learned task.\"\"\"\n    try:\n        data = request.json\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        \n        # Get the task\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Use the task's code instead of generating new code\n        code = task.playwright_code\n        \n        # Validate the code\n        validator = CodeValidator()\n        if not validator.validate(code):\n            error_msg = \"Task code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        # Create a test history entry for tracking\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (f\"Learned Task: {task.task_name}\", code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute the task\n        if execution_location == 'server':\n            socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if agent_sid:\n                socketio.emit('execute_on_agent', {\n                    'test_id': test_id,\n                    'code': code,\n                    'browser': browser,\n                    'mode': mode\n                }, to=agent_sid)\n            else:\n                return jsonify({'error': 'No agent connected'}), 503\n        \n        # Update task execution stats\n        start_time = time.time()\n        \n        # Record execution in background\n        def record_execution():\n            # Wait a bit for execution to complete\n            time.sleep(2)\n            \n            # Get execution result from test_history\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('SELECT status, logs FROM test_history WHERE id=?', (test_id,))\n            row = c.fetchone()\n            \n            if row:\n                status = row[0]\n                logs = row[1]\n                success = status == 'success'\n                \n                # Update task stats\n                task = LearnedTask.get_by_id(task_id)\n                if task:\n                    if success:\n                        task.success_count += 1\n                    else:\n                        task.failure_count += 1\n                    task.last_executed = datetime.now()\n                    task.save()\n                \n                # Record execution\n                execution_time = int((time.time() - start_time) * 1000)\n                execution = TaskExecution(\n                    task_id=task_id,\n                    execution_result=status,\n                    success=success,\n                    error_message=logs if not success else None,\n                    execution_time_ms=execution_time\n                )\n                execution.save()\n            \n            conn.close()\n        \n        socketio.start_background_task(record_execution)\n        \n        return jsonify({\n            'test_id': test_id,\n            'task_name': task.task_name,\n            'message': 'Task execution started'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/recall', methods=['POST'])\ndef recall_and_execute():\n    \"\"\"\n    Recall Mode: Search for a task by natural language and execute it.\n    This is the main entry point for the persistent learning system.\n    \"\"\"\n    try:\n        data = request.json\n        query = data.get('query')\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        auto_execute = data.get('auto_execute', False)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Recall Mode requires an OpenAI API key to search for tasks.'\n            }), 400\n        \n        # Search for the most relevant task\n        try:\n            results = semantic_search.search_tasks(query, top_k=1)\n        except Exception as search_error:\n            error_msg = str(search_error)\n            if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n                return jsonify({\n                    'error': f'OPENAI_API_KEY error: {error_msg}'\n                }), 400\n            raise\n        \n        if not results:\n            return jsonify({\n                'found': False,\n                'message': 'No matching tasks found. Consider creating a new task.'\n            })\n        \n        # Get the best match\n        best_match = results[0]\n        task_id = best_match['task_id']\n        similarity_score = best_match.get('similarity_score', 0)\n        \n        # If auto_execute is True and similarity is high enough, execute immediately\n        if auto_execute and similarity_score > 0.7:\n            # Execute the task\n            task = LearnedTask.get_by_id(task_id)\n            code = task.playwright_code\n            \n            # Create test history entry\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                      (query, code, browser, mode, execution_location, 'pending'))\n            test_id = c.lastrowid\n            conn.commit()\n            conn.close()\n            \n            # Execute\n            if execution_location == 'server':\n                socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n            \n            return jsonify({\n                'found': True,\n                'executed': True,\n                'test_id': test_id,\n                'task': best_match,\n                'similarity_score': similarity_score\n            })\n        else:\n            # Return the best match for user confirmation\n            return jsonify({\n                'found': True,\n                'executed': False,\n                'task': best_match,\n                'similarity_score': similarity_score,\n                'message': 'Task found. Please confirm execution or adjust the query.'\n            })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Teaching Mode Recording - Store recorded actions by session\nrecording_sessions = {}\n\n@app.route('/api/teaching/start', methods=['POST'])\ndef start_teaching_recording():\n    \"\"\"Start interactive recording session for Teaching Mode - routes to agent.\"\"\"\n    try:\n        session_id = request.json.get('session_id') or str(uuid.uuid4())\n        # Don't provide default URL - let browser open blank (like Playwright codegen)\n        start_url = request.json.get('start_url', '')\n        \n        # Check if any agent is connected\n        if not connected_agents:\n            return jsonify({\n                'error': 'No agent connected. Please connect a local agent to use Teaching Mode.',\n                'session_id': session_id\n            }), 400\n        \n        # Initialize recording session\n        recording_sessions[session_id] = {\n            'actions': [],\n            'start_time': time.time(),\n            'start_url': start_url\n        }\n        \n        # Emit start_recording event to agent\n        socketio.emit('start_recording', {\n            'session_id': session_id,\n            'start_url': start_url\n        })\n        \n        print(f\"📤 Sent start_recording to agent for session {session_id}\")\n        \n        return jsonify({\n            'success': True,\n            'session_id': session_id,\n            'message': 'Recording request sent to agent. Browser will open on your machine.'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/navigate', methods=['POST'])\ndef teaching_navigate():\n    \"\"\"Navigate to a URL during recording.\"\"\"\n    try:\n        session_id = request.json.get('session_id')\n        url = request.json.get('url')\n        \n        if not session_id or session_id not in active_recorders:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        recorder = active_recorders[session_id]\n        loop = active_loops.get(session_id)\n        \n        if not loop or not recorder.page:\n            return jsonify({'error': 'Recording session not ready'}), 400\n        \n        # Run navigation using the session's event loop\n        try:\n            asyncio.run_coroutine_threadsafe(recorder.page.goto(url), loop).result(timeout=10)\n            recorder.record_goto(url)\n            return jsonify({'success': True})\n        except Exception as e:\n            print(f\"Navigation error: {e}\")\n            return jsonify({'error': str(e)}), 500\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/actions', methods=['GET'])\ndef get_teaching_actions():\n    \"\"\"Get currently recorded actions.\"\"\"\n    try:\n        session_id = request.args.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'actions': []})\n        \n        session = recording_sessions[session_id]\n        return jsonify({'actions': session.get('actions', [])})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/stop', methods=['POST'])\ndef stop_teaching_recording():\n    \"\"\"Stop recording and return captured actions.\"\"\"\n    try:\n        session_id = request.json.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        # Emit stop_recording event to agent\n        socketio.emit('stop_recording', {\n            'session_id': session_id\n        })\n        \n        print(f\"📤 Sent stop_recording to agent for session {session_id}\")\n        \n        # Return success - actual actions will come via recording_stopped event\n        return jsonify({\n            'success': True,\n            'message': 'Stop request sent to agent'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/save_to_library', methods=['POST'])\ndef save_recording_to_library():\n    \"\"\"Save a recorded session to the task library.\"\"\"\n    try:\n        data = request.json\n        session_id = data.get('session_id')\n        task_name = data.get('task_name')\n        description = data.get('description', '')\n        tags = data.get('tags', [])\n        \n        if not session_id or not task_name:\n            return jsonify({'error': 'session_id and task_name are required'}), 400\n        \n        session = recording_sessions.get(session_id)\n        if not session:\n            return jsonify({'error': 'Recording session not found'}), 404\n        \n        playwright_code = session.get('playwright_code')\n        actions = session.get('actions', [])\n        \n        if not playwright_code:\n            return jsonify({'error': 'No recorded code available'}), 400\n        \n        task_id = str(uuid.uuid4())\n        \n        steps = [{'step': i+1, 'description': action.get('description', '')} \n                 for i, action in enumerate(actions)]\n        \n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags + ['recorded', 'teaching-mode']\n        )\n        \n        task.save()\n        \n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"✅ Recorded task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"⚠️ Failed to index task for search: {e}\")\n        \n        print(f\"✅ Recording saved to task library: {task_name} ({task_id})\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict(),\n            'message': f'Task \"{task_name}\" saved to library'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n\n@socketio.on('connect')\ndef handle_connect():\n    print(f'Client connected: {request.sid}')\n    emit('connected', {'sid': request.sid})\n    # Send current list of connected agents to newly connected web client\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print(f'Client disconnected: {request.sid}')\n    if request.sid in connected_agents:\n        del connected_agents[request.sid]\n        print(f'Updated connected_agents after disconnect: {connected_agents}')\n        socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_register')\ndef handle_agent_register(data):\n    agent_id = data.get('agent_id')\n    connected_agents[request.sid] = {\n        'agent_id': agent_id,\n        'browsers': data.get('browsers', []),\n        'connected_at': datetime.now().isoformat()\n    }\n    print(f'Agent registered: {agent_id}')\n    print(f'Updated connected_agents after register: {connected_agents}')\n    emit('agent_registered', {'status': 'success'})\n    print(f'Emitting agents_update: {list(connected_agents.values())}')\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_result')\ndef handle_agent_result(data):\n    test_id = data.get('test_id')\n    success = data.get('success')\n    logs = data.get('logs', [])\n    screenshot_data = data.get('screenshot')\n    \n    screenshot_path = None\n    if screenshot_data:\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        screenshot_bytes = base64.b64decode(screenshot_data)\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(screenshot_bytes)\n    \n    logs_json = json.dumps(logs)\n    status = 'success' if success else 'failed'\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': logs,\n        'screenshot_path': screenshot_path\n    })\n\n@socketio.on('agent_log')\ndef handle_agent_log(data):\n    socketio.emit('execution_status', {\n        'test_id': data.get('test_id'),\n        'status': 'running',\n        'message': data.get('message')\n    })\n\n\n@socketio.on('heartbeat')\ndef handle_heartbeat(data):\n    \"\"\"Handle heartbeat from agent to keep connection alive.\"\"\"\n    # Simply acknowledge - the ping/pong mechanism handles the rest\n    # This prevents timeout on idle connections\n    pass\n\n@socketio.on('recording_started')\ndef handle_recording_started(data):\n    \"\"\"Handle recording started event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        print(f\"✅ Recording session {session_id} started on agent\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'started',\n            'message': data.get('message', 'Browser opened on agent machine')\n        })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"❌ Recording session {session_id} failed to start: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_actions')\ndef handle_recording_actions(data):\n    \"\"\"Handle periodic action updates from agent.\"\"\"\n    session_id = data.get('session_id')\n    actions = data.get('actions', [])\n    \n    if session_id in recording_sessions:\n        recording_sessions[session_id]['actions'].extend(actions)\n        print(f\"📥 Received {len(actions)} actions for session {session_id}. Total: {len(recording_sessions[session_id]['actions'])}\")\n\n\n@socketio.on('recording_stopped')\ndef handle_recording_stopped(data):\n    \"\"\"Handle recording stopped event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        final_actions = data.get('final_actions', [])\n        \n        if session_id in recording_sessions:\n            # Add final actions\n            recording_sessions[session_id]['actions'].extend(final_actions)\n            all_actions = recording_sessions[session_id]['actions']\n            \n            print(f\"✅ Recording session {session_id} stopped. Total actions: {len(all_actions)}\")\n            \n            # Generate Playwright code from recorded actions\n            playwright_code = None\n            try:\n                if all_actions:\n                    playwright_code = generate_playwright_code_from_recording(all_actions)\n                    print(f\"✅ Generated Playwright code from {len(all_actions)} actions\")\n            except Exception as e:\n                print(f\"⚠️ Error generating Playwright code: {e}\")\n            \n            # Emit to web client with both actions and generated code\n            socketio.emit('recording_complete', {\n                'session_id': session_id,\n                'actions': all_actions,\n                'playwright_code': playwright_code\n            })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"❌ Recording session {session_id} stop failed: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_status')\ndef handle_recording_status(data):\n    \"\"\"Handle recording status updates from agent (including auto-stop on browser close).\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'stopped':\n        playwright_code = data.get('playwright_code')\n        actions = data.get('actions', [])\n        auto_stopped = data.get('auto_stopped', False)\n        \n        print(f\"✅ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped\")\n        print(f\"   Playwright code: {'Yes' if playwright_code else 'No'}\")\n        print(f\"   Actions extracted: {len(actions)}\")\n        \n        if session_id in recording_sessions:\n            recording_sessions[session_id]['playwright_code'] = playwright_code\n            recording_sessions[session_id]['actions'] = actions\n        else:\n            recording_sessions[session_id] = {\n                'playwright_code': playwright_code,\n                'actions': actions,\n                'start_time': time.time()\n            }\n        \n        socketio.emit('recording_complete', {\n            'session_id': session_id,\n            'playwright_code': playwright_code,\n            'actions': actions,\n            'auto_stopped': auto_stopped,\n            'message': 'Browser closed. Recording stopped automatically.' if auto_stopped else 'Recording stopped.'\n        })\n    else:\n        socketio.emit('recording_status', data)\n\n\n@socketio.on('element_selected')\ndef handle_element_selected(data):\n    test_id = data.get('test_id')\n    selector = data.get('selector')\n    failed_locator = data.get('failed_locator')  # Agent should send this\n    \n    print(f\"\\n✅ ELEMENT SELECTED EVENT RECEIVED:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  selector: {selector}\")\n    print(f\"  failed_locator: {failed_locator}\", flush=True)\n    \n    # Get the generated code from database\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT generated_code FROM test_history WHERE id=?', (test_id,))\n    row = c.fetchone()\n    \n    if not row:\n        print(f\"  ❌ Test {test_id} not found in database\", flush=True)\n        conn.close()\n        socketio.emit('error', {\n            'test_id': test_id,\n            'message': 'Test not found in database'\n        })\n        return\n    \n    generated_code = row[0]\n    \n    # If failed_locator not provided by agent, try to extract from healing_executor\n    if not failed_locator and test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        if healing_executor.failed_locators:\n            failed_locator = healing_executor.failed_locators[-1]['locator']\n    \n    # Heal the script\n    healed_code = generated_code.replace(failed_locator, selector) if failed_locator else generated_code\n    \n    print(f\"\\n🔧 HEALING SCRIPT IN handle_element_selected:\")\n    print(f\"  Failed locator: '{failed_locator}'\")\n    print(f\"  Healed locator: '{selector}'\")\n    print(f\"  Replacement successful: {healed_code != generated_code}\")\n    print(f\"  Healed code length: {len(healed_code)}\", flush=True)\n    \n    # Save healed code to database\n    c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ✅ Healed code saved to database for test {test_id}\", flush=True)\n    \n    # Update healing executor if it exists\n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.set_user_selector(selector)\n        healing_executor.healed_script = healed_code\n    \n    socketio.emit('element_selected_confirmed', {\n        'test_id': test_id,\n        'selector': selector,\n        'failed_locator': failed_locator,\n        'healed_script': healed_code\n    })\n\n@socketio.on('healing_attempt_result')\ndef handle_healing_attempt_result(data):\n    \"\"\"Handle result from agent healing attempt execution.\"\"\"\n    test_id = data.get('test_id')\n    \n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.set_agent_result({\n            'success': data.get('success'),\n            'logs': data.get('logs', []),\n            'screenshot': data.get('screenshot')\n        })\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 6890))\n    socketio.run(\n        app,\n        host='127.0.0.1',  # localhost\n        port=port,\n        debug=True,\n        allow_unsafe_werkzeug=True\n    )\n","size_bytes":61468},"visionvault/agents/socket_client.py":{"content":"import socketio\nimport asyncio\nfrom .config import AGENT_ID, SERVER_URL\nfrom .utils import detect_browsers\n\n\nclass SocketClient:\n    def __init__(self):\n        self.sio = socketio.Client(\n            reconnection=True,\n            reconnection_attempts=100,\n            reconnection_delay=1,\n            reconnection_delay_max=10,\n            request_timeout=30,\n            logger=False,\n            engineio_logger=False\n        )\n        self.setup_events()\n        self.event_loop = None\n\n    def setup_events(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.sio.event\n        def connect():\n            print(f\"✅ Connected to server: {SERVER_URL}\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n            print(f\"📤 Sent registration with browsers: {available_browsers}\")\n\n        @self.sio.event\n        def disconnect():\n            print(\"⚠️ Disconnected from server - will auto-reconnect...\")\n\n        @self.sio.event\n        def connect_error(data):\n            print(f\"❌ Connection error: {data}\")\n            print(\"   Retrying connection...\")\n\n        @self.sio.event\n        def reconnect():\n            print(\"🔄 Reconnected to server - re-registering...\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n\n        @self.sio.event\n        def agent_registered(data):\n            print(f\"Agent registered successfully: {data}\")\n\n    def connect(self):\n        \"\"\"Connect to the server\"\"\"\n        self.sio.connect(SERVER_URL,\n                         transports=['websocket', 'polling'],\n                         wait_timeout=10)\n\n    def disconnect(self):\n        \"\"\"Disconnect from server\"\"\"\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def emit(self, event, data):\n        \"\"\"Emit an event to server\"\"\"\n        self.sio.emit(event, data)\n\n    def on(self, event, handler):\n        \"\"\"Register event handler\"\"\"\n        self.sio.on(event, handler)\n\n    @property\n    def connected(self):\n        return self.sio.connected","size_bytes":2296},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"VisionVault - AI-Powered Browser Automation\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"eventlet>=0.37.0\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"flask-socketio>=5.5.1\",\n    \"gunicorn>=23.0.0\",\n    \"openai>=2.1.0\",\n    \"pillow>=11.3.0\",\n    \"playwright>=1.55.0\",\n    \"python-socketio>=5.14.1\",\n    \"websocket-client>=1.8.0\",\n]\n","size_bytes":415},"visionvault/__init__.py":{"content":"","size_bytes":0},"scripts/tred.py":{"content":"import asyncio\nimport base64\nfrom playwright.async_api import async_playwright\n\n# ---------------- Dummy Test Code ----------------\ndummy_code = \"\"\"\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    success = False\n\n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            await page.goto(\"https://example.com\")\n            logs.append(\"Page loaded successfully\")\n\n            # Try finding a widget that may fail\n            try:\n                await page.wait_for_selector(\"#nonexistent-widget\", timeout=2000)\n                logs.append(\"Widget found!\")\n            except:\n                logs.append(\"Widget not found, requires healing.\")\n\n            screenshot = await page.screenshot()\n            success = True\n            await browser.close()\n    except Exception as e:\n        logs.append(f\"Error: {e}\")\n\n    return {\"success\": success, \"logs\": logs, \"screenshot\": screenshot}\n\"\"\"\n\n# ---------------- Test Execution ----------------\nasync def execute_test(test_id, code, browser_name=\"chromium\", headless=True):\n    print(f\"\\n=== Executing Test {test_id} ===\")\n    local_vars = {}\n    exec(code, {}, local_vars)\n\n    if \"run_test\" not in local_vars:\n        print(\"Error: run_test function not found in code\")\n        return\n\n    run_test = local_vars[\"run_test\"]\n    result = await run_test(browser_name=browser_name, headless=headless)\n\n    print(f\"Test {test_id} Result: {'SUCCESS' if result['success'] else 'FAILED'}\")\n    for log in result[\"logs\"]:\n        print(f\" - {log}\")\n\n    if result[\"screenshot\"]:\n        filename = f\"screenshot_{test_id}.png\"\n        with open(filename, \"wb\") as f:\n            f.write(result[\"screenshot\"])\n        print(f\"Screenshot saved as {filename}\")\n\n# ---------------- Healing Execution ----------------\nasync def execute_healing(test_id, code, browser_name=\"chromium\", headless=True, attempt=1):\n    print(f\"\\n=== Healing Attempt {attempt} for Test {test_id} ===\")\n    await execute_test(f\"{test_id}_healing_{attempt}\", code, browser_name, headless)\n\n# ---------------- Main ----------------\nif __name__ == \"__main__\":\n    asyncio.run(execute_test(\"test1\", dummy_code))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=1))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=2))\n","size_bytes":2490},"visionvault/services/vector_store.py":{"content":"import numpy as np\nimport faiss\nimport json\nimport os\nfrom typing import List, Dict, Tuple, Optional\nimport google.generativeai as genai\n\n\nclass VectorStore:\n    \"\"\"Vector store for semantic search using FAISS.\"\"\"\n    \n    def __init__(self, dimension=768, index_path='data/vector_index.faiss', \n                 metadata_path='data/vector_metadata.json'):\n        self.dimension = dimension  # Gemini embeddings are 768 dimensions\n        self.index_path = index_path\n        self.metadata_path = metadata_path\n        self.index = None\n        self.metadata = []  # Store task_ids corresponding to each vector\n        \n        # Initialize or load index\n        self._load_or_create_index()\n    \n    def _load_or_create_index(self):\n        \"\"\"Load existing index or create a new one.\"\"\"\n        if os.path.exists(self.index_path) and os.path.exists(self.metadata_path):\n            print(f\"Loading existing vector index from {self.index_path}\")\n            self.index = faiss.read_index(self.index_path)\n            with open(self.metadata_path, 'r') as f:\n                self.metadata = json.load(f)\n        else:\n            print(\"Creating new vector index\")\n            # Using IndexFlatL2 for simplicity - cosine similarity index\n            self.index = faiss.IndexFlatL2(self.dimension)\n            self.metadata = []\n            self._save_index()\n    \n    def _save_index(self):\n        \"\"\"Save index and metadata to disk.\"\"\"\n        faiss.write_index(self.index, self.index_path)\n        with open(self.metadata_path, 'w') as f:\n            json.dump(self.metadata, f)\n    \n    def add_vector(self, task_id: str, embedding: np.ndarray):\n        \"\"\"Add a vector and its metadata to the index.\"\"\"\n        if embedding.shape[0] != self.dimension:\n            raise ValueError(f\"Embedding dimension {embedding.shape[0]} does not match index dimension {self.dimension}\")\n        \n        # FAISS expects vectors as float32 and in shape (1, dimension)\n        embedding_array = embedding.astype('float32').reshape(1, -1)\n        \n        # Add to index\n        self.index.add(embedding_array)\n        \n        # Add metadata\n        self.metadata.append(task_id)\n        \n        # Save to disk\n        self._save_index()\n    \n    def update_vector(self, task_id: str, new_embedding: np.ndarray):\n        \"\"\"Update a vector for an existing task_id.\"\"\"\n        # Find the index of the task_id\n        if task_id not in self.metadata:\n            # If not found, just add it\n            self.add_vector(task_id, new_embedding)\n            return\n        \n        # FAISS doesn't support updates directly, so we need to rebuild\n        # Get all vectors except the one to update\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        # Create new index\n        new_index = faiss.IndexFlatL2(self.dimension)\n        new_metadata = []\n        \n        # Add all vectors except the one being updated\n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        # Add the updated vector\n        new_embedding_array = new_embedding.astype('float32').reshape(1, -1)\n        new_index.add(new_embedding_array)\n        new_metadata.append(task_id)\n        \n        # Replace old index and metadata\n        self.index = new_index\n        self.metadata = new_metadata\n        \n        # Save to disk\n        self._save_index()\n    \n    def search(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Tuple[str, float]]:\n        \"\"\"\n        Search for the most similar vectors.\n        \n        Returns:\n            List of (task_id, distance) tuples, sorted by similarity (lower distance = more similar)\n        \"\"\"\n        if self.index.ntotal == 0:\n            return []\n        \n        # Ensure query is the right shape\n        query_array = query_embedding.astype('float32').reshape(1, -1)\n        \n        # Search\n        top_k = min(top_k, self.index.ntotal)  # Don't ask for more than we have\n        distances, indices = self.index.search(query_array, top_k)\n        \n        # Build results\n        results = []\n        for i, idx in enumerate(indices[0]):\n            if idx < len(self.metadata):  # Safety check\n                task_id = self.metadata[idx]\n                distance = float(distances[0][i])\n                results.append((task_id, distance))\n        \n        return results\n    \n    def delete_vector(self, task_id: str):\n        \"\"\"Delete a vector by task_id.\"\"\"\n        if task_id not in self.metadata:\n            return\n        \n        # Rebuild index without the deleted vector\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        new_index = faiss.IndexFlatL2(self.dimension)\n        new_metadata = []\n        \n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        self.index = new_index\n        self.metadata = new_metadata\n        \n        self._save_index()\n    \n    def get_all_task_ids(self) -> List[str]:\n        \"\"\"Get all task_ids in the index.\"\"\"\n        return self.metadata.copy()\n    \n    def clear(self):\n        \"\"\"Clear all vectors from the index.\"\"\"\n        self.index = faiss.IndexFlatL2(self.dimension)\n        self.metadata = []\n        self._save_index()\n\n\nclass EmbeddingService:\n    \"\"\"Service for generating embeddings using Google Gemini API.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.api_key = api_key or os.environ.get('GEMINI_API_KEY')\n        if not self.api_key:\n            raise ValueError(\"Gemini API key is required for embedding generation. Please set GEMINI_API_KEY environment variable.\")\n        \n        genai.configure(api_key=self.api_key)\n        self.model = \"models/text-embedding-004\"  # Gemini's latest embedding model\n    \n    def generate_embedding(self, text: str) -> np.ndarray:\n        \"\"\"Generate embedding for a text string.\"\"\"\n        try:\n            result = genai.embed_content(\n                model=self.model,\n                content=text,\n                task_type=\"retrieval_document\"\n            )\n            \n            # Extract the embedding vector\n            embedding = np.array(result['embedding'], dtype=np.float32)\n            return embedding\n            \n        except Exception as e:\n            print(f\"Error generating embedding: {e}\")\n            raise\n    \n    def generate_task_embedding(self, task_name: str, description: str, tags: List[str]) -> np.ndarray:\n        \"\"\"\n        Generate embedding for a task based on its metadata.\n        Combines task name, description, and tags into a single text.\n        \"\"\"\n        # Create a comprehensive text representation\n        text_parts = [task_name]\n        \n        if description:\n            text_parts.append(description)\n        \n        if tags:\n            text_parts.append(\"Tags: \" + \", \".join(tags))\n        \n        combined_text = \". \".join(text_parts)\n        \n        return self.generate_embedding(combined_text)\n\n\nclass SemanticSearch:\n    \"\"\"High-level semantic search service combining VectorStore and EmbeddingService.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.vector_store = VectorStore()\n        self.embedding_service = EmbeddingService(api_key)\n    \n    def index_task(self, task):\n        \"\"\"Index a LearnedTask for semantic search.\"\"\"\n        # Generate embedding from task metadata\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        # Add to vector store\n        self.vector_store.add_vector(task.task_id, embedding)\n        \n        # Also save embedding with the task\n        task.embedding_vector = embedding\n        task.save()\n    \n    def update_task_index(self, task):\n        \"\"\"Update the index for an existing task.\"\"\"\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        self.vector_store.update_vector(task.task_id, embedding)\n        \n        task.embedding_vector = embedding\n        task.save()\n    \n    def search_tasks(self, query: str, top_k: int = 5) -> List[Dict]:\n        \"\"\"\n        Search for tasks similar to the query.\n        \n        Returns:\n            List of task dictionaries with similarity scores\n        \"\"\"\n        # Generate embedding for query\n        query_embedding = self.embedding_service.generate_embedding(query)\n        \n        # Search vector store\n        results = self.vector_store.search(query_embedding, top_k)\n        \n        # Fetch task details from database\n        from visionvault.core.models import LearnedTask\n        \n        tasks_with_scores = []\n        for task_id, distance in results:\n            task = LearnedTask.get_by_id(task_id)\n            if task:\n                task_dict = task.to_dict()\n                task_dict['similarity_score'] = float(1 / (1 + distance))  # Convert distance to similarity\n                task_dict['distance'] = float(distance)\n                tasks_with_scores.append(task_dict)\n        \n        return tasks_with_scores\n    \n    def delete_task_from_index(self, task_id: str):\n        \"\"\"Remove a task from the search index.\"\"\"\n        self.vector_store.delete_vector(task_id)\n    \n    def reindex_all_tasks(self):\n        \"\"\"Rebuild the entire search index from scratch.\"\"\"\n        from visionvault.core.models import LearnedTask\n        \n        # Clear existing index\n        self.vector_store.clear()\n        \n        # Get all tasks\n        all_tasks = LearnedTask.get_all(limit=10000)\n        \n        # Index each task\n        for task in all_tasks:\n            try:\n                self.index_task(task)\n                print(f\"Indexed task: {task.task_name}\")\n            except Exception as e:\n                print(f\"Failed to index task {task.task_id}: {e}\")\n","size_bytes":10178},"visionvault/agents/browser_manager.py":{"content":"class BrowserManager:\n    def __init__(self):\n        self.active_page = None\n        self.active_playwright_instance = None\n        self.widget_injection_complete = None\n\n    async def cleanup_browser(self):\n        \"\"\"Clean up browser resources\"\"\"\n        if self.active_page and hasattr(self.active_page, 'context') and hasattr(self.active_page.context, 'browser'):\n            try:\n                browser = self.active_page.context.browser\n                await browser.close()\n                print(\"✅ Browser closed after healing attempt\")\n            except Exception as e:\n                print(f\"Browser cleanup error: {e}\")\n            finally:\n                self.active_page = None\n\n        if self.active_playwright_instance and hasattr(self.active_playwright_instance, 'stop'):\n            try:\n                await self.active_playwright_instance.stop()\n                print(\"✅ Playwright instance stopped\")\n            except Exception as e:\n                print(f\"Playwright cleanup error: {e}\")\n            finally:\n                self.active_playwright_instance = None\n\n    def set_active_page(self, page):\n        \"\"\"Set the active page for healing operations\"\"\"\n        self.active_page = page\n\n    def set_playwright_instance(self, playwright_instance):\n        \"\"\"Set the active playwright instance\"\"\"\n        self.active_playwright_instance = playwright_instance\n\n    def set_widget_event(self, event):\n        \"\"\"Set the widget injection completion event\"\"\"\n        self.widget_injection_complete = event","size_bytes":1539},"replit.md":{"content":"# VisionVault - AI-Powered Browser Automation\n\n## Overview\nVisionVault is an AI-powered browser automation tool that converts natural language commands into executable Playwright code. The system features automated healing for broken tests and persistent learning capabilities.\n\n## Project Type\n- **Language**: Python 3.11\n- **Framework**: Flask + Socket.IO\n- **Automation**: Playwright\n- **AI**: OpenAI (optional)\n- **Database**: SQLite (with optional vector search using FAISS)\n\n## Current State\nThe application has been successfully set up to run in the Replit environment:\n- ✅ All Python dependencies installed\n- ✅ Playwright Chromium browser installed\n- ✅ Web server configured to run on 0.0.0.0:5000\n- ✅ CORS configured for all origins (required for Replit proxy)\n- ✅ Workflow configured for development\n- ✅ Deployment configured (VM type for stateful operation)\n\n## Key Features\n1. **Natural Language to Code**: Convert plain English to Playwright automation scripts\n2. **Test Execution**: Run automation scripts in headless or headful mode\n3. **Automated Healing**: Auto-fix broken locators when UI elements change\n4. **Persistent Learning**: Store and reuse successful automation tasks\n5. **Semantic Search**: Find similar tasks using vector embeddings (requires OpenAI API key)\n6. **Agent-Based Execution**: Distribute automation across connected agents\n\n## Project Architecture\n\n### Main Components\n- **Web Server** (`visionvault/web/app.py`): Flask application with Socket.IO for real-time communication\n- **Agents** (`visionvault/agents/`): Remote execution agents with healing capabilities\n- **Services** (`visionvault/services/`): Core automation services (executor, healing, code validation, vector store)\n- **Core** (`visionvault/core/`): Database models and schemas\n\n### Entry Points\n- `run_server.py`: Start the web server (port 5000)\n- `run_agent.py`: Start an automation agent\n\n## Environment Configuration\n\n### Required Environment Variables\nNone required for basic operation.\n\n### Optional Environment Variables\n- `OPENAI_API_KEY`: Enable AI code generation (uses GPT-4o-mini)\n- `GEMINI_API_KEY`: Enable semantic search with Gemini embeddings (text-embedding-004)\n- `SESSION_SECRET`: Flask session secret (defaults to dev key if not set)\n- `PORT`: Server port (defaults to 5000)\n\n## Development Setup\n\n### Running Locally\nThe server is automatically started via the \"Server\" workflow which runs:\n```bash\npython run_server.py\n```\n\n### Database\n- Location: `data/automation.db`\n- Type: SQLite\n- Schema: Test history, learned tasks, task executions\n- Vector index: `data/vector_index.faiss` (for semantic search)\n\n## Deployment\n- **Type**: VM (stateful, always-on)\n- **Command**: `python run_server.py`\n- **Port**: 5000\n- **Host**: 0.0.0.0 (required for Replit)\n\n## Notes\n- The application works without API keys but with limited functionality:\n  - Without OPENAI_API_KEY: AI code generation is disabled\n  - Without GEMINI_API_KEY: Semantic search is disabled\n- Playwright browser automation requires system dependencies (automatically handled in Replit)\n- SocketIO is configured with gevent for async support\n- CORS is enabled for all origins to support Replit's iframe proxy\n- Embeddings use Google Gemini (768 dimensions) instead of OpenAI (1536 dimensions)\n\n## Recent Changes\n- **2025-10-12**: Migration to Replit environment completed\n  - Replaced OpenAI embeddings with Google Gemini embeddings (text-embedding-004)\n  - Removed hardcoded API keys for security\n  - Separated OPENAI_API_KEY (for code generation) and GEMINI_API_KEY (for semantic search)\n  - Configured Flask to bind to 0.0.0.0:5000\n  - Created .gitignore for Python project\n  - Set up development workflow\n  - Configured VM deployment\n  - Enhanced recording functionality:\n    - Auto-stop recording when browser closes\n    - Extract and display actions with locators\n    - Direct save to task library from recordings\n    - Improved persistent learning integration\n  - History re-execution feature:\n    - Added API endpoint to re-run tests from history\n    - Automatically uses healed script when available (falls back to generated script)\n    - History view loads command in read-only prompt with visual indicator\n    - Execute button detects history mode and uses appropriate API\n    - Displays script source (healed vs generated) with color-coded badges\n","size_bytes":4359},"recordings/fe150765-73d8-476e-89ef-72615806dfa6.py":{"content":"import re\nfrom playwright.sync_api import Playwright, sync_playwright, expect\n\n\ndef run(playwright: Playwright) -> None:\n    browser = playwright.chromium.launch(headless=False)\n    context = browser.new_context()\n    page = context.new_page()\n    page.goto(\"https://www.amazon.in/\")\n    page.get_by_text(\"Up to 80% off | Home, kitchen & moreKitchen essentialsHome decorFurnitureHome\").click()\n    page.get_by_text(\"Kitchen essentialsHome decorFurnitureHome improvement\").click()\n\n    # ---------------------\n    context.close()\n    browser.close()\n\n\nwith sync_playwright() as playwright:\n    run(playwright)\n","size_bytes":609}},"version":2}