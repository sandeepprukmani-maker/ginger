{"file_contents":{"OpenAIWeb/playwright_mcp/server/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\n\nlet lastExecution = null;\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    // Disable button and show spinner\n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    resultsDiv.innerHTML = '';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ instruction }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', `Completed in ${data.iterations} iteration(s)`);\n            displayResults(data);\n            // Store last execution for export\n            lastExecution = {\n                instruction: instruction,\n                steps: data.steps\n            };\n            showExportButton();\n        } else {\n            showStatus('error', `Error: ${data.error || 'Unknown error'}`);\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to execute: ${error.message}`);\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history.')) {\n        return;\n    }\n    \n    try {\n        const response = await fetch('/api/reset', {\n            method: 'POST',\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', 'Agent reset successfully');\n            resultsDiv.innerHTML = '';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to reset: ${error.message}`);\n    }\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    // Display steps\n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n    \n    // Display final message if available\n    if (data.message) {\n        const messageEl = document.createElement('div');\n        messageEl.className = 'final-message';\n        messageEl.textContent = data.message;\n        resultsDiv.appendChild(messageEl);\n    }\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success ? 'success' : 'error'}`;\n    statusEl.textContent = step.success ? 'Success' : 'Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `Tool: ${step.tool}`;\n    \n    const argsEl = document.createElement('div');\n    argsEl.className = 'step-args';\n    argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    stepEl.appendChild(argsEl);\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.style.color = '#721c24';\n        errorEl.style.marginTop = '10px';\n        errorEl.textContent = `Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        resultContent.textContent = JSON.stringify(step.result, null, 2);\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\nfunction showExportButton() {\n    // Check if export button already exists\n    if (document.getElementById('export-btn')) return;\n    \n    const buttonGroup = document.querySelector('.button-group');\n    const exportBtn = document.createElement('button');\n    exportBtn.id = 'export-btn';\n    exportBtn.className = 'btn btn-export';\n    exportBtn.textContent = 'Export as Playwright';\n    exportBtn.style.backgroundColor = '#10b981';\n    \n    exportBtn.addEventListener('click', async () => {\n        if (!lastExecution) {\n            showStatus('error', 'No execution to export');\n            return;\n        }\n        \n        try {\n            const response = await fetch('/api/export-playwright', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(lastExecution),\n            });\n            \n            const data = await response.json();\n            \n            if (data.success) {\n                // Create a modal to show the code\n                showExportModal(data.playwright_code, data.json_export);\n            } else {\n                showStatus('error', `Export failed: ${data.error}`);\n            }\n            \n        } catch (error) {\n            showStatus('error', `Export failed: ${error.message}`);\n        }\n    });\n    \n    buttonGroup.appendChild(exportBtn);\n}\n\nfunction showExportModal(playwrightCode, jsonExport) {\n    // Create modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';\n    \n    const content = document.createElement('div');\n    content.style.cssText = 'background: white; padding: 30px; border-radius: 12px; max-width: 800px; max-height: 80vh; overflow: auto; width: 90%;';\n    \n    content.innerHTML = `\n        <h2 style=\"margin-top: 0; color: #667eea;\">Export Options</h2>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">Playwright Test Code:</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(playwrightCode)}</pre>\n            <button id=\"copy-code-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Copy Code</button>\n            <button id=\"download-code-btn\" style=\"margin-top: 10px; margin-left: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download .spec.ts</button>\n        </div>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">JSON Export (for replay):</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(JSON.stringify(jsonExport, null, 2))}</pre>\n            <button id=\"download-json-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download JSON</button>\n        </div>\n        \n        <button id=\"close-modal-btn\" style=\"padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;\">Close</button>\n    `;\n    \n    modal.appendChild(content);\n    document.body.appendChild(modal);\n    \n    // Event handlers\n    document.getElementById('copy-code-btn').addEventListener('click', () => {\n        navigator.clipboard.writeText(playwrightCode);\n        showStatus('success', 'Code copied to clipboard!');\n    });\n    \n    document.getElementById('download-code-btn').addEventListener('click', () => {\n        downloadFile('automation.spec.ts', playwrightCode);\n        showStatus('success', 'Playwright code downloaded!');\n    });\n    \n    document.getElementById('download-json-btn').addEventListener('click', () => {\n        downloadFile('automation-steps.json', JSON.stringify(jsonExport, null, 2));\n        showStatus('success', 'JSON export downloaded!');\n    });\n    \n    document.getElementById('close-modal-btn').addEventListener('click', () => {\n        document.body.removeChild(modal);\n    });\n    \n    modal.addEventListener('click', (e) => {\n        if (e.target === modal) {\n            document.body.removeChild(modal);\n        }\n    });\n}\n\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\nfunction downloadFile(filename, content) {\n    const blob = new Blob([content], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n}\n\n// Check health on load\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        if (data.status === 'healthy') {\n            if (data.mcp_connected) {\n                console.log('Application is healthy and connected to MCP server');\n            } else {\n                console.log('Application is ready. MCP will initialize on first use.');\n            }\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":11652},"OpenAIWeb/OpenAIWeb/src/automation_engine.py":{"content":"import os\nfrom typing import Optional, Dict, Any\nfrom browser_use import Agent, Browser, BrowserProfile, ChatOpenAI\nfrom .playwright_code_generator import PlaywrightCodeGenerator\n\nclass BrowserAutomationEngine:\n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        headless: bool = False,\n        verbose: bool = False,\n        generate_code: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.headless = headless\n        self.verbose = verbose\n        self.generate_code = generate_code\n\n        self.llm = self._initialize_llm()\n        self.browser = self._initialize_browser()\n        self.code_generator = PlaywrightCodeGenerator(verbose=verbose) if generate_code else None\n\n    def _initialize_llm(self) -> ChatOpenAI:\n        # the newest OpenAI model is \"gpt-4o-mini\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        llm = ChatOpenAI(\n            model=self.model,\n            api_key=self.api_key\n        )\n\n        if self.verbose:\n            print(f\"‚úì Initialized LLM: {self.model}\")\n\n        return llm\n\n    def _initialize_browser(self) -> Browser:\n        import shutil\n\n        chromium_path = os.getenv(\"CHROMIUM_PATH\")\n        if not chromium_path:\n            chromium_path = shutil.which(\"chromium\") or shutil.which(\"chromium-browser\") or shutil.which(\"chrome\")\n\n        if chromium_path:\n            if self.verbose:\n                print(f\"‚úì Using Chromium at: {chromium_path}\")\n            profile = BrowserProfile(\n                headless=self.headless,\n                executable_path=chromium_path\n            )\n        else:\n            profile = BrowserProfile(\n                headless=self.headless\n            )\n\n        browser = Browser(\n            browser_profile=profile\n        )\n\n        if self.verbose:\n            print(f\"‚úì Initialized Browser (headless={self.headless})\")\n\n        return browser\n\n    async def run_task(self, task: str, output_file: Optional[str] = None) -> Dict[str, Any]:\n        if self.verbose:\n            print(f\"\\nüéØ Creating agent for task: {task}\\n\")\n\n        task_instruction = (\n            f\"{task}\\n\\n\"\n            \"IMPORTANT INSTRUCTIONS:\\n\"\n            \"1. You may do necessary auxiliary actions (wait for page loads, dismiss popups, etc.) to complete those steps.\\n\"\n            \"2. After completing the user's specified steps, STOP IMMEDIATELY.\\n\"\n            \"4. Do NOT continue to what seems like the 'next logical step' or try to complete an entire workflow.\\n\"\n            \"5. When you finish the last step specified by the user, call 'done' immediately.\"\n        )\n\n        task = task_instruction\n\n        agent = Agent(\n            task=task,\n            llm=self.llm,\n            browser=self.browser,\n        )\n\n        if self.verbose:\n            print(\"üîÑ Agent created, starting execution...\\n\")\n\n        history = await agent.run()\n\n        if self.verbose:\n            print(f\"\\nüìä Task execution completed\")\n            print(f\"   Steps taken: {len(history.history) if hasattr(history, 'history') else 'N/A'}\")\n\n        result = self._extract_result(history)\n\n        response = {\n            'result': result,\n            'history': history,\n            'generated_code': None,\n            'code_file': None\n        }\n\n        if self.generate_code and self.code_generator:\n            if self.verbose:\n                print(\"\\nüìù Generating Playwright code from actions...\")\n\n            self.code_generator.parse_history(history)\n            generated_code = self.code_generator.generate_code()\n            response['generated_code'] = generated_code\n\n            if output_file:\n                self.code_generator.save_code(output_file)\n                response['code_file'] = output_file\n                if self.verbose:\n                    print(f\"‚úì Code saved to: {output_file}\")\n\n        return response\n\n    def _extract_result(self, history) -> Optional[str]:\n        if not history:\n            return None\n\n        if hasattr(history, 'final_result'):\n            return str(history.final_result())\n\n        if hasattr(history, 'history') and history.history:\n            last_action = history.history[-1]\n            if hasattr(last_action, 'result'):\n                return str(last_action.result)\n\n        return \"Task completed successfully\"\n","size_bytes":4415},"OpenAIWeb/playwright_mcp/mcp/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"OpenAIWeb/OpenAIWeb/src/locator_utils.py":{"content":"\"\"\"\nHelper utilities for robust locator strategies and self-healing.\nThese are used when executing GENERATED Playwright code, not during initial browser-use automation.\n\"\"\"\n\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Locator\n\n\nclass LocatorBuilder:\n    \"\"\"Build robust locators with multiple fallback strategies\"\"\"\n    \n    @staticmethod\n    def by_text(text: str, exact: bool = False) -> List[str]:\n        \"\"\"Generate text-based locator strategies\"\"\"\n        escaped = text.replace('\"', '\\\\\"')\n        strategies = [\n            f'page.get_by_text(\"{escaped}\", exact={exact})',\n            f'page.locator(\\'text={escaped}\\')',\n        ]\n        if not exact:\n            strategies.append(f'page.locator(\\'//*[contains(text(), \"{escaped}\")]\\')')\n        return strategies\n    \n    @staticmethod\n    def by_role(role: str, name: Optional[str] = None) -> List[str]:\n        \"\"\"Generate role-based locator strategies\"\"\"\n        if name:\n            name_escaped = name.replace('\"', '\\\\\"')\n            return [\n                f'page.get_by_role(\"{role}\", name=\"{name_escaped}\")',\n                f'page.locator(\\'[role=\"{role}\"][aria-label=\"{name_escaped}\"]\\')',\n                f'page.locator(\\'[role=\"{role}\"]\\')',\n            ]\n        return [\n            f'page.get_by_role(\"{role}\")',\n            f'page.locator(\\'[role=\"{role}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_label(label: str) -> List[str]:\n        \"\"\"Generate label-based locator strategies\"\"\"\n        escaped = label.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_label(\"{escaped}\")',\n            f'page.locator(\\'[aria-label=\"{escaped}\"]\\')',\n            f'page.locator(\\'label:has-text(\"{escaped}\")\\')',\n        ]\n    \n    @staticmethod\n    def by_placeholder(placeholder: str) -> List[str]:\n        \"\"\"Generate placeholder-based locator strategies\"\"\"\n        escaped = placeholder.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_placeholder(\"{escaped}\")',\n            f'page.locator(\\'[placeholder=\"{escaped}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_test_id(test_id: str) -> List[str]:\n        \"\"\"Generate test-id based locator strategies\"\"\"\n        return [\n            f'page.get_by_test_id(\"{test_id}\")',\n            f'page.locator(\\'[data-testid=\"{test_id}\"]\\')',\n            f'page.locator(\\'[data-test-id=\"{test_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_id(element_id: str) -> List[str]:\n        \"\"\"Generate id-based locator strategies\"\"\"\n        return [\n            f'page.locator(\"#{element_id}\")',\n            f'page.locator(\\'[id=\"{element_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_css(selector: str) -> List[str]:\n        \"\"\"Generate CSS selector locator\"\"\"\n        return [f'page.locator(\"{selector}\")']\n    \n    @staticmethod\n    def by_xpath(xpath: str) -> List[str]:\n        \"\"\"Generate XPath locator\"\"\"\n        return [f'page.locator(\\'{xpath}\\')']\n\n\nasync def try_locator_strategies(\n    page: Page,\n    strategies: List[str],\n    timeout: int = 5000,\n    verbose: bool = False\n) -> Optional[Locator]:\n    \"\"\"\n    Try multiple locator strategies until one works.\n    Used in generated code for fallback locator support.\n    \n    Args:\n        page: Playwright page object\n        strategies: List of locator strategy strings\n        timeout: Timeout in milliseconds per strategy\n        verbose: Print debug information\n    \n    Returns:\n        Working Locator object, or None if all fail\n    \"\"\"\n    for i, strategy in enumerate(strategies):\n        try:\n            locator = eval(strategy)\n            await locator.wait_for(timeout=timeout)\n            if verbose and i > 0:\n                print(f\"   ‚úì Fallback strategy {i} worked: {strategy}\")\n            return locator\n        except Exception:\n            if verbose:\n                print(f\"   ‚ö†Ô∏è  Strategy {i} failed: {strategy}\")\n            continue\n    \n    return None\n\n\nclass LocatorHealer:\n    \"\"\"\n    Context information for self-healing locators.\n    This is used ONLY when executing generated Playwright code.\n    \"\"\"\n    \n    @staticmethod\n    def extract_element_info(locator_str: str) -> Dict[str, str]:\n        \"\"\"Extract information from a locator string for healing context\"\"\"\n        info = {\n            'type': 'unknown',\n            'value': '',\n            'description': ''\n        }\n        \n        if 'get_by_text' in locator_str:\n            info['type'] = 'text'\n            info['description'] = 'element with text'\n        elif 'get_by_role' in locator_str:\n            info['type'] = 'role'\n            info['description'] = 'element with role'\n        elif 'get_by_label' in locator_str:\n            info['type'] = 'label'\n            info['description'] = 'element with label'\n        elif 'get_by_placeholder' in locator_str:\n            info['type'] = 'placeholder'\n            info['description'] = 'input with placeholder'\n        elif 'get_by_test_id' in locator_str:\n            info['type'] = 'test_id'\n            info['description'] = 'element with test ID'\n        elif 'locator' in locator_str:\n            if 'text=' in locator_str:\n                info['type'] = 'text'\n                info['description'] = 'element with text'\n            elif '[role=' in locator_str:\n                info['type'] = 'role'\n                info['description'] = 'element with role'\n            elif '#' in locator_str:\n                info['type'] = 'id'\n                info['description'] = 'element with ID'\n            else:\n                info['type'] = 'css'\n                info['description'] = 'element matching CSS selector'\n        \n        return info\n    \n    @staticmethod\n    def build_healing_task(\n        locator_str: str,\n        action: str,\n        url: str,\n        title: str\n    ) -> str:\n        \"\"\"Build a task description for browser-use to heal a broken locator\"\"\"\n        element_info = LocatorHealer.extract_element_info(locator_str)\n        \n        task = f\"\"\"On the current page (URL: {url}, Title: {title}), find the {element_info['description']} that we need to {action}.\n\nThe previous locator ({locator_str}) no longer works. Analyze the page and locate the correct element, then provide information about its attributes so we can create a new working locator.\"\"\"\n        \n        return task\n","size_bytes":6328},"OpenAIWeb/OpenAIWeb/main.py":{"content":"#!/usr/bin/env python3\nimport argparse\nimport asyncio\nimport sys\nimport os\nfrom dotenv import load_dotenv\nfrom src.automation_engine import BrowserAutomationEngine\n\ndef print_header():\n    print(\"\\n\" + \"=\"*60)\n    print(\"  AI Browser Automation CLI\")\n    print(\"  Powered by OpenAI & browser-use\")\n    print(\"=\"*60 + \"\\n\")\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser(\n        description=\"AI-powered browser automation using natural language\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Run automation and see results\n  python main.py \"search for Python tutorials on Google\"\n  \n  # Generate reusable Playwright code\n  python main.py \"go to example.com and click login\" --generate-code --output login.py\n  \n  # Execute generated code with self-healing\n  python main.py --execute-code login.py\n  \n  # Run with visible browser\n  python main.py \"scrape Hacker News\" --no-headless\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"task\",\n        type=str,\n        nargs=\"?\",\n        help=\"Natural language description of the task to perform\"\n    )\n    \n    parser.add_argument(\n        \"--headless\",\n        action=\"store_true\",\n        default=False,\n        help=\"Run browser in headless mode (default: False)\"\n    )\n    \n    parser.add_argument(\n        \"--no-headless\",\n        action=\"store_true\",\n        help=\"Show browser window during automation\"\n    )\n    \n    parser.add_argument(\n        \"--model\",\n        type=str,\n        default=\"gpt-4o-mini\",\n        help=\"OpenAI model to use (default: gpt-4o-mini)\"\n    )\n    \n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Show detailed logs during execution\"\n    )\n    \n    parser.add_argument(\n        \"--generate-code\",\n        action=\"store_true\",\n        help=\"Generate reusable Playwright Python code from the automation\"\n    )\n    \n    parser.add_argument(\n        \"--output\",\n        type=str,\n        default=\"generated_automation.py\",\n        help=\"Output file for generated code (default: generated_automation.py)\"\n    )\n    \n    parser.add_argument(\n        \"--execute-code\",\n        type=str,\n        metavar=\"FILE\",\n        help=\"Execute a previously generated automation script with self-healing\"\n    )\n    \n    return parser.parse_args()\n\nasync def execute_generated_code(code_file: str, api_key: str, model: str, verbose: bool):\n    \"\"\"Execute a previously generated automation script with self-healing\"\"\"\n    from src.self_healing_executor import SelfHealingExecutor\n    import importlib.util\n    \n    if not os.path.exists(code_file):\n        print(f\"‚ùå Error: File not found: {code_file}\")\n        sys.exit(1)\n    \n    print(f\"üîß Loading automation script: {code_file}\")\n    print(f\"ü§ñ Self-healing enabled with model: {model}\")\n    print(\"\\n\" + \"-\"*60 + \"\\n\")\n    \n    executor = SelfHealingExecutor(\n        api_key=api_key,\n        model=model,\n        verbose=verbose\n    )\n    \n    spec = importlib.util.spec_from_file_location(\"automation_module\", code_file)\n    if spec is None or spec.loader is None:\n        print(f\"‚ùå Error: Could not load module from {code_file}\")\n        sys.exit(1)\n    \n    module = importlib.util.module_from_spec(spec)\n    \n    try:\n        spec.loader.exec_module(module)\n        \n        if hasattr(module, 'automated_task'):\n            automation_func = module.automated_task\n        else:\n            func_names = [name for name in dir(module) if not name.startswith('_') and callable(getattr(module, name))]\n            if func_names:\n                automation_func = getattr(module, func_names[0])\n            else:\n                print(\"‚ùå Error: No automation function found in script\")\n                sys.exit(1)\n        \n        print(\"üöÄ Starting self-healing execution...\\n\")\n        await executor.execute_with_healing(automation_func)\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"‚úÖ Automation completed successfully!\")\n        print(\"-\"*60)\n        \n    except Exception as e:\n        print(f\"\\n‚ùå Execution failed: {str(e)}\")\n        if verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n\n\nasync def main():\n    load_dotenv()\n    \n    api_key = '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'\n    if not api_key:\n        print(\"‚ùå Error: OPENAI_API_KEY not found in environment variables\")\n        print(\"\\nPlease set your OpenAI API key:\")\n        print(\"1. Copy .env.example to .env\")\n        print(\"2. Add your OpenAI API key to the .env file\")\n        print(\"\\nGet your API key from: https://platform.openai.com/api-keys\")\n        sys.exit(1)\n    \n    args = parse_arguments()\n    \n    print_header()\n    \n    if args.execute_code:\n        await execute_generated_code(\n            code_file=args.execute_code,\n            api_key=api_key,\n            model=args.model,\n            verbose=args.verbose\n        )\n        return\n    \n    if not args.task:\n        print(\"‚ùå Error: Task description required\")\n        print(\"Use --help for usage information\")\n        sys.exit(1)\n    \n    headless = args.headless and not args.no_headless\n    \n    print(f\"üìã Task: {args.task}\")\n    print(f\"ü§ñ Model: {args.model}\")\n    print(f\"üåê Headless Mode: {'Yes' if headless else 'No'}\")\n    print(f\"üìä Verbose: {'Yes' if args.verbose else 'No'}\")\n    if args.generate_code:\n        print(f\"üìù Code Generation: Enabled (output: {args.output})\")\n    print(\"\\n\" + \"-\"*60 + \"\\n\")\n    \n    engine = BrowserAutomationEngine(\n        api_key=api_key,\n        model=args.model,\n        headless=headless,\n        verbose=args.verbose,\n        generate_code=args.generate_code\n    )\n    \n    try:\n        print(\"üöÄ Starting browser automation...\\n\")\n        response = await engine.run_task(\n            args.task,\n            output_file=args.output if args.generate_code else None\n        )\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"‚úÖ Task completed successfully!\")\n        print(\"-\"*60 + \"\\n\")\n        \n        if response.get('result'):\n            print(\"üìÑ Result:\")\n            print(response['result'])\n            print()\n        \n        if response.get('code_file'):\n            print(f\"üìù Generated code saved to: {response['code_file']}\")\n            print(f\"\\nTo execute with self-healing:\")\n            print(f\"  python main.py --execute-code {response['code_file']}\")\n            print()\n        \n    except KeyboardInterrupt:\n        print(\"\\n\\n‚ö†Ô∏è  Task interrupted by user\")\n        sys.exit(0)\n    except Exception as e:\n        print(f\"\\n‚ùå Error: {str(e)}\")\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":6877},"OpenAIWeb/OpenAIWeb/replit.md":{"content":"# AI Browser Automation CLI\n\n## Overview\n\nThis is a Python CLI tool that enables AI-powered browser automation with self-healing code generation capabilities. Users describe automation tasks in natural language, and the tool executes them using OpenAI's GPT-4o-mini and the browser-use library. The tool can generate reusable Playwright scripts from automation sessions and execute them with automatic locator healing when elements change or move on web pages.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Core Architecture Pattern\n\n**Modular Python CLI Application** - The system follows a modular architecture with distinct components for automation execution, code generation, and self-healing capabilities. Each module has a single, well-defined responsibility.\n\n### AI Integration Layer\n\n**OpenAI GPT-4o-mini via browser-use** - The automation engine uses OpenAI's GPT-4o-mini model exclusively (released August 7, 2025) through the browser-use library for intelligent browser automation. This provides natural language task execution without requiring explicit programming.\n\n**Rationale**: Using browser-use abstracts away low-level browser control while providing AI-driven decision making for complex automation scenarios.\n\n### Browser Automation Stack\n\n**Playwright + browser-use** - The system uses Playwright as the underlying browser automation framework, wrapped by browser-use for AI capabilities during initial automation. Generated code uses pure Playwright for execution.\n\n**Chromium Browser Detection** - Automatically detects and uses available Chromium installations from environment variables or common system paths.\n\n**Rationale**: Playwright provides robust, cross-browser automation capabilities with excellent developer experience. Chromium is preferred for consistency across environments.\n\n### Code Generation & Self-Healing System\n\n**Two-Level Recovery Architecture**:\n1. **Level 1 - Locator Healing**: When generated Playwright code fails due to changed locators, the AI analyzes the current page and generates new locator strategies\n2. **Level 2 - AI Fallback**: If healed locators still fail, browser-use AI takes over to execute the specific action within the same browser session\n\n**Multiple Locator Strategy Pattern** - Generated code includes fallback locator strategies (text, role, label, CSS, XPath) to maximize resilience against page changes.\n\n**Rationale**: Self-healing only applies to generated code execution, not initial automation (which already uses AI natively). This ensures automation reliability even when web pages evolve.\n\n### Module Responsibilities\n\n- **automation_engine.py**: Orchestrates browser-use AI automation and optionally triggers code generation\n- **playwright_code_generator.py**: Converts browser-use action history into production-ready Playwright Python scripts\n- **self_healing_executor.py**: Executes generated Playwright code with AI-powered locator healing and fallback execution\n- **locator_utils.py**: Provides utilities for building robust multi-strategy locators\n\n### CLI Interface\n\n**argparse-based CLI** - Simple command-line interface supporting:\n- Direct task execution via natural language\n- Code generation with output file specification\n- Generated code execution with self-healing\n- Headless/headed browser mode toggle\n- Verbose logging options\n\n## External Dependencies\n\n### AI Services\n- **OpenAI API** (GPT-4o-mini model) - Required for all AI-powered automation and self-healing capabilities. Users must provide their own API key.\n\n### Browser Automation\n- **browser-use** - Python library wrapping Playwright with AI capabilities for natural language automation\n- **Playwright** - Core browser automation framework for cross-browser testing and automation\n- **Chromium** - Browser engine used for automation execution (auto-detected from system)\n\n### Python Dependencies\n- **python-dotenv** - Environment variable management for API keys and configuration\n- **asyncio** - Asynchronous execution support for browser automation operations\n\n### Browser Extensions (Pre-configured)\nThe `.config/browseruse/extensions/` directory contains pre-installed browser extensions used during automation:\n- **uBlock Origin** (cjpalhdlnbpafiamejdnhcphjbkeiagm) - Ad blocker\n- **I don't care about cookies** (edibdbjcniadpccecjdfdjjppcpchdlm) - Cookie consent handler\n- **ClearURLs** (lckanjgmijmafbedllaakclkaicjfmnk) - URL tracking parameter remover\n\n**Rationale**: These extensions improve automation reliability by handling common web annoyances (ads, cookie banners, tracking parameters) that could interfere with AI-driven automation.\n\n### Environment\n- **Replit** - Primary deployment platform (pre-configured)\n- **Python 3.11+** - Minimum required Python version","size_bytes":4809},"OpenAIWeb/OpenAIWeb/linkedins.py":{"content":"from playwright.async_api import async_playwright, Page, Browser, Locator\nfrom typing import Optional, List\nimport asyncio\n\n\nasync def automated_task():\n    \"\"\"Generated Playwright automation code with self-healing support\"\"\"\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=False)\n        context = await browser.new_context()\n        page = await context.new_page()\n\n        try:\n            # Step 1: goto\n            await page.goto(\"https://google.com\")\n            await page.wait_for_load_state('networkidle')\n\n            # Step 2: fill\n            # Text: doge\n            element = await self_healing_locator(\n                page,\n                primary=page.get_by_text(\"doge\"),\n                fallbacks=[\n                    'page.locator(\"text=\\\\\"doge\\\\\"\")',\n                    'page.locator(\"//*[contains(text(), \\\\\"doge\\\\\")]\")'\n                ]\n\n            )\n            await element.fill(\"doge\")\n\n            # Step 3: click\n            # Unable to determine locator for click action\n\n            print(\"‚úÖ Task completed successfully!\")\n\n        except Exception as e:\n            print(f\"‚ùå Error during automation: {e}\")\n            raise\n        finally:\n            await browser.close()\n\n\nasync def self_healing_locator(\n    page: Page,\n    primary: str,\n    fallbacks: Optional[List[str]] = None\n) -> Locator:\n    \"\"\"Try primary locator, fall back to alternatives if it fails\"\"\"\n    fallbacks = fallbacks or []\n    \n    # Try primary locator\n    try:\n        locator = eval(primary)\n        await locator.wait_for(timeout=5000)\n        return locator\n    except Exception as e:\n        print(f\"‚ö†Ô∏è  Primary locator failed: {primary}\")\n    \n    # Try fallback locators\n    for fallback in fallbacks:\n        try:\n            locator = eval(fallback)\n            await locator.wait_for(timeout=5000)\n            print(f\"‚úì Fallback locator succeeded: {fallback}\")\n            return locator\n        except Exception:\n            continue\n    \n    raise Exception(f\"All locators failed for: {primary}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(automated_task())","size_bytes":2140},"OpenAIWeb/playwright_mcp/mcp/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"OpenAIWeb/playwright_mcp/SETUP.md":{"content":"# Setup Guide - AI Browser Automation Agent\n\n## Complete setup instructions for running this project on Windows\n\n---\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed on your Windows machine:\n\n### 1. Python 3.11 or higher\n- Download from: https://www.python.org/downloads/\n- During installation, **check the box \"Add Python to PATH\"**\n- Verify installation:\n  ```cmd\n  python --version\n  ```\n\n### 2. Node.js 18 or higher\n- Download from: https://nodejs.org/\n- Use the LTS (Long Term Support) version\n- Verify installation:\n  ```cmd\n  node --version\n  npm --version\n  ```\n\n### 3. Git (optional, for cloning)\n- Download from: https://git-scm.com/download/win\n\n---\n\n## Step 1: Download the Project\n\n### Option A: Download from Replit\n1. In Replit, click the three dots menu (‚ãÆ) at the top\n2. Select \"Download as zip\"\n3. Extract the zip file to your desired location (e.g., `C:\\Projects\\ai-browser-agent`)\n\n### Option B: Clone from Git (if available)\n```cmd\ngit clone <repository-url>\ncd ai-browser-agent\n```\n\n---\n\n## Step 2: Install Python Dependencies\n\nOpen **Command Prompt** or **PowerShell** in the project directory:\n\n```cmd\ncd C:\\Projects\\ai-browser-agent\n```\n\nInstall Python packages:\n\n```cmd\npip install flask openai requests sseclient-py\n```\n\n---\n\n## Step 3: Install Node.js Dependencies\n\nIn the same directory, install the Playwright MCP server dependencies:\n\n```cmd\nnpm install\n```\n\nThis will install:\n- `@modelcontextprotocol/sdk`\n- `playwright`\n- `@playwright/test`\n- Other required packages\n\n---\n\n## Step 4: Install Playwright Browsers\n\nPlaywright needs to download browser binaries (Chromium):\n\n```cmd\nnpx playwright install chromium\n```\n\n---\n\n## Step 5: Set Up OpenAI API Key\n\nYou need an OpenAI API key to use the GPT-5 model.\n\n### Get your API key:\n1. Go to https://platform.openai.com/api-keys\n2. Sign in or create an account\n3. Click \"Create new secret key\"\n4. Copy the key (starts with `sk-`)\n\n### Set the environment variable:\n\n**Option A: Temporary (for current session only)**\n```cmd\nset OPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n**Option B: Permanent (recommended)**\n1. Open **System Properties** (search \"environment variables\" in Windows)\n2. Click \"Environment Variables\"\n3. Under \"User variables\", click \"New\"\n4. Variable name: `OPENAI_API_KEY`\n5. Variable value: `sk-your-actual-api-key-here`\n6. Click OK\n\n**Option C: Create a .env file** (if you modify the code to use python-dotenv)\n```\nOPENAI_API_KEY=sk-your-actual-api-key-here\n```\n\n---\n\n## Step 6: Run the Application\n\nStart the Flask web server:\n\n```cmd\npython main.py\n```\n\nYou should see output like:\n```\n * Serving Flask app 'app.web_app'\n * Debug mode: off\n * Running on http://127.0.0.1:5000\n```\n\n---\n\n## Step 7: Access the Web Interface\n\nOpen your web browser and go to:\n\n```\nhttp://localhost:5000\n```\n\nYou should see the AI Browser Automation Agent interface!\n\n---\n\n## Testing the Application\n\nTry these example instructions:\n\n1. **Simple navigation:**\n   ```\n   Go to example.com\n   ```\n\n2. **Search task:**\n   ```\n   Navigate to google.com and search for 'Playwright MCP'\n   ```\n\n3. **Page interaction:**\n   ```\n   Open github.com and find trending repositories\n   ```\n\n---\n\n## Troubleshooting\n\n### Issue: \"Python is not recognized\"\n- Make sure Python is added to your PATH during installation\n- Restart Command Prompt after installing Python\n- Try using `py` instead of `python`\n\n### Issue: \"npm is not recognized\"\n- Make sure Node.js is installed correctly\n- Restart Command Prompt after installing Node.js\n- Check if Node.js is in PATH: `where node`\n\n### Issue: \"OPENAI_API_KEY not set\"\n- Make sure you set the environment variable\n- Restart Command Prompt after setting permanent variables\n- Verify it's set: `echo %OPENAI_API_KEY%`\n\n### Issue: \"Port 5000 already in use\"\n- Another application is using port 5000\n- Edit `main.py` and change the port:\n  ```python\n  app.run(host='0.0.0.0', port=8000)\n  ```\n- Then access at: `http://localhost:8000`\n\n### Issue: Browser automation fails\n- Make sure Playwright browsers are installed: `npx playwright install chromium`\n- Check if antivirus is blocking browser execution\n- Try running as Administrator\n\n### Issue: \"Module not found\" errors\n- Make sure all Python packages are installed: `pip install flask openai requests sseclient-py`\n- Make sure Node.js packages are installed: `npm install`\n\n---\n\n## Project Structure\n\n```\nai-browser-agent/\n‚îú‚îÄ‚îÄ app/                      # Python application\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ web_app.py           # Flask web server\n‚îÇ   ‚îú‚îÄ‚îÄ mcp_stdio_client.py  # MCP client (subprocess)\n‚îÇ   ‚îú‚îÄ‚îÄ browser_agent.py     # OpenAI agent\n‚îÇ   ‚îú‚îÄ‚îÄ templates/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html       # Web UI\n‚îÇ   ‚îî‚îÄ‚îÄ static/\n‚îÇ       ‚îú‚îÄ‚îÄ css/style.css\n‚îÇ       ‚îî‚îÄ‚îÄ js/app.js\n‚îú‚îÄ‚îÄ main.py                  # Application entry point\n‚îú‚îÄ‚îÄ cli.js                   # Playwright MCP server (Node.js)\n‚îú‚îÄ‚îÄ package.json             # Node.js dependencies\n‚îú‚îÄ‚îÄ pyproject.toml           # Python project config\n‚îî‚îÄ‚îÄ SETUP.md                 # This file\n```\n\n---\n\n## How It Works\n\n1. **Flask Server**: Runs on port 5000, serves the web interface\n2. **User Input**: You enter a natural language instruction in the browser\n3. **OpenAI Processing**: GPT-5 interprets your instruction\n4. **MCP Communication**: Python spawns Node.js subprocess running Playwright MCP\n5. **Browser Automation**: Playwright executes browser actions (navigate, click, fill, etc.)\n6. **Results**: Actions and results are displayed in real-time\n\n---\n\n## API Endpoints\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute an instruction\n- `GET /api/tools` - List available browser tools\n- `POST /api/reset` - Reset agent conversation\n- `GET /health` - Health check\n\n---\n\n## Stopping the Application\n\nPress `Ctrl + C` in the Command Prompt window to stop the server.\n\n---\n\n## Notes for Windows Users\n\n1. **Firewall**: Windows may ask for firewall permission - allow it\n2. **Antivirus**: Some antivirus software may block browser automation - add exception if needed\n3. **PowerShell**: If using PowerShell, use `$env:OPENAI_API_KEY=\"sk-...\"` to set variables\n4. **Paths**: Use backslashes (`\\`) for Windows paths, or forward slashes (`/`) work too\n5. **Long Paths**: If you encounter path length issues, enable long paths in Windows\n\n---\n\n## Production Deployment\n\nThis setup is for **development/testing only**. For production:\n\n1. **Use a production WSGI server** (not Flask development server):\n   ```cmd\n   pip install gunicorn\n   gunicorn --bind 0.0.0.0:5000 app.web_app:app\n   ```\n   Note: Gunicorn doesn't work natively on Windows. Use `waitress` instead:\n   ```cmd\n   pip install waitress\n   waitress-serve --host=0.0.0.0 --port=5000 app.web_app:app\n   ```\n\n2. **Use environment variables** for all secrets (never hardcode API keys)\n\n3. **Add security headers** and CORS configuration\n\n4. **Consider deploying to a cloud platform** (Replit, Heroku, AWS, Azure, etc.)\n\n---\n\n## Cost Considerations\n\n- **OpenAI API**: You'll be charged based on GPT-5 usage (tokens processed)\n- Each instruction execution calls OpenAI multiple times (typically 2-5 calls)\n- Monitor your usage at: https://platform.openai.com/usage\n\n---\n\n## Support\n\nIf you encounter issues:\n1. Check the console output for error messages\n2. Verify all prerequisites are installed correctly\n3. Make sure your OpenAI API key is valid and has credits\n4. Check that port 5000 is not blocked by firewall\n\n---\n\n## License\n\nSee LICENSE file for details.\n\n---\n\n**Enjoy automating with AI!** ü§ñ\n","size_bytes":7614},"OpenAIWeb/playwright_mcp/server/services/mcp_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None, capabilities: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n            capabilities: Comma-separated capabilities to enable (e.g., \"vision,testing,tracing\")\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        # Use provided values or fall back to config.ini\n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        if capabilities is None:\n            # Default capabilities for better locator extraction\n            capabilities = config.get('browser', 'capabilities', fallback='testing')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        # Start MCP server process\n        args = [\"node\", \"mcp/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        # Add capabilities if specified\n        if capabilities:\n            args.append(f\"--caps={capabilities}\")\n        \n        # Set environment variable to skip Playwright host validation\n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        # Start reader threads\n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        # Start stderr reader to prevent deadlock\n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        # Give the process a moment to start\n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            # This is a response to a request\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            # This is a notification\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        # Not JSON, might be log output - ignore\n                        pass\n                except UnicodeDecodeError:\n                    # Skip lines with encoding issues\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                    # Optionally log stderr for debugging\n                    # print(f\"MCP stderr: {line.strip()}\")\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        # Create queue for this request\n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            # Send request\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            # Wait for response\n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            # Clean up\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)  # Timeout for tool calls\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":9488},"OpenAIWeb/OpenAIWeb/README.md":{"content":"# AI Browser Automation CLI\n\n> **A powerful Python CLI tool for AI-powered browser automation with self-healing code generation**\n\n## Quick Start\n\n```bash\n# Basic automation\npython main.py \"go to example.com and tell me the page title\"\n\n# Generate reusable code\npython main.py \"fill out login form\" --generate-code --output login.py\n\n# Execute with self-healing\npython main.py --execute-code login.py --verbose\n```\n\n## Features\n\n‚ú® **Natural Language Interface** - Describe tasks in plain English  \nü§ñ **AI-Powered Automation** - Uses OpenAI GPT-4o-mini and browser-use  \nüîß **Self-Healing Code** - Automatically fixes broken locators  \nüöÄ **Production Ready** - Generate maintainable Playwright scripts  \n\n## Documentation\n\nüìö **[Complete Documentation](DOCUMENTATION.md)** - Installation, usage, examples, and troubleshooting\n\n## Project Structure\n\n```\nai-browser-automation/\n‚îú‚îÄ‚îÄ src/                    # Core modules\n‚îÇ   ‚îú‚îÄ‚îÄ automation_engine.py\n‚îÇ   ‚îú‚îÄ‚îÄ playwright_code_generator.py\n‚îÇ   ‚îú‚îÄ‚îÄ self_healing_executor.py\n‚îÇ   ‚îî‚îÄ‚îÄ locator_utils.py\n‚îú‚îÄ‚îÄ examples/              # Example scripts\n‚îú‚îÄ‚îÄ main.py               # CLI entry point\n‚îú‚îÄ‚îÄ DOCUMENTATION.md      # Full documentation\n‚îî‚îÄ‚îÄ .env.example         # Environment template\n```\n\n## Prerequisites\n\n- Python 3.11+\n- OpenAI API key ([Get one here](https://platform.openai.com/api-keys))\n\n## Technology Stack\n\n- **browser-use** - AI browser automation\n- **OpenAI gpt-4o-mini** - Natural language understanding\n- **Playwright** - Browser automation backend\n- **Python 3.11+** - Modern Python features\n\n## License\n\nMIT License\n\n---\n\n**Built with ‚ù§Ô∏è using OpenAI, browser-use, and Playwright**\n","size_bytes":1717},"OpenAIWeb/playwright_mcp/pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask>=3.1.2\",\n    \"openai>=2.6.0\",\n    \"playwright>=1.55.0\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":262},"OpenAIWeb/playwright_mcp/mcp/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"OpenAIWeb/playwright_mcp/main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nfrom server import create_app\n\nif __name__ == '__main__':\n    app = create_app()\n    # Run Flask on port 5000, bound to all interfaces for Replit\n    app.run(host='0.0.0.0', port=5000, debug=False)\n","size_bytes":269},"OpenAIWeb/OpenAIWeb/IMPORT_COMPLETION.md":{"content":"# Import Migration Completed! üéâ\n\n## What Was Fixed\n\n### 1. Security Issue Resolved ‚úÖ\n- **Removed hardcoded API key** from `main.py` line 147\n- Now properly uses `os.getenv(\"OPENAI_API_KEY\")` to load from environment variables\n- This prevents exposing your API key in the codebase\n\n### 2. Code Generation Fixed ‚úÖ  \n- **Improved history parser** to handle browser-use 0.5.9's `AgentHistoryList` structure\n- Added `_extract_from_agent_history()` method to properly parse `AgentHistory` objects\n- Enhanced verbose debugging output with `--verbose` flag\n- Better error messages when actions can't be extracted\n\n### 3. Environment Setup ‚úÖ\n- Installed all Python dependencies via `uv`\n- Installed Playwright Chromium browser\n- Configured OpenAI integration with Replit Secrets\n\n## Important: API Key Issue\n\nThere's an **old API key still cached** in the environment. Here's how to fix it:\n\n### On Replit:\nThe new API key you added to Replit Secrets exists, but the old environment is still loaded.\n\n**To refresh and use your new key:**\n```bash\nkill 1\n```\nThis restarts the virtual machine and loads your new secret. Your workspace will reconnect automatically.\n\n### On Your Local Windows Machine:\nSince you're running this locally (based on your error logs), you need to update your local environment:\n\n1. **Create a `.env` file** in your project root:\n```bash\nOPENAI_API_KEY=your_actual_api_key_here\n```\n\n2. **Or set environment variable** in PowerShell:\n```powershell\n$env:OPENAI_API_KEY=\"your_actual_api_key_here\"\npython main.py \"go to example.com\" --verbose\n```\n\n## How to Use\n\n### Basic Usage:\n```bash\n# Simple automation\npython main.py \"go to example.com and tell me the page title\"\n\n# With code generation\npython main.py \"click the login button\" --generate-code --output login.py\n\n# With debugging\npython main.py \"fill out the form\" --verbose --generate-code\n```\n\n### On Replit (recommended):\n```bash\n# Use uv run to ensure correct environment\nuv run python main.py \"your task here\" --verbose\n```\n\n## Testing the Fixes\n\nAfter you refresh the API key (using `kill 1` on Replit or updating .env locally), test with:\n\n```bash\npython main.py \"open https://www.linkedin.com click Join Now\" --generate-code --output linkedin.py --verbose\n```\n\nThe `--verbose` flag will show you:\n- ‚úÖ How many AgentHistory items were found\n- ‚úÖ Which actions were extracted\n- ‚úÖ Any parsing issues\n\n## Expected Output\n\nWith the fixes, you should see:\n```\nüîç Parsing action history...\n   History type: <class 'browser_use.agent.views.AgentHistoryList'>\n   Found history attribute: X items\n   ‚úì Extracted goto action\n   ‚úì Extracted click action\n‚úì Parsed 2 actions\n‚úì Code saved to: linkedin.py\n```\n\nAnd the generated file should contain actual Playwright code, not just `# No actions to generate code from`.\n\n## Next Steps\n\n1. **Refresh environment** to load new API key\n2. **Test code generation** with verbose flag\n3. **Check generated files** to verify they contain code\n4. **Report any issues** if code is still empty\n\n## Files Modified\n\n- `main.py` - Fixed API key loading\n- `src/playwright_code_generator.py` - Fixed history parsing for browser-use 0.5.9\n- `pyproject.toml` - Dependencies configured\n- `.local/state/replit/agent/progress_tracker.md` - Import progress tracking\n\n## Troubleshooting\n\n### Empty Generated Files\n- Make sure API key is valid and environment is refreshed\n- Use `--verbose` flag to see what's being parsed\n- Check that the task actually completed successfully\n\n### API Key Errors  \n- Run `kill 1` on Replit to refresh environment\n- Check `env | grep OPENAI` to verify current key\n- Make sure new key starts with `sk-` and is valid\n\n### Windows asyncio Warnings\n- These are harmless cleanup warnings on Windows\n- They don't affect functionality\n- Ignore messages about \"I/O operation on closed pipe\"\n\n---\n\n**Import Status: ‚úÖ Complete (pending environment refresh)**\n","size_bytes":3895},"OpenAIWeb/OpenAIWeb/debug_history.py":{"content":"#!/usr/bin/env python3\n\"\"\"Debug script to understand browser-use history structure\"\"\"\nimport asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom src.automation_engine import BrowserAutomationEngine\n\nasync def main():\n    load_dotenv()\n    \n    api_key = os.getenv(\"OPENAI_API_KEY\")\n    if not api_key:\n        print(\"Error: OPENAI_API_KEY not set\")\n        return\n    \n    engine = BrowserAutomationEngine(\n        api_key=api_key,\n        model=\"gpt-4o-mini\",\n        headless=True,\n        verbose=True,\n        generate_code=False\n    )\n    \n    print(\"Running simple test task...\\n\")\n    response = await engine.run_task(\"go to example.com\", output_file=None)\n    \n    history = response['history']\n    print(\"\\n\" + \"=\"*60)\n    print(\"HISTORY STRUCTURE ANALYSIS\")\n    print(\"=\"*60)\n    print(f\"History type: {type(history)}\")\n    print(f\"History class name: {history.__class__.__name__}\")\n    print(f\"\\nAvailable attributes:\")\n    attrs = [a for a in dir(history) if not a.startswith('_')]\n    for attr in attrs[:20]:\n        print(f\"  - {attr}\")\n    \n    # Try different access methods\n    print(f\"\\nhasattr(history, 'history'): {hasattr(history, 'history')}\")\n    print(f\"hasattr(history, 'model_actions'): {hasattr(history, 'model_actions')}\")\n    print(f\"hasattr(history, 'items'): {hasattr(history, 'items')}\")\n    print(f\"hasattr(history, '__iter__'): {hasattr(history, '__iter__')}\")\n    \n    # Try to iterate\n    print(\"\\nAttempting to iterate over history:\")\n    try:\n        for i, item in enumerate(history):\n            print(f\"  Item {i}: type={type(item)}, value={item}\")\n            if i >= 2:  # Just show first 3\n                break\n    except Exception as e:\n        print(f\"  Error iterating: {e}\")\n    \n    # Try history.history\n    if hasattr(history, 'history'):\n        print(\"\\nAccessing history.history:\")\n        try:\n            hist_items = history.history\n            print(f\"  Type: {type(hist_items)}\")\n            print(f\"  Length: {len(hist_items) if hasattr(hist_items, '__len__') else 'N/A'}\")\n            if hist_items:\n                print(f\"  First item type: {type(hist_items[0])}\")\n                print(f\"  First item attributes: {[a for a in dir(hist_items[0]) if not a.startswith('_')][:15]}\")\n                if hasattr(hist_items[0], '__dict__'):\n                    print(f\"  First item dict keys: {list(hist_items[0].__dict__.keys())}\")\n        except Exception as e:\n            print(f\"  Error: {e}\")\n    \n    # Try model_actions\n    if hasattr(history, 'model_actions'):\n        print(\"\\nCalling history.model_actions():\")\n        try:\n            actions = history.model_actions()\n            print(f\"  Type: {type(actions)}\")\n            print(f\"  Length: {len(actions) if hasattr(actions, '__len__') else 'N/A'}\")\n            if actions:\n                print(f\"  First action type: {type(actions[0])}\")\n                if hasattr(actions[0], '__dict__'):\n                    print(f\"  First action dict keys: {list(actions[0].__dict__.keys())}\")\n        except Exception as e:\n            print(f\"  Error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":3127},"OpenAIWeb/OpenAIWeb/DOCUMENTATION.md":{"content":"# AI Browser Automation CLI with Self-Healing Code Generation\n\n## Overview\n\nA powerful Python CLI tool that performs AI-powered browser automation and generates reusable Playwright code with automatic self-healing capabilities. Simply describe what you want to do in natural language, and the AI handles everything‚Äîincluding fixing broken locators in generated code.\n\n**Key Features:**\n1. **AI Browser Automation**: Run tasks using natural language with browser-use\n2. **Self-Healing Code Generation**: Convert browser-use actions into reusable Playwright code with automatic locator healing\n3. **Enhanced AI Fallback**: Two-level recovery system ensures automation never fails\n\n---\n\n## Features\n\n### Core Capabilities\n- **Natural Language Interface**: Describe tasks in plain English\n- **Advanced Browser Automation**: Navigation, clicking, form filling, data extraction, multi-step workflows\n- **AI-Powered**: Uses OpenAI gpt-4o-mini with browser-use for intelligent task execution\n\n### Self-Healing Code Generation ‚≠ê\n- **Generate Reusable Code**: Convert automation into clean Playwright Python scripts\n- **Multiple Locator Strategies**: Text, role, ID, label, CSS, XPath with automatic fallbacks\n- **AI-Powered Self-Healing**: When locators fail in generated code, AI automatically finds elements and fixes locators **within the same browser session**\n- **Production-Ready**: Generated code is maintainable, testable, and adapts to page changes\n\n### Enhanced AI Fallback Execution ‚≠ê‚≠ê\n- **Two-Level Recovery System**: Ensures automation never fails\n- **Level 1 - Locator Healing**: AI finds new locators when elements move or change\n- **Level 2 - AI Fallback**: If healed locators fail, browser-use AI steps in to execute the specific action\n- **Same Browser Session**: No restarts, state preserved throughout recovery\n- **Zero Manual Intervention**: Completely automated recovery process\n\n**Important**: Self-healing applies only to **generated code execution**, not initial automation (which already uses AI natively).\n\n---\n\n## Prerequisites\n\n- Python 3.11 or higher\n- OpenAI API key ([Get one here](https://platform.openai.com/api-keys))\n- Replit environment (if running on Replit)\n\n---\n\n## Installation\n\n### On Replit (Recommended)\n\nThe project is pre-configured for Replit. You only need to:\n\n1. **Add your OpenAI API key**:\n   - The system will automatically prompt you for the `OPENAI_API_KEY`\n   - Get your API key from https://platform.openai.com/api-keys\n   - Add it to Replit Secrets when prompted\n\n2. **Dependencies are pre-installed**:\n   - browser-use\n   - langchain-openai\n   - playwright\n   - python-dotenv\n   - openai\n\n3. **Playwright browsers are pre-installed**:\n   - Chromium is already configured and ready to use\n\n### Manual Installation (Local)\n\nIf running locally:\n\n1. Install dependencies:\n```bash\npip install browser-use langchain-openai python-dotenv playwright openai\n```\n\n2. Install Playwright browser:\n```bash\npython -m playwright install chromium\n```\n\n3. Set up your OpenAI API key:\n```bash\nexport OPENAI_API_KEY=\"your-api-key-here\"\n```\n\n---\n\n## Usage\n\n### Mode 1: Direct Browser Automation\n\nRun tasks using natural language:\n\n```bash\npython main.py \"search for Python tutorials on Google\"\n```\n\n**Examples:**\n\n**Web Scraping:**\n```bash\npython main.py \"scrape the top 10 Hacker News posts with their titles and URLs\"\n```\n\n**Form Automation:**\n```bash\npython main.py \"go to example.com/contact and fill out the contact form with name: John Doe, email: john@example.com\"\n```\n\n**Multi-step Workflows:**\n```bash\npython main.py \"compare prices for iPhone 15 on Amazon and Best Buy\"\n```\n\n**Data Collection:**\n```bash\npython main.py \"find the top 5 Python automation libraries on GitHub and extract their star counts\"\n```\n\n**Simple Tasks:**\n```bash\npython main.py \"go to example.com and tell me the page title\"\n```\n\n### Mode 2: Code Generation\n\nGenerate reusable Playwright code from your automation:\n\n```bash\npython main.py \"go to example.com and click login\" --generate-code\n```\n\n**With custom output file:**\n```bash\npython main.py \"search for Python on Google\" --generate-code --output search_google.py\n```\n\n**With verbose logging:**\n```bash\npython main.py \"navigate to GitHub trending\" --generate-code --verbose\n```\n\n### Mode 3: Self-Healing Execution\n\nExecute generated code with automatic self-healing:\n\n```bash\npython main.py --execute-code generated_automation.py\n```\n\n**With verbose healing logs:**\n```bash\npython main.py --execute-code search_google.py --verbose\n```\n\nThe self-healing will automatically:\n- Detect when locators fail\n- Use AI to find correct elements\n- Generate new working locators\n- Resume execution smoothly\n- If healing fails, AI executes the action directly\n\n### Complete Workflow Example\n\n```bash\n# Step 1: Record and generate code\npython main.py \"go to example.com, click login, fill email with test@email.com\" \\\n  --generate-code --output login_flow.py --verbose\n\n# Step 2: Execute with self-healing (even if page changes)\npython main.py --execute-code login_flow.py --verbose\n```\n\n---\n\n## Command Options\n\n```bash\npython main.py [OPTIONS] \"task description\"\n\nOptions:\n  -h, --help              Show help message\n  --headless              Run browser in headless mode (default: False)\n  --no-headless           Show browser window\n  --model MODEL           OpenAI model to use (default: gpt-4o-mini)\n  --verbose               Show detailed logs\n  --generate-code         Generate reusable Playwright Python code\n  --output FILE           Output file for generated code (default: generated_automation.py)\n  --execute-code FILE     Execute a previously generated automation script with self-healing\n```\n\n---\n\n## How It Works\n\n### Mode 1: Direct Browser Automation\n1. User provides natural language task via CLI\n2. browser-use Agent interprets and executes the task\n3. Results returned to user\n\n### Mode 2: Code Generation\n1. User provides task with `--generate-code` flag\n2. browser-use Agent performs the automation\n3. Action history is captured and parsed\n4. PlaywrightCodeGenerator converts actions to reusable Python code\n5. Generated code includes multiple locator fallback strategies\n6. Code saved to file for later execution\n\n### Mode 3: Self-Healing Execution with AI Fallback\n1. User runs generated code with `--execute-code` flag\n2. SelfHealingExecutor loads and runs the Playwright script\n3. **When a locator fails:**\n   - Execution pauses (same browser session maintained)\n   - browser-use AI intervenes to analyze the page\n   - AI finds the element using intelligent heuristics\n   - New working locator is generated and cached\n   - Execution resumes smoothly with remaining steps\n4. **If healed locator also fails:**\n   - browser-use AI steps in to execute the specific failed action\n   - AI completes just that one action (click, fill, etc.)\n   - AI gracefully exits, returning control to the automation script\n   - Script continues executing remaining steps normally\n5. Process continues until all steps complete\n\n---\n\n## Enhanced Self-Healing with AI Fallback\n\n### Two-Level Recovery System\n\nThe self-healing executor features a **two-level recovery system** that ensures your automation scripts run successfully even when pages change dramatically.\n\n### Level 1: Locator Healing\n\nWhen a locator fails (e.g., button moved, ID changed):\n1. AI analyzes the current page\n2. Finds the element using smart heuristics\n3. Generates a new working locator\n4. Caches it for future use\n5. ‚úÖ Continues execution with the new locator\n\n### Level 2: AI Fallback Execution\n\nIf the healed locator also fails (e.g., element structure completely changed):\n1. ü§ñ browser-use AI steps into the **same browser session**\n2. AI executes **just that one specific action** (click, fill, etc.)\n3. AI reports success and **gracefully exits**\n4. Your automation script **continues** with the next steps\n5. ‚úÖ Zero manual intervention needed\n\n### Example Scenario\n\nImagine your script has these steps:\n```python\n1. Go to example.com\n2. Click login button       ‚Üê Locator fails!\n3. Fill email field\n4. Click submit\n```\n\n**Without AI Fallback:**\n```\nStep 1: ‚úÖ Success\nStep 2: ‚ö†Ô∏è  Locator failed\n        üîß Healing attempt...\n        ‚ùå Healed locator also failed\n        ‚ùå SCRIPT FAILS - Manual fix required\n```\n\n**With AI Fallback (Enhanced):**\n```\nStep 1: ‚úÖ Success\nStep 2: ‚ö†Ô∏è  Locator failed\n        üîß Healing attempt...\n        ‚ùå Healed locator also failed\n        ü§ñ browser-use AI stepping in...\n        ‚úÖ AI clicked the login button\n        üîÑ Continuing with automation script...\nStep 3: ‚úÖ Success (fills email field)\nStep 4: ‚úÖ Success (clicks submit)\n        ‚úÖ AUTOMATION COMPLETED\n```\n\n### Verbose Output Example\n\nWhen running with `--verbose`, you'll see:\n\n```bash\n$ python main.py --execute-code login_automation.py --verbose\n\nüöÄ Starting execution with self-healing enabled\n   Max healing attempts per locator: 3\n\n   # Step 1: Navigate to page\n   ‚úì page.goto(\"https://example.com\")\n\n   # Step 2: Click login button\n   ‚ö†Ô∏è  Locator failed: page.get_by_text(\"Login\")\n      Error: Timeout 10000ms exceeded\n\nüîß Healing attempt 1/3\n   Failed locator: page.get_by_text(\"Login\")\n   Action: click login button\n   ü§ñ AI analyzing page to find element...\n   üîó Connecting to browser session: ws://127.0.0.1:...\n   ‚úÖ Healing successful! New locator: page.get_by_role(\"button\", name=\"Sign In\")\n\n   # Trying healed locator...\n   ‚ùå Healed locator also failed: Timeout 10000ms exceeded\n\nü§ñ Healed locator failed - browser-use AI stepping in to execute action...\n   Action: click login button\n   ü§ñ AI executing action in current browser session...\n   ‚úÖ AI successfully executed the action!\n   üîÑ Continuing with automation script...\n\n   # Step 3: Fill email field\n   ‚úì Locator found immediately\n\n   # Step 4: Click submit\n   ‚úì Locator found immediately\n\n‚úÖ Execution completed successfully!\n   Healed 1 locator(s) during execution\n```\n\n### Key Benefits\n\n1. **Zero Manual Intervention**: Scripts fix themselves completely\n2. **Handles Severe Changes**: Even if page structure changes dramatically\n3. **Same Browser Session**: No restart, state preserved\n4. **Surgical Precision**: AI executes only the failed action, nothing more\n5. **Graceful Handoff**: Control returns smoothly to your script\n\n### When Is This Useful?\n\n- **Website Redesigns**: Complete UI changes that break all locators\n- **A/B Testing**: Site shows different versions to different users\n- **Dynamic Content**: Elements that change frequently\n- **Flaky Locators**: Selectors that work inconsistently\n- **Complex Pages**: Modern SPAs with unpredictable DOM structures\n\n---\n\n## Technology Stack\n\n- **Python 3.11+**: Modern Python features\n- **browser-use (0.5.9+)**: AI-powered browser automation framework\n- **OpenAI gpt-4o-mini**: Natural language understanding (newest model, released August 7, 2025)\n- **Playwright**: Browser automation backend for generated code execution\n- **langchain-openai**: OpenAI integration for LangChain\n- **python-dotenv**: Environment variable management\n\n---\n\n## Project Architecture\n\n### Main Components\n\n1. **main.py** - CLI entry point with three modes: automation, code generation, and self-healing execution\n2. **automation_engine.py** - Core automation logic with browser-use and code generation support\n3. **playwright_code_generator.py** - Converts browser-use action history to Playwright code\n4. **self_healing_executor.py** - Executes generated code with AI-powered locator healing\n5. **locator_utils.py** - Helper utilities for robust locator strategies\n6. **test_workflow.py** - Test script for the complete workflow\n\n### Generated Code Features\n\nGenerated code includes:\n\n1. **Multiple Locator Strategies**:\n   - Text-based locators (exact and partial match)\n   - Role-based locators (ARIA roles)\n   - Label-based locators\n   - ID and test-ID locators\n   - CSS and XPath selectors\n\n2. **Self-Healing Integration**:\n   - Automatic locator healing when elements change\n   - AI fallback execution for severe changes\n   - Locator caching for performance\n   - Same browser session continuity\n\n3. **Clean, Maintainable Code**:\n   - Async/await Playwright syntax\n   - Proper error handling\n   - Type hints\n   - Descriptive variable names\n\n---\n\n## Troubleshooting\n\n### Error: Missing OPENAI_API_KEY\n- Make sure you've added your OpenAI API key to Replit Secrets\n- On local machines, ensure the environment variable is set\n\n### Browser fails to start\n- On Replit: The browser is pre-configured and should work automatically\n- On local machines: Check that Chromium is properly installed with `python -m playwright install chromium`\n- Try running with `--no-headless` to see what's happening\n\n### Locators keep failing even with self-healing\n- Enable `--verbose` mode to see detailed healing logs\n- Check if the element exists on the page\n- Verify the action description is clear and accurate\n- Ensure your OpenAI API key is valid and has credits\n\n### API key rejected (401 error)\n- Double-check your OpenAI API key is correct\n- Verify the key starts with \"sk-proj-\" or \"sk-\"\n- Ensure the key has not been revoked\n- Check your OpenAI account has available credits\n\n---\n\n## Environment Variables\n\n- `OPENAI_API_KEY` (required): OpenAI API key for gpt-4o-mini access\n- `CHROMIUM_PATH` (optional): Custom path to Chromium browser (auto-detected on Replit)\n\n---\n\n## Best Practices\n\n1. **Use descriptive action descriptions**: \"click login button\" is better than \"click element\"\n2. **Enable verbose mode during development**: See exactly what's happening with `--verbose`\n3. **Monitor healing frequency**: If AI fallback triggers often, consider updating locators\n4. **Keep API key secure**: Store in environment variables, never in code\n5. **Test generated code**: Run with `--execute-code` to verify it works before deploying\n6. **Use meaningful output filenames**: Name generated scripts descriptively (e.g., `login_flow.py`, `checkout_process.py`)\n\n---\n\n## Limitations\n\n- Requires active OpenAI API key with available credits\n- AI execution takes slightly longer than direct locators (a few seconds)\n- Self-healing applies only to generated code execution, not initial automation\n- Limited to actions browser-use AI can understand (click, fill, navigate, extract, etc.)\n- Requires `action_description` parameter for AI fallback to work effectively\n\n---\n\n## Recent Updates\n\n### October 22, 2025 - Enhanced Self-Healing with AI Fallback Execution\n- **ENHANCED**: Self-healing now includes browser-use AI fallback execution\n  - When healed locator fails, browser-use AI executes the specific action\n  - AI gracefully exits after completing the action\n  - Automation script continues with remaining steps\n  - No manual intervention required\n- Added AIExecutedMarker class to track AI-executed actions\n- Updated documentation with enhanced self-healing flow\n\n### October 22, 2025 - Self-Healing Code Generation Added\n- **NEW**: PlaywrightCodeGenerator - Converts browser-use actions to reusable Playwright code\n- **NEW**: SelfHealingExecutor - AI-powered locator healing for generated code execution\n- **NEW**: CLI modes: --generate-code and --execute-code with self-healing\n- **NEW**: Locator utilities with multiple fallback strategies\n- Updated automation engine to support code generation mode\n- Created test workflow for validation\n\n### October 22, 2025 - Initial Setup\n- Initial project setup on Replit\n- Installed dependencies: browser-use, langchain-openai, python-dotenv, playwright\n- Installed Chromium browser\n- Created core CLI application (main.py)\n- Implemented browser automation engine (automation_engine.py)\n\n---\n\n## Future Enhancements\n\n- Export to Playwright Codegen format\n- Video recording of healing process\n- Locator confidence scoring\n- Multi-language code generation (TypeScript, Java, C#)\n- Configuration file for healing strategies\n- Session replay and debugging tools\n- Integration with CI/CD pipelines\n- Support for more browsers (Firefox, WebKit)\n\n---\n\n## License\n\nMIT License\n\n---\n\n## Support\n\nFor issues, questions, or contributions:\n- Check the troubleshooting section above\n- Review the verbose logs with `--verbose` flag\n- Ensure your OpenAI API key is valid and has credits\n- Verify all dependencies are properly installed\n\n---\n\n**Built with ‚ù§Ô∏è using OpenAI, browser-use, and Playwright**\n","size_bytes":16348},"OpenAIWeb/playwright_mcp/server/services/browser_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom typing import List, Dict, Any\nfrom openai import OpenAI\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        # Get API key from config.ini first, fallback to environment variable\n        api_key = config.get('openai', 'api_key', fallback=None)\n        if not api_key or api_key == 'YOUR_OPENAI_API_KEY_HERE':\n            api_key = os.environ.get('OPENAI_API_KEY')\n        \n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set in config.ini [openai] api_key field or as OPENAI_API_KEY environment variable. IMPORTANT: For security, prefer using environment variables instead of storing keys in config.ini.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Initialize MCP connection and get available tools\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        # Start conversation\n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                # Call OpenAI with function calling\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,  # type: ignore\n                    tools=tools,  # type: ignore\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                # Check if assistant wants to call tools\n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name  # type: ignore\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                        \n                        # Execute the tool\n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            # Extract useful information from result\n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            # Add tool result to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            # Add error to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    # Assistant has finished\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6718},"OpenAIWeb/OpenAIWeb/src/self_healing_executor.py":{"content":"import asyncio\nimport os\nfrom typing import Optional, Dict, Any, List, Callable\nfrom playwright.async_api import Page, Browser, Locator, async_playwright\nfrom browser_use import Agent, Browser as BrowserUseWrapper, ChatOpenAI\n\n\nclass AIExecutedMarker:\n    \"\"\"Marker to indicate an action was executed by browser-use AI instead of Playwright\"\"\"\n    def __init__(self, action_description: str):\n        self.action_description = action_description\n        self.executed_by_ai = True\n    \n    def __repr__(self):\n        return f\"<AIExecutedMarker: {self.action_description}>\"\n\n\nclass SelfHealingExecutor:\n    \"\"\"\n    Executes Playwright code with AI-powered self-healing capabilities.\n    When a locator fails, browser-use AI intervenes in the same session to fix it.\n    \"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.verbose = verbose\n        self.llm = None\n        self.healed_locators: Dict[str, str] = {}\n        self.healing_attempts = 0\n        self.max_healing_attempts = 3\n    \n    def _initialize_llm(self) -> ChatOpenAI:\n        \"\"\"Initialize OpenAI LLM for browser-use\"\"\"\n        if not self.llm:\n            self.llm = ChatOpenAI(\n                model=self.model,\n                api_key=self.api_key\n            )\n            if self.verbose:\n                print(f\"‚úì Initialized healing LLM: {self.model}\")\n        return self.llm\n    \n    async def heal_locator(\n        self,\n        page: Page,\n        failed_locator: str,\n        action_description: str,\n        element_description: str = \"\",\n        playwright_context = None\n    ) -> Optional[str]:\n        \"\"\"\n        Use browser-use AI to find and fix a broken locator in the same session.\n        \n        Args:\n            page: The Playwright page object\n            failed_locator: The locator that failed\n            action_description: What action we're trying to perform (e.g., \"click login button\")\n            element_description: Additional context about the element\n            playwright_context: The Playwright browser context to reuse\n        \n        Returns:\n            New working locator string, or None if healing failed\n        \"\"\"\n        if self.healing_attempts >= self.max_healing_attempts:\n            if self.verbose:\n                print(f\"‚ö†Ô∏è  Max healing attempts ({self.max_healing_attempts}) reached\")\n            return None\n        \n        self.healing_attempts += 1\n        \n        if self.verbose:\n            print(f\"\\nüîß Healing attempt {self.healing_attempts}/{self.max_healing_attempts}\")\n            print(f\"   Failed locator: {failed_locator}\")\n            print(f\"   Action: {action_description}\")\n        \n        try:\n            llm = self._initialize_llm()\n            \n            current_url = page.url\n            page_title = await page.title()\n            \n            task = f\"\"\"On this page ({current_url}), locate the element for: {action_description}.\n\nThe previous locator failed: {failed_locator}\nElement description: {element_description}\n\nIMPORTANT: After finding the correct element:\n1. Click or interact with it to confirm it's the right one\n2. Report back its exact attributes: text content, role, id, class, aria-label, placeholder, or any other identifying attributes\n3. Describe its location on the page for verification\n\nYour response should include the element's attributes in detail.\"\"\"\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI analyzing page to find element...\")\n            \n            cdp_url = await self._get_cdp_url(page)\n            \n            if not cdp_url:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not connect to existing browser session, fallback to heuristics\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üîó Connecting to browser session: {cdp_url}\")\n            \n            browser_wrapper = BrowserUseWrapper(\n                browser_session={'cdp_url': cdp_url}\n            )\n            \n            agent = Agent(\n                task=task,\n                llm=llm,\n                browser=browser_wrapper,\n            )\n            \n            result = await agent.run()\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI task result: {str(result)[:100] if result else 'None'}...\")\n            \n            history = agent.history if hasattr(agent, 'history') else None\n            \n            if not history:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  No history found on agent object\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üìã Analyzing agent history with {len(history.model_actions) if hasattr(history, 'model_actions') else 0} actions\")\n            \n            new_locator = await self._extract_locator_from_agent_history(\n                page=page,\n                history=history,\n                action_desc=action_description,\n                element_desc=element_description\n            )\n            \n            if new_locator:\n                self.healed_locators[failed_locator] = new_locator\n                if self.verbose:\n                    print(f\"   ‚úÖ Healing successful! New locator: {new_locator}\")\n                return new_locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not extract locator from AI, trying heuristics...\")\n                new_locator = await self._extract_locator_from_healing(page, action_description, element_description)\n                if new_locator:\n                    self.healed_locators[failed_locator] = new_locator\n                    if self.verbose:\n                        print(f\"   ‚úÖ Heuristic healing successful! New locator: {new_locator}\")\n                    return new_locator\n                \n                if self.verbose:\n                    print(f\"   ‚ùå Healing failed - could not determine new locator\")\n                return None\n                \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Healing error: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n            return None\n    \n    async def _get_cdp_url(self, page: Page) -> Optional[str]:\n        \"\"\"\n        Get CDP URL from the current Playwright browser session.\n        Uses multiple strategies to ensure compatibility.\n        \"\"\"\n        try:\n            browser = page.context.browser\n            \n            if hasattr(browser, '_impl_obj'):\n                impl_obj = browser._impl_obj\n                \n                if hasattr(impl_obj, '_connection') and hasattr(impl_obj._connection, 'url'):\n                    return impl_obj._connection.url\n                \n                if hasattr(impl_obj, '_transport') and hasattr(impl_obj._transport, 'url'):\n                    return impl_obj._transport.url\n            \n            if hasattr(browser, '_cdp_url'):\n                return browser._cdp_url\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Could not extract CDP URL: {str(e)}\")\n        \n        return None\n    \n    async def _extract_locator_from_agent_history(\n        self,\n        page: Page,\n        history,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Extract a working locator from browser-use agent's action history.\n        This parses what the AI actually found and interacted with.\n        \"\"\"\n        if not history:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  History object is None\")\n            return None\n        \n        try:\n            if hasattr(history, 'model_actions'):\n                try:\n                    actions = history.model_actions()\n                    if self.verbose:\n                        print(f\"   üìã Found {len(actions) if actions else 0} model actions in history\")\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ö†Ô∏è  Could not call model_actions(): {str(e)}\")\n                    actions = []\n                \n                for i, action in enumerate(reversed(actions)):\n                    if self.verbose:\n                        print(f\"   üîç Analyzing action {len(actions) - i}: {type(action)}\")\n                    \n                    if hasattr(action, '__dict__'):\n                        action_dict = action.__dict__\n                    elif isinstance(action, dict):\n                        action_dict = action\n                    else:\n                        continue\n                    \n                    action_type = action_dict.get('action', {})\n                    \n                    if isinstance(action_type, dict):\n                        if 'click_element' in action_type:\n                            element = action_type['click_element'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found click_element action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n                        \n                        if 'input_text' in action_type:\n                            element = action_type['input_text'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found input_text action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  History has no model_actions attribute\")\n            \n            if hasattr(history, 'history') and history.history:\n                if self.verbose:\n                    print(f\"   üîç Checking history.history list with {len(history.history)} items\")\n                for item in reversed(history.history):\n                    if hasattr(item, 'result') and hasattr(item.result, 'extracted_content'):\n                        if self.verbose:\n                            print(f\"   ‚úì Found extracted content in history item\")\n                        element_data = item.result.extracted_content\n                        if isinstance(element_data, dict) and 'attributes' in element_data:\n                            locator = await self._build_locator_from_element(page, element_data)\n                            if locator:\n                                return locator\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Error extracting from agent history: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n        \n        if self.verbose:\n            print(f\"   ‚ö†Ô∏è  Could not extract locator from agent history - falling back to heuristics\")\n        return None\n    \n    async def _build_locator_from_element(self, page: Page, element: Dict) -> Optional[str]:\n        \"\"\"Build a Playwright locator string from element attributes found by browser-use\"\"\"\n        if not element:\n            return None\n        \n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        attributes = element.get('attributes', {}) or {}\n        \n        strategies_to_try = []\n        \n        if attributes.get('data-testid'):\n            strategies_to_try.append(f'page.get_by_test_id(\"{attributes[\"data-testid\"]}\")')\n        \n        if attributes.get('id'):\n            strategies_to_try.append(f'page.locator(\"#{attributes[\"id\"]}\")')\n        \n        if attributes.get('aria-label'):\n            strategies_to_try.append(f'page.get_by_label(\"{attributes[\"aria-label\"]}\")')\n        \n        if role and text:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\", name=\"{text}\")')\n        elif role:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\")')\n        \n        if text:\n            strategies_to_try.append(f'page.get_by_text(\"{text}\")')\n        \n        if attributes.get('placeholder'):\n            strategies_to_try.append(f'page.get_by_placeholder(\"{attributes[\"placeholder\"]}\")')\n        \n        for strategy in strategies_to_try:\n            try:\n                locator = eval(strategy)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    return strategy if count == 1 else f'{strategy}.first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def _extract_locator_from_healing(\n        self,\n        page: Page,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Try to intelligently find a working locator based on common patterns.\n        This uses smart heuristics to locate elements after AI exploration.\n        \"\"\"\n        desc_lower = (action_desc + \" \" + element_desc).lower()\n        \n        common_selectors = []\n        \n        if \"login\" in desc_lower or \"sign in\" in desc_lower:\n            common_selectors.extend([\n                'button:has-text(\"Login\")',\n                'button:has-text(\"Sign in\")',\n                '[type=\"submit\"]',\n                'button[type=\"submit\"]',\n            ])\n        \n        if \"search\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"search\"]',\n                'input[name=\"q\"]',\n                'input[placeholder*=\"search\" i]',\n                '[aria-label*=\"search\" i]',\n            ])\n        \n        if \"submit\" in desc_lower or \"button\" in desc_lower:\n            common_selectors.extend([\n                'button[type=\"submit\"]',\n                'input[type=\"submit\"]',\n                'button',\n            ])\n        \n        if \"email\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"email\"]',\n                'input[name=\"email\"]',\n                'input[autocomplete=\"email\"]',\n            ])\n        \n        if \"password\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"password\"]',\n                'input[name=\"password\"]',\n                'input[autocomplete=\"current-password\"]',\n            ])\n        \n        for selector in common_selectors:\n            try:\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    if self.verbose:\n                        print(f\"   üîç Found working selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        text_elements = []\n        if \"click\" in desc_lower:\n            words = element_desc.split()\n            for word in words:\n                if len(word) > 3:\n                    text_elements.append(word)\n        \n        for text in text_elements[:3]:\n            try:\n                selector = f'text={text}'\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    if self.verbose:\n                        print(f\"   üîç Found working text selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def execute_action_with_ai(\n        self,\n        page: Page,\n        action_description: str,\n        element_description: str = \"\"\n    ) -> bool:\n        \"\"\"\n        When both original and healed locators fail, use browser-use AI \n        to execute the specific action, then gracefully exit.\n        \n        Args:\n            page: The Playwright page object\n            action_description: Description of the action to perform\n            element_description: Additional context about the element\n        \n        Returns:\n            True if action was executed successfully, False otherwise\n        \"\"\"\n        if self.verbose:\n            print(f\"\\nü§ñ Healed locator failed - browser-use AI stepping in to execute action...\")\n            print(f\"   Action: {action_description}\")\n        \n        try:\n            llm = self._initialize_llm()\n            current_url = page.url\n            \n            task = f\"\"\"On this page ({current_url}), perform this action: {action_description}.\n            \nElement description: {element_description}\n\nIMPORTANT:\n1. Complete ONLY this specific action\n2. Confirm the action was successful\n3. Do NOT perform any additional actions\n4. Report back whether the action succeeded or failed\n\nYour task is to execute this single action and nothing more.\"\"\"\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI executing action in current browser session...\")\n            \n            cdp_url = await self._get_cdp_url(page)\n            \n            if not cdp_url:\n                if self.verbose:\n                    print(f\"   ‚ùå Could not connect to browser session for AI execution\")\n                return False\n            \n            browser_wrapper = BrowserUseWrapper(\n                browser_session={'cdp_url': cdp_url}\n            )\n            \n            agent = Agent(\n                task=task,\n                llm=llm,\n                browser=browser_wrapper,\n            )\n            \n            result = await agent.run()\n            \n            # STRICT verification: require proof of actual DOM interaction AND explicit success status\n            action_completed = False\n            \n            # Step 1: STRICT result verification - require explicit success confirmation\n            if not result:\n                if self.verbose:\n                    print(f\"   ‚ùå No result returned from Agent.run() - cannot confirm success\")\n                return False\n            \n            if self.verbose:\n                print(f\"   üìä Analyzing Agent.run() result...\")\n            \n            # Check for explicit errors - immediate failure\n            if hasattr(result, 'error') and result.error:\n                if self.verbose:\n                    print(f\"   ‚ùå Result contains error: {result.error}\")\n                return False\n            \n            if hasattr(result, 'errors') and result.errors:\n                if self.verbose:\n                    print(f\"   ‚ùå Result contains errors: {result.errors}\")\n                return False\n            \n            # Require explicit completion status - fail if missing or not done\n            has_done_status = False\n            if hasattr(result, 'is_done') and callable(result.is_done):\n                try:\n                    is_done = result.is_done()\n                    has_done_status = True\n                    if self.verbose:\n                        print(f\"   üìä Result.is_done(): {is_done}\")\n                    if not is_done:\n                        if self.verbose:\n                            print(f\"   ‚ùå Result.is_done() returned False - task not completed\")\n                        return False\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ùå Error checking result.is_done(): {str(e)}\")\n                        print(f\"   ‚ùå Cannot verify completion - failing conservatively\")\n                    return False\n            \n            # Check status field if present\n            if hasattr(result, 'status'):\n                status_str = str(result.status).lower()\n                if self.verbose:\n                    print(f\"   üìä Result status: {result.status}\")\n                if 'fail' in status_str or 'error' in status_str:\n                    if self.verbose:\n                        print(f\"   ‚ùå Result status indicates failure\")\n                    return False\n                # Require positive status indication\n                if 'done' in status_str or 'success' in status_str or 'complete' in status_str:\n                    has_done_status = True\n            \n            # Step 2: Verify actual DOM interaction occurred\n            action_completed = False\n            \n            # Parse the action_description to know what type of interaction we expect\n            action_lower = action_description.lower()\n            expected_action_type = None\n            if 'click' in action_lower:\n                expected_action_type = 'click_element'\n            elif 'fill' in action_lower or 'type' in action_lower or 'enter' in action_lower:\n                expected_action_type = 'input_text'\n            elif 'navigate' in action_lower or 'goto' in action_lower or 'go to' in action_lower:\n                expected_action_type = 'go_to_url'\n            \n            if self.verbose:\n                print(f\"   üìä Expected action type: {expected_action_type or 'any DOM interaction'}\")\n            \n            # Check history for actual DOM interactions\n            history = agent.history if hasattr(agent, 'history') else None\n            confirmed_interactions = []\n            \n            if history and hasattr(history, 'model_actions'):\n                try:\n                    actions = history.model_actions()\n                    if self.verbose:\n                        print(f\"   üìã Checking {len(actions) if actions else 0} model action(s) for DOM interactions...\")\n                    \n                    if actions:\n                        for i, action in enumerate(actions):\n                            if hasattr(action, '__dict__'):\n                                action_dict = action.__dict__\n                            elif isinstance(action, dict):\n                                action_dict = action\n                            else:\n                                continue\n                            \n                            action_data = action_dict.get('action', {})\n                            if isinstance(action_data, dict):\n                                # Check for actual DOM interactions\n                                if 'click_element' in action_data:\n                                    confirmed_interactions.append('click_element')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found click_element interaction at action {i}\")\n                                elif 'input_text' in action_data:\n                                    confirmed_interactions.append('input_text')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found input_text interaction at action {i}\")\n                                elif 'go_to_url' in action_data:\n                                    confirmed_interactions.append('go_to_url')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found go_to_url interaction at action {i}\")\n                \n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ö†Ô∏è  Error checking model_actions: {str(e)}\")\n            \n            # Step 3: Decide success - require BOTH DOM interaction AND no failures\n            # First check: did we get the right type of interaction?\n            interaction_confirmed = False\n            if confirmed_interactions:\n                # If we expected a specific action type, verify we got it\n                if expected_action_type:\n                    if expected_action_type in confirmed_interactions:\n                        interaction_confirmed = True\n                        if self.verbose:\n                            print(f\"   ‚úì Found expected '{expected_action_type}' interaction\")\n                    else:\n                        if self.verbose:\n                            print(f\"   ‚ùå AI performed {confirmed_interactions} but not expected '{expected_action_type}'\")\n                        return False\n                else:\n                    # No specific expectation, any DOM interaction counts\n                    interaction_confirmed = True\n                    if self.verbose:\n                        print(f\"   ‚úì Found DOM interactions: {confirmed_interactions}\")\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå No DOM interactions found in agent history\")\n                return False\n            \n            # Second check: verify agent history confirms completion\n            history_confirmed = False\n            if history:\n                # Be conservative: require completion status if available\n                if hasattr(history, 'is_done') and callable(history.is_done):\n                    try:\n                        history_done = history.is_done()\n                        if self.verbose:\n                            print(f\"   üìä History.is_done(): {history_done}\")\n                        if not history_done:\n                            if self.verbose:\n                                print(f\"   ‚ùå History indicates task not completed\")\n                            return False\n                        history_confirmed = True\n                    except Exception as e:\n                        if self.verbose:\n                            print(f\"   ‚ùå Error verifying history completion: {str(e)}\")\n                            print(f\"   ‚ùå Cannot confirm - failing conservatively\")\n                        return False\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå No history available - cannot confirm action completion\")\n                return False\n            \n            # Final: require ALL confirmation layers\n            if not has_done_status and not history_confirmed:\n                if self.verbose:\n                    print(f\"   ‚ùå No explicit done/success status found in result or history\")\n                    print(f\"   ‚ùå Cannot confirm action completed - failing conservatively\")\n                return False\n            \n            # All checks passed: we have DOM interaction AND explicit success confirmation\n            action_completed = interaction_confirmed and (has_done_status or history_confirmed)\n            \n            if action_completed:\n                if self.verbose:\n                    print(f\"   ‚úÖ AI successfully executed the action!\")\n                    print(f\"   üîÑ Continuing with automation script...\")\n                return True\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå AI did not complete the action\")\n                return False\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå AI execution failed: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n            return False\n    \n    async def safe_locator(\n        self,\n        page: Page,\n        locator_str: str,\n        action_description: str = \"\",\n        element_description: str = \"\",\n        timeout: int = 10000\n    ):\n        \"\"\"\n        Get a locator with automatic self-healing if it fails.\n        \n        Args:\n            page: Playwright page object\n            locator_str: Locator string (e.g., 'page.get_by_text(\"Login\")')\n            action_description: Description of the action being performed\n            element_description: Description of the element\n            timeout: Timeout in milliseconds\n        \n        Returns:\n            Working Locator object, AIExecutedMarker if AI executed the action, or None if all attempts fail\n        \"\"\"\n        if locator_str in self.healed_locators:\n            locator_str = self.healed_locators[locator_str]\n            if self.verbose:\n                print(f\"   üìù Using previously healed locator: {locator_str}\")\n        \n        try:\n            locator = eval(locator_str)\n            await locator.wait_for(timeout=timeout)\n            return locator\n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Locator failed: {locator_str}\")\n                print(f\"      Error: {str(e)[:100]}\")\n            \n            healed_locator_str = await self.heal_locator(\n                page=page,\n                failed_locator=locator_str,\n                action_description=action_description,\n                element_description=element_description\n            )\n            \n            if healed_locator_str:\n                try:\n                    healed_locator = eval(healed_locator_str)\n                    await healed_locator.wait_for(timeout=timeout)\n                    return healed_locator\n                except Exception as heal_error:\n                    if self.verbose:\n                        print(f\"   ‚ùå Healed locator also failed: {str(heal_error)[:100]}\")\n                    \n                    if action_description:\n                        ai_executed = await self.execute_action_with_ai(\n                            page=page,\n                            action_description=action_description,\n                            element_description=element_description\n                        )\n                        \n                        if ai_executed:\n                            return AIExecutedMarker(action_description)\n                        else:\n                            if self.verbose:\n                                print(f\"   ‚ùå All recovery attempts failed (locator healing + AI execution)\")\n            \n            if self.verbose:\n                print(f\"   ‚ùå Unable to locate element or execute action: {action_description or locator_str}\")\n            return None\n    \n    async def execute_with_healing(\n        self,\n        automation_func: Callable,\n        *args,\n        **kwargs\n    ) -> Any:\n        \"\"\"\n        Execute an automation function with self-healing support.\n        \n        Args:\n            automation_func: Async function to execute\n            *args, **kwargs: Arguments to pass to the function\n        \n        Returns:\n            Result of the automation function\n        \"\"\"\n        self.healing_attempts = 0\n        self.healed_locators.clear()\n        \n        if self.verbose:\n            print(\"\\nüöÄ Starting execution with self-healing enabled\")\n            print(f\"   Max healing attempts per locator: {self.max_healing_attempts}\")\n        \n        try:\n            result = await automation_func(*args, **kwargs)\n            \n            if self.verbose:\n                print(\"\\n‚úÖ Execution completed successfully!\")\n                if self.healed_locators:\n                    print(f\"   Healed {len(self.healed_locators)} locator(s) during execution\")\n            \n            return result\n        except Exception as e:\n            if self.verbose:\n                print(f\"\\n‚ùå Execution failed: {str(e)}\")\n            raise\n\n\nclass HealingContext:\n    \"\"\"Context manager for self-healing Playwright automation\"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.executor = SelfHealingExecutor(\n            api_key=api_key,\n            model=model,\n            verbose=verbose\n        )\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright = None\n    \n    async def __aenter__(self):\n        \"\"\"Set up Playwright browser with healing support\"\"\"\n        self.playwright = await async_playwright().start()\n        self.browser = await self.playwright.chromium.launch(headless=False)\n        context = await self.browser.new_context()\n        self.page = await context.new_page()\n        \n        setattr(self.page, 'healing_locator', self._create_healing_locator_method())\n        \n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Clean up browser\"\"\"\n        if self.browser:\n            await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n    \n    def _create_healing_locator_method(self):\n        \"\"\"Create a healing locator method bound to the page\"\"\"\n        async def healing_locator(\n            locator_str: str,\n            action_desc: str = \"\",\n            element_desc: str = \"\"\n        ) -> Optional[Locator]:\n            return await self.executor.safe_locator(\n                page=self.page,\n                locator_str=locator_str,\n                action_description=action_desc,\n                element_description=element_desc\n            )\n        \n        return healing_locator\n","size_bytes":33231},"OpenAIWeb/OpenAIWeb/test_example.py":{"content":"# No actions to generate code from","size_bytes":34},"OpenAIWeb/playwright_mcp/server/__init__.py":{"content":"\"\"\"\nAI Browser Automation Server\nFlask application for browser automation using OpenAI + Playwright MCP\n\"\"\"\nfrom flask import Flask\nimport os\n\n\ndef create_app():\n    \"\"\"Application factory for Flask app\"\"\"\n    app = Flask(__name__)\n    app.config['SECRET_KEY'] = os.urandom(24)\n    \n    # Register routes\n    from server.routes import register_routes\n    register_routes(app)\n    \n    return app\n","size_bytes":396},"OpenAIWeb/OpenAIWeb/pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.5.9\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=2.6.0\",\n    \"playwright>=1.55.0\",\n    \"python-dotenv>=1.1.1\",\n]\n","size_bytes":276},"OpenAIWeb/OpenAIWeb/src/playwright_code_generator.py":{"content":"import re\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass LocatorStrategy:\n    \"\"\"Represents a locator with multiple fallback strategies\"\"\"\n    primary: str\n    fallbacks: List[str]\n    description: str\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"Converts browser-use action history to reusable Playwright Python code\"\"\"\n\n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n        self.actions: List[Dict[str, Any]] = []\n        self.imports = set([\n            \"import asyncio\",\n            \"from playwright.async_api import async_playwright, Page, Browser, Locator\",\n            \"from typing import Optional\",\n        ])\n\n    def parse_history(self, history) -> None:\n        \"\"\"Parse browser-use history and extract actions\"\"\"\n        if not history:\n            if self.verbose:\n                print(\"‚ö†Ô∏è  No history provided to parse\")\n            return\n\n        if self.verbose:\n            print(\"üîç Parsing action history...\")\n            print(f\"   History type: {type(history)}\")\n            print(f\"   History attributes: {dir(history)[:10]}...\")\n\n        # For browser-use 0.5.9+, AgentHistoryList has a .history attribute containing AgentHistory objects\n        # Do NOT iterate directly over AgentHistoryList as it returns tuples\n\n        actions_found = False\n\n        # Method 1: history.history attribute (the correct way for browser-use 0.5.9)\n        if hasattr(history, 'history'):\n            try:\n                hist_items = history.history\n                if self.verbose:\n                    print(f\"   Found history.history: {len(hist_items)} AgentHistory items\")\n                for item in hist_items:\n                    if self.verbose:\n                        print(f\"     Processing AgentHistory item: has model_output={hasattr(item, 'model_output')}\")\n                    # Each item is an AgentHistory object with model_output\n                    if hasattr(item, 'model_output') and item.model_output:\n                        self._extract_from_agent_history(item)\n                        actions_found = True\n            except Exception as e:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not access history.history: {e}\")\n\n        # Method 2: model_actions method (older browser-use versions)\n        if not actions_found and hasattr(history, 'model_actions'):\n            try:\n                model_actions = history.model_actions()\n                if self.verbose:\n                    print(\n                        f\"   Found model_actions: {len(model_actions) if hasattr(model_actions, '__len__') else 'unknown'} items\")\n                for action in model_actions:\n                    self._extract_action(action)\n                    actions_found = True\n            except Exception as e:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not access model_actions: {e}\")\n\n        if self.verbose:\n            print(f\"‚úì Parsed {len(self.actions)} actions\")\n            if len(self.actions) == 0:\n                print(\"‚ö†Ô∏è  WARNING: No actions were extracted from history!\")\n                print(\"   This will result in empty generated code.\")\n\n    def _extract_from_agent_history(self, agent_history) -> None:\n        \"\"\"Extract actions from AgentHistory object (browser-use 0.5.9)\"\"\"\n        if not hasattr(agent_history, 'model_output') or not agent_history.model_output:\n            return\n\n        model_output = agent_history.model_output\n\n        if self.verbose:\n            print(f\"       model_output type: {type(model_output)}\")\n            if hasattr(model_output, '__dict__'):\n                print(f\"       model_output keys: {list(model_output.__dict__.keys())}\")\n\n        # model_output should have the action information\n        if hasattr(model_output, 'action') and model_output.action:\n            actions = model_output.action if isinstance(model_output.action, list) else [model_output.action]\n\n            if self.verbose:\n                print(f\"       Found {len(actions)} action(s)\")\n\n            for action in actions:\n                if self.verbose:\n                    print(f\"       Action type: {type(action)}\")\n                    if hasattr(action, '__dict__'):\n                        print(f\"       Action dict keys: {list(action.__dict__.keys())}\")\n                    # Check if action has a 'root' attribute which might contain the actual action\n                    if hasattr(action, 'root'):\n                        print(f\"       Action.root type: {type(action.root)}\")\n                        if hasattr(action.root, '__dict__'):\n                            print(f\"       Action.root keys: {list(action.root.__dict__.keys())}\")\n\n                # Handle 'root' wrapper in Pydantic models\n                if hasattr(action, 'root'):\n                    actual_action = action.root\n                    if isinstance(actual_action, list):\n                        for sub_action in actual_action:\n                            self._extract_action(sub_action)\n                    else:\n                        self._extract_action(actual_action)\n                else:\n                    self._extract_action(action)\n        elif hasattr(model_output, '__dict__'):\n            # Try to extract action from model_output dict\n            self._extract_action(model_output)\n\n    def _extract_action(self, action) -> None:\n        \"\"\"Extract action details from browser-use action object\"\"\"\n        action_data = {\n            'type': 'unknown',\n            'params': {},\n            'element': None,\n            'locators': [],\n            'description': ''\n        }\n\n        # Convert action to dict\n        if hasattr(action, '__dict__'):\n            action_dict = action.__dict__\n        elif isinstance(action, dict):\n            action_dict = action\n        else:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Skipping action of unknown type: {type(action)}\")\n            return\n\n        if self.verbose:\n            print(f\"   Examining action: {list(action_dict.keys())[:5]}...\")\n\n        # Browser-use 0.5.9+ uses simpler action keys: navigate, click, input, etc.\n        # Handle the new action structure first\n        if 'navigate' in action_dict:\n            nav_data = action_dict.get('navigate', {})\n            if hasattr(nav_data, '__dict__'):\n                nav_data = nav_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': nav_data.get('url', '') if isinstance(nav_data, dict) else str(nav_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'click' in action_dict:\n            click_data = action_dict.get('click', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            # In new format, element info might be in 'element_index' or similar\n            element = click_data.get('element', click_data) if isinstance(click_data, dict) else {}\n            action_data['element'] = element\n            action_data['locators'] = self._generate_locators(element)\n            action_data['description'] = f\"Click element\"\n\n        elif 'input' in action_dict:\n            input_data = action_dict.get('input', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            element = input_data.get('element', input_data) if isinstance(input_data, dict) else {}\n            action_data['element'] = element\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(element)\n            action_data['description'] = f\"Input text\"\n\n        elif 'done' in action_dict:\n            # Skip 'done' action as it's just a completion signal\n            if self.verbose:\n                print(f\"   ‚úì Skipping 'done' action (completion signal)\")\n            return\n\n        # Legacy browser-use format support (older versions)\n        elif 'go_to_url' in action_dict:\n            url_data = action_dict.get('go_to_url', {})\n            if hasattr(url_data, '__dict__'):\n                url_data = url_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': url_data.get('url', '') if isinstance(url_data, dict) else str(url_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'go_to_url' in actual_action:\n            url_data = actual_action.get('go_to_url', {})\n            if hasattr(url_data, '__dict__'):\n                url_data = url_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': url_data.get('url', '') if isinstance(url_data, dict) else str(url_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'click_element' in action_dict:\n            click_data = action_dict.get('click_element', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            action_data['element'] = click_data.get('element', {}) if isinstance(click_data, dict) else {}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Click element\"\n\n        elif 'click_element' in actual_action:\n            click_data = actual_action.get('click_element', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            action_data['element'] = click_data.get('element', {}) if isinstance(click_data, dict) else {}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Click element\"\n\n        elif 'input_text' in action_dict:\n            input_data = action_dict.get('input_text', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            action_data['element'] = input_data.get('element', {}) if isinstance(input_data, dict) else {}\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Input text\"\n\n        elif 'input_text' in actual_action:\n            input_data = actual_action.get('input_text', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            action_data['element'] = input_data.get('element', {}) if isinstance(input_data, dict) else {}\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Input text\"\n\n        elif 'extract_content' in action_dict or 'extract_content' in actual_action:\n            action_data['type'] = 'extract'\n            extract_data = action_dict.get('extract_content', actual_action.get('extract_content', {}))\n            action_data['params'] = extract_data if isinstance(extract_data, dict) else {}\n            action_data['description'] = f\"Extract content\"\n\n        if action_data['type'] != 'unknown':\n            self.actions.append(action_data)\n            if self.verbose:\n                print(f\"   ‚úì Extracted {action_data['type']} action\")\n        else:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Could not extract action from: {list(action_dict.keys())}\")\n\n    def _generate_locators(self, element: Dict[str, Any]) -> List[LocatorStrategy]:\n        \"\"\"Generate multiple locator strategies for an element\"\"\"\n        strategies = []\n\n        if not element:\n            return strategies\n\n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        tag = element.get('tag', '').strip()\n        attributes = element.get('attributes', {})\n\n        if text:\n            strategies.append(LocatorStrategy(\n                primary=f'page.get_by_text(\"{self._escape_quotes(text)}\")',\n                fallbacks=[\n                    f'page.locator(\\'text=\"{self._escape_quotes(text)}\"\\')',\n                    f'page.locator(\\'//*[contains(text(), \"{self._escape_quotes(text)}\")]\\')',\n                ],\n                description=f\"Text: {text[:50]}\"\n            ))\n\n        if role:\n            role_locator = f'page.get_by_role(\"{role}\"'\n            if text:\n                role_locator += f', name=\"{self._escape_quotes(text)}\"'\n            role_locator += ')'\n\n            strategies.append(LocatorStrategy(\n                primary=role_locator,\n                fallbacks=[f'page.locator(\\'[role=\"{role}\"]\\')', ],\n                description=f\"Role: {role}\"\n            ))\n\n        if attributes:\n            for key, value in attributes.items():\n                if key in ['id', 'data-testid', 'name', 'aria-label']:\n                    if key == 'id':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\"#{value}\")',\n                            fallbacks=[f'page.get_by_test_id(\"{value}\")'],\n                            description=f\"ID: {value}\"\n                        ))\n                    elif key == 'data-testid':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_test_id(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[data-testid=\"{value}\"]\\')', ],\n                            description=f\"Test ID: {value}\"\n                        ))\n                    elif key == 'name':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\\'[name=\"{value}\"]\\')',\n                            fallbacks=[f'page.get_by_label(\"{value}\")'],\n                            description=f\"Name: {value}\"\n                        ))\n                    elif key == 'aria-label':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_label(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[aria-label=\"{value}\"]\\')', ],\n                            description=f\"Aria-label: {value}\"\n                        ))\n\n        if tag and not strategies:\n            strategies.append(LocatorStrategy(\n                primary=f'page.locator(\"{tag}\")',\n                fallbacks=[],\n                description=f\"Tag: {tag}\"\n            ))\n\n        return strategies\n\n    def _escape_quotes(self, text: str) -> str:\n        \"\"\"Escape quotes in text for code generation\"\"\"\n        return text.replace('\"', '\\\\\"').replace(\"'\", \"\\\\'\")\n\n    def generate_code(self, function_name: str = \"automated_task\") -> str:\n        \"\"\"Generate complete Playwright Python code from actions\"\"\"\n        if not self.actions:\n            return \"# No actions to generate code from\"\n\n        code_lines = []\n\n        code_lines.extend(sorted(self.imports))\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n\n        code_lines.append(f\"async def {function_name}():\")\n        code_lines.append('    \"\"\"Generated Playwright automation code with self-healing support\"\"\"')\n        code_lines.append(\"    async with async_playwright() as p:\")\n        code_lines.append(\"        browser = await p.chromium.launch(headless=False)\")\n        code_lines.append(\"        context = await browser.new_context()\")\n        code_lines.append(\"        page = await context.new_page()\")\n        code_lines.append(\"\")\n        code_lines.append(\"        try:\")\n\n        for i, action in enumerate(self.actions):\n            code_lines.append(f\"            # Step {i + 1}: {action['type']}\")\n\n            if action['type'] == 'goto':\n                url = action['params'].get('url', '')\n                code_lines.append(f'            await page.goto(\"{url}\")')\n                code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n\n            elif action['type'] == 'click':\n                locators = action.get('locators', [])\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f\"            await element.click()\")\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for click action\")\n\n            elif action['type'] == 'fill':\n                locators = action.get('locators', [])\n                text = action['params'].get('text', '')\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f'            await element.fill(\"{self._escape_quotes(text)}\")')\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for fill action\")\n\n            elif action['type'] == 'extract':\n                code_lines.append(\"            # Extract content (implement based on your needs)\")\n                code_lines.append(\"            content = await page.content()\")\n\n            code_lines.append(\"\")\n\n        code_lines.append('            print(\"‚úÖ Task completed successfully!\")')\n        code_lines.append(\"\")\n        code_lines.append(\"        except Exception as e:\")\n        code_lines.append('            print(f\"‚ùå Error during automation: {e}\")')\n        code_lines.append(\"            raise\")\n        code_lines.append(\"        finally:\")\n        code_lines.append(\"            await browser.close()\")\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n\n        code_lines.append(\n            \"async def self_healing_locator(page: Page, primary: str, fallbacks: List[str] = None) -> Locator:\")\n        code_lines.append('    \"\"\"Try primary locator, fall back to alternatives if it fails\"\"\"')\n        code_lines.append(\"    fallbacks = fallbacks or []\")\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try primary locator\")\n        code_lines.append(\"    try:\")\n        code_lines.append(\"        locator = eval(primary)\")\n        code_lines.append(\"        await locator.wait_for(timeout=5000)\")\n        code_lines.append(\"        return locator\")\n        code_lines.append(\"    except Exception as e:\")\n        code_lines.append('        print(f\"‚ö†Ô∏è  Primary locator failed: {primary}\")')\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try fallback locators\")\n        code_lines.append(\"    for fallback in fallbacks:\")\n        code_lines.append(\"        try:\")\n        code_lines.append(\"            locator = eval(fallback)\")\n        code_lines.append(\"            await locator.wait_for(timeout=5000)\")\n        code_lines.append('            print(f\"‚úì Fallback locator succeeded: {fallback}\")')\n        code_lines.append(\"            return locator\")\n        code_lines.append(\"        except Exception:\")\n        code_lines.append(\"            continue\")\n        code_lines.append(\"    \")\n        code_lines.append('    raise Exception(f\"All locators failed for: {primary}\")')\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n        code_lines.append('if __name__ == \"__main__\":')\n        code_lines.append(f\"    asyncio.run({function_name}())\")\n\n        return \"\\n\".join(code_lines)\n\n    def save_code(self, filepath: str, function_name: str = \"automated_task\") -> None:\n        \"\"\"Generate and save code to a file\"\"\"\n        code = self.generate_code(function_name)\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            f.write(code)\n\n        if self.verbose:\n            print(f\"‚úì Code saved to: {filepath}\")\n","size_bytes":21037},"OpenAIWeb/playwright_mcp/server/routes.py":{"content":"\"\"\"\nFlask Routes for Browser Automation\n\"\"\"\nfrom flask import render_template, request, jsonify\nfrom server.services.mcp_client import MCPStdioClient\nfrom server.services.browser_agent import BrowserAgent\nimport re\nfrom datetime import datetime\n\n# Initialize MCP client and agent (using STDIO transport)\nmcp_client = None\nbrowser_agent = None\n\n\ndef get_mcp_client():\n    \"\"\"Lazy initialization of MCP client\"\"\"\n    global mcp_client, browser_agent\n    if mcp_client is None:\n        mcp_client = MCPStdioClient()\n        browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\ndef register_routes(app):\n    \"\"\"Register all routes with the Flask app\"\"\"\n    \n    @app.route('/')\n    def index():\n        \"\"\"Render main page\"\"\"\n        return render_template('index.html')\n    \n    \n    @app.route('/api/execute', methods=['POST'])\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            instruction = data.get('instruction', '').strip()\n            \n            if not instruction:\n                return jsonify({\n                    'success': False,\n                    'error': 'Please provide an instruction'\n                }), 400\n            \n            # Get or create MCP client\n            _, agent = get_mcp_client()\n            \n            # Execute the instruction\n            result = agent.execute_instruction(instruction)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            client, _ = get_mcp_client()\n            \n            if not client.initialized:\n                client.initialize()\n            \n            tools = client.list_tools()\n            \n            return jsonify({\n                'success': True,\n                'tools': tools\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/reset', methods=['POST'])\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            _, agent = get_mcp_client()\n            agent.reset_conversation()\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully'\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/export-playwright', methods=['POST'])\n    def export_playwright():\n        \"\"\"Export last execution as Playwright code\"\"\"\n        try:\n            data = request.get_json()\n            steps = data.get('steps', [])\n            instruction = data.get('instruction', 'Automated task')\n            language = data.get('language', 'python')  # Default to Python\n            \n            if not steps:\n                return jsonify({\n                    'success': False,\n                    'error': 'No steps to export'\n                }), 400\n            \n            # Generate Playwright code based on language\n            if language == 'python':\n                playwright_code = generate_playwright_code_python(steps, instruction)\n            else:\n                playwright_code = generate_playwright_code_javascript(steps, instruction)\n            \n            # Enhanced JSON export with selector information\n            json_export = {\n                'instruction': instruction,\n                'timestamp': datetime.now().isoformat(),\n                'steps': steps,\n                'language': language,\n                'usage_notes': {\n                    'description': 'Steps executed by AI with full context',\n                    'replay': 'Can be used to replay automation programmatically',\n                    'selectors': 'Check result.snapshot fields for element information'\n                }\n            }\n            \n            return jsonify({\n                'success': True,\n                'playwright_code': playwright_code,\n                'json_export': json_export\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            # Only check if MCP client exists, don't force initialization\n            global mcp_client\n            \n            if mcp_client is not None:\n                # Client exists, check if process is alive\n                if mcp_client.process and mcp_client.process.poll() is None:\n                    return jsonify({\n                        'status': 'healthy',\n                        'mcp_connected': True,\n                        'transport': 'STDIO'\n                    })\n            \n            # MCP client not yet initialized, but that's okay\n            return jsonify({\n                'status': 'healthy',\n                'mcp_connected': False,\n                'message': 'MCP will initialize on first use'\n            })\n        except Exception as e:\n            return jsonify({\n                'status': 'unhealthy',\n                'mcp_connected': False,\n                'error': str(e)\n            }), 503\n\n\ndef generate_playwright_code_python(steps, instruction):\n    \"\"\"Generate Python Playwright code from execution steps with native locators\"\"\"\n    code_lines = [\n        \"from playwright.sync_api import sync_playwright, expect\",\n        \"import re\",\n        \"\",\n        \"\",\n        \"def run():\",\n        '    \"\"\"' + instruction + '\"\"\"',\n        \"    with sync_playwright() as p:\",\n        \"        # Launch browser\",\n        \"        browser = p.chromium.launch(headless=False)\",\n        \"        page = browser.new_page()\",\n        \"\",\n    ]\n    \n    # Track page snapshots to extract locators\n    last_snapshot = None\n    step_number = 1\n    \n    for step in steps:\n        if not step.get('success'):\n            continue\n            \n        tool = step.get('tool', '')\n        args = step.get('arguments', {})\n        result = step.get('result', {})\n        \n        # Update snapshot from result - normalize to string\n        if isinstance(result, dict) and 'snapshot' in result:\n            snapshot_data = result['snapshot']\n            if isinstance(snapshot_data, dict):\n                # MCP returns snapshot as dict with logicalTree or ariaTree\n                last_snapshot = snapshot_data.get('logicalTree') or snapshot_data.get('ariaTree')\n            elif isinstance(snapshot_data, str):\n                last_snapshot = snapshot_data\n        \n        if tool == 'browser_navigate':\n            url = args.get('url', '')\n            code_lines.append(f'        # {step_number}. Navigate to page')\n            code_lines.append(f'        page.goto(\"{url}\")')\n            code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_snapshot':\n            # Snapshot already updated above\n            pass\n                \n        elif tool == 'browser_click':\n            ref = args.get('ref', '')\n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Click element')\n                code_lines.append(f'        {locator_code}.click()')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Click element [ref={ref}] - Could not extract locator')\n                code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_fill':\n            ref = args.get('ref', '')\n            value = args.get('value', '').replace('\"', '\\\\\"')\n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Fill form field')\n                code_lines.append(f'        {locator_code}.fill(\"{value}\")')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Fill element [ref={ref}] with \"{value}\" - Could not extract locator')\n                code_lines.append('')\n            step_number += 1\n        \n        elif tool == 'browser_type':\n            # Handle browser_type tool (types text and optionally presses Enter)\n            ref = args.get('ref', '')\n            text = args.get('text', '').replace('\"', '\\\\\"')\n            submit = args.get('submit', False)\n            \n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Type text into field')\n                code_lines.append(f'        {locator_code}.fill(\"{text}\")')\n                if submit:\n                    code_lines.append(f'        {locator_code}.press(\"Enter\")')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Type \"{text}\" into element [ref={ref}] - Could not extract locator')\n                if submit:\n                    code_lines.append(f'        # TODO: Press Enter')\n                code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_screenshot':\n            code_lines.append(f'        # {step_number}. Take screenshot')\n            code_lines.append('        page.screenshot(path=\"screenshot.png\")')\n            code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_close':\n            code_lines.append('        # Close browser')\n            code_lines.append('        browser.close()')\n            code_lines.append('')\n    \n    # Add browser close if not already added\n    if not any('browser.close()' in line for line in code_lines):\n        code_lines.append('        # Close browser')\n        code_lines.append('        browser.close()')\n        code_lines.append('')\n    \n    code_lines.extend([\n        \"\",\n        'if __name__ == \"__main__\":',\n        \"    run()\",\n        \"\",\n        \"# Generated from AI Browser Automation Agent\",\n        \"# Uses Playwright Python with native locators for better stability and readability\",\n        \"# Tip: Add assertions with expect() to verify page state\"\n    ])\n    \n    return '\\n'.join(code_lines)\n\n\ndef generate_playwright_code_javascript(steps, instruction):\n    \"\"\"Generate JavaScript Playwright test code from execution steps with native locators\"\"\"\n    code_lines = [\n        \"import { test, expect } from '@playwright/test';\",\n        \"\",\n        f\"test('{instruction}', async ({{ page }}) => {{\",\n    ]\n    \n    # Track page snapshots to extract locators\n    last_snapshot = None\n    \n    for step in steps:\n        if not step.get('success'):\n            continue\n            \n        tool = step.get('tool', '')\n        args = step.get('arguments', {})\n        result = step.get('result', {})\n        \n        # Update snapshot from result - normalize to string\n        if isinstance(result, dict) and 'snapshot' in result:\n            snapshot_data = result['snapshot']\n            if isinstance(snapshot_data, dict):\n                # MCP returns snapshot as dict with logicalTree or ariaTree\n                last_snapshot = snapshot_data.get('logicalTree') or snapshot_data.get('ariaTree')\n            elif isinstance(snapshot_data, str):\n                last_snapshot = snapshot_data\n        \n        if tool == 'browser_navigate':\n            url = args.get('url', '')\n            code_lines.append(f\"  await page.goto('{url}');\")\n            \n        elif tool == 'browser_snapshot':\n            # Snapshot already updated above\n            pass\n                \n        elif tool == 'browser_click':\n            ref = args.get('ref', '')\n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.click();\")\n            else:\n                code_lines.append(f\"  // TODO: Click element [ref={ref}] - Could not extract locator\")\n            \n        elif tool == 'browser_fill':\n            ref = args.get('ref', '')\n            value = args.get('value', '').replace(\"'\", \"\\\\'\")\n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.fill('{value}');\")\n            else:\n                code_lines.append(f\"  // TODO: Fill element [ref={ref}] with '{value}' - Could not extract locator\")\n        \n        elif tool == 'browser_type':\n            # Handle browser_type tool (types text and optionally presses Enter)\n            ref = args.get('ref', '')\n            text = args.get('text', '').replace(\"'\", \"\\\\'\")\n            submit = args.get('submit', False)\n            \n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.fill('{text}');\")\n                if submit:\n                    code_lines.append(f\"  await {locator_code}.press('Enter');\")\n            else:\n                code_lines.append(f\"  // TODO: Type '{text}' into element [ref={ref}] - Could not extract locator\")\n                if submit:\n                    code_lines.append(f\"  // TODO: Press Enter\")\n            \n        elif tool == 'browser_screenshot':\n            code_lines.append(f\"  await page.screenshot({{ path: 'screenshot.png' }});\")\n            \n        elif tool == 'browser_close':\n            code_lines.append(f\"  // Browser will close automatically after test\")\n    \n    code_lines.extend([\n        \"});\",\n        \"\",\n        \"// Generated from AI Browser Automation Agent\",\n        \"// Uses Playwright native locators for better stability and readability\",\n        \"// Tip: Add assertions with expect() to verify page state\"\n    ])\n    \n    return '\\n'.join(code_lines)\n\n\ndef extract_playwright_locator_python(ref, snapshot, result):\n    \"\"\"\n    Extract Python Playwright native locator code from ref and snapshot data\n    Returns Python Playwright locator code string or None\n    \n    Examples:\n        page.get_by_role(\"button\", name=\"Submit\")\n        page.get_by_text(\"Click here\")\n        page.get_by_label(\"Email\")\n        page.get_by_placeholder(\"Search...\")\n    \"\"\"\n    if not ref:\n        return None\n    \n    # First, try to extract structured locator from result\n    if isinstance(result, dict):\n        # Check for structured locator metadata\n        if 'locator' in result:\n            locator_info = result['locator']\n            if isinstance(locator_info, dict):\n                # Extract locator from structured data\n                locator_type = locator_info.get('type', '')\n                locator_value = locator_info.get('value', '')\n                if locator_type and locator_value:\n                    # Convert JavaScript locator to Python (getByRole -> get_by_role)\n                    python_locator_type = locator_type.replace('getBy', 'get_by_').replace('By', '_by_').lower()\n                    value_escaped = locator_value.replace('\"', '\\\\\"')\n                    return f'page.{python_locator_type}(\"{value_escaped}\")'\n        \n        # Try to extract from content (MCP server often includes Playwright code)\n        content = result.get('content', [])\n        for item in content:\n            if isinstance(item, dict) and item.get('type') == 'text':\n                text = item.get('text', '')\n                # Look for Playwright locator code in the result\n                # Format: await page.getByRole('button', { name: 'Submit' }).action();\n                locator_match = re.search(r'await\\s+page\\.(getBy\\w+)\\(([^)]+)\\)', text)\n                if locator_match:\n                    method = locator_match.group(1)\n                    args_str = locator_match.group(2)\n                    \n                    # Convert method name to Python (getByRole -> get_by_role)\n                    python_method = 'get_by_role' if 'Role' in method else \\\n                                   'get_by_label' if 'Label' in method else \\\n                                   'get_by_placeholder' if 'Placeholder' in method else \\\n                                   'get_by_text' if 'Text' in method else method.lower()\n                    \n                    # Convert JavaScript object syntax to Python kwargs\n                    # Change { name: 'Submit' } to name=\"Submit\"\n                    # Change 'text' to \"text\"\n                    python_args = args_str.replace(\"'\", '\"')  # Use double quotes\n                    \n                    # Convert { key: value } to key=value\n                    python_args = re.sub(r'\\{\\s*(\\w+):\\s*([^}]+)\\s*\\}', r'\\1=\\2', python_args)\n                    \n                    return f\"page.{python_method}({python_args})\"\n    \n    # Fallback to snapshot parsing\n    if not snapshot or not isinstance(snapshot, str):\n        return None\n    \n    # Parse the snapshot to find the element with this ref\n    ref_pattern = rf'\\[ref={re.escape(ref)}\\]'\n    lines = snapshot.split('\\n')\n    \n    for i, line in enumerate(lines):\n        if ref_pattern not in line:\n            continue\n        \n        # Found the ref, now extract element information\n        element_info = {\n            'role': None,\n            'name': None,\n            'text': None,\n            'placeholder': None,\n            'label': None,\n            'tag': None\n        }\n        \n        # Search context around the ref (typically 10 lines before and 2 after)\n        context_start = max(0, i - 10)\n        context_end = min(len(lines), i + 3)\n        context_lines = lines[context_start:context_end]\n        \n        # Extract attributes from the context\n        for ctx_line in context_lines:\n            # Extract role\n            if 'role=' in ctx_line:\n                role_match = re.search(r\"role=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if role_match:\n                    element_info['role'] = role_match.group(1)\n            \n            # Extract name attribute (often used with role)\n            if 'name=' in ctx_line:\n                name_match = re.search(r\"name=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if name_match:\n                    element_info['name'] = name_match.group(1)\n            \n            # Extract placeholder\n            if 'placeholder=' in ctx_line:\n                placeholder_match = re.search(r\"placeholder=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if placeholder_match:\n                    element_info['placeholder'] = placeholder_match.group(1)\n            \n            # Extract label text (for get_by_label)\n            if 'label=' in ctx_line or '<label' in ctx_line.lower():\n                label_match = re.search(r\"(?:label=|>)[\\s]*['\\\"]?([^'\\\"<>]+)['\\\"]?\", ctx_line)\n                if label_match:\n                    element_info['label'] = label_match.group(1).strip()\n        \n        # Extract text content from the line with ref\n        text_match = re.search(r'[\"\\']([^\"\\']{1,100})[\"\\'].*?\\[ref=', line)\n        if text_match:\n            element_info['text'] = text_match.group(1)\n        \n        # Generate Python Playwright native locator code based on available info\n        # Priority: role with name > text > placeholder > label > fallback\n        \n        # 1. Try get_by_role (most stable and accessible)\n        if element_info['role']:\n            role = element_info['role']\n            name = element_info['name'] or element_info['text']\n            \n            # Escape double quotes in name\n            if name:\n                name_escaped = name.replace('\"', '\\\\\"')\n                return f'page.get_by_role(\"{role}\", name=\"{name_escaped}\")'\n            else:\n                return f'page.get_by_role(\"{role}\")'\n        \n        # 2. Try get_by_placeholder (for input fields)\n        if element_info['placeholder']:\n            placeholder_escaped = element_info['placeholder'].replace('\"', '\\\\\"')\n            return f'page.get_by_placeholder(\"{placeholder_escaped}\")'\n        \n        # 3. Try get_by_label (for form fields)\n        if element_info['label']:\n            label_escaped = element_info['label'].replace('\"', '\\\\\"')\n            return f'page.get_by_label(\"{label_escaped}\")'\n        \n        # 4. Try get_by_text (for elements with visible text)\n        if element_info['text']:\n            # Use exact match for short text\n            text_escaped = element_info['text'].replace('\"', '\\\\\"')\n            if len(element_info['text']) < 50:\n                return f'page.get_by_text(\"{text_escaped}\")'\n            else:\n                # Use substring match for long text\n                text_preview = element_info['text'][:30].replace('\"', '\\\\\"')\n                return f'page.locator(f\"text={text_preview}\")'\n        \n        # 5. Extract CSS selector as fallback from the snapshot\n        css_selector = extract_css_selector_from_line(line, ref)\n        if css_selector:\n            return f'page.locator(\"{css_selector}\")'\n        \n        # 6. Last resort: use the ref attribute with a comment\n        # Note: This won't work in production, but shows what element was targeted\n        return f'page.locator(\"[ref={ref}]\")  # Note: ref attribute may not exist in actual page'\n    \n    # If we couldn't find the ref at all in snapshot, try to use structured data\n    return None\n\n\ndef extract_css_selector_from_line(line, ref):\n    \"\"\"\n    Extract a CSS selector from the snapshot line\n    Returns CSS selector string or None\n    \"\"\"\n    # Try to extract ID\n    id_match = re.search(r'id=[\"\\']([^\"\\']+)[\"\\']', line)\n    if id_match:\n        element_id = id_match.group(1)\n        return f'#{element_id}'\n    \n    # Try to extract class (use first class)\n    class_match = re.search(r'class=[\"\\']([^\"\\']+)[\"\\']', line)\n    if class_match:\n        classes = class_match.group(1).split()\n        if classes:\n            # Use first class as selector\n            return f'.{classes[0]}'\n    \n    # Try to extract tag name with attributes\n    tag_match = re.search(r'<(\\w+)', line)\n    if tag_match:\n        tag = tag_match.group(1)\n        \n        # If it has a name attribute, use that\n        name_match = re.search(r'name=[\"\\']([^\"\\']+)[\"\\']', line)\n        if name_match:\n            name = name_match.group(1)\n            return f'{tag}[name=\"{name}\"]'\n        \n        # If it has a type attribute (for inputs)\n        type_match = re.search(r'type=[\"\\']([^\"\\']+)[\"\\']', line)\n        if type_match:\n            input_type = type_match.group(1)\n            return f'{tag}[type=\"{input_type}\"]'\n    \n    return None\n\n\ndef extract_playwright_locator(ref, snapshot, result):\n    \"\"\"\n    Extract Playwright native locator code from ref and snapshot data\n    Returns Playwright locator code string or None\n    \n    Examples:\n        page.getByRole('button', { name: 'Submit' })\n        page.getByText('Click here')\n        page.getByLabel('Email')\n        page.getByPlaceholder('Search...')\n    \"\"\"\n    if not ref:\n        return None\n    \n    # First, try to extract structured locator from result\n    if isinstance(result, dict):\n        # Check for structured locator metadata\n        if 'locator' in result:\n            locator_info = result['locator']\n            if isinstance(locator_info, dict):\n                # Extract locator from structured data\n                locator_type = locator_info.get('type', '')\n                locator_value = locator_info.get('value', '')\n                if locator_type and locator_value:\n                    value_escaped = locator_value.replace(\"'\", \"\\\\'\")\n                    return f\"page.{locator_type}('{value_escaped}')\"\n        \n        # Try to extract from content (MCP server often includes Playwright code)\n        content = result.get('content', [])\n        for item in content:\n            if isinstance(item, dict) and item.get('type') == 'text':\n                text = item.get('text', '')\n                # Look for Playwright locator code in the result\n                # Format: await page.getByRole(...).action();\n                locator_match = re.search(r'await\\s+page\\.(getBy\\w+\\([^)]+(?:\\s*,\\s*\\{[^}]+\\})?\\))', text)\n                if locator_match:\n                    return f\"page.{locator_match.group(1)}\"\n    \n    # Fallback to snapshot parsing\n    if not snapshot or not isinstance(snapshot, str):\n        return None\n    \n    # Parse the snapshot to find the element with this ref\n    ref_pattern = rf'\\[ref={re.escape(ref)}\\]'\n    lines = snapshot.split('\\n')\n    \n    for i, line in enumerate(lines):\n        if ref_pattern not in line:\n            continue\n        \n        # Found the ref, now extract element information\n        element_info = {\n            'role': None,\n            'name': None,\n            'text': None,\n            'placeholder': None,\n            'label': None,\n            'tag': None\n        }\n        \n        # Search context around the ref (typically 10 lines before and 2 after)\n        context_start = max(0, i - 10)\n        context_end = min(len(lines), i + 3)\n        context_lines = lines[context_start:context_end]\n        \n        # Extract attributes from the context\n        for ctx_line in context_lines:\n            # Extract role\n            if 'role=' in ctx_line:\n                role_match = re.search(r\"role=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if role_match:\n                    element_info['role'] = role_match.group(1)\n            \n            # Extract name attribute (often used with role)\n            if 'name=' in ctx_line:\n                name_match = re.search(r\"name=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if name_match:\n                    element_info['name'] = name_match.group(1)\n            \n            # Extract placeholder\n            if 'placeholder=' in ctx_line:\n                placeholder_match = re.search(r\"placeholder=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if placeholder_match:\n                    element_info['placeholder'] = placeholder_match.group(1)\n            \n            # Extract label text (for getByLabel)\n            if 'label=' in ctx_line or '<label' in ctx_line.lower():\n                label_match = re.search(r\"(?:label=|>)[\\s]*['\\\"]?([^'\\\"<>]+)['\\\"]?\", ctx_line)\n                if label_match:\n                    element_info['label'] = label_match.group(1).strip()\n        \n        # Extract text content from the line with ref\n        text_match = re.search(r'[\"\\']([^\"\\']{1,100})[\"\\'].*?\\[ref=', line)\n        if text_match:\n            element_info['text'] = text_match.group(1)\n        \n        # Generate Playwright native locator code based on available info\n        # Priority: role with name > text > placeholder > label > fallback\n        \n        # 1. Try getByRole (most stable and accessible)\n        if element_info['role']:\n            role = element_info['role']\n            name = element_info['name'] or element_info['text']\n            \n            # Escape single quotes in name\n            if name:\n                name_escaped = name.replace(\"'\", \"\\\\'\")\n                return f\"page.getByRole('{role}', {{ name: '{name_escaped}' }})\"\n            else:\n                return f\"page.getByRole('{role}')\"\n        \n        # 2. Try getByPlaceholder (for input fields)\n        if element_info['placeholder']:\n            placeholder_escaped = element_info['placeholder'].replace(\"'\", \"\\\\'\")\n            return f\"page.getByPlaceholder('{placeholder_escaped}')\"\n        \n        # 3. Try getByLabel (for form fields)\n        if element_info['label']:\n            label_escaped = element_info['label'].replace(\"'\", \"\\\\'\")\n            return f\"page.getByLabel('{label_escaped}')\"\n        \n        # 4. Try getByText (for elements with visible text)\n        if element_info['text']:\n            # Use exact match for short text, partial for longer text\n            text_escaped = element_info['text'].replace(\"'\", \"\\\\'\")\n            if len(element_info['text']) < 50:\n                return f\"page.getByText('{text_escaped}')\"\n            else:\n                # Use substring match for long text\n                text_preview = element_info['text'][:30].replace(\"'\", \"\\\\'\")\n                return f\"page.getByText('{text_preview}', {{ exact: false }})\"\n        \n        # 5. Fallback: could not extract enough information\n        break\n    \n    return None\n","size_bytes":28834},"OpenAIWeb/playwright_mcp/jink.py":{"content":"from playwright.sync_api import sync_playwright, expect\nimport re\n\n\ndef test_login():\n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=False)\n        page = browser.new_page()\n\n        # 1. Open the login page\n        page.goto(\"https://practicetestautomation.com/practice-test-login/\")\n\n        # 2. Type username and password\n        page.fill(\"input#username\", \"student\")\n        page.fill(\"input#password\", \"Password123\")\n\n        # 3. Click Submit button\n        page.click(\"button#submit\")\n\n        # 4. Verify URL contains expected path\n        expect(page).to_have_url(re.compile(r\"practicetestautomation\\.com/logged-in-successfully/\"))\n\n        # 5. Verify the page contains expected text\n        expect(page.locator(\"body\")).to_contain_text(\"Congratulations\")\n        # or alternatively\n        # expect(page.locator(\"body\")).to_contain_text(\"successfully logged in\")\n\n        # 6. Verify Log out button is displayed\n        expect(page.locator(\"a[href='/practice-test-login/']\")).to_be_visible()\n\n        browser.close()\n\n\nif __name__ == \"__main__\":\n    test_login()\n","size_bytes":1107},"OpenAIWeb/OpenAIWeb/src/__init__.py":{"content":"\"\"\"\nAI Browser Automation with Self-Healing Code Generation\n\nThis package provides AI-powered browser automation with automatic code generation\nand self-healing capabilities.\n\"\"\"\n\n__version__ = \"1.0.0\"\n\nfrom .automation_engine import BrowserAutomationEngine\nfrom .playwright_code_generator import PlaywrightCodeGenerator\nfrom .self_healing_executor import SelfHealingExecutor\nfrom .locator_utils import LocatorBuilder, LocatorHealer\n\n__all__ = [\n    \"BrowserAutomationEngine\",\n    \"PlaywrightCodeGenerator\",\n    \"SelfHealingExecutor\",\n    \"LocatorBuilder\",\n    \"LocatorHealer\",\n]\n","size_bytes":580},"OpenAIWeb/playwright_mcp/server/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 16px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\nheader {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 40px;\n    text-align: center;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.subtitle {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.main-content {\n    padding: 40px;\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 40px;\n}\n\n@media (max-width: 768px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n}\n\n.instruction-panel,\n.results-panel {\n    background: #f8f9fa;\n    padding: 30px;\n    border-radius: 12px;\n}\n\n.instruction-panel h2,\n.results-panel h2 {\n    font-size: 1.5rem;\n    margin-bottom: 20px;\n    color: #667eea;\n}\n\n.help-text {\n    color: #666;\n    margin-bottom: 10px;\n}\n\n.examples {\n    list-style: none;\n    margin-bottom: 20px;\n    padding-left: 0;\n}\n\n.examples li {\n    background: white;\n    padding: 10px 15px;\n    margin-bottom: 8px;\n    border-radius: 6px;\n    border-left: 3px solid #667eea;\n    font-size: 0.9rem;\n    color: #555;\n}\n\n#instruction-input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    margin-bottom: 20px;\n    transition: border-color 0.3s;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n}\n\n.button-group {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 12px 30px;\n    border: none;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    flex: 1;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #d0d0d0;\n}\n\n.spinner {\n    width: 16px;\n    height: 16px;\n    border: 2px solid #ffffff;\n    border-top: 2px solid transparent;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.status {\n    padding: 15px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    font-weight: 600;\n    display: none;\n}\n\n.status.success {\n    background: #d4edda;\n    color: #155724;\n    border: 1px solid #c3e6cb;\n    display: block;\n}\n\n.status.error {\n    background: #f8d7da;\n    color: #721c24;\n    border: 1px solid #f5c6cb;\n    display: block;\n}\n\n.status.processing {\n    background: #d1ecf1;\n    color: #0c5460;\n    border: 1px solid #bee5eb;\n    display: block;\n}\n\n.results-container {\n    max-height: 600px;\n    overflow-y: auto;\n}\n\n.step {\n    background: white;\n    padding: 20px;\n    margin-bottom: 15px;\n    border-radius: 8px;\n    border-left: 4px solid #667eea;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    background: #667eea;\n    color: white;\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status {\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d4edda;\n    color: #155724;\n}\n\n.step-status.error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #764ba2;\n    margin-bottom: 8px;\n}\n\n.step-args {\n    background: #f8f9fa;\n    padding: 10px;\n    border-radius: 6px;\n    font-size: 0.9rem;\n    font-family: monospace;\n    margin-top: 8px;\n    overflow-x: auto;\n}\n\n.final-message {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 8px;\n    margin-top: 20px;\n    font-size: 1.1rem;\n}\n\nfooter {\n    background: #f8f9fa;\n    padding: 20px;\n    text-align: center;\n    color: #666;\n    border-top: 1px solid #e0e0e0;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f1f1;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #667eea;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #764ba2;\n}\n","size_bytes":4892},"OpenAIWeb/OpenAIWeb/examples/example_login_automation.py":{"content":"\"\"\"\nExample: Login Automation Script\n\nThis example demonstrates how to use the AI Browser Automation CLI\nto automate a login process on a website.\n\nUsage:\n    # Generate code for this automation:\n    python main.py \"go to example.com, click login, fill email with test@example.com, click submit\" \\\n        --generate-code --output examples/generated_login.py\n\n    # Execute with self-healing:\n    python main.py --execute-code examples/generated_login.py --verbose\n\"\"\"\n\nasync def automated_task(page, safe_locator):\n    \"\"\"\n    This is an example of what generated code looks like.\n    In practice, you would use --generate-code to create this automatically.\n    \"\"\"\n    await page.goto(\"https://example.com\")\n    \n    login_button = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_text(\"Login\"),\n            lambda: page.get_by_role(\"button\", name=\"Login\"),\n            lambda: page.get_by_label(\"Login\"),\n        ],\n        action_description=\"click login button\"\n    )\n    await login_button.click()\n    \n    email_input = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_label(\"Email\"),\n            lambda: page.get_by_placeholder(\"Email\"),\n            lambda: page.locator(\"input[type='email']\"),\n        ],\n        action_description=\"fill email field\"\n    )\n    await email_input.fill(\"test@example.com\")\n    \n    submit_button = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_text(\"Submit\"),\n            lambda: page.get_by_role(\"button\", name=\"Submit\"),\n            lambda: page.locator(\"button[type='submit']\"),\n        ],\n        action_description=\"click submit button\"\n    )\n    await submit_button.click()\n    \n    await page.wait_for_timeout(2000)\n    \n    print(\"‚úÖ Login automation completed!\")\n","size_bytes":1797},"replit.md":{"content":"# AI Browser Automation Agent\n\n## Overview\n\nA professional-grade AI browser automation platform that combines OpenAI's language models with two automation engines: browser-use (langchain-based) and Playwright MCP (Model Context Protocol). The system provides both a web interface and CLI tools for executing browser automation tasks via natural language instructions.\n\nThe platform features intelligent engine fallback, self-healing code generation capabilities, and can convert AI-driven automations into maintainable Playwright scripts.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Application Structure\n\n**Dual-Interface Design**\n- **Web Application**: Flask-based server providing REST API and browser UI for interactive automation\n- **CLI Tools**: Direct command-line access for automation execution and code generation\n\nThe application uses a clean separation between web serving (`src/web/`) and core automation logic (`src/automation/`).\n\n### Automation Engine Architecture\n\n**Multi-Engine Strategy with Intelligent Fallback**\n\nThe system implements three execution modes managed by `EngineManager`:\n\n1. **Auto Mode** (Default): Attempts browser-use first, falls back to Playwright MCP on failure\n2. **Browser-use Mode**: Uses langchain + OpenAI for AI-driven browser automation\n3. **Playwright MCP Mode**: Uses Model Context Protocol with structured tool calling\n\n**Rationale**: Different automation tasks have different characteristics. Browser-use excels at complex, multi-step workflows with natural language understanding, while Playwright MCP provides more structured, reliable execution for simpler tasks. The fallback mechanism ensures high success rates.\n\n**Engine Implementations**:\n- `BrowserUseAutomationEngine`: Wraps browser-use library with langchain's ChatOpenAI\n- `MCPAutomationEngine`: Integrates Playwright MCP via subprocess communication and BrowserAgent for OpenAI-based instruction interpretation\n\n### Self-Healing Code Generation\n\n**Two-Phase Approach**:\n\n1. **Code Generation Phase**: `PlaywrightCodeGenerator` converts browser-use action history into reusable Playwright Python scripts with multiple fallback locator strategies\n2. **Self-Healing Execution Phase**: `SelfHealingExecutor` runs generated code and uses browser-use AI to fix failed locators in real-time\n\n**Design Decision**: Generated code includes multiple locator strategies (text, role, label-based) to reduce brittleness. When all strategies fail during execution, the AI intervenes in the same browser session to locate and interact with elements, then records the successful strategy for future use.\n\n**Trade-offs**:\n- Pro: Generated scripts are more maintainable than pure AI automation\n- Pro: Self-healing reduces maintenance burden when pages change\n- Con: Adds latency during healing attempts (mitigated by max 3 attempts)\n\n### Frontend Architecture\n\n**Technology**: Vanilla JavaScript with async/await for API communication\n\n**Design Pattern**: Single-page application with client-side rendering\n- Event-driven interaction model\n- RESTful API consumption via fetch\n- Real-time status updates and result display\n\n**Rationale**: Keeps frontend lightweight and avoids build tooling complexity while maintaining professional UX.\n\n### Communication Protocols\n\n**MCP Integration via STDIO**\n\nThe Playwright MCP server runs as a subprocess with JSON-RPC communication over stdin/stdout:\n- `MCPStdioClient` manages subprocess lifecycle and bidirectional communication\n- Threading model: separate threads for reading stdout and stderr\n- Request/response correlation via ID-based pending request tracking\n\n**Design Decision**: STDIO transport chosen over HTTP for:\n- Simpler deployment (no port management)\n- Tighter process coupling (server dies with client)\n- Lower latency for tool calls\n\n### Configuration Management\n\nUses INI file (`config.ini`) for:\n- OpenAI API keys and model selection\n- Browser preferences (headless mode, browser type)\n- MCP capabilities configuration\n\n**Security Note**: Code warns against committing API keys and recommends environment variables for production.\n\n## External Dependencies\n\n### AI Services\n- **OpenAI API**: Required for both automation engines\n  - browser-use uses via langchain's `ChatOpenAI` wrapper\n  - Playwright MCP uses via native `OpenAI` client\n  - Default model: `gpt-4o-mini` (explicitly specified, not to be changed without user request)\n\n### Browser Automation\n- **browser-use**: AI-powered automation library (v0.5.9+) using langchain\n- **Playwright**: Core browser automation (v1.57.0-alpha)\n- **Playwright MCP Server** (`@playwright/mcp`): Model Context Protocol implementation for Playwright\n  - Runs as Node.js subprocess via `tools/mcp-server/cli.js`\n  - Provides structured browser tools via MCP\n\n### Web Framework\n- **Flask**: Python web server for REST API and template serving\n- No database required (stateless design)\n\n### Python Dependencies\n- `langchain-openai`: LangChain's OpenAI integration\n- `playwright`: Browser automation library\n- `openai`: Official OpenAI Python client\n- `browser-use`: Natural language browser automation\n\n### Node.js Dependencies (MCP Server)\n- `playwright`: Playwright Node.js package\n- `playwright-core`: Core Playwright engine\n- `@modelcontextprotocol/sdk`: MCP protocol implementation\n- Various express/CORS middleware for MCP server capabilities\n\n### Browser Requirements\n- Chromium browser (detected via environment variable `CHROMIUM_PATH` or system PATH)\n- Supports Chrome, Chromium, or chromium-browser binaries\n\n### Configuration Files\n- `config.ini`: Application configuration (API keys, browser settings)\n- `package.json`: Node.js MCP server dependencies and metadata\n- No database schema files (application is stateless)","size_bytes":5794},"src/web/routes.py":{"content":"\"\"\"\nFlask Routes for Browser Automation\n\"\"\"\nfrom flask import render_template, request, jsonify\nfrom src.web.services.engine_manager import EngineManager\nimport re\nfrom datetime import datetime\n\n# Initialize Engine Manager\nengine_manager = None\n\n\ndef get_engine_manager():\n    \"\"\"Lazy initialization of Engine Manager\"\"\"\n    global engine_manager\n    if engine_manager is None:\n        engine_manager = EngineManager()\n    return engine_manager\n\n\ndef register_routes(app):\n    \"\"\"Register all routes with the Flask app\"\"\"\n    \n    @app.route('/')\n    def index():\n        \"\"\"Render main page\"\"\"\n        return render_template('index.html')\n    \n    \n    @app.route('/api/execute', methods=['POST'])\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            instruction = data.get('instruction', '').strip()\n            engine_mode = data.get('engine_mode', 'auto')\n            headless = data.get('headless', True)\n            \n            if not instruction:\n                return jsonify({\n                    'success': False,\n                    'error': 'Please provide an instruction'\n                }), 400\n            \n            manager = get_engine_manager()\n            \n            result = manager.execute(instruction, engine_mode, headless)\n            \n            return jsonify(result.to_dict())\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/engines', methods=['GET'])\n    def get_engines():\n        \"\"\"Get available automation engines\"\"\"\n        try:\n            manager = get_engine_manager()\n            engines = manager.get_available_engines()\n            \n            return jsonify({\n                'success': True,\n                **engines\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/reset', methods=['POST'])\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_mode = data.get('engine_mode')\n            \n            manager = get_engine_manager()\n            manager.reset(engine_mode)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully'\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/api/export-playwright', methods=['POST'])\n    def export_playwright():\n        \"\"\"Export last execution as Playwright code\"\"\"\n        try:\n            data = request.get_json()\n            steps = data.get('steps', [])\n            instruction = data.get('instruction', 'Automated task')\n            language = data.get('language', 'python')  # Default to Python\n            \n            if not steps:\n                return jsonify({\n                    'success': False,\n                    'error': 'No steps to export'\n                }), 400\n            \n            # Generate Playwright code based on language\n            if language == 'python':\n                playwright_code = generate_playwright_code_python(steps, instruction)\n            else:\n                playwright_code = generate_playwright_code_javascript(steps, instruction)\n            \n            # Enhanced JSON export with selector information\n            json_export = {\n                'instruction': instruction,\n                'timestamp': datetime.now().isoformat(),\n                'steps': steps,\n                'language': language,\n                'usage_notes': {\n                    'description': 'Steps executed by AI with full context',\n                    'replay': 'Can be used to replay automation programmatically',\n                    'selectors': 'Check result.snapshot fields for element information'\n                }\n            }\n            \n            return jsonify({\n                'success': True,\n                'playwright_code': playwright_code,\n                'json_export': json_export\n            })\n            \n        except Exception as e:\n            return jsonify({\n                'success': False,\n                'error': str(e)\n            }), 500\n    \n    \n    @app.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            manager = get_engine_manager()\n            \n            return jsonify({\n                'status': 'healthy',\n                'engines_available': ['browser-use', 'playwright-mcp'],\n                'message': 'Dual-engine automation system ready'\n            })\n        except Exception as e:\n            return jsonify({\n                'status': 'unhealthy',\n                'error': str(e)\n            }), 503\n\n\ndef generate_playwright_code_python(steps, instruction):\n    \"\"\"Generate Python Playwright code from execution steps with native locators\"\"\"\n    code_lines = [\n        \"from playwright.sync_api import sync_playwright, expect\",\n        \"import re\",\n        \"\",\n        \"\",\n        \"def run():\",\n        '    \"\"\"' + instruction + '\"\"\"',\n        \"    with sync_playwright() as p:\",\n        \"        # Launch browser\",\n        \"        browser = p.chromium.launch(headless=False)\",\n        \"        page = browser.new_page()\",\n        \"\",\n    ]\n    \n    # Track page snapshots to extract locators\n    last_snapshot = None\n    step_number = 1\n    \n    for step in steps:\n        if not step.get('success'):\n            continue\n            \n        tool = step.get('tool', '')\n        args = step.get('arguments', {})\n        result = step.get('result', {})\n        \n        # Update snapshot from result - normalize to string\n        if isinstance(result, dict) and 'snapshot' in result:\n            snapshot_data = result['snapshot']\n            if isinstance(snapshot_data, dict):\n                # MCP returns snapshot as dict with logicalTree or ariaTree\n                last_snapshot = snapshot_data.get('logicalTree') or snapshot_data.get('ariaTree')\n            elif isinstance(snapshot_data, str):\n                last_snapshot = snapshot_data\n        \n        if tool == 'browser_navigate':\n            url = args.get('url', '')\n            code_lines.append(f'        # {step_number}. Navigate to page')\n            code_lines.append(f'        page.goto(\"{url}\")')\n            code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_snapshot':\n            # Snapshot already updated above\n            pass\n                \n        elif tool == 'browser_click':\n            ref = args.get('ref', '')\n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Click element')\n                code_lines.append(f'        {locator_code}.click()')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Click element [ref={ref}] - Could not extract locator')\n                code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_fill':\n            ref = args.get('ref', '')\n            value = args.get('value', '').replace('\"', '\\\\\"')\n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Fill form field')\n                code_lines.append(f'        {locator_code}.fill(\"{value}\")')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Fill element [ref={ref}] with \"{value}\" - Could not extract locator')\n                code_lines.append('')\n            step_number += 1\n        \n        elif tool == 'browser_type':\n            # Handle browser_type tool (types text and optionally presses Enter)\n            ref = args.get('ref', '')\n            text = args.get('text', '').replace('\"', '\\\\\"')\n            submit = args.get('submit', False)\n            \n            locator_code = extract_playwright_locator_python(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f'        # {step_number}. Type text into field')\n                code_lines.append(f'        {locator_code}.fill(\"{text}\")')\n                if submit:\n                    code_lines.append(f'        {locator_code}.press(\"Enter\")')\n                code_lines.append('')\n            else:\n                code_lines.append(f'        # TODO: Type \"{text}\" into element [ref={ref}] - Could not extract locator')\n                if submit:\n                    code_lines.append(f'        # TODO: Press Enter')\n                code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_screenshot':\n            code_lines.append(f'        # {step_number}. Take screenshot')\n            code_lines.append('        page.screenshot(path=\"screenshot.png\")')\n            code_lines.append('')\n            step_number += 1\n            \n        elif tool == 'browser_close':\n            code_lines.append('        # Close browser')\n            code_lines.append('        browser.close()')\n            code_lines.append('')\n    \n    # Add browser close if not already added\n    if not any('browser.close()' in line for line in code_lines):\n        code_lines.append('        # Close browser')\n        code_lines.append('        browser.close()')\n        code_lines.append('')\n    \n    code_lines.extend([\n        \"\",\n        'if __name__ == \"__main__\":',\n        \"    run()\",\n        \"\",\n        \"# Generated from AI Browser Automation Agent\",\n        \"# Uses Playwright Python with native locators for better stability and readability\",\n        \"# Tip: Add assertions with expect() to verify page state\"\n    ])\n    \n    return '\\n'.join(code_lines)\n\n\ndef generate_playwright_code_javascript(steps, instruction):\n    \"\"\"Generate JavaScript Playwright test code from execution steps with native locators\"\"\"\n    code_lines = [\n        \"import { test, expect } from '@playwright/test';\",\n        \"\",\n        f\"test('{instruction}', async ({{ page }}) => {{\",\n    ]\n    \n    # Track page snapshots to extract locators\n    last_snapshot = None\n    \n    for step in steps:\n        if not step.get('success'):\n            continue\n            \n        tool = step.get('tool', '')\n        args = step.get('arguments', {})\n        result = step.get('result', {})\n        \n        # Update snapshot from result - normalize to string\n        if isinstance(result, dict) and 'snapshot' in result:\n            snapshot_data = result['snapshot']\n            if isinstance(snapshot_data, dict):\n                # MCP returns snapshot as dict with logicalTree or ariaTree\n                last_snapshot = snapshot_data.get('logicalTree') or snapshot_data.get('ariaTree')\n            elif isinstance(snapshot_data, str):\n                last_snapshot = snapshot_data\n        \n        if tool == 'browser_navigate':\n            url = args.get('url', '')\n            code_lines.append(f\"  await page.goto('{url}');\")\n            \n        elif tool == 'browser_snapshot':\n            # Snapshot already updated above\n            pass\n                \n        elif tool == 'browser_click':\n            ref = args.get('ref', '')\n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.click();\")\n            else:\n                code_lines.append(f\"  // TODO: Click element [ref={ref}] - Could not extract locator\")\n            \n        elif tool == 'browser_fill':\n            ref = args.get('ref', '')\n            value = args.get('value', '').replace(\"'\", \"\\\\'\")\n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.fill('{value}');\")\n            else:\n                code_lines.append(f\"  // TODO: Fill element [ref={ref}] with '{value}' - Could not extract locator\")\n        \n        elif tool == 'browser_type':\n            # Handle browser_type tool (types text and optionally presses Enter)\n            ref = args.get('ref', '')\n            text = args.get('text', '').replace(\"'\", \"\\\\'\")\n            submit = args.get('submit', False)\n            \n            locator_code = extract_playwright_locator(ref, last_snapshot, result)\n            if locator_code:\n                code_lines.append(f\"  await {locator_code}.fill('{text}');\")\n                if submit:\n                    code_lines.append(f\"  await {locator_code}.press('Enter');\")\n            else:\n                code_lines.append(f\"  // TODO: Type '{text}' into element [ref={ref}] - Could not extract locator\")\n                if submit:\n                    code_lines.append(f\"  // TODO: Press Enter\")\n            \n        elif tool == 'browser_screenshot':\n            code_lines.append(f\"  await page.screenshot({{ path: 'screenshot.png' }});\")\n            \n        elif tool == 'browser_close':\n            code_lines.append(f\"  // Browser will close automatically after test\")\n    \n    code_lines.extend([\n        \"});\",\n        \"\",\n        \"// Generated from AI Browser Automation Agent\",\n        \"// Uses Playwright native locators for better stability and readability\",\n        \"// Tip: Add assertions with expect() to verify page state\"\n    ])\n    \n    return '\\n'.join(code_lines)\n\n\ndef extract_playwright_locator_python(ref, snapshot, result):\n    \"\"\"\n    Extract Python Playwright native locator code from ref and snapshot data\n    Returns Python Playwright locator code string or None\n    \n    Examples:\n        page.get_by_role(\"button\", name=\"Submit\")\n        page.get_by_text(\"Click here\")\n        page.get_by_label(\"Email\")\n        page.get_by_placeholder(\"Search...\")\n    \"\"\"\n    if not ref:\n        return None\n    \n    # First, try to extract structured locator from result\n    if isinstance(result, dict):\n        # Check for structured locator metadata\n        if 'locator' in result:\n            locator_info = result['locator']\n            if isinstance(locator_info, dict):\n                # Extract locator from structured data\n                locator_type = locator_info.get('type', '')\n                locator_value = locator_info.get('value', '')\n                if locator_type and locator_value:\n                    # Convert JavaScript locator to Python (getByRole -> get_by_role)\n                    python_locator_type = locator_type.replace('getBy', 'get_by_').replace('By', '_by_').lower()\n                    value_escaped = locator_value.replace('\"', '\\\\\"')\n                    return f'page.{python_locator_type}(\"{value_escaped}\")'\n        \n        # Try to extract from content (MCP server often includes Playwright code)\n        content = result.get('content', [])\n        for item in content:\n            if isinstance(item, dict) and item.get('type') == 'text':\n                text = item.get('text', '')\n                # Look for Playwright locator code in the result\n                # Format: await page.getByRole('button', { name: 'Submit' }).action();\n                locator_match = re.search(r'await\\s+page\\.(getBy\\w+)\\(([^)]+)\\)', text)\n                if locator_match:\n                    method = locator_match.group(1)\n                    args_str = locator_match.group(2)\n                    \n                    # Convert method name to Python (getByRole -> get_by_role)\n                    python_method = 'get_by_role' if 'Role' in method else \\\n                                   'get_by_label' if 'Label' in method else \\\n                                   'get_by_placeholder' if 'Placeholder' in method else \\\n                                   'get_by_text' if 'Text' in method else method.lower()\n                    \n                    # Convert JavaScript object syntax to Python kwargs\n                    # Change { name: 'Submit' } to name=\"Submit\"\n                    # Change 'text' to \"text\"\n                    python_args = args_str.replace(\"'\", '\"')  # Use double quotes\n                    \n                    # Convert { key: value } to key=value\n                    python_args = re.sub(r'\\{\\s*(\\w+):\\s*([^}]+)\\s*\\}', r'\\1=\\2', python_args)\n                    \n                    return f\"page.{python_method}({python_args})\"\n    \n    # Fallback to snapshot parsing\n    if not snapshot or not isinstance(snapshot, str):\n        return None\n    \n    # Parse the snapshot to find the element with this ref\n    ref_pattern = rf'\\[ref={re.escape(ref)}\\]'\n    lines = snapshot.split('\\n')\n    \n    for i, line in enumerate(lines):\n        if ref_pattern not in line:\n            continue\n        \n        # Found the ref, now extract element information\n        element_info = {\n            'role': None,\n            'name': None,\n            'text': None,\n            'placeholder': None,\n            'label': None,\n            'tag': None\n        }\n        \n        # Search context around the ref (typically 10 lines before and 2 after)\n        context_start = max(0, i - 10)\n        context_end = min(len(lines), i + 3)\n        context_lines = lines[context_start:context_end]\n        \n        # Extract attributes from the context\n        for ctx_line in context_lines:\n            # Extract role\n            if 'role=' in ctx_line:\n                role_match = re.search(r\"role=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if role_match:\n                    element_info['role'] = role_match.group(1)\n            \n            # Extract name attribute (often used with role)\n            if 'name=' in ctx_line:\n                name_match = re.search(r\"name=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if name_match:\n                    element_info['name'] = name_match.group(1)\n            \n            # Extract placeholder\n            if 'placeholder=' in ctx_line:\n                placeholder_match = re.search(r\"placeholder=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if placeholder_match:\n                    element_info['placeholder'] = placeholder_match.group(1)\n            \n            # Extract label text (for get_by_label)\n            if 'label=' in ctx_line or '<label' in ctx_line.lower():\n                label_match = re.search(r\"(?:label=|>)[\\s]*['\\\"]?([^'\\\"<>]+)['\\\"]?\", ctx_line)\n                if label_match:\n                    element_info['label'] = label_match.group(1).strip()\n        \n        # Extract text content from the line with ref\n        text_match = re.search(r'[\"\\']([^\"\\']{1,100})[\"\\'].*?\\[ref=', line)\n        if text_match:\n            element_info['text'] = text_match.group(1)\n        \n        # Generate Python Playwright native locator code based on available info\n        # Priority: role with name > text > placeholder > label > fallback\n        \n        # 1. Try get_by_role (most stable and accessible)\n        if element_info['role']:\n            role = element_info['role']\n            name = element_info['name'] or element_info['text']\n            \n            # Escape double quotes in name\n            if name:\n                name_escaped = name.replace('\"', '\\\\\"')\n                return f'page.get_by_role(\"{role}\", name=\"{name_escaped}\")'\n            else:\n                return f'page.get_by_role(\"{role}\")'\n        \n        # 2. Try get_by_placeholder (for input fields)\n        if element_info['placeholder']:\n            placeholder_escaped = element_info['placeholder'].replace('\"', '\\\\\"')\n            return f'page.get_by_placeholder(\"{placeholder_escaped}\")'\n        \n        # 3. Try get_by_label (for form fields)\n        if element_info['label']:\n            label_escaped = element_info['label'].replace('\"', '\\\\\"')\n            return f'page.get_by_label(\"{label_escaped}\")'\n        \n        # 4. Try get_by_text (for elements with visible text)\n        if element_info['text']:\n            # Use exact match for short text\n            text_escaped = element_info['text'].replace('\"', '\\\\\"')\n            if len(element_info['text']) < 50:\n                return f'page.get_by_text(\"{text_escaped}\")'\n            else:\n                # Use substring match for long text\n                text_preview = element_info['text'][:30].replace('\"', '\\\\\"')\n                return f'page.locator(f\"text={text_preview}\")'\n        \n        # 5. Extract CSS selector as fallback from the snapshot\n        css_selector = extract_css_selector_from_line(line, ref)\n        if css_selector:\n            return f'page.locator(\"{css_selector}\")'\n        \n        # 6. Last resort: use the ref attribute with a comment\n        # Note: This won't work in production, but shows what element was targeted\n        return f'page.locator(\"[ref={ref}]\")  # Note: ref attribute may not exist in actual page'\n    \n    # If we couldn't find the ref at all in snapshot, try to use structured data\n    return None\n\n\ndef extract_css_selector_from_line(line, ref):\n    \"\"\"\n    Extract a CSS selector from the snapshot line\n    Returns CSS selector string or None\n    \"\"\"\n    # Try to extract ID\n    id_match = re.search(r'id=[\"\\']([^\"\\']+)[\"\\']', line)\n    if id_match:\n        element_id = id_match.group(1)\n        return f'#{element_id}'\n    \n    # Try to extract class (use first class)\n    class_match = re.search(r'class=[\"\\']([^\"\\']+)[\"\\']', line)\n    if class_match:\n        classes = class_match.group(1).split()\n        if classes:\n            # Use first class as selector\n            return f'.{classes[0]}'\n    \n    # Try to extract tag name with attributes\n    tag_match = re.search(r'<(\\w+)', line)\n    if tag_match:\n        tag = tag_match.group(1)\n        \n        # If it has a name attribute, use that\n        name_match = re.search(r'name=[\"\\']([^\"\\']+)[\"\\']', line)\n        if name_match:\n            name = name_match.group(1)\n            return f'{tag}[name=\"{name}\"]'\n        \n        # If it has a type attribute (for inputs)\n        type_match = re.search(r'type=[\"\\']([^\"\\']+)[\"\\']', line)\n        if type_match:\n            input_type = type_match.group(1)\n            return f'{tag}[type=\"{input_type}\"]'\n    \n    return None\n\n\ndef extract_playwright_locator(ref, snapshot, result):\n    \"\"\"\n    Extract Playwright native locator code from ref and snapshot data\n    Returns Playwright locator code string or None\n    \n    Examples:\n        page.getByRole('button', { name: 'Submit' })\n        page.getByText('Click here')\n        page.getByLabel('Email')\n        page.getByPlaceholder('Search...')\n    \"\"\"\n    if not ref:\n        return None\n    \n    # First, try to extract structured locator from result\n    if isinstance(result, dict):\n        # Check for structured locator metadata\n        if 'locator' in result:\n            locator_info = result['locator']\n            if isinstance(locator_info, dict):\n                # Extract locator from structured data\n                locator_type = locator_info.get('type', '')\n                locator_value = locator_info.get('value', '')\n                if locator_type and locator_value:\n                    value_escaped = locator_value.replace(\"'\", \"\\\\'\")\n                    return f\"page.{locator_type}('{value_escaped}')\"\n        \n        # Try to extract from content (MCP server often includes Playwright code)\n        content = result.get('content', [])\n        for item in content:\n            if isinstance(item, dict) and item.get('type') == 'text':\n                text = item.get('text', '')\n                # Look for Playwright locator code in the result\n                # Format: await page.getByRole(...).action();\n                locator_match = re.search(r'await\\s+page\\.(getBy\\w+\\([^)]+(?:\\s*,\\s*\\{[^}]+\\})?\\))', text)\n                if locator_match:\n                    return f\"page.{locator_match.group(1)}\"\n    \n    # Fallback to snapshot parsing\n    if not snapshot or not isinstance(snapshot, str):\n        return None\n    \n    # Parse the snapshot to find the element with this ref\n    ref_pattern = rf'\\[ref={re.escape(ref)}\\]'\n    lines = snapshot.split('\\n')\n    \n    for i, line in enumerate(lines):\n        if ref_pattern not in line:\n            continue\n        \n        # Found the ref, now extract element information\n        element_info = {\n            'role': None,\n            'name': None,\n            'text': None,\n            'placeholder': None,\n            'label': None,\n            'tag': None\n        }\n        \n        # Search context around the ref (typically 10 lines before and 2 after)\n        context_start = max(0, i - 10)\n        context_end = min(len(lines), i + 3)\n        context_lines = lines[context_start:context_end]\n        \n        # Extract attributes from the context\n        for ctx_line in context_lines:\n            # Extract role\n            if 'role=' in ctx_line:\n                role_match = re.search(r\"role=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if role_match:\n                    element_info['role'] = role_match.group(1)\n            \n            # Extract name attribute (often used with role)\n            if 'name=' in ctx_line:\n                name_match = re.search(r\"name=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if name_match:\n                    element_info['name'] = name_match.group(1)\n            \n            # Extract placeholder\n            if 'placeholder=' in ctx_line:\n                placeholder_match = re.search(r\"placeholder=['\\\"]([^'\\\"]+)['\\\"]\", ctx_line)\n                if placeholder_match:\n                    element_info['placeholder'] = placeholder_match.group(1)\n            \n            # Extract label text (for getByLabel)\n            if 'label=' in ctx_line or '<label' in ctx_line.lower():\n                label_match = re.search(r\"(?:label=|>)[\\s]*['\\\"]?([^'\\\"<>]+)['\\\"]?\", ctx_line)\n                if label_match:\n                    element_info['label'] = label_match.group(1).strip()\n        \n        # Extract text content from the line with ref\n        text_match = re.search(r'[\"\\']([^\"\\']{1,100})[\"\\'].*?\\[ref=', line)\n        if text_match:\n            element_info['text'] = text_match.group(1)\n        \n        # Generate Playwright native locator code based on available info\n        # Priority: role with name > text > placeholder > label > fallback\n        \n        # 1. Try getByRole (most stable and accessible)\n        if element_info['role']:\n            role = element_info['role']\n            name = element_info['name'] or element_info['text']\n            \n            # Escape single quotes in name\n            if name:\n                name_escaped = name.replace(\"'\", \"\\\\'\")\n                return f\"page.getByRole('{role}', {{ name: '{name_escaped}' }})\"\n            else:\n                return f\"page.getByRole('{role}')\"\n        \n        # 2. Try getByPlaceholder (for input fields)\n        if element_info['placeholder']:\n            placeholder_escaped = element_info['placeholder'].replace(\"'\", \"\\\\'\")\n            return f\"page.getByPlaceholder('{placeholder_escaped}')\"\n        \n        # 3. Try getByLabel (for form fields)\n        if element_info['label']:\n            label_escaped = element_info['label'].replace(\"'\", \"\\\\'\")\n            return f\"page.getByLabel('{label_escaped}')\"\n        \n        # 4. Try getByText (for elements with visible text)\n        if element_info['text']:\n            # Use exact match for short text, partial for longer text\n            text_escaped = element_info['text'].replace(\"'\", \"\\\\'\")\n            if len(element_info['text']) < 50:\n                return f\"page.getByText('{text_escaped}')\"\n            else:\n                # Use substring match for long text\n                text_preview = element_info['text'][:30].replace(\"'\", \"\\\\'\")\n                return f\"page.getByText('{text_preview}', {{ exact: false }})\"\n        \n        # 5. Fallback: could not extract enough information\n        break\n    \n    return None\n","size_bytes":28253},"src/automation/automation_engine.py":{"content":"import os\nfrom typing import Optional, Dict, Any\nfrom browser_use import Agent, Browser, BrowserProfile, ChatOpenAI\nfrom .playwright_code_generator import PlaywrightCodeGenerator\n\nclass BrowserAutomationEngine:\n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        headless: bool = False,\n        verbose: bool = False,\n        generate_code: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.headless = headless\n        self.verbose = verbose\n        self.generate_code = generate_code\n\n        self.llm = self._initialize_llm()\n        self.browser = self._initialize_browser()\n        self.code_generator = PlaywrightCodeGenerator(verbose=verbose) if generate_code else None\n\n    def _initialize_llm(self) -> ChatOpenAI:\n        # the newest OpenAI model is \"gpt-4o-mini\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        llm = ChatOpenAI(\n            model=self.model,\n            api_key=self.api_key\n        )\n\n        if self.verbose:\n            print(f\"‚úì Initialized LLM: {self.model}\")\n\n        return llm\n\n    def _initialize_browser(self) -> Browser:\n        import shutil\n\n        chromium_path = os.getenv(\"CHROMIUM_PATH\")\n        if not chromium_path:\n            chromium_path = shutil.which(\"chromium\") or shutil.which(\"chromium-browser\") or shutil.which(\"chrome\")\n\n        if chromium_path:\n            if self.verbose:\n                print(f\"‚úì Using Chromium at: {chromium_path}\")\n            profile = BrowserProfile(\n                headless=self.headless,\n                executable_path=chromium_path\n            )\n        else:\n            profile = BrowserProfile(\n                headless=self.headless\n            )\n\n        browser = Browser(\n            browser_profile=profile\n        )\n\n        if self.verbose:\n            print(f\"‚úì Initialized Browser (headless={self.headless})\")\n\n        return browser\n\n    async def run_task(self, task: str, output_file: Optional[str] = None) -> Dict[str, Any]:\n        if self.verbose:\n            print(f\"\\nüéØ Creating agent for task: {task}\\n\")\n\n        task_instruction = (\n            f\"{task}\\n\\n\"\n            \"IMPORTANT INSTRUCTIONS:\\n\"\n            \"1. You may do necessary auxiliary actions (wait for page loads, dismiss popups, etc.) to complete those steps.\\n\"\n            \"2. After completing the user's specified steps, STOP IMMEDIATELY.\\n\"\n            \"4. Do NOT continue to what seems like the 'next logical step' or try to complete an entire workflow.\\n\"\n            \"5. When you finish the last step specified by the user, call 'done' immediately.\"\n        )\n\n        task = task_instruction\n\n        agent = Agent(\n            task=task,\n            llm=self.llm,\n            browser=self.browser,\n        )\n\n        if self.verbose:\n            print(\"üîÑ Agent created, starting execution...\\n\")\n\n        history = await agent.run()\n\n        if self.verbose:\n            print(f\"\\nüìä Task execution completed\")\n            print(f\"   Steps taken: {len(history.history) if hasattr(history, 'history') else 'N/A'}\")\n\n        result = self._extract_result(history)\n\n        response = {\n            'result': result,\n            'history': history,\n            'generated_code': None,\n            'code_file': None\n        }\n\n        if self.generate_code and self.code_generator:\n            if self.verbose:\n                print(\"\\nüìù Generating Playwright code from actions...\")\n\n            self.code_generator.parse_history(history)\n            generated_code = self.code_generator.generate_code()\n            response['generated_code'] = generated_code\n\n            if output_file:\n                self.code_generator.save_code(output_file)\n                response['code_file'] = output_file\n                if self.verbose:\n                    print(f\"‚úì Code saved to: {output_file}\")\n\n        return response\n\n    def _extract_result(self, history) -> Optional[str]:\n        if not history:\n            return None\n\n        if hasattr(history, 'final_result'):\n            return str(history.final_result())\n\n        if hasattr(history, 'history') and history.history:\n            last_action = history.history[-1]\n            if hasattr(last_action, 'result'):\n                return str(last_action.result)\n\n        return \"Task completed successfully\"\n","size_bytes":4415},"src/web/static/css/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    min-height: 100vh;\n    padding: 20px;\n    color: #333;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 16px;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n    overflow: hidden;\n}\n\nheader {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 40px;\n    text-align: center;\n}\n\nheader h1 {\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n    font-weight: 700;\n}\n\n.subtitle {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.main-content {\n    padding: 40px;\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: 40px;\n}\n\n@media (max-width: 768px) {\n    .main-content {\n        grid-template-columns: 1fr;\n    }\n}\n\n.instruction-panel,\n.results-panel {\n    background: #f8f9fa;\n    padding: 30px;\n    border-radius: 12px;\n}\n\n.instruction-panel h2,\n.results-panel h2 {\n    font-size: 1.5rem;\n    margin-bottom: 20px;\n    color: #667eea;\n}\n\n.help-text {\n    color: #666;\n    margin-bottom: 10px;\n}\n\n.examples {\n    list-style: none;\n    margin-bottom: 20px;\n    padding-left: 0;\n}\n\n.examples li {\n    background: white;\n    padding: 10px 15px;\n    margin-bottom: 8px;\n    border-radius: 6px;\n    border-left: 3px solid #667eea;\n    font-size: 0.9rem;\n    color: #555;\n}\n\n#instruction-input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-family: inherit;\n    resize: vertical;\n    margin-bottom: 20px;\n    transition: border-color 0.3s;\n}\n\n#instruction-input:focus {\n    outline: none;\n    border-color: #667eea;\n}\n\n.settings-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    border: 2px solid #e0e0e0;\n}\n\n.setting-group {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    margin-bottom: 15px;\n}\n\n.setting-group:last-child {\n    margin-bottom: 0;\n}\n\n.setting-group label {\n    font-weight: 600;\n    color: #555;\n    min-width: 80px;\n}\n\n.select-control {\n    flex: 1;\n    padding: 10px 15px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.95rem;\n    background: white;\n    cursor: pointer;\n    transition: border-color 0.3s;\n}\n\n.select-control:focus {\n    outline: none;\n    border-color: #667eea;\n}\n\n.toggle-label {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    cursor: pointer;\n    user-select: none;\n}\n\n.toggle-label input[type=\"checkbox\"] {\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n}\n\n.toggle-text {\n    font-weight: 600;\n    color: #555;\n}\n\n.help-tooltip {\n    cursor: help;\n    color: #667eea;\n    font-size: 1.1rem;\n    margin-left: 5px;\n}\n\n.engine-info {\n    background: #e7f3ff;\n    border: 1px solid #b3d9ff;\n    padding: 12px 15px;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 0.95rem;\n}\n\n.button-group {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.btn {\n    padding: 12px 30px;\n    border: none;\n    border-radius: 8px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.btn-primary {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    flex: 1;\n}\n\n.btn-primary:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);\n}\n\n.btn-primary:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n.btn-secondary {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.btn-secondary:hover {\n    background: #d0d0d0;\n}\n\n.spinner {\n    width: 16px;\n    height: 16px;\n    border: 2px solid #ffffff;\n    border-top: 2px solid transparent;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.status {\n    padding: 15px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    font-weight: 600;\n    display: none;\n}\n\n.status.success {\n    background: #d4edda;\n    color: #155724;\n    border: 1px solid #c3e6cb;\n    display: block;\n}\n\n.status.error {\n    background: #f8d7da;\n    color: #721c24;\n    border: 1px solid #f5c6cb;\n    display: block;\n}\n\n.status.processing {\n    background: #d1ecf1;\n    color: #0c5460;\n    border: 1px solid #bee5eb;\n    display: block;\n}\n\n.results-container {\n    max-height: 600px;\n    overflow-y: auto;\n}\n\n.step {\n    background: white;\n    padding: 20px;\n    margin-bottom: 15px;\n    border-radius: 8px;\n    border-left: 4px solid #667eea;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.step-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.step-number {\n    background: #667eea;\n    color: white;\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status {\n    padding: 5px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 600;\n}\n\n.step-status.success {\n    background: #d4edda;\n    color: #155724;\n}\n\n.step-status.error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.step-tool {\n    font-weight: 600;\n    color: #764ba2;\n    margin-bottom: 8px;\n}\n\n.step-args {\n    background: #f8f9fa;\n    padding: 10px;\n    border-radius: 6px;\n    font-size: 0.9rem;\n    font-family: monospace;\n    margin-top: 8px;\n    overflow-x: auto;\n}\n\n.final-message {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 20px;\n    border-radius: 8px;\n    margin-top: 20px;\n    font-size: 1.1rem;\n}\n\nfooter {\n    background: #f8f9fa;\n    padding: 20px;\n    text-align: center;\n    color: #666;\n    border-top: 1px solid #e0e0e0;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f1f1;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #667eea;\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #764ba2;\n}\n","size_bytes":6138},"src/automation/playwright_code_generator.py":{"content":"import re\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass LocatorStrategy:\n    \"\"\"Represents a locator with multiple fallback strategies\"\"\"\n    primary: str\n    fallbacks: List[str]\n    description: str\n\n\nclass PlaywrightCodeGenerator:\n    \"\"\"Converts browser-use action history to reusable Playwright Python code\"\"\"\n\n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n        self.actions: List[Dict[str, Any]] = []\n        self.imports = set([\n            \"import asyncio\",\n            \"from playwright.async_api import async_playwright, Page, Browser, Locator\",\n            \"from typing import Optional\",\n        ])\n\n    def parse_history(self, history) -> None:\n        \"\"\"Parse browser-use history and extract actions\"\"\"\n        if not history:\n            if self.verbose:\n                print(\"‚ö†Ô∏è  No history provided to parse\")\n            return\n\n        if self.verbose:\n            print(\"üîç Parsing action history...\")\n            print(f\"   History type: {type(history)}\")\n            print(f\"   History attributes: {dir(history)[:10]}...\")\n\n        # For browser-use 0.5.9+, AgentHistoryList has a .history attribute containing AgentHistory objects\n        # Do NOT iterate directly over AgentHistoryList as it returns tuples\n\n        actions_found = False\n\n        # Method 1: history.history attribute (the correct way for browser-use 0.5.9)\n        if hasattr(history, 'history'):\n            try:\n                hist_items = history.history\n                if self.verbose:\n                    print(f\"   Found history.history: {len(hist_items)} AgentHistory items\")\n                for item in hist_items:\n                    if self.verbose:\n                        print(f\"     Processing AgentHistory item: has model_output={hasattr(item, 'model_output')}\")\n                    # Each item is an AgentHistory object with model_output\n                    if hasattr(item, 'model_output') and item.model_output:\n                        self._extract_from_agent_history(item)\n                        actions_found = True\n            except Exception as e:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not access history.history: {e}\")\n\n        # Method 2: model_actions method (older browser-use versions)\n        if not actions_found and hasattr(history, 'model_actions'):\n            try:\n                model_actions = history.model_actions()\n                if self.verbose:\n                    print(\n                        f\"   Found model_actions: {len(model_actions) if hasattr(model_actions, '__len__') else 'unknown'} items\")\n                for action in model_actions:\n                    self._extract_action(action)\n                    actions_found = True\n            except Exception as e:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not access model_actions: {e}\")\n\n        if self.verbose:\n            print(f\"‚úì Parsed {len(self.actions)} actions\")\n            if len(self.actions) == 0:\n                print(\"‚ö†Ô∏è  WARNING: No actions were extracted from history!\")\n                print(\"   This will result in empty generated code.\")\n\n    def _extract_from_agent_history(self, agent_history) -> None:\n        \"\"\"Extract actions from AgentHistory object (browser-use 0.5.9)\"\"\"\n        if not hasattr(agent_history, 'model_output') or not agent_history.model_output:\n            return\n\n        model_output = agent_history.model_output\n\n        if self.verbose:\n            print(f\"       model_output type: {type(model_output)}\")\n            if hasattr(model_output, '__dict__'):\n                print(f\"       model_output keys: {list(model_output.__dict__.keys())}\")\n\n        # model_output should have the action information\n        if hasattr(model_output, 'action') and model_output.action:\n            actions = model_output.action if isinstance(model_output.action, list) else [model_output.action]\n\n            if self.verbose:\n                print(f\"       Found {len(actions)} action(s)\")\n\n            for action in actions:\n                if self.verbose:\n                    print(f\"       Action type: {type(action)}\")\n                    if hasattr(action, '__dict__'):\n                        print(f\"       Action dict keys: {list(action.__dict__.keys())}\")\n                    # Check if action has a 'root' attribute which might contain the actual action\n                    if hasattr(action, 'root'):\n                        print(f\"       Action.root type: {type(action.root)}\")\n                        if hasattr(action.root, '__dict__'):\n                            print(f\"       Action.root keys: {list(action.root.__dict__.keys())}\")\n\n                # Handle 'root' wrapper in Pydantic models\n                if hasattr(action, 'root'):\n                    actual_action = action.root\n                    if isinstance(actual_action, list):\n                        for sub_action in actual_action:\n                            self._extract_action(sub_action)\n                    else:\n                        self._extract_action(actual_action)\n                else:\n                    self._extract_action(action)\n        elif hasattr(model_output, '__dict__'):\n            # Try to extract action from model_output dict\n            self._extract_action(model_output)\n\n    def _extract_action(self, action) -> None:\n        \"\"\"Extract action details from browser-use action object\"\"\"\n        action_data = {\n            'type': 'unknown',\n            'params': {},\n            'element': None,\n            'locators': [],\n            'description': ''\n        }\n\n        # Convert action to dict\n        if hasattr(action, '__dict__'):\n            action_dict = action.__dict__\n        elif isinstance(action, dict):\n            action_dict = action\n        else:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Skipping action of unknown type: {type(action)}\")\n            return\n\n        if self.verbose:\n            print(f\"   Examining action: {list(action_dict.keys())[:5]}...\")\n\n        # Browser-use 0.5.9+ uses simpler action keys: navigate, click, input, etc.\n        # Handle the new action structure first\n        if 'navigate' in action_dict:\n            nav_data = action_dict.get('navigate', {})\n            if hasattr(nav_data, '__dict__'):\n                nav_data = nav_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': nav_data.get('url', '') if isinstance(nav_data, dict) else str(nav_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'click' in action_dict:\n            click_data = action_dict.get('click', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            # In new format, element info might be in 'element_index' or similar\n            element = click_data.get('element', click_data) if isinstance(click_data, dict) else {}\n            action_data['element'] = element\n            action_data['locators'] = self._generate_locators(element)\n            action_data['description'] = f\"Click element\"\n\n        elif 'input' in action_dict:\n            input_data = action_dict.get('input', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            element = input_data.get('element', input_data) if isinstance(input_data, dict) else {}\n            action_data['element'] = element\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(element)\n            action_data['description'] = f\"Input text\"\n\n        elif 'done' in action_dict:\n            # Skip 'done' action as it's just a completion signal\n            if self.verbose:\n                print(f\"   ‚úì Skipping 'done' action (completion signal)\")\n            return\n\n        # Legacy browser-use format support (older versions)\n        elif 'go_to_url' in action_dict:\n            url_data = action_dict.get('go_to_url', {})\n            if hasattr(url_data, '__dict__'):\n                url_data = url_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': url_data.get('url', '') if isinstance(url_data, dict) else str(url_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'go_to_url' in actual_action:\n            url_data = actual_action.get('go_to_url', {})\n            if hasattr(url_data, '__dict__'):\n                url_data = url_data.__dict__\n            action_data['type'] = 'goto'\n            action_data['params'] = {'url': url_data.get('url', '') if isinstance(url_data, dict) else str(url_data)}\n            action_data['description'] = f\"Navigate to URL\"\n\n        elif 'click_element' in action_dict:\n            click_data = action_dict.get('click_element', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            action_data['element'] = click_data.get('element', {}) if isinstance(click_data, dict) else {}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Click element\"\n\n        elif 'click_element' in actual_action:\n            click_data = actual_action.get('click_element', {})\n            if hasattr(click_data, '__dict__'):\n                click_data = click_data.__dict__\n            action_data['type'] = 'click'\n            action_data['element'] = click_data.get('element', {}) if isinstance(click_data, dict) else {}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Click element\"\n\n        elif 'input_text' in action_dict:\n            input_data = action_dict.get('input_text', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            action_data['element'] = input_data.get('element', {}) if isinstance(input_data, dict) else {}\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Input text\"\n\n        elif 'input_text' in actual_action:\n            input_data = actual_action.get('input_text', {})\n            if hasattr(input_data, '__dict__'):\n                input_data = input_data.__dict__\n            action_data['type'] = 'fill'\n            action_data['element'] = input_data.get('element', {}) if isinstance(input_data, dict) else {}\n            action_data['params'] = {'text': input_data.get('text', '') if isinstance(input_data, dict) else ''}\n            action_data['locators'] = self._generate_locators(action_data['element'])\n            action_data['description'] = f\"Input text\"\n\n        elif 'extract_content' in action_dict or 'extract_content' in actual_action:\n            action_data['type'] = 'extract'\n            extract_data = action_dict.get('extract_content', actual_action.get('extract_content', {}))\n            action_data['params'] = extract_data if isinstance(extract_data, dict) else {}\n            action_data['description'] = f\"Extract content\"\n\n        if action_data['type'] != 'unknown':\n            self.actions.append(action_data)\n            if self.verbose:\n                print(f\"   ‚úì Extracted {action_data['type']} action\")\n        else:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Could not extract action from: {list(action_dict.keys())}\")\n\n    def _generate_locators(self, element: Dict[str, Any]) -> List[LocatorStrategy]:\n        \"\"\"Generate multiple locator strategies for an element\"\"\"\n        strategies = []\n\n        if not element:\n            return strategies\n\n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        tag = element.get('tag', '').strip()\n        attributes = element.get('attributes', {})\n\n        if text:\n            strategies.append(LocatorStrategy(\n                primary=f'page.get_by_text(\"{self._escape_quotes(text)}\")',\n                fallbacks=[\n                    f'page.locator(\\'text=\"{self._escape_quotes(text)}\"\\')',\n                    f'page.locator(\\'//*[contains(text(), \"{self._escape_quotes(text)}\")]\\')',\n                ],\n                description=f\"Text: {text[:50]}\"\n            ))\n\n        if role:\n            role_locator = f'page.get_by_role(\"{role}\"'\n            if text:\n                role_locator += f', name=\"{self._escape_quotes(text)}\"'\n            role_locator += ')'\n\n            strategies.append(LocatorStrategy(\n                primary=role_locator,\n                fallbacks=[f'page.locator(\\'[role=\"{role}\"]\\')', ],\n                description=f\"Role: {role}\"\n            ))\n\n        if attributes:\n            for key, value in attributes.items():\n                if key in ['id', 'data-testid', 'name', 'aria-label']:\n                    if key == 'id':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\"#{value}\")',\n                            fallbacks=[f'page.get_by_test_id(\"{value}\")'],\n                            description=f\"ID: {value}\"\n                        ))\n                    elif key == 'data-testid':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_test_id(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[data-testid=\"{value}\"]\\')', ],\n                            description=f\"Test ID: {value}\"\n                        ))\n                    elif key == 'name':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.locator(\\'[name=\"{value}\"]\\')',\n                            fallbacks=[f'page.get_by_label(\"{value}\")'],\n                            description=f\"Name: {value}\"\n                        ))\n                    elif key == 'aria-label':\n                        strategies.append(LocatorStrategy(\n                            primary=f'page.get_by_label(\"{value}\")',\n                            fallbacks=[f'page.locator(\\'[aria-label=\"{value}\"]\\')', ],\n                            description=f\"Aria-label: {value}\"\n                        ))\n\n        if tag and not strategies:\n            strategies.append(LocatorStrategy(\n                primary=f'page.locator(\"{tag}\")',\n                fallbacks=[],\n                description=f\"Tag: {tag}\"\n            ))\n\n        return strategies\n\n    def _escape_quotes(self, text: str) -> str:\n        \"\"\"Escape quotes in text for code generation\"\"\"\n        return text.replace('\"', '\\\\\"').replace(\"'\", \"\\\\'\")\n\n    def generate_code(self, function_name: str = \"automated_task\") -> str:\n        \"\"\"Generate complete Playwright Python code from actions\"\"\"\n        if not self.actions:\n            return \"# No actions to generate code from\"\n\n        code_lines = []\n\n        code_lines.extend(sorted(self.imports))\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n\n        code_lines.append(f\"async def {function_name}():\")\n        code_lines.append('    \"\"\"Generated Playwright automation code with self-healing support\"\"\"')\n        code_lines.append(\"    async with async_playwright() as p:\")\n        code_lines.append(\"        browser = await p.chromium.launch(headless=False)\")\n        code_lines.append(\"        context = await browser.new_context()\")\n        code_lines.append(\"        page = await context.new_page()\")\n        code_lines.append(\"\")\n        code_lines.append(\"        try:\")\n\n        for i, action in enumerate(self.actions):\n            code_lines.append(f\"            # Step {i + 1}: {action['type']}\")\n\n            if action['type'] == 'goto':\n                url = action['params'].get('url', '')\n                code_lines.append(f'            await page.goto(\"{url}\")')\n                code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n\n            elif action['type'] == 'click':\n                locators = action.get('locators', [])\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f\"            await element.click()\")\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for click action\")\n\n            elif action['type'] == 'fill':\n                locators = action.get('locators', [])\n                text = action['params'].get('text', '')\n                if locators:\n                    primary = locators[0]\n                    code_lines.append(f\"            # {primary.description}\")\n                    code_lines.append(f\"            element = await self_healing_locator(\")\n                    code_lines.append(f\"                page,\")\n                    code_lines.append(f\"                primary={primary.primary},\")\n                    fallback_str = \", \".join([f'\"{fb}\"' for fb in primary.fallbacks])\n                    code_lines.append(f\"                fallbacks=[{fallback_str}]\")\n                    code_lines.append(f\"            )\")\n                    code_lines.append(f'            await element.fill(\"{self._escape_quotes(text)}\")')\n                else:\n                    code_lines.append(f\"            # Unable to determine locator for fill action\")\n\n            elif action['type'] == 'extract':\n                code_lines.append(\"            # Extract content (implement based on your needs)\")\n                code_lines.append(\"            content = await page.content()\")\n\n            code_lines.append(\"\")\n\n        code_lines.append('            print(\"‚úÖ Task completed successfully!\")')\n        code_lines.append(\"\")\n        code_lines.append(\"        except Exception as e:\")\n        code_lines.append('            print(f\"‚ùå Error during automation: {e}\")')\n        code_lines.append(\"            raise\")\n        code_lines.append(\"        finally:\")\n        code_lines.append(\"            await browser.close()\")\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n\n        code_lines.append(\n            \"async def self_healing_locator(page: Page, primary: str, fallbacks: List[str] = None) -> Locator:\")\n        code_lines.append('    \"\"\"Try primary locator, fall back to alternatives if it fails\"\"\"')\n        code_lines.append(\"    fallbacks = fallbacks or []\")\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try primary locator\")\n        code_lines.append(\"    try:\")\n        code_lines.append(\"        locator = eval(primary)\")\n        code_lines.append(\"        await locator.wait_for(timeout=5000)\")\n        code_lines.append(\"        return locator\")\n        code_lines.append(\"    except Exception as e:\")\n        code_lines.append('        print(f\"‚ö†Ô∏è  Primary locator failed: {primary}\")')\n        code_lines.append(\"    \")\n        code_lines.append(\"    # Try fallback locators\")\n        code_lines.append(\"    for fallback in fallbacks:\")\n        code_lines.append(\"        try:\")\n        code_lines.append(\"            locator = eval(fallback)\")\n        code_lines.append(\"            await locator.wait_for(timeout=5000)\")\n        code_lines.append('            print(f\"‚úì Fallback locator succeeded: {fallback}\")')\n        code_lines.append(\"            return locator\")\n        code_lines.append(\"        except Exception:\")\n        code_lines.append(\"            continue\")\n        code_lines.append(\"    \")\n        code_lines.append('    raise Exception(f\"All locators failed for: {primary}\")')\n        code_lines.append(\"\")\n        code_lines.append(\"\")\n        code_lines.append('if __name__ == \"__main__\":')\n        code_lines.append(f\"    asyncio.run({function_name}())\")\n\n        return \"\\n\".join(code_lines)\n\n    def save_code(self, filepath: str, function_name: str = \"automated_task\") -> None:\n        \"\"\"Generate and save code to a file\"\"\"\n        code = self.generate_code(function_name)\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            f.write(code)\n\n        if self.verbose:\n            print(f\"‚úì Code saved to: {filepath}\")\n","size_bytes":21037},"src/web/static/js/app.js":{"content":"// Main application JavaScript\nconst instructionInput = document.getElementById('instruction-input');\nconst executeBtn = document.getElementById('execute-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst engineSelect = document.getElementById('engine-select');\nconst headlessToggle = document.getElementById('headless-toggle');\nconst statusDiv = document.getElementById('status');\nconst resultsDiv = document.getElementById('results');\nconst engineInfo = document.getElementById('engine-info');\n\nlet lastExecution = null;\n\n// Execute instruction\nexecuteBtn.addEventListener('click', async () => {\n    const instruction = instructionInput.value.trim();\n    \n    if (!instruction) {\n        showStatus('error', 'Please enter an instruction');\n        return;\n    }\n    \n    const engineMode = engineSelect.value;\n    const headless = headlessToggle.checked;\n    \n    setExecuting(true);\n    showStatus('processing', 'AI is processing your instruction...');\n    resultsDiv.innerHTML = '';\n    engineInfo.style.display = 'none';\n    \n    try {\n        const response = await fetch('/api/execute', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ \n                instruction,\n                engine_mode: engineMode,\n                headless: headless\n            }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', data.message || 'Task completed successfully');\n            displayEngineInfo(data);\n            displayResults(data);\n            lastExecution = {\n                instruction: instruction,\n                steps: data.steps\n            };\n            showExportButton();\n        } else {\n            showStatus('error', `Error: ${data.error || 'Unknown error'}`);\n            if (data.engine_used) {\n                displayEngineInfo(data);\n            }\n            if (data.steps && data.steps.length > 0) {\n                displayResults(data);\n            }\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to execute: ${error.message}`);\n    } finally {\n        setExecuting(false);\n    }\n});\n\n// Reset agent\nresetBtn.addEventListener('click', async () => {\n    if (!confirm('Reset the agent? This will clear the conversation history.')) {\n        return;\n    }\n    \n    try {\n        const engineMode = engineSelect.value === 'auto' ? null : engineSelect.value;\n        \n        const response = await fetch('/api/reset', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ engine_mode: engineMode }),\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            showStatus('success', 'Agent reset successfully');\n            resultsDiv.innerHTML = '';\n            engineInfo.style.display = 'none';\n            instructionInput.value = '';\n        } else {\n            showStatus('error', `Failed to reset: ${data.error}`);\n        }\n        \n    } catch (error) {\n        showStatus('error', `Failed to reset: ${error.message}`);\n    }\n});\n\n// Allow Enter key to execute (Shift+Enter for new line)\ninstructionInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        executeBtn.click();\n    }\n});\n\n// Helper functions\nfunction setExecuting(executing) {\n    executeBtn.disabled = executing;\n    const btnText = executeBtn.querySelector('.btn-text');\n    const spinner = executeBtn.querySelector('.spinner');\n    \n    if (executing) {\n        btnText.textContent = 'Executing...';\n        spinner.style.display = 'inline-block';\n    } else {\n        btnText.textContent = 'Execute';\n        spinner.style.display = 'none';\n    }\n}\n\nfunction showStatus(type, message) {\n    statusDiv.className = `status ${type}`;\n    statusDiv.textContent = message;\n}\n\nfunction displayEngineInfo(data) {\n    if (!data.engine_used) return;\n    \n    const icon = data.engine_used === 'browser-use' ? 'üöÄ' : 'üé≠';\n    const engineName = data.engine_used === 'browser-use' ? 'Browser-use' : 'Playwright MCP';\n    let infoHTML = `${icon} <strong>Engine used:</strong> ${engineName}`;\n    \n    if (data.fallback_occurred) {\n        infoHTML += ` <span style=\"color: #f59e0b; font-weight: 600;\">(‚ö†Ô∏è Fallback occurred)</span>`;\n    }\n    \n    engineInfo.innerHTML = infoHTML;\n    engineInfo.style.display = 'block';\n}\n\nfunction displayResults(data) {\n    const steps = data.steps || [];\n    \n    steps.forEach((step, index) => {\n        const stepEl = createStepElement(step, step.step_number || index + 1);\n        resultsDiv.appendChild(stepEl);\n    });\n}\n\nfunction createStepElement(step, number) {\n    const stepEl = document.createElement('div');\n    stepEl.className = 'step';\n    \n    const headerEl = document.createElement('div');\n    headerEl.className = 'step-header';\n    \n    const numberEl = document.createElement('span');\n    numberEl.className = 'step-number';\n    numberEl.textContent = `Step ${number}`;\n    \n    const statusEl = document.createElement('span');\n    statusEl.className = `step-status ${step.success !== false ? 'success' : 'error'}`;\n    statusEl.textContent = step.success !== false ? 'Success' : 'Failed';\n    \n    headerEl.appendChild(numberEl);\n    headerEl.appendChild(statusEl);\n    \n    const toolEl = document.createElement('div');\n    toolEl.className = 'step-tool';\n    toolEl.textContent = `Tool: ${step.tool || 'unknown'}`;\n    \n    stepEl.appendChild(headerEl);\n    stepEl.appendChild(toolEl);\n    \n    if (step.arguments && Object.keys(step.arguments).length > 0) {\n        const argsEl = document.createElement('div');\n        argsEl.className = 'step-args';\n        argsEl.textContent = JSON.stringify(step.arguments, null, 2);\n        stepEl.appendChild(argsEl);\n    }\n    \n    if (step.error) {\n        const errorEl = document.createElement('div');\n        errorEl.className = 'step-error';\n        errorEl.style.color = '#721c24';\n        errorEl.style.marginTop = '10px';\n        errorEl.textContent = `Error: ${step.error}`;\n        stepEl.appendChild(errorEl);\n    } else if (step.result && Object.keys(step.result).length > 0) {\n        const resultEl = document.createElement('details');\n        resultEl.style.marginTop = '10px';\n        \n        const summary = document.createElement('summary');\n        summary.textContent = 'View Result';\n        summary.style.cursor = 'pointer';\n        summary.style.color = '#667eea';\n        summary.style.fontWeight = '600';\n        \n        const resultContent = document.createElement('pre');\n        resultContent.style.background = '#f8f9fa';\n        resultContent.style.padding = '10px';\n        resultContent.style.borderRadius = '6px';\n        resultContent.style.marginTop = '10px';\n        resultContent.style.fontSize = '0.85rem';\n        resultContent.style.overflow = 'auto';\n        \n        const resultText = typeof step.result === 'string' ? step.result : JSON.stringify(step.result, null, 2);\n        resultContent.textContent = resultText;\n        \n        resultEl.appendChild(summary);\n        resultEl.appendChild(resultContent);\n        stepEl.appendChild(resultEl);\n    }\n    \n    return stepEl;\n}\n\nfunction showExportButton() {\n    if (document.getElementById('export-btn')) return;\n    \n    const buttonGroup = document.querySelector('.button-group');\n    const exportBtn = document.createElement('button');\n    exportBtn.id = 'export-btn';\n    exportBtn.className = 'btn btn-export';\n    exportBtn.textContent = 'Export as Playwright';\n    exportBtn.style.backgroundColor = '#10b981';\n    \n    exportBtn.addEventListener('click', async () => {\n        if (!lastExecution) {\n            showStatus('error', 'No execution to export');\n            return;\n        }\n        \n        try {\n            const response = await fetch('/api/export-playwright', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(lastExecution),\n            });\n            \n            const data = await response.json();\n            \n            if (data.success) {\n                showExportModal(data.playwright_code, data.json_export);\n            } else {\n                showStatus('error', `Export failed: ${data.error}`);\n            }\n            \n        } catch (error) {\n            showStatus('error', `Export failed: ${error.message}`);\n        }\n    });\n    \n    buttonGroup.appendChild(exportBtn);\n}\n\nfunction showExportModal(playwrightCode, jsonExport) {\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';\n    \n    const content = document.createElement('div');\n    content.style.cssText = 'background: white; padding: 30px; border-radius: 12px; max-width: 800px; max-height: 80vh; overflow: auto; width: 90%;';\n    \n    content.innerHTML = `\n        <h2 style=\"margin-top: 0; color: #667eea;\">Export Options</h2>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">Playwright Test Code:</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(playwrightCode)}</pre>\n            <button id=\"copy-code-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Copy Code</button>\n            <button id=\"download-code-btn\" style=\"margin-top: 10px; margin-left: 10px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download .spec.ts</button>\n        </div>\n        \n        <div style=\"margin-bottom: 20px;\">\n            <h3 style=\"color: #333;\">JSON Export (for replay):</h3>\n            <pre style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem;\">${escapeHtml(JSON.stringify(jsonExport, null, 2))}</pre>\n            <button id=\"download-json-btn\" style=\"margin-top: 10px; padding: 10px 20px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;\">Download JSON</button>\n        </div>\n        \n        <button id=\"close-modal-btn\" style=\"padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;\">Close</button>\n    `;\n    \n    modal.appendChild(content);\n    document.body.appendChild(modal);\n    \n    document.getElementById('copy-code-btn').addEventListener('click', () => {\n        navigator.clipboard.writeText(playwrightCode);\n        showStatus('success', 'Code copied to clipboard!');\n    });\n    \n    document.getElementById('download-code-btn').addEventListener('click', () => {\n        downloadFile('automation.spec.ts', playwrightCode);\n        showStatus('success', 'Playwright code downloaded!');\n    });\n    \n    document.getElementById('download-json-btn').addEventListener('click', () => {\n        downloadFile('automation-steps.json', JSON.stringify(jsonExport, null, 2));\n        showStatus('success', 'JSON export downloaded!');\n    });\n    \n    document.getElementById('close-modal-btn').addEventListener('click', () => {\n        document.body.removeChild(modal);\n    });\n    \n    modal.addEventListener('click', (e) => {\n        if (e.target === modal) {\n            document.body.removeChild(modal);\n        }\n    });\n}\n\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\nfunction downloadFile(filename, content) {\n    const blob = new Blob([content], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n}\n\nwindow.addEventListener('load', async () => {\n    try {\n        const response = await fetch('/api/engines');\n        const data = await response.json();\n        \n        if (data.success && data.engines) {\n            console.log('Available engines:', data.engines.map(e => e.name).join(', '));\n        }\n        \n        const healthResponse = await fetch('/health');\n        const healthData = await healthResponse.json();\n        \n        if (healthData.status === 'healthy') {\n            console.log('Application is ready');\n        } else {\n            showStatus('error', 'Server error. Please refresh the page.');\n        }\n    } catch (error) {\n        showStatus('error', 'Failed to connect to the application');\n    }\n});\n","size_bytes":12878},"src/web/services/engine_manager.py":{"content":"\"\"\"\nEngine Manager - Orchestrates automation engine selection and fallback\n\"\"\"\nfrom typing import Literal, Optional\nfrom .automation_engine_interface import ExecutionResult\nfrom .browser_use import BrowserUseAutomationEngine\nfrom .playwright_mcp import MCPAutomationEngine\n\n\nEngineMode = Literal[\"auto\", \"browser-use\", \"playwright-mcp\"]\n\n\nclass EngineManager:\n    \"\"\"Manages automation engine selection and fallback logic\"\"\"\n    \n    def __init__(self):\n        self.browser_use = BrowserUseAutomationEngine()\n        self.mcp = MCPAutomationEngine()\n        \n    def execute(\n        self, \n        instruction: str,\n        engine_mode: EngineMode = \"auto\",\n        headless: bool = True\n    ) -> ExecutionResult:\n        \"\"\"\n        Execute instruction with specified engine mode and fallback\n        \n        Args:\n            instruction: Natural language instruction\n            engine_mode: \"auto\" (browser-use with MCP fallback), \"browser-use\", or \"playwright-mcp\"\n            headless: Run browser in headless mode\n            \n        Returns:\n            ExecutionResult with execution details and metadata\n        \"\"\"\n        if engine_mode == \"playwright-mcp\":\n            return self._execute_with_mcp(instruction, headless)\n        elif engine_mode == \"browser-use\":\n            return self._execute_with_browser_use(instruction, headless)\n        else:\n            return self._execute_with_auto_fallback(instruction, headless)\n    \n    def _execute_with_browser_use(\n        self, \n        instruction: str, \n        headless: bool\n    ) -> ExecutionResult:\n        \"\"\"Execute with browser-use only\"\"\"\n        result = self.browser_use.execute_instruction(instruction, headless)\n        return result\n    \n    def _execute_with_mcp(\n        self, \n        instruction: str, \n        headless: bool\n    ) -> ExecutionResult:\n        \"\"\"Execute with Playwright MCP only\"\"\"\n        result = self.mcp.execute_instruction(instruction, headless)\n        return result\n    \n    def _execute_with_auto_fallback(\n        self, \n        instruction: str, \n        headless: bool\n    ) -> ExecutionResult:\n        \"\"\"\n        Execute with browser-use first, fallback to MCP on failure\n        Priority: browser-use > playwright-mcp\n        \"\"\"\n        result = self.browser_use.execute_instruction(instruction, headless)\n        \n        if result.success:\n            return result\n        \n        print(f\"‚ö†Ô∏è Browser-use failed: {result.error}\")\n        print(f\"üîÑ Falling back to Playwright MCP...\")\n        \n        fallback_result = self.mcp.execute_instruction(instruction, headless)\n        fallback_result.fallback_occurred = True\n        \n        if fallback_result.success:\n            fallback_result.message = f\"Completed with fallback to {fallback_result.engine_used}. Original error: {result.error}\"\n        else:\n            fallback_result.message = f\"Both engines failed. Browser-use: {result.error}. MCP: {fallback_result.error}\"\n            fallback_result.error = f\"browser-use: {result.error} | playwright-mcp: {fallback_result.error}\"\n        \n        return fallback_result\n    \n    def reset(self, engine_mode: Optional[EngineMode] = None) -> None:\n        \"\"\"Reset conversation state for one or all engines\"\"\"\n        if engine_mode == \"browser-use\" or engine_mode is None:\n            self.browser_use.reset_conversation()\n        if engine_mode == \"playwright-mcp\" or engine_mode is None:\n            self.mcp.reset_conversation()\n    \n    def get_available_engines(self) -> dict:\n        \"\"\"Get list of available engines\"\"\"\n        return {\n            'engines': [\n                {\n                    'id': 'auto',\n                    'name': 'Auto (browser-use ‚Üí MCP fallback)',\n                    'description': 'Uses browser-use first, falls back to Playwright MCP on failure'\n                },\n                {\n                    'id': 'browser-use',\n                    'name': 'Browser-use only',\n                    'description': 'AI-powered automation with browser-use library'\n                },\n                {\n                    'id': 'playwright-mcp',\n                    'name': 'Playwright MCP only',\n                    'description': 'Playwright Model Context Protocol server'\n                }\n            ]\n        }\n","size_bytes":4288},"README.md":{"content":"# AI Browser Automation Agent\n\n> **Dual-engine browser automation platform powered by OpenAI and Playwright with intelligent fallback and self-healing capabilities**\n\n## Overview\n\nA professional-grade AI browser automation system offering both a web interface and CLI tools for intelligent browser automation. The system features:\n\n- **Dual-Engine Architecture**: browser-use + Playwright MCP with automatic fallback\n- **Web Interface**: User-friendly Flask application for interactive automation\n- **Self-Healing Code Generation**: Convert automations into maintainable Playwright scripts\n- **Production Ready**: Clean architecture with professional code organization\n\n## Quick Start\n\n### Web Application\n\n```bash\n# Start the Flask web server\npython app.py\n```\n\nThen open your browser to `http://localhost:5000`\n\n### CLI Automation\n\n```bash\n# Direct automation\npython -m src.automation.cli \"search for Python tutorials on Google\"\n\n# Generate reusable code\npython -m src.automation.cli \"fill out login form\" --generate-code --output login.py\n\n# Execute with self-healing\npython -m src.automation.cli --execute-code login.py --verbose\n```\n\n## Features\n\n### Web Application\n- üé® **Interactive UI**: Clean, modern interface for browser automation\n- üîÑ **Real-time Execution**: Stream results as automation runs\n- üîÄ **Engine Selection**: Choose between browser-use, Playwright MCP, or auto-fallback\n- üì§ **Code Export**: Convert executions to Playwright code (Python/JavaScript)\n- üõ†Ô∏è **API Endpoints**: RESTful API for programmatic access\n\n### Automation Engines\n- **browser-use**: AI-powered automation with natural language understanding\n- **Playwright MCP**: Model Context Protocol integration for structured automation\n- **Auto Mode**: Intelligent fallback system (browser-use ‚Üí MCP)\n\n### Code Generation & Self-Healing\n- üîß **Self-Healing Locators**: Automatically fixes broken selectors\n- üìù **Clean Code Output**: Production-ready Playwright scripts\n- üéØ **Multiple Strategies**: Text, role, ID, label, CSS, XPath with fallbacks\n- üîÑ **AI Recovery**: Two-level recovery ensures automation never fails\n\n## Architecture\n\n```\nai-browser-automation/\n‚îú‚îÄ‚îÄ src/                          # Core application code\n‚îÇ   ‚îú‚îÄ‚îÄ automation/              # CLI automation modules\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ automation_engine.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ playwright_code_generator.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ self_healing_executor.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ locator_utils.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples/\n‚îÇ   ‚îî‚îÄ‚îÄ web/                     # Flask web application\n‚îÇ       ‚îú‚îÄ‚îÄ __init__.py          # Flask app factory\n‚îÇ       ‚îú‚îÄ‚îÄ routes.py            # API endpoints\n‚îÇ       ‚îú‚îÄ‚îÄ services/            # Business logic\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ browser_use/     # ü§ñ browser-use engine\n‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ engine.py\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ playwright_mcp/  # üõ†Ô∏è Playwright MCP engine\n‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine.py\n‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.py\n‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ browser_agent.py\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ automation_engine_interface.py\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ engine_manager.py\n‚îÇ       ‚îú‚îÄ‚îÄ static/              # CSS, JavaScript\n‚îÇ       ‚îî‚îÄ‚îÄ templates/           # HTML templates\n‚îú‚îÄ‚îÄ tools/                       # Development tools\n‚îÇ   ‚îî‚îÄ‚îÄ mcp-server/             # Playwright MCP Node.js server\n‚îú‚îÄ‚îÄ app.py                      # Web application entry point\n‚îú‚îÄ‚îÄ pyproject.toml              # Python dependencies\n‚îî‚îÄ‚îÄ config.ini                  # Application configuration\n```\n\n## Prerequisites\n\n- **Python 3.11+**\n- **Node.js 18+** (for MCP server)\n- **OpenAI API Key** ([Get one here](https://platform.openai.com/api-keys))\n\n## Installation\n\n### On Replit (Recommended)\n\nDependencies are pre-installed. Simply add your `OPENAI_API_KEY` when prompted.\n\n### Local Installation\n\n1. **Install Python dependencies**:\n```bash\npip install -e .\n```\n\n2. **Install Node.js dependencies** (for MCP server):\n```bash\ncd tools/mcp-server\nnpm install\ncd ../..\n```\n\n3. **Install Playwright browsers**:\n```bash\npython -m playwright install chromium\n```\n\n4. **Set your OpenAI API key**:\n```bash\nexport OPENAI_API_KEY=\"sk-your-api-key-here\"\n```\n\n## Usage\n\n### Web Interface\n\n1. **Start the server**:\n```bash\npython app.py\n```\n\n2. **Open your browser**: Navigate to `http://localhost:5000`\n\n3. **Enter instructions**: Type natural language commands like:\n   - \"Navigate to google.com and search for 'Playwright MCP'\"\n   - \"Open github.com and find trending repositories\"\n   - \"Go to example.com and tell me the page title\"\n\n4. **Choose engine**: Select Auto (recommended), browser-use only, or Playwright MCP only\n\n5. **View results**: See real-time execution steps and results\n\n6. **Export code**: Click \"Export Playwright Code\" to get reusable scripts\n\n### CLI Automation\n\n#### Basic Automation\n\n```bash\n# Simple tasks\npython -m src.automation.cli \"go to example.com and tell me the page title\"\n\n# Web scraping\npython -m src.automation.cli \"scrape the top 10 Hacker News posts with their titles and URLs\"\n\n# Form automation\npython -m src.automation.cli \"go to example.com/contact and fill out the contact form with name: John Doe, email: john@example.com\"\n\n# Multi-step workflows\npython -m src.automation.cli \"compare prices for iPhone 15 on Amazon and Best Buy\"\n```\n\n#### Code Generation\n\n```bash\n# Generate Python Playwright code\npython -m src.automation.cli \"login to example.com\" --generate-code --output login.py\n\n# Execute generated code (with self-healing)\npython -m src.automation.cli --execute-code login.py --verbose\n```\n\n## API Endpoints\n\n### Web Application API\n\n- `GET /` - Web interface\n- `POST /api/execute` - Execute automation instruction\n- `GET /api/engines` - List available automation engines\n- `POST /api/reset` - Reset agent conversation state\n- `POST /api/export-playwright` - Export execution as Playwright code\n- `GET /health` - Health check endpoint\n\n### Example API Call\n\n```bash\ncurl -X POST http://localhost:5000/api/execute \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"instruction\": \"go to example.com\",\n    \"engine_mode\": \"auto\",\n    \"headless\": true\n  }'\n```\n\n## How It Works\n\n### Web Application Flow\n\n1. **User Input**: Natural language instruction entered in browser\n2. **Engine Selection**: Auto-select or user-specified engine\n3. **AI Processing**: OpenAI interprets instruction and plans actions\n4. **Execution**: Browser automation performed via selected engine\n5. **Fallback** (Auto mode): If browser-use fails, automatically retry with MCP\n6. **Results**: Real-time streaming of execution steps and outcomes\n7. **Export**: Optional conversion to reusable Playwright code\n\n### Self-Healing Code Generation\n\n1. **Initial Execution**: browser-use performs automation with AI\n2. **Code Generation**: Actions converted to Playwright code with robust locators\n3. **Self-Healing** (when generated code runs):\n   - **Level 1**: If locator fails, AI finds element and updates locator\n   - **Level 2**: If healing fails, browser-use AI executes the action\n4. **Zero Downtime**: Same browser session, state preserved throughout\n\n## Configuration\n\n### Environment Variables\n\n- `OPENAI_API_KEY` - Required: Your OpenAI API key\n- `FLASK_SECRET_KEY` - Optional: Flask session secret\n\n### config.ini\n\n```ini\n[openai]\nmodel = gpt-4o-mini\ntemperature = 0.7\n\n[browser]\nheadless = false\ntimeout = 30000\n```\n\n## Troubleshooting\n\n### Port 5000 already in use\nEdit `app.py` and change the port:\n```python\napp.run(host='0.0.0.0', port=8000)\n```\n\n### OpenAI API Key not set\nVerify it's set: `echo $OPENAI_API_KEY`\n\n### Playwright browsers not installed\n```bash\npython -m playwright install chromium\n```\n\n### Module import errors\nMake sure you're in the project root and dependencies are installed:\n```bash\npip install -e .\n```\n\n## Cost Considerations\n\n- OpenAI API charges based on token usage\n- Each automation typically uses 2-5 API calls\n- Monitor usage at: https://platform.openai.com/usage\n- Consider using caching and code generation to reduce repeated API calls\n\n## Production Deployment\n\n### For web application:\n\n1. **Use a production WSGI server**:\n```bash\npip install gunicorn\ngunicorn --bind 0.0.0.0:5000 --workers 4 app:app\n```\n\n2. **Set environment variables** securely\n3. **Add security headers** and configure CORS\n4. **Use HTTPS** in production\n\n### Replit Deployment\n\nThe project is pre-configured for Replit deployment. Simply click \"Deploy\" in the Replit interface.\n\n## Technology Stack\n\n- **Flask 3.1+** - Web framework\n- **OpenAI GPT-4o-mini** - Natural language understanding\n- **browser-use** - AI browser automation\n- **Playwright** - Browser automation backend  \n- **Playwright MCP** - Model Context Protocol integration\n- **Python 3.11+** - Modern Python features\n- **Node.js 18+** - MCP server runtime\n\n## License\n\nMIT License - See LICENSE file for details\n\n## Support\n\nIf you encounter issues:\n1. Check console output for error messages\n2. Verify all prerequisites are installed\n3. Ensure OpenAI API key is valid and has credits\n4. Check that required ports are not blocked\n\n---\n\n**Built with AI-powered automation using OpenAI, browser-use, and Playwright** ü§ñ\n","size_bytes":9337},"tools/mcp-server/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"src/automation/__init__.py":{"content":"\"\"\"\nAI Browser Automation with Self-Healing Code Generation\n\nThis package provides AI-powered browser automation with automatic code generation\nand self-healing capabilities.\n\"\"\"\n\n__version__ = \"1.0.0\"\n\nfrom .automation_engine import BrowserAutomationEngine\nfrom .playwright_code_generator import PlaywrightCodeGenerator\nfrom .self_healing_executor import SelfHealingExecutor\nfrom .locator_utils import LocatorBuilder, LocatorHealer\n\n__all__ = [\n    \"BrowserAutomationEngine\",\n    \"PlaywrightCodeGenerator\",\n    \"SelfHealingExecutor\",\n    \"LocatorBuilder\",\n    \"LocatorHealer\",\n]\n","size_bytes":580},"tools/mcp-server/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"app.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nfrom src.web import create_app\n\nif __name__ == '__main__':\n    app = create_app()\n    # Run Flask on port 5000, bound to all interfaces for Replit\n    app.run(host='0.0.0.0', port=5000, debug=False)\n","size_bytes":270},"src/automation/locator_utils.py":{"content":"\"\"\"\nHelper utilities for robust locator strategies and self-healing.\nThese are used when executing GENERATED Playwright code, not during initial browser-use automation.\n\"\"\"\n\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Locator\n\n\nclass LocatorBuilder:\n    \"\"\"Build robust locators with multiple fallback strategies\"\"\"\n    \n    @staticmethod\n    def by_text(text: str, exact: bool = False) -> List[str]:\n        \"\"\"Generate text-based locator strategies\"\"\"\n        escaped = text.replace('\"', '\\\\\"')\n        strategies = [\n            f'page.get_by_text(\"{escaped}\", exact={exact})',\n            f'page.locator(\\'text={escaped}\\')',\n        ]\n        if not exact:\n            strategies.append(f'page.locator(\\'//*[contains(text(), \"{escaped}\")]\\')')\n        return strategies\n    \n    @staticmethod\n    def by_role(role: str, name: Optional[str] = None) -> List[str]:\n        \"\"\"Generate role-based locator strategies\"\"\"\n        if name:\n            name_escaped = name.replace('\"', '\\\\\"')\n            return [\n                f'page.get_by_role(\"{role}\", name=\"{name_escaped}\")',\n                f'page.locator(\\'[role=\"{role}\"][aria-label=\"{name_escaped}\"]\\')',\n                f'page.locator(\\'[role=\"{role}\"]\\')',\n            ]\n        return [\n            f'page.get_by_role(\"{role}\")',\n            f'page.locator(\\'[role=\"{role}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_label(label: str) -> List[str]:\n        \"\"\"Generate label-based locator strategies\"\"\"\n        escaped = label.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_label(\"{escaped}\")',\n            f'page.locator(\\'[aria-label=\"{escaped}\"]\\')',\n            f'page.locator(\\'label:has-text(\"{escaped}\")\\')',\n        ]\n    \n    @staticmethod\n    def by_placeholder(placeholder: str) -> List[str]:\n        \"\"\"Generate placeholder-based locator strategies\"\"\"\n        escaped = placeholder.replace('\"', '\\\\\"')\n        return [\n            f'page.get_by_placeholder(\"{escaped}\")',\n            f'page.locator(\\'[placeholder=\"{escaped}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_test_id(test_id: str) -> List[str]:\n        \"\"\"Generate test-id based locator strategies\"\"\"\n        return [\n            f'page.get_by_test_id(\"{test_id}\")',\n            f'page.locator(\\'[data-testid=\"{test_id}\"]\\')',\n            f'page.locator(\\'[data-test-id=\"{test_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_id(element_id: str) -> List[str]:\n        \"\"\"Generate id-based locator strategies\"\"\"\n        return [\n            f'page.locator(\"#{element_id}\")',\n            f'page.locator(\\'[id=\"{element_id}\"]\\')',\n        ]\n    \n    @staticmethod\n    def by_css(selector: str) -> List[str]:\n        \"\"\"Generate CSS selector locator\"\"\"\n        return [f'page.locator(\"{selector}\")']\n    \n    @staticmethod\n    def by_xpath(xpath: str) -> List[str]:\n        \"\"\"Generate XPath locator\"\"\"\n        return [f'page.locator(\\'{xpath}\\')']\n\n\nasync def try_locator_strategies(\n    page: Page,\n    strategies: List[str],\n    timeout: int = 5000,\n    verbose: bool = False\n) -> Optional[Locator]:\n    \"\"\"\n    Try multiple locator strategies until one works.\n    Used in generated code for fallback locator support.\n    \n    Args:\n        page: Playwright page object\n        strategies: List of locator strategy strings\n        timeout: Timeout in milliseconds per strategy\n        verbose: Print debug information\n    \n    Returns:\n        Working Locator object, or None if all fail\n    \"\"\"\n    for i, strategy in enumerate(strategies):\n        try:\n            locator = eval(strategy)\n            await locator.wait_for(timeout=timeout)\n            if verbose and i > 0:\n                print(f\"   ‚úì Fallback strategy {i} worked: {strategy}\")\n            return locator\n        except Exception:\n            if verbose:\n                print(f\"   ‚ö†Ô∏è  Strategy {i} failed: {strategy}\")\n            continue\n    \n    return None\n\n\nclass LocatorHealer:\n    \"\"\"\n    Context information for self-healing locators.\n    This is used ONLY when executing generated Playwright code.\n    \"\"\"\n    \n    @staticmethod\n    def extract_element_info(locator_str: str) -> Dict[str, str]:\n        \"\"\"Extract information from a locator string for healing context\"\"\"\n        info = {\n            'type': 'unknown',\n            'value': '',\n            'description': ''\n        }\n        \n        if 'get_by_text' in locator_str:\n            info['type'] = 'text'\n            info['description'] = 'element with text'\n        elif 'get_by_role' in locator_str:\n            info['type'] = 'role'\n            info['description'] = 'element with role'\n        elif 'get_by_label' in locator_str:\n            info['type'] = 'label'\n            info['description'] = 'element with label'\n        elif 'get_by_placeholder' in locator_str:\n            info['type'] = 'placeholder'\n            info['description'] = 'input with placeholder'\n        elif 'get_by_test_id' in locator_str:\n            info['type'] = 'test_id'\n            info['description'] = 'element with test ID'\n        elif 'locator' in locator_str:\n            if 'text=' in locator_str:\n                info['type'] = 'text'\n                info['description'] = 'element with text'\n            elif '[role=' in locator_str:\n                info['type'] = 'role'\n                info['description'] = 'element with role'\n            elif '#' in locator_str:\n                info['type'] = 'id'\n                info['description'] = 'element with ID'\n            else:\n                info['type'] = 'css'\n                info['description'] = 'element matching CSS selector'\n        \n        return info\n    \n    @staticmethod\n    def build_healing_task(\n        locator_str: str,\n        action: str,\n        url: str,\n        title: str\n    ) -> str:\n        \"\"\"Build a task description for browser-use to heal a broken locator\"\"\"\n        element_info = LocatorHealer.extract_element_info(locator_str)\n        \n        task = f\"\"\"On the current page (URL: {url}, Title: {title}), find the {element_info['description']} that we need to {action}.\n\nThe previous locator ({locator_str}) no longer works. Analyze the page and locate the correct element, then provide information about its attributes so we can create a new working locator.\"\"\"\n        \n        return task\n","size_bytes":6328},"src/web/__init__.py":{"content":"\"\"\"\nAI Browser Automation Server\nFlask application for browser automation using OpenAI + Playwright MCP\n\"\"\"\nfrom flask import Flask\nimport os\n\n\ndef create_app():\n    \"\"\"Application factory for Flask app\"\"\"\n    app = Flask(__name__)\n    app.config['SECRET_KEY'] = os.urandom(24)\n    \n    # Register routes\n    from src.web.routes import register_routes\n    register_routes(app)\n    \n    return app\n","size_bytes":397},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"browser-use>=0.8.1\",\n    \"flask>=3.1.2\",\n    \"langchain-openai>=1.0.1\",\n    \"openai>=1.109.1\",\n    \"playwright>=1.55.0\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"sseclient-py>=1.8.0\",\n]\n","size_bytes":349},"tools/mcp-server/index.d.ts":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Config } from './config';\nimport type { BrowserContext } from 'playwright';\n\nexport declare function createConnection(config?: Config, contextGetter?: () => Promise<BrowserContext>): Promise<Server>;\nexport {};\n","size_bytes":921},"src/automation/examples/example_login_automation.py":{"content":"\"\"\"\nExample: Login Automation Script\n\nThis example demonstrates how to use the AI Browser Automation CLI\nto automate a login process on a website.\n\nUsage:\n    # Generate code for this automation:\n    python main.py \"go to example.com, click login, fill email with test@example.com, click submit\" \\\n        --generate-code --output examples/generated_login.py\n\n    # Execute with self-healing:\n    python main.py --execute-code examples/generated_login.py --verbose\n\"\"\"\n\nasync def automated_task(page, safe_locator):\n    \"\"\"\n    This is an example of what generated code looks like.\n    In practice, you would use --generate-code to create this automatically.\n    \"\"\"\n    await page.goto(\"https://example.com\")\n    \n    login_button = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_text(\"Login\"),\n            lambda: page.get_by_role(\"button\", name=\"Login\"),\n            lambda: page.get_by_label(\"Login\"),\n        ],\n        action_description=\"click login button\"\n    )\n    await login_button.click()\n    \n    email_input = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_label(\"Email\"),\n            lambda: page.get_by_placeholder(\"Email\"),\n            lambda: page.locator(\"input[type='email']\"),\n        ],\n        action_description=\"fill email field\"\n    )\n    await email_input.fill(\"test@example.com\")\n    \n    submit_button = await safe_locator(\n        page,\n        [\n            lambda: page.get_by_text(\"Submit\"),\n            lambda: page.get_by_role(\"button\", name=\"Submit\"),\n            lambda: page.locator(\"button[type='submit']\"),\n        ],\n        action_description=\"click submit button\"\n    )\n    await submit_button.click()\n    \n    await page.wait_for_timeout(2000)\n    \n    print(\"‚úÖ Login automation completed!\")\n","size_bytes":1797},"src/automation/self_healing_executor.py":{"content":"import asyncio\nimport os\nfrom typing import Optional, Dict, Any, List, Callable\nfrom playwright.async_api import Page, Browser, Locator, async_playwright\nfrom browser_use import Agent, Browser as BrowserUseWrapper, ChatOpenAI\n\n\nclass AIExecutedMarker:\n    \"\"\"Marker to indicate an action was executed by browser-use AI instead of Playwright\"\"\"\n    def __init__(self, action_description: str):\n        self.action_description = action_description\n        self.executed_by_ai = True\n    \n    def __repr__(self):\n        return f\"<AIExecutedMarker: {self.action_description}>\"\n\n\nclass SelfHealingExecutor:\n    \"\"\"\n    Executes Playwright code with AI-powered self-healing capabilities.\n    When a locator fails, browser-use AI intervenes in the same session to fix it.\n    \"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.api_key = api_key\n        self.model = model\n        self.verbose = verbose\n        self.llm = None\n        self.healed_locators: Dict[str, str] = {}\n        self.healing_attempts = 0\n        self.max_healing_attempts = 3\n    \n    def _initialize_llm(self) -> ChatOpenAI:\n        \"\"\"Initialize OpenAI LLM for browser-use\"\"\"\n        if not self.llm:\n            self.llm = ChatOpenAI(\n                model=self.model,\n                api_key=self.api_key\n            )\n            if self.verbose:\n                print(f\"‚úì Initialized healing LLM: {self.model}\")\n        return self.llm\n    \n    async def heal_locator(\n        self,\n        page: Page,\n        failed_locator: str,\n        action_description: str,\n        element_description: str = \"\",\n        playwright_context = None\n    ) -> Optional[str]:\n        \"\"\"\n        Use browser-use AI to find and fix a broken locator in the same session.\n        \n        Args:\n            page: The Playwright page object\n            failed_locator: The locator that failed\n            action_description: What action we're trying to perform (e.g., \"click login button\")\n            element_description: Additional context about the element\n            playwright_context: The Playwright browser context to reuse\n        \n        Returns:\n            New working locator string, or None if healing failed\n        \"\"\"\n        if self.healing_attempts >= self.max_healing_attempts:\n            if self.verbose:\n                print(f\"‚ö†Ô∏è  Max healing attempts ({self.max_healing_attempts}) reached\")\n            return None\n        \n        self.healing_attempts += 1\n        \n        if self.verbose:\n            print(f\"\\nüîß Healing attempt {self.healing_attempts}/{self.max_healing_attempts}\")\n            print(f\"   Failed locator: {failed_locator}\")\n            print(f\"   Action: {action_description}\")\n        \n        try:\n            llm = self._initialize_llm()\n            \n            current_url = page.url\n            page_title = await page.title()\n            \n            task = f\"\"\"On this page ({current_url}), locate the element for: {action_description}.\n\nThe previous locator failed: {failed_locator}\nElement description: {element_description}\n\nIMPORTANT: After finding the correct element:\n1. Click or interact with it to confirm it's the right one\n2. Report back its exact attributes: text content, role, id, class, aria-label, placeholder, or any other identifying attributes\n3. Describe its location on the page for verification\n\nYour response should include the element's attributes in detail.\"\"\"\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI analyzing page to find element...\")\n            \n            cdp_url = await self._get_cdp_url(page)\n            \n            if not cdp_url:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not connect to existing browser session, fallback to heuristics\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üîó Connecting to browser session: {cdp_url}\")\n            \n            browser_wrapper = BrowserUseWrapper(\n                browser_session={'cdp_url': cdp_url}\n            )\n            \n            agent = Agent(\n                task=task,\n                llm=llm,\n                browser=browser_wrapper,\n            )\n            \n            result = await agent.run()\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI task result: {str(result)[:100] if result else 'None'}...\")\n            \n            history = agent.history if hasattr(agent, 'history') else None\n            \n            if not history:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  No history found on agent object\")\n                return await self._extract_locator_from_healing(page, action_description, element_description)\n            \n            if self.verbose:\n                print(f\"   üìã Analyzing agent history with {len(history.model_actions) if hasattr(history, 'model_actions') else 0} actions\")\n            \n            new_locator = await self._extract_locator_from_agent_history(\n                page=page,\n                history=history,\n                action_desc=action_description,\n                element_desc=element_description\n            )\n            \n            if new_locator:\n                self.healed_locators[failed_locator] = new_locator\n                if self.verbose:\n                    print(f\"   ‚úÖ Healing successful! New locator: {new_locator}\")\n                return new_locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  Could not extract locator from AI, trying heuristics...\")\n                new_locator = await self._extract_locator_from_healing(page, action_description, element_description)\n                if new_locator:\n                    self.healed_locators[failed_locator] = new_locator\n                    if self.verbose:\n                        print(f\"   ‚úÖ Heuristic healing successful! New locator: {new_locator}\")\n                    return new_locator\n                \n                if self.verbose:\n                    print(f\"   ‚ùå Healing failed - could not determine new locator\")\n                return None\n                \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Healing error: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n            return None\n    \n    async def _get_cdp_url(self, page: Page) -> Optional[str]:\n        \"\"\"\n        Get CDP URL from the current Playwright browser session.\n        Uses multiple strategies to ensure compatibility.\n        \"\"\"\n        try:\n            browser = page.context.browser\n            \n            if hasattr(browser, '_impl_obj'):\n                impl_obj = browser._impl_obj\n                \n                if hasattr(impl_obj, '_connection') and hasattr(impl_obj._connection, 'url'):\n                    return impl_obj._connection.url\n                \n                if hasattr(impl_obj, '_transport') and hasattr(impl_obj._transport, 'url'):\n                    return impl_obj._transport.url\n            \n            if hasattr(browser, '_cdp_url'):\n                return browser._cdp_url\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Could not extract CDP URL: {str(e)}\")\n        \n        return None\n    \n    async def _extract_locator_from_agent_history(\n        self,\n        page: Page,\n        history,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Extract a working locator from browser-use agent's action history.\n        This parses what the AI actually found and interacted with.\n        \"\"\"\n        if not history:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  History object is None\")\n            return None\n        \n        try:\n            if hasattr(history, 'model_actions'):\n                try:\n                    actions = history.model_actions()\n                    if self.verbose:\n                        print(f\"   üìã Found {len(actions) if actions else 0} model actions in history\")\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ö†Ô∏è  Could not call model_actions(): {str(e)}\")\n                    actions = []\n                \n                for i, action in enumerate(reversed(actions)):\n                    if self.verbose:\n                        print(f\"   üîç Analyzing action {len(actions) - i}: {type(action)}\")\n                    \n                    if hasattr(action, '__dict__'):\n                        action_dict = action.__dict__\n                    elif isinstance(action, dict):\n                        action_dict = action\n                    else:\n                        continue\n                    \n                    action_type = action_dict.get('action', {})\n                    \n                    if isinstance(action_type, dict):\n                        if 'click_element' in action_type:\n                            element = action_type['click_element'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found click_element action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n                        \n                        if 'input_text' in action_type:\n                            element = action_type['input_text'].get('element', {})\n                            if self.verbose:\n                                print(f\"   ‚úì Found input_text action with element: {element}\")\n                            locator = await self._build_locator_from_element(page, element)\n                            if locator:\n                                return locator\n            else:\n                if self.verbose:\n                    print(f\"   ‚ö†Ô∏è  History has no model_actions attribute\")\n            \n            if hasattr(history, 'history') and history.history:\n                if self.verbose:\n                    print(f\"   üîç Checking history.history list with {len(history.history)} items\")\n                for item in reversed(history.history):\n                    if hasattr(item, 'result') and hasattr(item.result, 'extracted_content'):\n                        if self.verbose:\n                            print(f\"   ‚úì Found extracted content in history item\")\n                        element_data = item.result.extracted_content\n                        if isinstance(element_data, dict) and 'attributes' in element_data:\n                            locator = await self._build_locator_from_element(page, element_data)\n                            if locator:\n                                return locator\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå Error extracting from agent history: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n        \n        if self.verbose:\n            print(f\"   ‚ö†Ô∏è  Could not extract locator from agent history - falling back to heuristics\")\n        return None\n    \n    async def _build_locator_from_element(self, page: Page, element: Dict) -> Optional[str]:\n        \"\"\"Build a Playwright locator string from element attributes found by browser-use\"\"\"\n        if not element:\n            return None\n        \n        text = element.get('text', '').strip()\n        role = element.get('role', '').strip()\n        attributes = element.get('attributes', {}) or {}\n        \n        strategies_to_try = []\n        \n        if attributes.get('data-testid'):\n            strategies_to_try.append(f'page.get_by_test_id(\"{attributes[\"data-testid\"]}\")')\n        \n        if attributes.get('id'):\n            strategies_to_try.append(f'page.locator(\"#{attributes[\"id\"]}\")')\n        \n        if attributes.get('aria-label'):\n            strategies_to_try.append(f'page.get_by_label(\"{attributes[\"aria-label\"]}\")')\n        \n        if role and text:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\", name=\"{text}\")')\n        elif role:\n            strategies_to_try.append(f'page.get_by_role(\"{role}\")')\n        \n        if text:\n            strategies_to_try.append(f'page.get_by_text(\"{text}\")')\n        \n        if attributes.get('placeholder'):\n            strategies_to_try.append(f'page.get_by_placeholder(\"{attributes[\"placeholder\"]}\")')\n        \n        for strategy in strategies_to_try:\n            try:\n                locator = eval(strategy)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    return strategy if count == 1 else f'{strategy}.first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def _extract_locator_from_healing(\n        self,\n        page: Page,\n        action_desc: str,\n        element_desc: str\n    ) -> Optional[str]:\n        \"\"\"\n        Try to intelligently find a working locator based on common patterns.\n        This uses smart heuristics to locate elements after AI exploration.\n        \"\"\"\n        desc_lower = (action_desc + \" \" + element_desc).lower()\n        \n        common_selectors = []\n        \n        if \"login\" in desc_lower or \"sign in\" in desc_lower:\n            common_selectors.extend([\n                'button:has-text(\"Login\")',\n                'button:has-text(\"Sign in\")',\n                '[type=\"submit\"]',\n                'button[type=\"submit\"]',\n            ])\n        \n        if \"search\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"search\"]',\n                'input[name=\"q\"]',\n                'input[placeholder*=\"search\" i]',\n                '[aria-label*=\"search\" i]',\n            ])\n        \n        if \"submit\" in desc_lower or \"button\" in desc_lower:\n            common_selectors.extend([\n                'button[type=\"submit\"]',\n                'input[type=\"submit\"]',\n                'button',\n            ])\n        \n        if \"email\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"email\"]',\n                'input[name=\"email\"]',\n                'input[autocomplete=\"email\"]',\n            ])\n        \n        if \"password\" in desc_lower:\n            common_selectors.extend([\n                'input[type=\"password\"]',\n                'input[name=\"password\"]',\n                'input[autocomplete=\"current-password\"]',\n            ])\n        \n        for selector in common_selectors:\n            try:\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    await locator.first.wait_for(timeout=2000, state=\"visible\")\n                    if self.verbose:\n                        print(f\"   üîç Found working selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        text_elements = []\n        if \"click\" in desc_lower:\n            words = element_desc.split()\n            for word in words:\n                if len(word) > 3:\n                    text_elements.append(word)\n        \n        for text in text_elements[:3]:\n            try:\n                selector = f'text={text}'\n                locator = page.locator(selector)\n                count = await locator.count()\n                if count > 0:\n                    if self.verbose:\n                        print(f\"   üîç Found working text selector: {selector}\")\n                    return f'page.locator(\"{selector}\").first'\n            except Exception:\n                continue\n        \n        return None\n    \n    async def execute_action_with_ai(\n        self,\n        page: Page,\n        action_description: str,\n        element_description: str = \"\"\n    ) -> bool:\n        \"\"\"\n        When both original and healed locators fail, use browser-use AI \n        to execute the specific action, then gracefully exit.\n        \n        Args:\n            page: The Playwright page object\n            action_description: Description of the action to perform\n            element_description: Additional context about the element\n        \n        Returns:\n            True if action was executed successfully, False otherwise\n        \"\"\"\n        if self.verbose:\n            print(f\"\\nü§ñ Healed locator failed - browser-use AI stepping in to execute action...\")\n            print(f\"   Action: {action_description}\")\n        \n        try:\n            llm = self._initialize_llm()\n            current_url = page.url\n            \n            task = f\"\"\"On this page ({current_url}), perform this action: {action_description}.\n            \nElement description: {element_description}\n\nIMPORTANT:\n1. Complete ONLY this specific action\n2. Confirm the action was successful\n3. Do NOT perform any additional actions\n4. Report back whether the action succeeded or failed\n\nYour task is to execute this single action and nothing more.\"\"\"\n            \n            if self.verbose:\n                print(f\"   ü§ñ AI executing action in current browser session...\")\n            \n            cdp_url = await self._get_cdp_url(page)\n            \n            if not cdp_url:\n                if self.verbose:\n                    print(f\"   ‚ùå Could not connect to browser session for AI execution\")\n                return False\n            \n            browser_wrapper = BrowserUseWrapper(\n                browser_session={'cdp_url': cdp_url}\n            )\n            \n            agent = Agent(\n                task=task,\n                llm=llm,\n                browser=browser_wrapper,\n            )\n            \n            result = await agent.run()\n            \n            # STRICT verification: require proof of actual DOM interaction AND explicit success status\n            action_completed = False\n            \n            # Step 1: STRICT result verification - require explicit success confirmation\n            if not result:\n                if self.verbose:\n                    print(f\"   ‚ùå No result returned from Agent.run() - cannot confirm success\")\n                return False\n            \n            if self.verbose:\n                print(f\"   üìä Analyzing Agent.run() result...\")\n            \n            # Check for explicit errors - immediate failure\n            if hasattr(result, 'error') and result.error:\n                if self.verbose:\n                    print(f\"   ‚ùå Result contains error: {result.error}\")\n                return False\n            \n            if hasattr(result, 'errors') and result.errors:\n                if self.verbose:\n                    print(f\"   ‚ùå Result contains errors: {result.errors}\")\n                return False\n            \n            # Require explicit completion status - fail if missing or not done\n            has_done_status = False\n            if hasattr(result, 'is_done') and callable(result.is_done):\n                try:\n                    is_done = result.is_done()\n                    has_done_status = True\n                    if self.verbose:\n                        print(f\"   üìä Result.is_done(): {is_done}\")\n                    if not is_done:\n                        if self.verbose:\n                            print(f\"   ‚ùå Result.is_done() returned False - task not completed\")\n                        return False\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ùå Error checking result.is_done(): {str(e)}\")\n                        print(f\"   ‚ùå Cannot verify completion - failing conservatively\")\n                    return False\n            \n            # Check status field if present\n            if hasattr(result, 'status'):\n                status_str = str(result.status).lower()\n                if self.verbose:\n                    print(f\"   üìä Result status: {result.status}\")\n                if 'fail' in status_str or 'error' in status_str:\n                    if self.verbose:\n                        print(f\"   ‚ùå Result status indicates failure\")\n                    return False\n                # Require positive status indication\n                if 'done' in status_str or 'success' in status_str or 'complete' in status_str:\n                    has_done_status = True\n            \n            # Step 2: Verify actual DOM interaction occurred\n            action_completed = False\n            \n            # Parse the action_description to know what type of interaction we expect\n            action_lower = action_description.lower()\n            expected_action_type = None\n            if 'click' in action_lower:\n                expected_action_type = 'click_element'\n            elif 'fill' in action_lower or 'type' in action_lower or 'enter' in action_lower:\n                expected_action_type = 'input_text'\n            elif 'navigate' in action_lower or 'goto' in action_lower or 'go to' in action_lower:\n                expected_action_type = 'go_to_url'\n            \n            if self.verbose:\n                print(f\"   üìä Expected action type: {expected_action_type or 'any DOM interaction'}\")\n            \n            # Check history for actual DOM interactions\n            history = agent.history if hasattr(agent, 'history') else None\n            confirmed_interactions = []\n            \n            if history and hasattr(history, 'model_actions'):\n                try:\n                    actions = history.model_actions()\n                    if self.verbose:\n                        print(f\"   üìã Checking {len(actions) if actions else 0} model action(s) for DOM interactions...\")\n                    \n                    if actions:\n                        for i, action in enumerate(actions):\n                            if hasattr(action, '__dict__'):\n                                action_dict = action.__dict__\n                            elif isinstance(action, dict):\n                                action_dict = action\n                            else:\n                                continue\n                            \n                            action_data = action_dict.get('action', {})\n                            if isinstance(action_data, dict):\n                                # Check for actual DOM interactions\n                                if 'click_element' in action_data:\n                                    confirmed_interactions.append('click_element')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found click_element interaction at action {i}\")\n                                elif 'input_text' in action_data:\n                                    confirmed_interactions.append('input_text')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found input_text interaction at action {i}\")\n                                elif 'go_to_url' in action_data:\n                                    confirmed_interactions.append('go_to_url')\n                                    if self.verbose:\n                                        print(f\"   ‚úì Found go_to_url interaction at action {i}\")\n                \n                except Exception as e:\n                    if self.verbose:\n                        print(f\"   ‚ö†Ô∏è  Error checking model_actions: {str(e)}\")\n            \n            # Step 3: Decide success - require BOTH DOM interaction AND no failures\n            # First check: did we get the right type of interaction?\n            interaction_confirmed = False\n            if confirmed_interactions:\n                # If we expected a specific action type, verify we got it\n                if expected_action_type:\n                    if expected_action_type in confirmed_interactions:\n                        interaction_confirmed = True\n                        if self.verbose:\n                            print(f\"   ‚úì Found expected '{expected_action_type}' interaction\")\n                    else:\n                        if self.verbose:\n                            print(f\"   ‚ùå AI performed {confirmed_interactions} but not expected '{expected_action_type}'\")\n                        return False\n                else:\n                    # No specific expectation, any DOM interaction counts\n                    interaction_confirmed = True\n                    if self.verbose:\n                        print(f\"   ‚úì Found DOM interactions: {confirmed_interactions}\")\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå No DOM interactions found in agent history\")\n                return False\n            \n            # Second check: verify agent history confirms completion\n            history_confirmed = False\n            if history:\n                # Be conservative: require completion status if available\n                if hasattr(history, 'is_done') and callable(history.is_done):\n                    try:\n                        history_done = history.is_done()\n                        if self.verbose:\n                            print(f\"   üìä History.is_done(): {history_done}\")\n                        if not history_done:\n                            if self.verbose:\n                                print(f\"   ‚ùå History indicates task not completed\")\n                            return False\n                        history_confirmed = True\n                    except Exception as e:\n                        if self.verbose:\n                            print(f\"   ‚ùå Error verifying history completion: {str(e)}\")\n                            print(f\"   ‚ùå Cannot confirm - failing conservatively\")\n                        return False\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå No history available - cannot confirm action completion\")\n                return False\n            \n            # Final: require ALL confirmation layers\n            if not has_done_status and not history_confirmed:\n                if self.verbose:\n                    print(f\"   ‚ùå No explicit done/success status found in result or history\")\n                    print(f\"   ‚ùå Cannot confirm action completed - failing conservatively\")\n                return False\n            \n            # All checks passed: we have DOM interaction AND explicit success confirmation\n            action_completed = interaction_confirmed and (has_done_status or history_confirmed)\n            \n            if action_completed:\n                if self.verbose:\n                    print(f\"   ‚úÖ AI successfully executed the action!\")\n                    print(f\"   üîÑ Continuing with automation script...\")\n                return True\n            else:\n                if self.verbose:\n                    print(f\"   ‚ùå AI did not complete the action\")\n                return False\n            \n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ùå AI execution failed: {str(e)}\")\n                import traceback\n                traceback.print_exc()\n            return False\n    \n    async def safe_locator(\n        self,\n        page: Page,\n        locator_str: str,\n        action_description: str = \"\",\n        element_description: str = \"\",\n        timeout: int = 10000\n    ):\n        \"\"\"\n        Get a locator with automatic self-healing if it fails.\n        \n        Args:\n            page: Playwright page object\n            locator_str: Locator string (e.g., 'page.get_by_text(\"Login\")')\n            action_description: Description of the action being performed\n            element_description: Description of the element\n            timeout: Timeout in milliseconds\n        \n        Returns:\n            Working Locator object, AIExecutedMarker if AI executed the action, or None if all attempts fail\n        \"\"\"\n        if locator_str in self.healed_locators:\n            locator_str = self.healed_locators[locator_str]\n            if self.verbose:\n                print(f\"   üìù Using previously healed locator: {locator_str}\")\n        \n        try:\n            locator = eval(locator_str)\n            await locator.wait_for(timeout=timeout)\n            return locator\n        except Exception as e:\n            if self.verbose:\n                print(f\"   ‚ö†Ô∏è  Locator failed: {locator_str}\")\n                print(f\"      Error: {str(e)[:100]}\")\n            \n            healed_locator_str = await self.heal_locator(\n                page=page,\n                failed_locator=locator_str,\n                action_description=action_description,\n                element_description=element_description\n            )\n            \n            if healed_locator_str:\n                try:\n                    healed_locator = eval(healed_locator_str)\n                    await healed_locator.wait_for(timeout=timeout)\n                    return healed_locator\n                except Exception as heal_error:\n                    if self.verbose:\n                        print(f\"   ‚ùå Healed locator also failed: {str(heal_error)[:100]}\")\n                    \n                    if action_description:\n                        ai_executed = await self.execute_action_with_ai(\n                            page=page,\n                            action_description=action_description,\n                            element_description=element_description\n                        )\n                        \n                        if ai_executed:\n                            return AIExecutedMarker(action_description)\n                        else:\n                            if self.verbose:\n                                print(f\"   ‚ùå All recovery attempts failed (locator healing + AI execution)\")\n            \n            if self.verbose:\n                print(f\"   ‚ùå Unable to locate element or execute action: {action_description or locator_str}\")\n            return None\n    \n    async def execute_with_healing(\n        self,\n        automation_func: Callable,\n        *args,\n        **kwargs\n    ) -> Any:\n        \"\"\"\n        Execute an automation function with self-healing support.\n        \n        Args:\n            automation_func: Async function to execute\n            *args, **kwargs: Arguments to pass to the function\n        \n        Returns:\n            Result of the automation function\n        \"\"\"\n        self.healing_attempts = 0\n        self.healed_locators.clear()\n        \n        if self.verbose:\n            print(\"\\nüöÄ Starting execution with self-healing enabled\")\n            print(f\"   Max healing attempts per locator: {self.max_healing_attempts}\")\n        \n        try:\n            result = await automation_func(*args, **kwargs)\n            \n            if self.verbose:\n                print(\"\\n‚úÖ Execution completed successfully!\")\n                if self.healed_locators:\n                    print(f\"   Healed {len(self.healed_locators)} locator(s) during execution\")\n            \n            return result\n        except Exception as e:\n            if self.verbose:\n                print(f\"\\n‚ùå Execution failed: {str(e)}\")\n            raise\n\n\nclass HealingContext:\n    \"\"\"Context manager for self-healing Playwright automation\"\"\"\n    \n    def __init__(\n        self,\n        api_key: str,\n        model: str = \"gpt-4o-mini\",\n        verbose: bool = False\n    ):\n        self.executor = SelfHealingExecutor(\n            api_key=api_key,\n            model=model,\n            verbose=verbose\n        )\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright = None\n    \n    async def __aenter__(self):\n        \"\"\"Set up Playwright browser with healing support\"\"\"\n        self.playwright = await async_playwright().start()\n        self.browser = await self.playwright.chromium.launch(headless=False)\n        context = await self.browser.new_context()\n        self.page = await context.new_page()\n        \n        setattr(self.page, 'healing_locator', self._create_healing_locator_method())\n        \n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Clean up browser\"\"\"\n        if self.browser:\n            await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n    \n    def _create_healing_locator_method(self):\n        \"\"\"Create a healing locator method bound to the page\"\"\"\n        async def healing_locator(\n            locator_str: str,\n            action_desc: str = \"\",\n            element_desc: str = \"\"\n        ) -> Optional[Locator]:\n            return await self.executor.safe_locator(\n                page=self.page,\n                locator_str=locator_str,\n                action_description=action_desc,\n                element_description=element_desc\n            )\n        \n        return healing_locator\n","size_bytes":33231},"src/web/services/automation_engine_interface.py":{"content":"\"\"\"\nShared interface for automation engines\n\"\"\"\nfrom typing import Protocol, Dict, Any, List\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass ExecutionResult:\n    \"\"\"Result from an automation execution\"\"\"\n    success: bool\n    message: str\n    steps: List[Dict[str, Any]]\n    error: str = \"\"\n    engine_used: str = \"\"\n    fallback_occurred: bool = False\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON response\"\"\"\n        return {\n            'success': self.success,\n            'message': self.message,\n            'steps': self.steps,\n            'error': self.error,\n            'engine_used': self.engine_used,\n            'fallback_occurred': self.fallback_occurred\n        }\n\n\nclass AutomationEngine(Protocol):\n    \"\"\"Protocol/Interface for automation engines\"\"\"\n    \n    def execute_instruction(\n        self, \n        instruction: str, \n        headless: bool = True\n    ) -> ExecutionResult:\n        \"\"\"\n        Execute a browser automation instruction\n        \n        Args:\n            instruction: Natural language instruction to execute\n            headless: Whether to run browser in headless mode\n            \n        Returns:\n            ExecutionResult with success status, steps, and metadata\n        \"\"\"\n        ...\n    \n    def reset_conversation(self) -> None:\n        \"\"\"Reset the conversation/session state\"\"\"\n        ...\n    \n    @property\n    def name(self) -> str:\n        \"\"\"Return the engine name\"\"\"\n        ...\n","size_bytes":1485},"src/web/services/playwright_mcp/engine.py":{"content":"\"\"\"\nPlaywright MCP automation engine adapter\n\"\"\"\nfrom typing import Dict, Any\nfrom .client import MCPStdioClient\nfrom ..automation_engine_interface import AutomationEngine, ExecutionResult\nfrom .browser_agent import BrowserAgent\n\n\nclass MCPAutomationEngine:\n    \"\"\"Adapter for Playwright MCP automation engine\"\"\"\n    \n    def __init__(self):\n        self.mcp_client = None\n        self._browser_agent = None\n        \n    @property\n    def name(self) -> str:\n        return \"playwright-mcp\"\n    \n    def _ensure_initialized(self):\n        \"\"\"Ensure MCP client and browser agent are initialized\"\"\"\n        if self.mcp_client is None:\n            self.mcp_client = MCPStdioClient()\n            if not self.mcp_client.initialized:\n                self.mcp_client.initialize()\n        \n        if self._browser_agent is None:\n            self._browser_agent = BrowserAgent(self.mcp_client)\n    \n    def execute_instruction(\n        self, \n        instruction: str, \n        headless: bool = True\n    ) -> ExecutionResult:\n        \"\"\"Execute instruction using Playwright MCP\"\"\"\n        try:\n            self._ensure_initialized()\n            \n            # Execute the instruction via BrowserAgent\n            result = self._browser_agent.execute_instruction(instruction)\n            \n            # Transform BrowserAgent result to ExecutionResult format\n            if result.get('success', False):\n                return ExecutionResult(\n                    success=True,\n                    message=result.get('message', 'Task completed successfully'),\n                    steps=self._format_steps(result.get('steps', [])),\n                    engine_used=self.name,\n                    fallback_occurred=False\n                )\n            else:\n                error_msg = result.get('error', 'Unknown error')\n                return ExecutionResult(\n                    success=False,\n                    message=f\"Playwright MCP execution failed: {error_msg}\",\n                    steps=self._format_steps(result.get('steps', [])),\n                    error=error_msg,\n                    engine_used=self.name,\n                    fallback_occurred=False\n                )\n                \n        except Exception as e:\n            error_msg = str(e)\n            return ExecutionResult(\n                success=False,\n                message=f\"Playwright MCP execution failed: {error_msg}\",\n                steps=[],\n                error=error_msg,\n                engine_used=self.name,\n                fallback_occurred=False\n            )\n    \n    def _format_steps(self, steps: list) -> list:\n        \"\"\"Format BrowserAgent steps to match expected format\"\"\"\n        formatted_steps = []\n        for i, step in enumerate(steps, 1):\n            formatted_step = {\n                'step_number': i,\n                'success': step.get('success', True),\n                'tool': step.get('tool', ''),\n                'arguments': step.get('arguments', {}),\n                'result': step.get('result', {})\n            }\n            \n            if 'error' in step:\n                formatted_step['error'] = step['error']\n            \n            formatted_steps.append(formatted_step)\n        \n        return formatted_steps\n    \n    def reset_conversation(self) -> None:\n        \"\"\"Reset conversation state\"\"\"\n        if self._browser_agent:\n            self._browser_agent.reset_conversation()\n        \n        if self.mcp_client:\n            try:\n                self.mcp_client.call_tool('browser_close', {})\n            except:\n                pass\n","size_bytes":3556},"src/web/services/playwright_mcp/__init__.py":{"content":"\"\"\"\nPlaywright MCP Engine Module\nModel Context Protocol-based browser automation using Playwright\n\"\"\"\nfrom .engine import MCPAutomationEngine\nfrom .client import MCPStdioClient\nfrom .browser_agent import BrowserAgent\n\n__all__ = ['MCPAutomationEngine', 'MCPStdioClient', 'BrowserAgent']\n","size_bytes":286},"src/web/services/browser_use/engine.py":{"content":"\"\"\"\nBrowserUse automation engine adapter\n\"\"\"\nimport os\nimport asyncio\nfrom typing import Dict, Any\nfrom browser_use import Agent, Browser, BrowserProfile\nfrom langchain_openai import ChatOpenAI\nfrom ..automation_engine_interface import AutomationEngine, ExecutionResult\n\n\nclass BrowserUseAutomationEngine:\n    \"\"\"Adapter for browser-use automation engine\"\"\"\n    \n    def __init__(self):\n        self._api_key = os.getenv('OPENAI_API_KEY')\n        \n    @property\n    def name(self) -> str:\n        return \"browser-use\"\n    \n    def execute_instruction(\n        self, \n        instruction: str, \n        headless: bool = True\n    ) -> ExecutionResult:\n        \"\"\"Execute instruction using browser-use\"\"\"\n        try:\n            llm = ChatOpenAI(\n                model=\"gpt-4o-mini\",\n                api_key=self._api_key\n            )\n            \n            profile = BrowserProfile(headless=headless)\n            browser = Browser(browser_profile=profile)\n            \n            task_instruction = (\n                f\"{instruction}\\n\\n\"\n                \"IMPORTANT INSTRUCTIONS:\\n\"\n                \"1. You may do necessary auxiliary actions (wait for page loads, dismiss popups, etc.) to complete those steps.\\n\"\n                \"2. After completing the user's specified steps, STOP IMMEDIATELY.\\n\"\n                \"3. Do NOT continue to what seems like the 'next logical step' or try to complete an entire workflow.\\n\"\n                \"4. When you finish the last step specified by the user, call 'done' immediately.\"\n            )\n            \n            agent = Agent(\n                task=task_instruction,\n                llm=llm,\n                browser=browser\n            )\n            \n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                history = loop.run_until_complete(agent.run())\n                \n                steps = self._extract_steps_from_history(history)\n                result_message = self._extract_result(history) or 'Task completed successfully'\n                \n                return ExecutionResult(\n                    success=True,\n                    message=result_message,\n                    steps=steps,\n                    engine_used=self.name,\n                    fallback_occurred=False\n                )\n            finally:\n                loop.close()\n                \n        except Exception as e:\n            error_msg = str(e)\n            return ExecutionResult(\n                success=False,\n                message=f\"Browser-use execution failed: {error_msg}\",\n                steps=[],\n                error=error_msg,\n                engine_used=self.name,\n                fallback_occurred=False\n            )\n    \n    def _extract_result(self, history) -> str:\n        \"\"\"Extract final result from history\"\"\"\n        if not history:\n            return None\n        \n        if hasattr(history, 'final_result') and history.final_result():\n            return str(history.final_result())\n        \n        if hasattr(history, 'history') and history.history:\n            last_item = history.history[-1]\n            if hasattr(last_item, 'result') and hasattr(last_item.result, 'extracted_content'):\n                return last_item.result.extracted_content\n        \n        return None\n    \n    def _extract_steps_from_history(self, history) -> list:\n        \"\"\"Extract execution steps from browser-use history\"\"\"\n        steps = []\n        \n        if not history:\n            return steps\n        \n        if hasattr(history, 'history'):\n            for i, item in enumerate(history.history, 1):\n                step = {\n                    'step_number': i,\n                    'success': True,\n                    'tool': 'browser-use action',\n                    'arguments': {},\n                    'result': {}\n                }\n                \n                if hasattr(item, 'model_output') and item.model_output:\n                    step['result']['thought'] = str(item.model_output.current_state.thought) if hasattr(item.model_output.current_state, 'thought') else ''\n                    \n                    if hasattr(item.model_output, 'action'):\n                        action = item.model_output.action\n                        if hasattr(action, '__class__'):\n                            step['tool'] = action.__class__.__name__\n                        if hasattr(action, '__dict__'):\n                            step['arguments'] = {k: str(v) for k, v in action.__dict__.items() if not k.startswith('_')}\n                \n                if hasattr(item, 'result'):\n                    if hasattr(item.result, 'extracted_content'):\n                        step['result']['content'] = item.result.extracted_content\n                    elif hasattr(item.result, '__dict__'):\n                        step['result'].update({k: str(v) for k, v in item.result.__dict__.items() if not k.startswith('_')})\n                \n                steps.append(step)\n        \n        return steps\n    \n    def reset_conversation(self) -> None:\n        \"\"\"Reset conversation state\"\"\"\n        pass\n","size_bytes":5131},"src/web/services/browser_use/__init__.py":{"content":"\"\"\"\nbrowser-use Engine Module\nAI-powered browser automation using the browser-use library\n\"\"\"\nfrom .engine import BrowserUseAutomationEngine\n\n__all__ = ['BrowserUseAutomationEngine']\n","size_bytes":183},"src/web/services/playwright_mcp/browser_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\n\"\"\"\nimport json\nimport os\nimport configparser\nfrom typing import List, Dict, Any\nfrom openai import OpenAI\n\n\nclass BrowserAgent:\n    \"\"\"AI agent that performs browser automation based on natural language instructions\"\"\"\n    \n    def __init__(self, mcp_client: Any):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        # Get API key from config.ini first, fallback to environment variable\n        api_key = config.get('openai', 'api_key', fallback=None)\n        if not api_key or api_key == 'YOUR_OPENAI_API_KEY_HERE':\n            api_key = os.environ.get('OPENAI_API_KEY')\n        \n        if not api_key:\n            raise ValueError(\"OpenAI API key must be set in config.ini [openai] api_key field or as OPENAI_API_KEY environment variable. IMPORTANT: For security, prefer using environment variables instead of storing keys in config.ini.\")\n        \n        self.client = OpenAI(api_key=api_key)\n        self.model = config.get('openai', 'model', fallback='gpt-4o-mini')\n        self.conversation_history = []\n        self.max_iterations = 10\n        \n    def execute_instruction(self, instruction: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Initialize MCP connection and get available tools\n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        # Start conversation\n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant. \nYou help users automate web browsing tasks using natural language instructions.\n\nWhen given an instruction:\n1. Break it down into browser automation steps\n2. Use the available browser tools to accomplish the task\n3. Navigate to websites, click elements, fill forms, and extract information as needed\n4. Always check the page state after navigation to understand what's available\n5. Use element references (ref) from the page snapshot when clicking or filling forms\n6. Be precise and follow the user's intent carefully\n\nImportant: When you see page snapshots in YAML format, look for element references like [ref=e1], [ref=e2], etc. \nUse these references when calling browser_click or browser_fill tools.\n\nRespond with tool calls to accomplish the task.\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                # Call OpenAI with function calling\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,  # type: ignore\n                    tools=tools,  # type: ignore\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                # Check if assistant wants to call tools\n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name  # type: ignore\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                        \n                        # Execute the tool\n                        try:\n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            # Extract useful information from result\n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            # Add tool result to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": json.dumps(result, indent=2)\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            # Add error to conversation\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    # Assistant has finished\n                    final_response = message.content or \"Task completed\"\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration\n                    }\n                    \n            except Exception as e:\n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration\n        }\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n","size_bytes":6718},"src/web/services/playwright_mcp/client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = None, browser: str = None, capabilities: str = None):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (overrides config.ini if provided)\n            browser: Browser to use (overrides config.ini if provided)\n            capabilities: Comma-separated capabilities to enable (e.g., \"vision,testing,tracing\")\n        \"\"\"\n        # Load configuration from .ini file\n        config = configparser.ConfigParser()\n        config.read('config.ini')\n        \n        # Use provided values or fall back to config.ini\n        if headless is None:\n            headless = config.getboolean('browser', 'headless')\n        if browser is None:\n            browser = config.get('browser', 'browser')\n        if capabilities is None:\n            # Default capabilities for better locator extraction\n            capabilities = config.get('browser', 'capabilities', fallback='testing')\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        # Start MCP server process\n        args = [\"node\", \"mcp/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        # Add capabilities if specified\n        if capabilities:\n            args.append(f\"--caps={capabilities}\")\n        \n        # Set environment variable to skip Playwright host validation\n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        # Start reader threads\n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        # Start stderr reader to prevent deadlock\n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        # Give the process a moment to start\n        time.sleep(0.5)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            # This is a response to a request\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            # This is a notification\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        # Not JSON, might be log output - ignore\n                        pass\n                except UnicodeDecodeError:\n                    # Skip lines with encoding issues\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                    # Optionally log stderr for debugging\n                    # print(f\"MCP stderr: {line.strip()}\")\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        # Create queue for this request\n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            # Send request\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            # Wait for response\n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            # Clean up\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=45)  # Timeout for tool calls\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":9488}},"version":2}