{"file_contents":{"scripts/port_terminator.py":{"content":"import psutil\nfrom typing import List\n\ndef terminate_ports(ports: List[int]):\n    \"\"\"\n    Terminates all processes using the specified ports.\n    Args:\n        ports (List[int]): List of port numbers to terminate connections for.\n    \"\"\"\n    for port in ports:\n        found = False\n        for conn in psutil.net_connections(kind='inet'):\n            if conn.laddr.port == port:\n                found = True\n                pid = conn.pid\n                if pid:\n                    try:\n                        p = psutil.Process(pid)\n                        print(f\"Terminating process {pid} on port {port}...\")\n                        p.terminate()\n                        p.wait(timeout=3)\n                        print(f\"Process {pid} terminated.\")\n                    except Exception as e:\n                        print(f\"Error terminating process {pid} on port {port}: {e}\")\n                else:\n                    print(f\"No PID found for connection on port {port}.\")\n        if not found:\n            print(f\"No process found using port {port}.\")\n\nif __name__ == \"__main__\":\n    # Example usage: terminate ports 8080 and 5000\n    terminate_ports([7890, 5000])\n\n","size_bytes":1174},"visionvault/agents/socket_client.py":{"content":"import socketio\nimport asyncio\nfrom .config import AGENT_ID, SERVER_URL\nfrom .utils import detect_browsers\n\n\nclass SocketClient:\n    def __init__(self):\n        self.sio = socketio.Client(\n            reconnection=True,\n            reconnection_attempts=100,\n            reconnection_delay=1,\n            reconnection_delay_max=10,\n            request_timeout=30,\n            logger=False,\n            engineio_logger=False\n        )\n        self.setup_events()\n        self.event_loop = None\n\n    def setup_events(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.sio.event\n        def connect():\n            print(f\"✅ Connected to server: {SERVER_URL}\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n            print(f\"📤 Sent registration with browsers: {available_browsers}\")\n\n        @self.sio.event\n        def disconnect():\n            print(\"⚠️ Disconnected from server - will auto-reconnect...\")\n\n        @self.sio.event\n        def connect_error(data):\n            print(f\"❌ Connection error: {data}\")\n            print(\"   Retrying connection...\")\n\n        @self.sio.event\n        def reconnect():\n            print(\"🔄 Reconnected to server - re-registering...\")\n            available_browsers = detect_browsers()\n            self.sio.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': available_browsers\n            })\n\n        @self.sio.event\n        def agent_registered(data):\n            print(f\"Agent registered successfully: {data}\")\n\n    def connect(self):\n        \"\"\"Connect to the server\"\"\"\n        self.sio.connect(SERVER_URL,\n                         transports=['websocket', 'polling'],\n                         wait_timeout=10)\n\n    def disconnect(self):\n        \"\"\"Disconnect from server\"\"\"\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def emit(self, event, data):\n        \"\"\"Emit an event to server\"\"\"\n        self.sio.emit(event, data)\n\n    def on(self, event, handler):\n        \"\"\"Register event handler\"\"\"\n        self.sio.on(event, handler)\n\n    @property\n    def connected(self):\n        return self.sio.connected","size_bytes":2296},"visionvault/agents/config.py":{"content":"import os\nimport uuid\nimport socket\n\n\ndef get_server_url():\n    \"\"\"Auto-detect server URL based on environment\"\"\"\n    # Priority 1: User-specified environment variable\n    if os.environ.get('AGENT_SERVER_URL'):\n        return os.environ.get('AGENT_SERVER_URL')\n\n    # Priority 2: Check if running in same environment as server\n    # Look for common local development ports\n    local_ports = [7890, 5000, 8000, 3000]\n\n    for port in local_ports:\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(0.5)\n            result = sock.connect_ex(('127.0.0.1', port))\n            sock.close()\n            if result == 0:  # Port is open\n                print(f\"✓ Detected local server on port {port}\")\n                return f'http://127.0.0.1:{port}'\n        except:\n            pass\n\n    # Priority 3: Default to standard port 5000\n    print(\"ℹ No server detected. Using default: http://127.0.0.1:5000\")\n    print(\"  Set AGENT_SERVER_URL environment variable to override\")\n    return 'http://127.0.0.1:5000'\n\n\n# Global configuration\nSERVER_URL = get_server_url()\nAGENT_ID = str(uuid.uuid4())","size_bytes":1148},"visionvault/services/action_recorder.py":{"content":"import asyncio\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\nfrom playwright.async_api import Page, Browser, async_playwright\nimport uuid\n\n\nclass ActionRecorder:\n    \"\"\"Records browser actions for teaching mode.\"\"\"\n    \n    def __init__(self):\n        self.actions: List[Dict] = []\n        self.is_recording = False\n        self.page: Optional[Page] = None\n        self.browser: Optional[Browser] = None\n        self.playwright_instance = None\n    \n    async def start_recording(self, browser_name='chromium', headless=False):\n        \"\"\"Start recording browser actions.\"\"\"\n        self.actions = []\n        self.is_recording = True\n        self.playwright_instance = await async_playwright().start()\n        browser_type = getattr(self.playwright_instance, browser_name)\n        self.browser = await browser_type.launch(headless=headless)\n        self.page = await self.browser.new_page()\n\n        # Use add_init_script for persistent listeners\n        await self.page.add_init_script(self._get_event_listener_js())\n        await self.page.expose_function('recordUserAction', self._handle_user_action)\n        self.page.on('framenavigated', lambda frame: asyncio.create_task(self._on_navigation(frame)))\n        self.page.on('close', lambda: self._on_page_close())\n        return self.page\n\n    def _get_event_listener_js(self):\n        # JS to listen for click, input, change, keyboard events and call recordUserAction\n        return '''\n        (function() {\n            // Use WeakMap to track debounce timers by element identity, not selector\n            const inputTimers = new WeakMap();\n            const DEBOUNCE_DELAY = 500; // Wait 500ms after last keystroke\n            \n            function getSelector(el) {\n                let selector = el.tagName.toLowerCase();\n                if (el.id) {\n                    selector += '#' + el.id;\n                } else if (el.className && typeof el.className === 'string') {\n                    const classes = el.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            function sendAction(type, selector, value, text, key) {\n                if (window.recordUserAction) {\n                    const action = {type, selector, value, text, timestamp: new Date().toISOString()};\n                    if (key) action.key = key;\n                    window.recordUserAction(action);\n                }\n            }\n            \n            // Record clicks\n            document.addEventListener('click', function(e) {\n                const selector = getSelector(e.target);\n                const text = e.target.innerText ? e.target.innerText.substring(0, 50) : null;\n                sendAction('click', selector, null, text);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                // Clear existing timer for THIS SPECIFIC element\n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                // Set new timer - will only fire if user stops typing for DEBOUNCE_DELAY ms\n                const timer = setTimeout(() => {\n                    sendAction('fill', selector, el.value, null);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record change events (for selects, checkboxes, radios)\n            document.addEventListener('change', function(e) {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (el.type === 'checkbox' || el.type === 'radio') {\n                    sendAction('check', selector, el.checked, null);\n                } else if (el.tagName.toLowerCase() === 'select') {\n                    sendAction('select', selector, el.value, null);\n                }\n            }, true);\n            \n            // Record keyboard events (Enter, Tab, Escape, etc.)\n            document.addEventListener('keydown', function(e) {\n                // Only record special keys, not regular characters (those are captured via input)\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter key and there's a pending input timer, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        sendAction('fill', selector, el.value, null);\n                        inputTimers.delete(el);\n                    }\n                    \n                    sendAction('press', selector, null, null, e.key);\n                }\n            }, true);\n            \n            // Record form submissions\n            document.addEventListener('submit', function(e) {\n                const selector = getSelector(e.target);\n                sendAction('submit', selector, null, null);\n            }, true);\n        })();\n        '''\n\n    async def _on_navigation(self, frame):\n        \"\"\"Record navigation events.\"\"\"\n        if frame == self.page.main_frame:\n            self.record_action({\n                'type': 'navigate',\n                'url': frame.url,\n                'timestamp': datetime.now().isoformat()\n            })\n            # Re-expose function after navigation\n            try:\n                await self.page.expose_function('recordUserAction', self._handle_user_action)\n            except Exception as e:\n                pass\n\n    def _on_page_close(self):\n        self.is_recording = False\n\n    async def _handle_user_action(self, action):\n        # Receives actions from JS and records them\n        self.record_action(action)\n\n    def record_action(self, action: Dict):\n        \"\"\"Record an action with deduplication.\"\"\"\n        if self.is_recording:\n            # Deduplicate consecutive identical actions\n            if self.actions and self._is_duplicate_action(self.actions[-1], action):\n                return  # Skip duplicate\n            self.actions.append(action)\n    \n    def _is_duplicate_action(self, action1: Dict, action2: Dict) -> bool:\n        \"\"\"Check if two actions are duplicates - only deduplicate identical fills and navigation.\"\"\"\n        action_type = action1.get('type')\n        \n        # Different types are never duplicates\n        if action_type != action2.get('type'):\n            return False\n        \n        # For fill actions: same selector AND same value = duplicate\n        if action_type == 'fill':\n            return (action1.get('selector') == action2.get('selector') and \n                    action1.get('value') == action2.get('value'))\n        \n        # For navigation: same URL = duplicate\n        if action_type in ('navigate', 'goto'):\n            return action1.get('url') == action2.get('url')\n        \n        # Allow all other actions (clicks, presses, etc.) - user may intentionally repeat them\n        return False\n    \n    def record_goto(self, url: str):\n        \"\"\"Record a goto action.\"\"\"\n        self.record_action({\n            'type': 'goto',\n            'url': url,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_click(self, selector: str, text: Optional[str] = None):\n        \"\"\"Record a click action.\"\"\"\n        self.record_action({\n            'type': 'click',\n            'selector': selector,\n            'text': text,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_fill(self, selector: str, value: str):\n        \"\"\"Record a fill/input action.\"\"\"\n        self.record_action({\n            'type': 'fill',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_select(self, selector: str, value: str):\n        \"\"\"Record a select action.\"\"\"\n        self.record_action({\n            'type': 'select',\n            'selector': selector,\n            'value': value,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_check(self, selector: str):\n        \"\"\"Record a checkbox/radio check action.\"\"\"\n        self.record_action({\n            'type': 'check',\n            'selector': selector,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def record_wait(self, wait_type: str, selector: Optional[str] = None, timeout: int = 5000):\n        \"\"\"Record a wait action.\"\"\"\n        action = {\n            'type': 'wait',\n            'wait_type': wait_type,  # 'navigation', 'selector', 'timeout'\n            'timeout': timeout,\n            'timestamp': datetime.now().isoformat()\n        }\n        if selector:\n            action['selector'] = selector\n        self.record_action(action)\n    \n    async def stop_recording(self):\n        \"\"\"Stop recording and return captured actions.\"\"\"\n        self.is_recording = False\n        \n        # Close browser\n        if self.browser:\n            await self.browser.close()\n        if self.playwright_instance:\n            await self.playwright_instance.stop()\n        \n        return self.actions\n    \n    def generate_playwright_code(self, actions: Optional[List[Dict]] = None) -> str:\n        \"\"\"Generate Playwright code from recorded actions.\"\"\"\n        if actions is None:\n            actions = self.actions\n        \n        if not actions:\n            return \"\"\n        \n        # Start building the code\n        code_lines = [\n            \"async def run_test(browser_name='chromium', headless=True):\",\n            \"    from playwright.async_api import async_playwright\",\n            \"    logs = []\",\n            \"    screenshot = None\",\n            \"    \",\n            \"    try:\",\n            \"        async with async_playwright() as p:\",\n            \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n            \"            page = await browser.new_page()\",\n            \"            \",\n        ]\n        \n        # Convert actions to code\n        for i, action in enumerate(actions):\n            action_type = action.get('type')\n            \n            if action_type == 'goto' or action_type == 'navigate':\n                url = action.get('url')\n                code_lines.append(f\"            await page.goto('{url}')\")\n                code_lines.append(f\"            logs.append('Navigated to {url}')\")\n            \n            elif action_type == 'click':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.click('{selector}')\")\n                code_lines.append(f\"            logs.append('Clicked {selector}')\")\n            \n            elif action_type == 'fill':\n                selector = action.get('selector')\n                value = action.get('value', '').replace(\"'\", \"\\\\'\")\n                code_lines.append(f\"            await page.fill('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Filled {selector}')\")\n            \n            elif action_type == 'select':\n                selector = action.get('selector')\n                value = action.get('value')\n                code_lines.append(f\"            await page.select_option('{selector}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option in {selector}')\")\n            \n            elif action_type == 'check':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.check('{selector}')\")\n                code_lines.append(f\"            logs.append('Checked {selector}')\")\n            \n            elif action_type == 'wait':\n                wait_type = action.get('wait_type')\n                if wait_type == 'navigation':\n                    code_lines.append(\"            await page.wait_for_load_state('networkidle')\")\n                    code_lines.append(\"            logs.append('Waited for navigation')\")\n                elif wait_type == 'selector':\n                    selector = action.get('selector')\n                    timeout = action.get('timeout', 5000)\n                    code_lines.append(f\"            await page.wait_for_selector('{selector}', timeout={timeout})\")\n                    code_lines.append(f\"            logs.append('Waited for {selector}')\")\n                elif wait_type == 'timeout':\n                    timeout = action.get('timeout', 1000)\n                    code_lines.append(f\"            await page.wait_for_timeout({timeout})\")\n                    code_lines.append(f\"            logs.append('Waited {timeout}ms')\")\n            \n            elif action_type == 'press':\n                selector = action.get('selector')\n                key = action.get('key', 'Enter')\n                code_lines.append(f\"            await page.press('{selector}', '{key}')\")\n                code_lines.append(f\"            logs.append('Pressed {key} on {selector}')\")\n            \n            elif action_type == 'submit':\n                selector = action.get('selector')\n                code_lines.append(f\"            await page.locator('{selector}').press('Enter')\")\n                code_lines.append(f\"            logs.append('Submitted form {selector}')\")\n        \n        # Add screenshot and closing code\n        code_lines.extend([\n            \"            \",\n            \"            # Take screenshot before closing\",\n            \"            screenshot = await page.screenshot()\",\n            \"            logs.append('Screenshot captured')\",\n            \"            \",\n            \"            await browser.close()\",\n            \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n            \"    \",\n            \"    except Exception as e:\",\n            \"        logs.append(f'Error: {str(e)}')\",\n            \"        if 'page' in locals():\",\n            \"            try:\",\n            \"                screenshot = await page.screenshot()\",\n            \"            except:\",\n            \"                pass\",\n            \"        if 'browser' in locals():\",\n            \"            try:\",\n            \"                await browser.close()\",\n            \"            except:\",\n            \"                pass\",\n            \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    @staticmethod\n    def parse_code_to_actions(playwright_code: str) -> List[Dict]:\n        \"\"\"\n        Parse Playwright code to extract actions (reverse operation).\n        This is a simple parser that looks for common patterns.\n        \"\"\"\n        actions = []\n        lines = playwright_code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            # Parse goto\n            if 'page.goto(' in line:\n                import re\n                match = re.search(r\"page\\.goto\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'goto',\n                        'url': match.group(1)\n                    })\n            \n            # Parse click\n            elif 'page.click(' in line:\n                import re\n                match = re.search(r\"page\\.click\\(['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'click',\n                        'selector': match.group(1)\n                    })\n            \n            # Parse fill\n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r\"page\\.fill\\(['\\\"](.+?)['\\\"],\\s*['\\\"](.+?)['\\\"]\\)\", line)\n                if match:\n                    actions.append({\n                        'type': 'fill',\n                        'selector': match.group(1),\n                        'value': match.group(2)\n                    })\n            \n            # Add more parsers as needed\n        \n        return actions\n\n\nclass InteractiveRecorder(ActionRecorder):\n    \"\"\"\n    Enhanced recorder that can intercept and record actual user interactions.\n    This would be used with a UI where users can click through a task.\n    \"\"\"\n    \n    async def start_interactive_recording(self, browser_name='chromium'):\n        \"\"\"Start interactive recording with visible browser.\"\"\"\n        page = await self.start_recording(browser_name, headless=False)\n        \n        # Inject improved JavaScript with debouncing and keyboard capture\n        await page.add_init_script(\"\"\"\n            window.__recordedActions = [];\n            const inputTimers = new WeakMap();  // Track by element identity, not selector\n            const DEBOUNCE_DELAY = 500;\n            \n            // Helper to generate CSS selector (must be defined first!)\n            function getSelector(element) {\n                let selector = element.tagName.toLowerCase();\n                if (element.id) {\n                    selector += '#' + element.id;\n                } else if (element.className && typeof element.className === 'string') {\n                    const classes = element.className.split(' ').filter(c => c.trim());\n                    if (classes.length > 0) {\n                        selector += '.' + classes.join('.');  // Include ALL classes for specificity\n                    }\n                }\n                return selector;\n            }\n            \n            // Record clicks\n            document.addEventListener('click', (e) => {\n                const selector = getSelector(e.target);\n                window.__recordedActions.push({\n                    type: 'click',\n                    selector: selector,\n                    text: e.target.textContent ? e.target.textContent.trim().substring(0, 50) : '',\n                    timestamp: new Date().toISOString()\n                });\n                console.log('🎬 Recorded click:', selector);\n            }, true);\n            \n            // Record input with debouncing - track by element identity using WeakMap\n            document.addEventListener('input', (e) => {\n                const el = e.target;\n                const selector = getSelector(el);\n                \n                if (inputTimers.has(el)) {\n                    clearTimeout(inputTimers.get(el));\n                }\n                \n                const timer = setTimeout(() => {\n                    window.__recordedActions.push({\n                        type: 'fill',\n                        selector: selector,\n                        value: el.value,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('🎬 Recorded fill:', selector, '=', el.value);\n                    inputTimers.delete(el);\n                }, DEBOUNCE_DELAY);\n                \n                inputTimers.set(el, timer);\n            }, true);\n            \n            // Record keyboard events\n            document.addEventListener('keydown', (e) => {\n                const specialKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n                \n                if (specialKeys.includes(e.key)) {\n                    const el = e.target;\n                    const selector = getSelector(el);\n                    \n                    // If Enter and there's pending input, send it immediately\n                    if (e.key === 'Enter' && inputTimers.has(el)) {\n                        clearTimeout(inputTimers.get(el));\n                        window.__recordedActions.push({\n                            type: 'fill',\n                            selector: selector,\n                            value: el.value,\n                            timestamp: new Date().toISOString()\n                        });\n                        console.log('🎬 Recorded fill (Enter):', selector, '=', el.value);\n                        inputTimers.delete(el);\n                    }\n                    \n                    window.__recordedActions.push({\n                        type: 'press',\n                        selector: selector,\n                        key: e.key,\n                        timestamp: new Date().toISOString()\n                    });\n                    console.log('🎬 Recorded keypress:', e.key, 'on', selector);\n                }\n            }, true);\n            \n            console.log('✅ VisionVault recording initialized - actions will be captured automatically');\n        \"\"\")\n        \n        return page\n    \n    async def get_recorded_actions_from_page(self):\n        \"\"\"Get actions recorded by JavaScript injection.\"\"\"\n        if not self.page:\n            return []\n        \n        try:\n            js_actions = await self.page.evaluate(\"window.__recordedActions || []\")\n            return js_actions\n        except:\n            return []\n","size_bytes":21461},"recordings/fe150765-73d8-476e-89ef-72615806dfa6.py":{"content":"import re\nfrom playwright.sync_api import Playwright, sync_playwright, expect\n\n\ndef run(playwright: Playwright) -> None:\n    browser = playwright.chromium.launch(headless=False)\n    context = browser.new_context()\n    page = context.new_page()\n    page.goto(\"https://www.amazon.in/\")\n    page.get_by_text(\"Up to 80% off | Home, kitchen & moreKitchen essentialsHome decorFurnitureHome\").click()\n    page.get_by_text(\"Kitchen essentialsHome decorFurnitureHome improvement\").click()\n\n    # ---------------------\n    context.close()\n    browser.close()\n\n\nwith sync_playwright() as playwright:\n    run(playwright)\n","size_bytes":609},"visionvault/services/intelligent_planner.py":{"content":"\"\"\"\nIntelligent Pre-Execution Planner\n\nThis module analyzes user commands BEFORE execution to:\n1. Predict potential failures and edge cases\n2. Generate multiple execution strategies\n3. Pre-validate URLs and element availability\n4. Optimize execution path for speed and reliability\n5. Provide confidence scores and risk assessment\n\"\"\"\n\nimport re\nfrom typing import Dict, List, Optional\nfrom openai import OpenAI\n\n\nclass IntelligentPlanner:\n    \"\"\"AI-powered pre-execution planning and analysis\"\"\"\n\n    def __init__(self, openai_client: Optional[OpenAI] = None):\n        self.client = openai_client\n        self.common_patterns = self._load_common_patterns()\n\n    def _load_common_patterns(self) -> Dict:\n        \"\"\"Load common automation patterns and success strategies\"\"\"\n        return {\n            'search': {\n                'keywords': ['search', 'find', 'look for', 'query'],\n                'common_issues': [\n                    'search box not visible', 'autocomplete interference',\n                    'slow page load'\n                ],\n                'best_practices': [\n                    'wait for search box', 'use placeholder locator',\n                    'handle autocomplete'\n                ]\n            },\n            'login': {\n                'keywords': ['login', 'sign in', 'authenticate', 'log in'],\n                'common_issues':\n                ['captcha', 'two-factor auth', 'session timeout'],\n                'best_practices':\n                ['wait for form', 'check for errors', 'handle redirects']\n            },\n            'form_fill': {\n                'keywords': ['fill', 'enter', 'type', 'input'],\n                'common_issues':\n                ['validation errors', 'required fields', 'field not ready'],\n                'best_practices': [\n                    'wait for field visibility', 'validate after fill',\n                    'handle dropdowns'\n                ]\n            },\n            'navigation': {\n                'keywords': ['go to', 'navigate', 'open', 'visit'],\n                'common_issues': ['slow load', 'redirects', 'cookie banners'],\n                'best_practices':\n                ['wait for load state', 'handle popups', 'extended timeout']\n            },\n            'click': {\n                'keywords': ['click', 'press', 'select', 'choose'],\n                'common_issues':\n                ['element not clickable', 'covered by overlay', 'not visible'],\n                'best_practices':\n                ['scroll into view', 'wait for visible', 'check for overlays']\n            }\n        }\n\n    def analyze_command(self, command: str) -> Dict:\n        \"\"\"\n        Analyze command and generate execution plan with risk assessment.\n        Returns: {\n            'intent': str,\n            'complexity': str (low/medium/high),\n            'predicted_steps': List[str],\n            'potential_issues': List[str],\n            'recommended_strategies': List[str],\n            'confidence_score': float (0-100),\n            'estimated_time': str\n        }\n        \"\"\"\n        if not self.client:\n            return self._basic_analysis(command)\n\n        try:\n            # Use GPT-4o for deep command understanding\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\n                    \"role\":\n                    \"system\",\n                    \"content\":\n                    \"\"\"You are an expert automation planner with deep understanding of web applications.\n\nAnalyze the user's automation command and provide a detailed execution plan.\n\nYour analysis must include:\n1. PRIMARY INTENT: What the user wants to accomplish\n2. COMPLEXITY: low/medium/high based on steps and potential issues\n3. PREDICTED STEPS: Detailed step-by-step breakdown\n4. POTENTIAL ISSUES: Common failures (slow load, dynamic content, overlays, SPAs, auth, etc.)\n5. RECOMMENDED STRATEGIES: Best practices to avoid failures\n6. CONFIDENCE SCORE: 0-100 based on clarity and feasibility\n7. ESTIMATED TIME: Expected execution time (e.g., \"10-20 seconds\")\n\nConsider:\n- Website type (SPA, static, e-commerce, etc.)\n- Dynamic content and async loading\n- Common UI patterns (modals, dropdowns, autocomplete)\n- Potential blockers (captcha, auth, cookies)\n- Element stability and visibility\n- Network delays and page load times\n\nReturn a comprehensive analysis that helps generate flawless code.\"\"\"\n                }, {\n                    \"role\":\n                    \"user\",\n                    \"content\":\n                    f\"Analyze this automation command and create an execution plan:\\n\\n{command}\"\n                }],\n                temperature=0.3)\n\n            analysis_text = response.choices[0].message.content.strip()\n\n            # Parse the AI response into structured format\n            return self._parse_ai_analysis(analysis_text, command)\n\n        except Exception as e:\n            print(f\"⚠️  AI planning error: {e}\")\n            return self._basic_analysis(command)\n\n    def _parse_ai_analysis(self, analysis_text: str, command: str) -> Dict:\n        \"\"\"Parse AI analysis into structured format\"\"\"\n\n        # Extract sections from AI response\n        intent = self._extract_section(analysis_text,\n                                       ['PRIMARY INTENT', 'INTENT', 'PURPOSE'])\n        complexity = self._extract_complexity(analysis_text)\n        steps = self._extract_list(\n            analysis_text, ['PREDICTED STEPS', 'STEPS', 'EXECUTION STEPS'])\n        issues = self._extract_list(analysis_text,\n                                    ['POTENTIAL ISSUES', 'ISSUES', 'RISKS'])\n        strategies = self._extract_list(\n            analysis_text,\n            ['RECOMMENDED STRATEGIES', 'STRATEGIES', 'BEST PRACTICES'])\n        confidence = self._extract_confidence(analysis_text)\n        time_est = self._extract_section(\n            analysis_text, ['ESTIMATED TIME', 'TIME', 'DURATION'])\n\n        return {\n            'intent':\n            intent or self._infer_intent(command),\n            'complexity':\n            complexity or 'medium',\n            'predicted_steps':\n            steps or ['Execute command'],\n            'potential_issues':\n            issues or ['Standard web automation risks'],\n            'recommended_strategies':\n            strategies or ['Use robust locators', 'Add proper waits'],\n            'confidence_score':\n            confidence or 70.0,\n            'estimated_time':\n            time_est or '10-30 seconds',\n            'full_analysis':\n            analysis_text\n        }\n\n    def _extract_section(self, text: str, headers: List[str]) -> str:\n        \"\"\"Extract content from a section with given headers\"\"\"\n        for header in headers:\n            pattern = rf\"{header}[:\\s]+(.+?)(?=\\n(?:[A-Z\\s]+:|$))\"\n            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)\n            if match:\n                return match.group(1).strip()\n        return \"\"\n\n    def _extract_list(self, text: str, headers: List[str]) -> List[str]:\n        \"\"\"Extract bulleted or numbered list from text\"\"\"\n        section = self._extract_section(text, headers)\n        if not section:\n            return []\n\n        # Find list items (bullets, numbers, dashes)\n        items = re.findall(r'(?:^|\\n)[\\s]*(?:[-•*]|\\d+\\.)\\s*(.+)', section)\n        if items:\n            return [item.strip() for item in items if item.strip()]\n\n        # Fallback: split by newlines\n        lines = [line.strip() for line in section.split('\\n') if line.strip()]\n        return lines[:5]  # Limit to 5 items\n\n    def _extract_complexity(self, text: str) -> str:\n        \"\"\"Extract complexity level\"\"\"\n        text_lower = text.lower()\n        if 'complexity: low' in text_lower or 'low complexity' in text_lower:\n            return 'low'\n        elif 'complexity: high' in text_lower or 'high complexity' in text_lower:\n            return 'high'\n        elif 'complexity: medium' in text_lower or 'medium complexity' in text_lower:\n            return 'medium'\n        return 'medium'\n\n    def _extract_confidence(self, text: str) -> float:\n        \"\"\"Extract confidence score\"\"\"\n        # Look for patterns like \"85%\", \"confidence: 90\", etc.\n        patterns = [\n            r'confidence[:\\s]+(\\d+)', r'(\\d+)%?\\s*confidence',\n            r'score[:\\s]+(\\d+)'\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return float(match.group(1))\n\n        return 75.0  # Default confidence\n\n    def _basic_analysis(self, command: str) -> Dict:\n        \"\"\"Fallback analysis without AI\"\"\"\n        intent = self._infer_intent(command)\n        pattern = self._match_pattern(command)\n\n        return {\n            'intent':\n            intent,\n            'complexity':\n            'medium',\n            'predicted_steps': [f'Execute: {command}'],\n            'potential_issues':\n            pattern.get('common_issues', ['Standard risks'])\n            if pattern else ['Standard risks'],\n            'recommended_strategies':\n            pattern.get('best_practices', ['Use robust locators'])\n            if pattern else ['Use robust locators'],\n            'confidence_score':\n            70.0,\n            'estimated_time':\n            '10-30 seconds',\n            'full_analysis':\n            'Basic analysis (AI not available)'\n        }\n\n    def _infer_intent(self, command: str) -> str:\n        \"\"\"Infer user intent from command\"\"\"\n        command_lower = command.lower()\n\n        if any(kw in command_lower for kw in ['search', 'find', 'look for']):\n            return 'Search for information'\n        elif any(kw in command_lower for kw in ['login', 'sign in', 'log in']):\n            return 'Authenticate user'\n        elif any(kw in command_lower for kw in ['buy', 'purchase', 'order']):\n            return 'Complete purchase'\n        elif any(kw in command_lower for kw in ['fill', 'enter', 'submit']):\n            return 'Fill and submit form'\n        elif any(kw in command_lower for kw in ['click', 'press', 'select']):\n            return 'Interact with element'\n        elif any(kw in command_lower\n                 for kw in ['go to', 'navigate', 'open', 'visit']):\n            return 'Navigate to page'\n        else:\n            return 'Execute automation task'\n\n    def _match_pattern(self, command: str) -> Optional[Dict]:\n        \"\"\"Match command to known patterns\"\"\"\n        command_lower = command.lower()\n\n        for pattern_name, pattern in self.common_patterns.items():\n            if any(kw in command_lower for kw in pattern['keywords']):\n                return pattern\n\n        return None\n\n    def generate_optimized_prompt(self, command: str, analysis: Dict) -> str:\n        \"\"\"\n        Generate enhanced prompt for code generation based on analysis.\n        Includes predicted issues and recommended strategies.\n        \"\"\"\n        strategies_text = '\\n'.join(\n            [f\"- {s}\" for s in analysis['recommended_strategies']])\n        issues_text = '\\n'.join(\n            [f\"- {s}\" for s in analysis['potential_issues']])\n\n        enhanced_prompt = f\"\"\"Generate Playwright code for: {command}\n\nEXECUTION PLAN ANALYSIS:\nIntent: {analysis['intent']}\nComplexity: {analysis['complexity']}\nConfidence: {analysis['confidence_score']:.0f}%\n\nPREDICTED POTENTIAL ISSUES:\n{issues_text}\n\nREQUIRED STRATEGIES (MANDATORY):\n{strategies_text}\n\nCRITICAL REQUIREMENTS:\n1. Implement ALL recommended strategies above\n2. Add robust error handling for predicted issues\n3. Use intelligent waits (wait_for_load_state, wait_for_selector with visible/attached states)\n4. Include retry logic for dynamic content\n5. Handle common blockers (cookie banners, overlays, modals)\n6. Add detailed logging for each step\n7. Use the most reliable locators (testId > role > placeholder > label > text)\n8. Set appropriate timeouts (10000ms for critical operations)\n\nGenerate production-ready code that anticipates and handles these issues proactively.\"\"\"\n\n        return enhanced_prompt\n","size_bytes":12006},"visionvault/web/app.py":{"content":"import os\nimport json\nimport sqlite3\nimport uuid\nimport time\nfrom datetime import datetime\nfrom typing import Optional\nfrom flask import Flask, render_template, request, jsonify, send_from_directory, Response\nfrom flask_socketio import SocketIO, emit\nfrom flask_cors import CORS\nfrom openai import OpenAI\nfrom visionvault.services.executor import ServerExecutor\nfrom visionvault.services.healing_executor import HealingExecutor\nfrom visionvault.services.code_validator import CodeValidator\nfrom visionvault.core.models import Database, LearnedTask, TaskExecution\nfrom visionvault.services.vector_store import SemanticSearch\nfrom visionvault.services.intelligent_planner import IntelligentPlanner\nfrom visionvault.services.self_learning_engine import SelfLearningEngine\nfrom visionvault.services.dom_inspector import dom_inspector\nfrom visionvault.services.mcp_manager import MCPAutomationManager\nfrom visionvault.services.unified_engine import UnifiedAutomationEngine\nimport base64\nimport asyncio\nimport re\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key-change-in-production')\napp.config['UPLOAD_FOLDER'] = 'data/uploads'\napp.config['DATABASE_PATH'] = 'data/automation.db'\nCORS(app)\nsocketio = SocketIO(\n    app, \n    async_mode='threading', \n    cors_allowed_origins=\"*\",\n    ping_timeout=60,           # 60 seconds before considering connection dead\n    ping_interval=25,          # Send ping every 25 seconds to keep connection alive\n    max_http_buffer_size=10**8,  # 100MB buffer for large payloads\n    engineio_logger=False,     # Reduce logging overhead\n    logger=False\n)\n\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'screenshots'), exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'logs'), exist_ok=True)\n\n# Cache absolute upload directory path at module load for efficiency\nUPLOAD_DIR_ABS = os.path.abspath(app.config['UPLOAD_FOLDER'])\n\nopenai_api_key = os.environ.get('OPENAI_API_KEY')\ngemini_api_key = os.environ.get('GEMINI_API_KEY')\n\nif openai_api_key:\n    client = OpenAI(api_key=openai_api_key)\n    print(\"✅ OpenAI client initialized for code generation\")\nelse:\n    client = None\n    print(\"WARNING: OPENAI_API_KEY is not set. AI code generation will not be available.\")\n\nif gemini_api_key:\n    try:\n        semantic_search = SemanticSearch(api_key=gemini_api_key)\n        print(\"✅ Semantic search service initialized with Gemini embeddings\")\n    except Exception as e:\n        semantic_search = None\n        print(f\"⚠️ Failed to initialize semantic search: {e}\")\nelse:\n    semantic_search = None\n    print(\"WARNING: GEMINI_API_KEY is not set. Semantic search will not be available.\")\n\nconnected_agents = {}\nactive_healing_executors = {}\nactive_recorders = {}  # Track active recording sessions\nactive_loops = {}  # Track event loops for recording sessions\n\n# Initialize database with new tables\ndb = Database()\nprint(\"✅ Database initialized with persistent learning tables\")\n\n# Initialize super-intelligent systems\nif client:\n    intelligent_planner = IntelligentPlanner(openai_client=client)\n    print(\"✅ Intelligent Planner initialized (GPT-4o pre-execution analysis)\")\nelse:\n    intelligent_planner = None\n    print(\"⚠️  Intelligent Planner disabled (requires OPENAI_API_KEY)\")\n\nself_learning_engine = SelfLearningEngine()\nprint(f\"✅ Self-Learning Engine initialized (learned from {self_learning_engine.knowledge_base['total_executions']} past executions)\")\n\n# Initialize MCP automation manager (legacy compatibility)\nmcp_manager = MCPAutomationManager(socketio, openai_api_key)\nprint(\"✅ MCP Automation Manager initialized\")\n\n# Initialize UNIFIED Automation Engine (intelligent merge of MCP + Legacy)\nunified_engine = UnifiedAutomationEngine(\n    socketio=socketio,\n    openai_client=client,\n    gemini_api_key=gemini_api_key\n)\nprint(\"🎯 Unified Automation Engine ready - intelligent strategy selection enabled\")\n\n\ndef extract_url_from_command(command: str) -> Optional[str]:\n    \"\"\"Extract URL from natural language command\"\"\"\n    # Try to find explicit URLs\n    url_pattern = r'(https?://[^\\s]+|www\\.[^\\s]+|[a-zA-Z0-9-]+\\.(com|org|net|io|dev|co|ai)[^\\s]*)'\n    urls = re.findall(url_pattern, command.lower())\n    \n    if urls:\n        url = urls[0] if isinstance(urls[0], str) else urls[0][0]\n        # Add https:// if missing\n        if not url.startswith('http'):\n            url = 'https://' + url\n        return url\n    \n    # Try to infer from common patterns\n    command_lower = command.lower()\n    \n    # \"go to X\" or \"navigate to X\" or \"open X\"\n    patterns = [\n        r'(?:go to|navigate to|open|visit)\\s+([a-zA-Z0-9-]+(?:\\.[a-zA-Z]{2,})+)',\n        r'(?:search on|use)\\s+([a-zA-Z0-9-]+)(?:\\s|$)',\n    ]\n    \n    for pattern in patterns:\n        match = re.search(pattern, command_lower)\n        if match:\n            domain = match.group(1)\n            # Common sites without .com/.org etc\n            if domain in ['google', 'youtube', 'facebook', 'twitter', 'amazon', 'reddit', 'github', 'linkedin']:\n                return f'https://www.{domain}.com'\n            elif '.' not in domain:\n                return f'https://www.{domain}.com'\n            else:\n                return f'https://{domain}' if not domain.startswith('http') else domain\n    \n    return None\n\n\ndef generate_playwright_code(natural_language_command, browser='chromium', similar_tasks=None):\n    \"\"\"\n    Generate Playwright code with SUPER-INTELLIGENT analysis and planning.\n    \n    Uses:\n    - Intelligent Planner: Pre-execution analysis and risk assessment\n    - Self-Learning Engine: Learned patterns from past executions\n    - Similar Task Reuse: Code from related tasks\n    \n    Args:\n        natural_language_command: The user's command\n        browser: Browser type (chromium, firefox, webkit)\n        similar_tasks: List of similar tasks to use as context (optional)\n    \"\"\"\n    if not client:\n        raise Exception(\"OpenAI API key not configured. Please set the OPENAI_API_KEY environment variable.\")\n    \n    try:\n        # STEP 0: DOM Inspection - Analyze actual page for perfect locator selection\n        dom_analysis = None\n        page_url = extract_url_from_command(natural_language_command)\n        \n        if page_url:\n            print(f\"\\n🔍 INTELLIGENT DOM INSPECTION...\")\n            print(f\"   Analyzing page: {page_url}\")\n            try:\n                # Run DOM inspection in asyncio event loop\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n                dom_analysis = loop.run_until_complete(\n                    dom_inspector.analyze_page(page_url, natural_language_command)\n                )\n                loop.close()\n                \n                if 'error' not in dom_analysis:\n                    intent_matched = len(dom_analysis.get('intent_matched_elements', []))\n                    form_elements = len(dom_analysis.get('form_elements', []))\n                    interactive = len(dom_analysis.get('interactive_elements', []))\n                    print(f\"   ✅ Page analyzed successfully!\")\n                    print(f\"   Found: {intent_matched} intent-matched, {form_elements} form, {interactive} interactive elements\")\n                else:\n                    print(f\"   ⚠️  DOM inspection failed: {dom_analysis.get('error', 'Unknown error')}\")\n                    print(f\"   Falling back to standard locator strategies\")\n                    dom_analysis = None\n            except Exception as e:\n                print(f\"   ⚠️  DOM inspection error: {str(e)}\")\n                print(f\"   Falling back to standard locator strategies\")\n                dom_analysis = None\n        else:\n            print(\"\\n⚠️  No URL detected in command - skipping DOM inspection\")\n        \n        # STEP 1: Pre-execution intelligent planning\n        execution_plan = None\n        learned_recommendations = None\n        \n        if intelligent_planner:\n            print(\"\\n🧠 INTELLIGENT PRE-EXECUTION ANALYSIS...\")\n            execution_plan = intelligent_planner.analyze_command(natural_language_command)\n            print(f\"   Intent: {execution_plan['intent']}\")\n            print(f\"   Complexity: {execution_plan['complexity']}\")\n            print(f\"   Confidence: {execution_plan['confidence_score']:.0f}%\")\n            print(f\"   Predicted issues: {len(execution_plan['potential_issues'])}\")\n            print(f\"   Recommended strategies: {len(execution_plan['recommended_strategies'])}\")\n        \n        # STEP 2: Get self-learning recommendations\n        learned_recommendations = self_learning_engine.get_recommendations(natural_language_command)\n        print(f\"\\n📚 SELF-LEARNING RECOMMENDATIONS:\")\n        print(f\"   Predicted success rate: {learned_recommendations['predicted_success_rate']:.1f}%\")\n        print(f\"   Recommended locators: {', '.join(learned_recommendations['recommended_locators'][:3])}\")\n        print(f\"   Confidence: {learned_recommendations['confidence']:.0f}%\")\n        # Build system prompt with reusable code context\n        system_prompt = \"\"\"You are an expert at converting natural language commands into Playwright Python code with ENHANCED RELIABILITY.\n\nYour goal is to generate code efficiently by REUSING existing code and locators whenever possible.\n\nGenerate complete, executable Playwright code that:\n1. Uses async/await syntax\n2. Includes proper browser launch with the specified browser\n3. Has error handling with proper cleanup\n4. Returns a dict with 'success', 'logs', 'screenshot', and 'current_step' keys\n5. ALWAYS takes screenshot BEFORE closing browser (CRITICAL)\n6. The code should be a complete async function named 'run_test' that takes browser_name and headless parameters\n\nCRITICAL TIMEOUT RULES:\n- Use 5000ms (5 seconds) timeout for LOCATOR action methods only\n- LOCATOR actions that accept timeout: click(), fill(), locator.press(), select_option(), check(), etc.\n- NEVER add timeout to: locator() calls, page.keyboard.press(), page.mouse methods\n- Examples:\n  ✅ CORRECT: await page.get_by_role(\"button\").click(timeout=5000)\n  ✅ CORRECT: await page.get_by_placeholder(\"Search\").fill(\"text\", timeout=5000)\n  ✅ CORRECT: await page.get_by_text(\"Enter\").press(\"Enter\", timeout=5000)  # locator.press()\n  ✅ CORRECT: await page.keyboard.press(\"Enter\")  # NO timeout parameter!\n  ❌ WRONG: await page.locator(\"button\", timeout=5000)  # locator() doesn't accept timeout!\n  ❌ WRONG: await page.keyboard.press(\"Enter\", timeout=5000)  # keyboard.press() doesn't accept timeout!\n\nCRITICAL STEP TRACKING:\n- Label each major step with a comment like \"# STEP 1: Navigate to website\"\n- Update current_step variable before each step for granular error tracking\n- Log each step completion with step number\n\nCRITICAL LOCATOR SELECTION STRATEGY (Priority Order - Use the FIRST available):\nBased on Playwright best practices and proven success rates, ALWAYS select locators in this priority order:\n\n⚠️ CRITICAL RULE: NEVER use CSS selectors or page.locator() unless absolutely necessary!\n❌ BAD: page.locator(\"input[aria-label='Search']\") or page.locator(\"#id\") \n✅ GOOD: page.get_by_role(), page.get_by_placeholder(), page.get_by_label()\n\n1. Test ID (HIGHEST PRIORITY - 99% success rate)\n   ✅ page.get_by_test_id(\"submit-btn\")\n   Use when element has data-testid attribute\n\n2. Role with Name (Accessibility-first - 95% success rate) ⭐ PREFERRED\n   ✅ page.get_by_role(\"button\", name=\"Submit\")\n   ✅ page.get_by_role(\"link\", name=\"Login\")\n   ✅ page.get_by_role(\"textbox\", name=\"Search\")\n   ✅ page.get_by_role(\"combobox\", name=\"Search\")  # For search boxes!\n   Common roles: button, link, textbox, combobox, checkbox, radio, heading\n   ALWAYS use for interactive elements (buttons, links, inputs)\n\n3. Placeholder (90% success rate)\n   ✅ page.get_by_placeholder(\"Enter your email\")\n   ✅ page.get_by_placeholder(\"Search\")\n   Use for form inputs with placeholder text\n\n4. Label (85% success rate)\n   ✅ page.get_by_label(\"Email Address\")\n   Use when form field has associated label\n\n5. Text Content (80% success rate)\n   ✅ page.get_by_text(\"Submit\", exact=True)\n   Use for elements with unique visible text\n\n6. Alt Text (for images only)\n   ✅ page.get_by_alt_text(\"Company Logo\")\n\n7. Title Attribute\n   ✅ page.get_by_title(\"Close dialog\")\n\n8. ❌ CSS Selectors (LAST RESORT - 70% success rate, often breaks)\n   Only if NO semantic locator exists:\n   page.locator(\"#unique-id\")  # ID only\n   ❌ NEVER use: page.locator(\"input\"), page.locator(\".class\"), page.locator(\"[aria-label='...']\")\n\nSMART LOCATOR SELECTION BY ELEMENT TYPE:\n┌─────────────────┬────────────────────────────────────────────────┐\n│ Element Type    │ Best Locator (in order of preference)          │\n├─────────────────┼────────────────────────────────────────────────┤\n│ Search box      │ 1. get_by_role(\"combobox\", name=\"Search\")     │\n│                 │ 2. get_by_placeholder(\"Search...\")             │\n│                 │ 3. get_by_label(\"Search\")                      │\n├─────────────────┼────────────────────────────────────────────────┤\n│ Button          │ 1. get_by_role(\"button\", name=\"Submit\")       │\n│                 │ 2. get_by_text(\"Submit\", exact=True)           │\n├─────────────────┼────────────────────────────────────────────────┤\n│ Link            │ 1. get_by_role(\"link\", name=\"Login\")          │\n│                 │ 2. get_by_text(\"Login\", exact=True)            │\n├─────────────────┼────────────────────────────────────────────────┤\n│ Text input      │ 1. get_by_label(\"Email\")                      │\n│                 │ 2. get_by_placeholder(\"Enter email\")           │\n│                 │ 3. get_by_role(\"textbox\", name=\"Email\")       │\n├─────────────────┼────────────────────────────────────────────────┤\n│ Checkbox/Radio  │ 1. get_by_role(\"checkbox\", name=\"Remember\")   │\n│                 │ 2. get_by_label(\"Remember me\")                 │\n└─────────────────┴────────────────────────────────────────────────┘\n\nCRITICAL: Search boxes are usually role=\"combobox\" or have a placeholder!\nExample: Google search → page.get_by_role(\"combobox\", name=\"Search\") or page.get_by_placeholder(\"Search\")\n\nCRITICAL NAVIGATION RULES:\n- NEVER use page.wait_for_navigation() - this is Puppeteer syntax, NOT Playwright!\n- For navigation after click/submit, use: async with page.expect_navigation(): await page.click(...)\n- Or use: await page.wait_for_load_state('networkidle') after the action\n- Or simply await page.click() and Playwright auto-waits for navigation\n- Example: await page.get_by_role(\"button\", name=\"Submit\").click(timeout=5000)\n          await page.wait_for_load_state('networkidle')  # Wait for page to load\n\nCRITICAL RULE: Always take screenshot BEFORE closing browser/page. Never close browser before screenshot.\n\nExample structure with BEST PRACTICE LOCATORS:\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    browser = None\n    page = None\n    current_step = 0\n    \n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            \n            # STEP 1: Navigate to website\n            current_step = 1\n            await page.goto('https://example.com', timeout=10000)\n            logs.append(\"STEP 1: Navigated to website\")\n            \n            # STEP 2: Click login button (using role - Score 100)\n            current_step = 2\n            await page.get_by_role(\"button\", name=\"Login\").click(timeout=5000)\n            logs.append(\"STEP 2: Clicked login button\")\n            \n            # STEP 3: Fill username (using label - Score 140)\n            current_step = 3\n            await page.get_by_label(\"Username\").fill('testuser', timeout=5000)\n            logs.append(\"STEP 3: Filled username\")\n            \n            # STEP 4: Fill password (using placeholder - Score 120)\n            current_step = 4\n            await page.get_by_placeholder(\"Enter password\").fill('pass123', timeout=5000)\n            logs.append(\"STEP 4: Filled password\")\n            \n            # STEP 5: Submit (using role - Score 100)\n            current_step = 5\n            await page.get_by_role(\"button\", name=\"Submit\").click(timeout=5000)\n            logs.append(\"STEP 5: Submitted form\")\n            \n            # CRITICAL: Screenshot and page HTML capture BEFORE closing\n            screenshot = await page.screenshot()\n            page_html = await page.content()  # Capture page HTML for healing analysis\n            await browser.close()\n            return {'success': True, 'logs': logs, 'screenshot': screenshot, 'page_html': page_html, 'current_step': current_step}\n    except Exception as e:\n        error_msg = f\"Error at STEP {current_step}: {str(e)}\"\n        logs.append(error_msg)\n        # Try to get screenshot and page HTML even on error, BEFORE cleanup\n        page_html = ''\n        if page:\n            try:\n                screenshot = await page.screenshot()\n                page_html = await page.content()  # Capture page HTML for healing analysis\n            except:\n                pass\n        if browser:\n            try:\n                await browser.close()\n            except:\n                pass\n        return {'success': False, 'logs': logs, 'screenshot': screenshot, 'page_html': page_html, 'current_step': current_step}\n\nOnly return the function code, no explanations.\"\"\"\n\n        # Add DOM inspection results to the prompt (HIGHEST PRIORITY - real page data!)\n        if dom_analysis and 'error' not in dom_analysis:\n            dom_recommendations = dom_inspector.generate_locator_recommendations(dom_analysis)\n            system_prompt += f\"\\n\\n{dom_recommendations}\\n\"\n            system_prompt += \"🎯 CRITICAL: Use the exact locators from DOM analysis above - they are CONFIRMED to exist!\\n\"\n            system_prompt += \"These locators were extracted from the actual live page, ensuring 99%+ accuracy.\\n\\n\"\n\n        # Add intelligent planner's recommendations to the prompt\n        if execution_plan:\n            system_prompt += f\"\\n\\n--- INTELLIGENT EXECUTION PLAN ---\\n\"\n            system_prompt += f\"Intent: {execution_plan['intent']}\\n\"\n            system_prompt += f\"Complexity: {execution_plan['complexity']}\\n\"\n            system_prompt += f\"Estimated Time: {execution_plan['estimated_time']}\\n\\n\"\n            \n            if execution_plan['potential_issues']:\n                system_prompt += \"PREDICTED POTENTIAL ISSUES (must handle):\\n\"\n                for issue in execution_plan['potential_issues']:\n                    system_prompt += f\"- {issue}\\n\"\n                system_prompt += \"\\n\"\n            \n            if execution_plan['recommended_strategies']:\n                system_prompt += \"REQUIRED STRATEGIES (must implement):\\n\"\n                for strategy in execution_plan['recommended_strategies']:\n                    system_prompt += f\"- {strategy}\\n\"\n                system_prompt += \"\\n\"\n        \n        # Add self-learning recommendations\n        if learned_recommendations['recommended_locators']:\n            system_prompt += f\"\\n--- LEARNED BEST LOCATORS ---\\n\"\n            system_prompt += f\"Based on {self_learning_engine.knowledge_base['total_executions']} past executions:\\n\"\n            for loc in learned_recommendations['recommended_locators'][:5]:\n                system_prompt += f\"- {loc} (proven effective)\\n\"\n            system_prompt += \"\\n\"\n        \n        # Add similar tasks as context if available - ENHANCED CODE ADAPTATION MODE\n        if similar_tasks and len(similar_tasks) > 0:\n            best_similarity = similar_tasks[0].get('similarity_score', 0)\n            \n            system_prompt += \"\\n\\n--- 🎯 SMART CODE ADAPTATION MODE ACTIVATED ---\\n\"\n            system_prompt += \"Below are existing tasks that are similar to the new request. Your job is to INTELLIGENTLY ADAPT the existing code, NOT generate from scratch.\\n\\n\"\n            \n            for i, task in enumerate(similar_tasks, 1):\n                similarity = task.get('similarity_score', 0)\n                system_prompt += f\"Task {i} (Similarity: {similarity:.0%}): {task['task_name']}\\n\"\n                if task.get('description'):\n                    system_prompt += f\"Description: {task['description']}\\n\"\n                system_prompt += f\"Existing Code:\\n```python\\n{task['playwright_code']}\\n```\\n\\n\"\n            \n            # Add smart adaptation instructions based on similarity level\n            if best_similarity > 0.50:\n                # High similarity - minor adaptation needed\n                system_prompt += \"\"\"--- 🔧 CODE ADAPTATION STRATEGY (HIGH SIMILARITY) ---\n⚠️  WARNING: The existing task is VERY similar to the new request!\n\nMANDATORY APPROACH - Follow these steps EXACTLY:\n1. START with the existing code from Task 1 as your BASE\n2. IDENTIFY what needs to change (e.g., search terms, URLs, button names)\n3. REPLACE only the specific values that differ - DO NOT rewrite locators or structure\n4. KEEP all working locators, selectors, and navigation patterns UNCHANGED\n5. MAINTAIN the exact same code structure and error handling\n\nEXAMPLES OF SMART ADAPTATION:\n- Old: await page.fill(\"#search\", \"dog food\")\n  New: await page.fill(\"#search\", \"cat food\")  ← ONLY change the search term\n  \n- Old: await page.goto(\"https://flipkart.com\")\n  New: await page.goto(\"https://flipkart.com\")  ← KEEP if same site\n  \n- Old: await page.get_by_role(\"button\", name=\"Search\").click()\n  New: await page.get_by_role(\"button\", name=\"Search\").click()  ← KEEP if same button\n\n❌ DO NOT:\n- Generate new code from scratch\n- Change working locators or selectors\n- Modify the overall structure\n- Add unnecessary waits or steps\n\n✅ DO:\n- Copy the existing code structure\n- Replace ONLY the parameter values that need to change\n- Preserve all proven locators and patterns\n- Keep comments and logging intact\n\"\"\"\n            else:\n                # Moderate similarity - partial reuse\n                system_prompt += \"\"\"--- 🔧 CODE ADAPTATION STRATEGY (MODERATE SIMILARITY) ---\nThe existing tasks share some patterns with the new request.\n\nRECOMMENDED APPROACH:\n1. Identify REUSABLE patterns: URLs, navigation flows, locator types, wait strategies\n2. COPY working code sections (navigation, form filling, button clicks)\n3. ADAPT values and targets to match the new requirement\n4. COMBINE patterns from multiple tasks if needed\n5. Only generate NEW code for unique parts not covered\n\nFOCUS ON:\n- Reusing proven locators and selectors\n- Maintaining the same navigation structure\n- Copying error handling patterns\n- Adapting values (search terms, form data) to new requirements\n\"\"\"\n            \n            system_prompt += \"\\n🎯 GOAL: Generate adapted code that leverages existing proven patterns and minimizes new code generation.\\n\"\n\n        # Build enhanced user prompt with all context\n        user_prompt = f\"NEW REQUEST: {natural_language_command}\\n\"\n        user_prompt += f\"Target Browser: {browser}\\n\"\n        \n        if similar_tasks and len(similar_tasks) > 0:\n            best_similarity = similar_tasks[0].get('similarity_score', 0)\n            if best_similarity > 0.50:\n                user_prompt += f\"\\n⚠️  CRITICAL: An existing task is {best_similarity:.0%} similar to this request!\\n\"\n                user_prompt += \"You MUST adapt the existing code, NOT generate from scratch.\\n\"\n                user_prompt += \"Identify the differences and make MINIMAL changes to the existing code.\\n\"\n            else:\n                user_prompt += f\"\\n✅ Found {len(similar_tasks)} related task(s). Reuse their proven patterns and locators.\\n\"\n        \n        if execution_plan:\n            user_prompt += f\"\\n\\nEXECUTION PLAN: {execution_plan['full_analysis'][:500]}\"\n        \n        user_prompt += f\"\\n\\nGenerate PRODUCTION-READY code that handles all predicted issues and implements all recommended strategies.\"\n\n        # Use GPT-4o-mini for code generation\n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt}\n            ],\n            temperature=0.2  # Lower temperature for more consistent, reliable code\n        )\n\n        code = response.choices[0].message.content\n        if not code:\n            raise Exception(\"No code generated from OpenAI\")\n        code = code.strip()\n        if code.startswith('```python'):\n            code = code[9:]\n        if code.startswith('```'):\n            code = code[3:]\n        if code.endswith('```'):\n            code = code[:-3]\n\n        return code.strip()\n    except Exception as e:\n        raise Exception(f\"OpenAI API error: {str(e)}\")\n\n\ndef generate_playwright_code_from_recording(recorded_events):\n    \"\"\"\n    Convert recorded events from ComprehensiveRecordingSessionManager to executable Playwright code.\n    This generates proper Playwright code with full browser launch, error handling, and screenshot capture.\n    \"\"\"\n    if not recorded_events or len(recorded_events) == 0:\n        raise Exception(\"No recorded events to convert to code\")\n    \n    # Start building the code\n    code_lines = [\n        \"async def run_test(browser_name='chromium', headless=True):\",\n        \"    from playwright.async_api import async_playwright\",\n        \"    logs = []\",\n        \"    screenshot = None\",\n        \"    browser = None\",\n        \"    page = None\",\n        \"    \",\n        \"    try:\",\n        \"        async with async_playwright() as p:\",\n        \"            browser = await getattr(p, browser_name).launch(headless=headless)\",\n        \"            page = await browser.new_page()\",\n        \"            \",\n    ]\n    \n    # Convert each event to Playwright code\n    for i, event in enumerate(recorded_events):\n        action = event.get('action')\n        target = event.get('target', '')\n        value = event.get('value', '')\n        description = event.get('description', '')\n        attributes = event.get('attributes', {})\n        \n        # Escape single quotes in strings\n        if value:\n            value = str(value).replace(\"'\", \"\\\\'\")\n        if target:\n            target = str(target).replace(\"'\", \"\\\\'\")\n        \n        if action == 'navigation':\n            # Navigation action\n            code_lines.append(f\"            await page.goto('{target}')\")\n            code_lines.append(f\"            logs.append('Navigated to {target}')\")\n            \n        elif action == 'click':\n            # Check if next event is navigation (click causes page change)\n            next_event = recorded_events[i + 1] if i + 1 < len(recorded_events) else None\n            is_link = attributes.get('tag') == 'a'\n            is_form_submit = attributes.get('type') == 'submit' or attributes.get('isFormSubmit')\n            causes_navigation = (next_event and next_event.get('action') == 'navigation')\n            \n            # If click causes navigation, use expect_navigation\n            if causes_navigation or is_link or is_form_submit:\n                code_lines.append(f\"            # Click that triggers navigation\")\n                code_lines.append(f\"            async with page.expect_navigation():\")\n                code_lines.append(f\"                await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target} and navigated')\")\n            else:\n                # Regular click without navigation\n                code_lines.append(f\"            await page.click('{target}')\")\n                code_lines.append(f\"            logs.append('Clicked {target}')\")\n            \n        elif action == 'type':\n            # Input/fill action\n            code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n            code_lines.append(f\"            logs.append('Typed into {target}')\")\n            \n        elif action == 'change':\n            # Change action (select, checkbox, radio)\n            attributes = event.get('attributes', {})\n            tag = attributes.get('tag', 'unknown')\n            \n            if tag == 'select':\n                code_lines.append(f\"            await page.select_option('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Selected option {value} in {target}')\")\n            elif attributes.get('type') in ['checkbox', 'radio']:\n                if value:  # If checked\n                    code_lines.append(f\"            await page.check('{target}')\")\n                    code_lines.append(f\"            logs.append('Checked {target}')\")\n                else:\n                    code_lines.append(f\"            await page.uncheck('{target}')\")\n                    code_lines.append(f\"            logs.append('Unchecked {target}')\")\n            else:\n                code_lines.append(f\"            await page.fill('{target}', '{value}')\")\n                code_lines.append(f\"            logs.append('Changed {target} to {value}')\")\n                \n        elif action == 'keypress':\n            # Key press action\n            key = event.get('key', 'Enter')\n            code_lines.append(f\"            await page.keyboard.press('{key}')\")\n            code_lines.append(f\"            logs.append('Pressed {key} key')\")\n            \n        elif action == 'dialog':\n            # Dialog detection (alert, confirm, prompt)\n            dialog_type = event.get('dialog_type', 'alert')\n            dialog_message = event.get('target', '').replace(\"'\", \"\\\\'\")\n            code_lines.append(f\"            # Handle {dialog_type} dialog\")\n            code_lines.append(f\"            # Dialog will auto-accept in Playwright\")\n            code_lines.append(f\"            logs.append('Dialog appeared: {dialog_message}')\")\n        \n        elif action == 'dialog_accept':\n            # Dialog acceptance\n            dialog_type = event.get('target', 'dialog')\n            code_lines.append(f\"            logs.append('Accepted {dialog_type}')\")\n        \n        elif action == 'popup_opened':\n            # New window/popup opened\n            popup_url = target.replace(\"'\", \"\\\\'\") if target else 'popup'\n            code_lines.append(f\"            # New popup window opened\")\n            code_lines.append(f\"            # Playwright automatically tracks popup pages\")\n            code_lines.append(f\"            logs.append('Popup opened: {popup_url}')\")\n        \n        elif action == 'page_created':\n            # New tab created\n            page_url = target.replace(\"'\", \"\\\\'\") if target else 'new page'\n            code_lines.append(f\"            # New page/tab opened\")\n            code_lines.append(f\"            logs.append('New page opened: {page_url}')\")\n        \n        elif action == 'frame_attached':\n            # iFrame/widget loaded\n            frame_name = event.get('frame_name', 'widget')\n            code_lines.append(f\"            # Frame/Widget loaded: {frame_name}\")\n            code_lines.append(f\"            logs.append('Frame attached: {frame_name}')\")\n            \n        elif action == 'form_submit':\n            # Form submission - press Enter on the form\n            code_lines.append(f\"            await page.keyboard.press('Enter')\")\n            code_lines.append(f\"            logs.append('Submitted form')\")\n    \n    code_lines.extend([\n        \"            \",\n        \"            # Take screenshot before closing\",\n        \"            screenshot = await page.screenshot()\",\n        \"            logs.append('Screenshot captured')\",\n        \"            \",\n        \"            await browser.close()\",\n        \"            return {'success': True, 'logs': logs, 'screenshot': screenshot}\",\n        \"    \",\n        \"    except Exception as e:\",\n        \"        logs.append(f'Error: {str(e)}')\",\n        \"        if 'page' in locals():\",\n        \"            try:\",\n        \"                screenshot = await page.screenshot()\",\n        \"            except:\",\n        \"                pass\",\n        \"        if 'browser' in locals():\",\n        \"            try:\",\n        \"                await browser.close()\",\n        \"            except:\",\n        \"                pass\",\n        \"        return {'success': False, 'logs': logs, 'screenshot': screenshot}\"\n    ])\n    \n    return \"\\n\".join(code_lines)\n\n\n@app.after_request\ndef add_header(response):\n    \"\"\"Add cache-control headers to prevent caching issues in iframe\"\"\"\n    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n    response.headers['Pragma'] = 'no-cache'\n    response.headers['Expires'] = '0'\n    return response\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/api/history')\ndef get_history():\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT * FROM test_history ORDER BY created_at DESC LIMIT 50')\n    rows = c.fetchall()\n    conn.close()\n    \n    history = []\n    for row in rows:\n        history.append({\n            'id': row[0],\n            'command': row[1],\n            'generated_code': row[2],\n            'healed_code': row[3],\n            'browser': row[4],\n            'mode': row[5],\n            'execution_location': row[6],\n            'status': row[7],\n            'logs': row[8],\n            'screenshot_path': row[9],\n            'created_at': row[10]\n        })\n    \n    return jsonify(history)\n\n@app.route('/api/history/<int:history_id>', methods=['DELETE'])\ndef delete_history_item(history_id):\n    \"\"\"Delete a single history item.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM test_history WHERE id=?', (history_id,))\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True, 'message': 'History item deleted'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/history/all', methods=['DELETE'])\ndef delete_all_history():\n    \"\"\"Delete all history items.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM test_history')\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True, 'message': 'All history deleted'})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/history/rerun/<int:history_id>', methods=['POST'])\ndef rerun_from_history(history_id):\n    \"\"\"Re-execute a test from history using healed code if available, otherwise generated code.\"\"\"\n    try:\n        data = request.json or {}\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT command, generated_code, healed_code, browser, mode, execution_location FROM test_history WHERE id=?', (history_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return jsonify({'error': 'History item not found'}), 404\n        \n        command, generated_code, healed_code, browser, mode, execution_location = row\n        \n        code_to_use = healed_code if healed_code else generated_code\n        code_source = 'healed' if healed_code else 'generated'\n        \n        use_healing = data.get('use_healing', True)\n        auto_save = data.get('auto_save', False)\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, healed_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, healed_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        print(f\"🔄 Re-running test from history #{history_id} as test #{test_id}\")\n        print(f\"   Using {code_source} code\")\n        print(f\"   Command: {command}\")\n        \n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if use_healing:\n                socketio.start_background_task(execute_agent_with_healing, test_id, code_to_use, browser, mode, auto_save=auto_save, original_command=command)\n            else:\n                if agent_sid:\n                    socketio.emit('execute_on_agent', {\n                        'test_id': test_id,\n                        'code': code_to_use,\n                        'browser': browser,\n                        'mode': mode\n                    }, to=agent_sid)\n                else:\n                    return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id,\n            'code': code_to_use,\n            'code_source': code_source,\n            'original_history_id': history_id,\n            'command': command\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_test():\n    \"\"\"\n    UNIFIED AUTOMATION ENDPOINT\n    Intelligently routes to MCP or Code Generation based on task analysis.\n    No more manual engine selection - the system decides!\n    \"\"\"\n    data = request.json or {}\n    command = data.get('command')\n    browser = data.get('browser', 'chromium')\n    mode = data.get('mode', 'headless')\n    execution_location = data.get('execution_location', 'server')\n    use_healing = data.get('use_healing', True)\n    auto_save = data.get('auto_save', False)\n    \n    # Backward compatibility: accept automation_engine but ignore it\n    # The unified engine will make its own intelligent decision\n    _ = data.get('automation_engine', None)  # Ignored\n    \n    if not command:\n        return jsonify({'error': 'Command is required'}), 400\n    \n    # Server execution only for now (agent execution maintained for compatibility)\n    if execution_location != 'server':\n        # Fall back to legacy agent execution\n        return _execute_legacy_agent(command, browser, mode, use_healing, auto_save)\n    \n    try:\n        print(f\"\\n🎯 UNIFIED AUTOMATION ENGINE\")\n        print(f\"   Command: {command}\")\n        print(f\"   Browser: {browser}, Mode: {mode}\")\n        \n        headless = mode == 'headless'\n        \n        # Create test history entry\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (command, '[Unified Engine - Analyzing...]', browser, mode, 'server', 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute with unified engine in background\n        def run_unified_automation():\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            try:\n                result = loop.run_until_complete(\n                    unified_engine.execute(test_id, command, browser, headless)\n                )\n                \n                # Emit final result\n                socketio.emit('execution_result', {\n                    'test_id': test_id,\n                    'success': result['success'],\n                    'logs': result['logs'],\n                    'screenshot': result.get('screenshot'),\n                    'code': result.get('code')\n                })\n                \n                # Update database with final code and results\n                conn = sqlite3.connect(app.config['DATABASE_PATH'])\n                c = conn.cursor()\n                \n                final_code = result.get('code') or '[Unified Engine Execution]'\n                screenshot_path = None\n                \n                if result.get('screenshot'):\n                    screenshot_path = f\"screenshots/unified_{test_id}.png\"\n                    screenshot_full_path = os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path)\n                    os.makedirs(os.path.dirname(screenshot_full_path), exist_ok=True)\n                    with open(screenshot_full_path, 'wb') as f:\n                        f.write(base64.b64decode(result['screenshot']))\n                \n                c.execute('UPDATE test_history SET status = ?, logs = ?, screenshot_path = ?, generated_code = ? WHERE id = ?',\n                          ('success' if result['success'] else 'failed',\n                           json.dumps(result['logs']),\n                           screenshot_path,\n                           final_code,\n                           test_id))\n                conn.commit()\n                conn.close()\n                \n            except Exception as e:\n                import traceback\n                traceback.print_exc()\n                \n                # Emit error\n                socketio.emit('execution_result', {\n                    'test_id': test_id,\n                    'success': False,\n                    'logs': [f\"❌ Execution error: {str(e)}\"],\n                    'screenshot': None,\n                    'code': None\n                })\n                \n                # Update database with error\n                conn = sqlite3.connect(app.config['DATABASE_PATH'])\n                c = conn.cursor()\n                c.execute('UPDATE test_history SET status = ?, logs = ? WHERE id = ?',\n                          ('failed', json.dumps([f\"Error: {str(e)}\"]), test_id))\n                conn.commit()\n                conn.close()\n            finally:\n                loop.close()\n        \n        socketio.start_background_task(run_unified_automation)\n        \n        return jsonify({\n            'test_id': test_id,\n            'code': '[Unified Engine - Strategy will be selected automatically]',\n            'code_source': 'unified',\n            'automation_engine': 'unified'\n        })\n        \n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': f'Unified automation failed: {str(e)}'}), 500\n\n\ndef _execute_legacy_agent(command, browser, mode, use_healing, auto_save):\n    \"\"\"Legacy agent execution path (for backward compatibility)\"\"\"\n    try:\n        # Generate code using legacy method\n        generated_code = generate_playwright_code(command, browser)\n        \n        validator = CodeValidator()\n        if not validator.validate(generated_code):\n            error_msg = \"Code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, browser, mode, 'agent', 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Agent execution\n        agent_sid = None\n        for sid in connected_agents:\n            agent_sid = sid\n            break\n        \n        if use_healing:\n            socketio.start_background_task(execute_agent_with_healing, test_id, generated_code, browser, mode, auto_save=auto_save, original_command=command)\n        else:\n            if agent_sid:\n                socketio.emit('execute_on_agent', {\n                    'test_id': test_id,\n                    'code': generated_code,\n                    'browser': browser,\n                    'mode': mode\n                }, to=agent_sid)\n            else:\n                return jsonify({'error': 'No agent connected'}), 503\n        \n        return jsonify({\n            'test_id': test_id,\n            'code': generated_code,\n            'code_source': 'generated'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\ndef execute_on_server(test_id, code, browser, mode, auto_save=False, original_command=None):\n    executor = ServerExecutor()\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on server in {mode} mode...'\n    })\n    \n    result = executor.execute(code, browser, headless)\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    code = code if code else 'No code generated.'\n\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=code,\n                description=f\"Auto-saved from successful execution in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    # SELF-LEARNING: Record execution for continuous improvement\n    if original_command:\n        self_learning_engine.learn_from_execution(\n            command=original_command,\n            code=code,\n            result=result,\n            healing_attempts=0,\n            url=''\n        )\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path\n    })\n\ndef execute_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing with healing in {mode} mode...'\n    })\n    \n    try:\n        result = asyncio.run(healing_executor.execute_with_healing(code, browser, headless, test_id))\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\n💾 SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ✅ Database updated successfully\", flush=True)\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from successful {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    # SELF-LEARNING: Record healing execution for continuous improvement\n    if original_command:\n        healing_attempts = len(healing_executor.failed_locators) if hasattr(healing_executor, 'failed_locators') else 0\n        final_code = healed_code if healed_code else code\n        \n        self_learning_engine.learn_from_execution(\n            command=original_command,\n            code=final_code,\n            result=result,\n            healing_attempts=healing_attempts,\n            url=''\n        )\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\ndef execute_agent_with_healing(test_id, code, browser, mode, auto_save=False, original_command=None):\n    \"\"\"Execute automation on agent with server-coordinated healing.\"\"\"\n    import gevent\n    from gevent.event import AsyncResult\n    \n    # Find the agent's session ID\n    agent_sid = None\n    for sid in connected_agents:\n        agent_sid = sid\n        break  # Get the first available agent\n    \n    healing_executor = HealingExecutor(socketio, api_key=openai_api_key)\n    healing_executor.execution_mode = 'agent'  # Mark as agent execution\n    healing_executor.agent_sid = agent_sid  # Store agent session ID\n    # Use gevent AsyncResult for cross-greenlet communication\n    healing_executor.agent_result_async = AsyncResult()\n    active_healing_executors[test_id] = healing_executor\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on agent with healing in {mode} mode...'\n    })\n    \n    # Run async code synchronously using gevent - NO asyncio.run()\n    # This keeps us in the same greenlet so socket.io handlers can communicate\n    async def _run_healing():\n        return await healing_executor.execute_with_healing(code, browser, headless, test_id)\n    \n    try:\n        # Use gevent to wrap the async function\n        import nest_asyncio\n        nest_asyncio.apply()\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        try:\n            result = loop.run_until_complete(_run_healing())\n        finally:\n            loop.close()\n    finally:\n        if test_id in active_healing_executors:\n            del active_healing_executors[test_id]\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', [])) if result.get('logs') else '[]'\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    print(f\"\\n💾 SAVING TO DATABASE:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  status: {status}\")\n    print(f\"  healed_code is None: {healed_code is None}\")\n    print(f\"  healed_code length: {len(healed_code) if healed_code else 0}\", flush=True)\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    # Auto-save successful healed executions as learned tasks\n    if auto_save and result.get('success') and original_command and semantic_search:\n        try:\n            # Use healed code if available, otherwise use original code\n            final_code = healed_code if healed_code else code\n            task_id = str(uuid.uuid4())\n            task_name = original_command[:100]  # Limit name length\n            \n            task = LearnedTask(\n                task_id=task_id,\n                task_name=task_name,\n                playwright_code=final_code,\n                description=f\"Auto-saved from agent {'healed' if healed_code else 'execution'} in {mode} mode\",\n                steps=[],\n                tags=[mode, browser, 'auto-saved', 'agent', 'healed' if healed_code else 'standard']\n            )\n            task.save()\n            \n            # Index for semantic search\n            semantic_search.index_task(task)\n            print(f\"✅ Auto-saved successful agent {'healed ' if healed_code else ''}execution as learned task: '{task_name}'\")\n            \n            socketio.emit('task_auto_saved', {\n                'test_id': test_id,\n                'task_id': task_id,\n                'task_name': task_name,\n                'was_healed': bool(healed_code)\n            })\n        except Exception as e:\n            print(f\"⚠️  Failed to auto-save task: {e}\")\n    \n    print(f\"  ✅ Database updated successfully\", flush=True)\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\n@app.route('/api/heal', methods=['POST'])\ndef heal_locator():\n    data = request.json or {}\n    test_id = data.get('test_id')\n    failed_locator = data.get('failed_locator')\n    healed_locator = data.get('healed_locator')\n    \n    if not all([test_id, failed_locator, healed_locator]):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT generated_code, healed_code FROM test_history WHERE id=?', (test_id,))\n        row = c.fetchone()\n        \n        if not row:\n            return jsonify({'error': 'Test not found'}), 404\n        \n        original_code = row[0]\n        current_healed = row[1] or original_code\n        \n        new_healed = current_healed.replace(failed_locator, healed_locator)\n        \n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (new_healed, test_id))\n        conn.commit()\n        conn.close()\n        \n        socketio.emit('script_healed', {\n            'test_id': test_id,\n            'healed_script': new_healed,\n            'failed_locator': failed_locator,\n            'healed_locator': healed_locator\n        })\n        \n        return jsonify({'success': True, 'healed_script': new_healed})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/uploads/<path:filename>')\ndef uploaded_file(filename):\n    return send_from_directory(UPLOAD_DIR_ABS, filename)\n\n@app.route('/api/agent/download')\ndef download_agent():\n    # Get the current server URL dynamically\n    replit_domain = os.environ.get('REPLIT_DEV_DOMAIN', 'localhost:5000')\n    server_url = f'https://{replit_domain}' if replit_domain != 'localhost:5000' else 'http://localhost:5000'\n    \n    # Read the local agent file\n    with open('visionvault/agents/local_agent.py', 'r', encoding='utf-8') as f:\n        agent_code = f.read()\n    \n    # Replace the default port in get_server_url to prioritize the current server\n    # This ensures downloaded agent connects to the right server by default\n    agent_code = agent_code.replace(\n        'local_ports = [5000, 8000, 3000, 7890]',\n        f'# Auto-configured for this server\\n    local_ports = [{replit_domain.split(\":\")[-1] if \":\" in replit_domain else \"5000\"}, 5000, 8000, 3000, 7890]'\n    )\n    \n    # Also add the server URL as a comment for reference\n    agent_code = f'# Auto-downloaded from: {server_url}\\n# This agent will automatically connect to the server\\n\\n{agent_code}'\n    \n    # Create a temporary response with the modified content\n    return Response(\n        agent_code,\n        mimetype='text/x-python',\n        headers={'Content-Disposition': 'attachment; filename=local_agent.py'}\n    )\n\n# ========== Persistent Learning API Endpoints ==========\n\n@app.route('/api/tasks', methods=['GET'])\ndef get_all_tasks():\n    \"\"\"Get all learned tasks.\"\"\"\n    try:\n        limit = request.args.get('limit', 100, type=int)\n        tasks = LearnedTask.get_all(limit=limit)\n        return jsonify([task.to_dict() for task in tasks])\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['GET'])\ndef get_task(task_id):\n    \"\"\"Get a specific learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        return jsonify(task.to_dict())\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/save', methods=['POST'])\ndef save_learned_task():\n    \"\"\"Save a new learned task or update existing one.\"\"\"\n    try:\n        data = request.json or {}\n        \n        # Extract task data\n        task_id = data.get('task_id') or str(uuid.uuid4())\n        task_name = data.get('task_name')\n        playwright_code = data.get('playwright_code')\n        description = data.get('description', '')\n        steps = data.get('steps', [])\n        tags = data.get('tags', [])\n        \n        if not task_name or not playwright_code:\n            return jsonify({'error': 'task_name and playwright_code are required'}), 400\n        \n        # Create task object\n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags\n        )\n        \n        # Save to database\n        task.save()\n        \n        # Index for semantic search\n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"✅ Task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"⚠️ Failed to index task for search: {e}\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict()\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>', methods=['DELETE'])\ndef delete_task(task_id):\n    \"\"\"Delete a learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Remove from semantic search index\n        if semantic_search:\n            semantic_search.delete_task_from_index(task_id)\n        \n        # Delete from database\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('DELETE FROM learned_tasks WHERE task_id=?', (task_id,))\n        conn.commit()\n        conn.close()\n        \n        return jsonify({'success': True})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/search', methods=['POST'])\ndef search_tasks():\n    \"\"\"Search for tasks using natural language.\"\"\"\n    try:\n        data = request.json or {}\n        query = data.get('query')\n        top_k = data.get('top_k', 5)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Semantic search requires an OpenAI API key to generate embeddings.'\n            }), 400\n        \n        # Search for relevant tasks\n        results = semantic_search.search_tasks(query, top_k=top_k)\n        \n        return jsonify({\n            'query': query,\n            'results': results\n        })\n    except Exception as e:\n        error_msg = str(e)\n        # Check if it's an API key or embedding-related error\n        if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n            return jsonify({\n                'error': f'OPENAI_API_KEY error: {error_msg}'\n            }), 400\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/<task_id>/execute', methods=['POST'])\ndef execute_learned_task(task_id):\n    \"\"\"Execute a learned task.\"\"\"\n    try:\n        data = request.json or {}\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        \n        # Get the task\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Use the task's code instead of generating new code\n        code = task.playwright_code\n        \n        # Validate the code\n        validator = CodeValidator()\n        if not validator.validate(code):\n            error_msg = \"Task code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        # Create a test history entry for tracking\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (f\"Learned Task: {task.task_name}\", code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        # Execute the task\n        if execution_location == 'server':\n            socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n        else:\n            agent_sid = None\n            for sid in connected_agents:\n                agent_sid = sid\n                break\n            \n            if agent_sid:\n                socketio.emit('execute_on_agent', {\n                    'test_id': test_id,\n                    'code': code,\n                    'browser': browser,\n                    'mode': mode\n                }, to=agent_sid)\n            else:\n                return jsonify({'error': 'No agent connected'}), 503\n        \n        # Update task execution stats\n        start_time = time.time()\n        \n        # Record execution in background\n        def record_execution():\n            # Wait a bit for execution to complete\n            time.sleep(2)\n            \n            # Get execution result from test_history\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('SELECT status, logs FROM test_history WHERE id=?', (test_id,))\n            row = c.fetchone()\n            \n            if row:\n                status = row[0]\n                logs = row[1]\n                success = status == 'success'\n                \n                # Update task stats\n                task = LearnedTask.get_by_id(task_id)\n                if task:\n                    if success:\n                        task.success_count += 1\n                    else:\n                        task.failure_count += 1\n                    task.last_executed = datetime.now()\n                    task.save()\n                \n                # Record execution\n                execution_time = int((time.time() - start_time) * 1000)\n                execution = TaskExecution(\n                    task_id=task_id,\n                    execution_result=status,\n                    success=success,\n                    error_message=logs if not success else None,\n                    execution_time_ms=execution_time\n                )\n                execution.save()\n            \n            conn.close()\n        \n        socketio.start_background_task(record_execution)\n        \n        return jsonify({\n            'test_id': test_id,\n            'task_name': task.task_name,\n            'message': 'Task execution started'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/tasks/recall', methods=['POST'])\ndef recall_and_execute():\n    \"\"\"\n    Recall Mode: Search for a task by natural language and execute it.\n    This is the main entry point for the persistent learning system.\n    \"\"\"\n    try:\n        data = request.json or {}\n        query = data.get('query')\n        browser = data.get('browser', 'chromium')\n        mode = data.get('mode', 'headless')\n        execution_location = data.get('execution_location', 'server')\n        auto_execute = data.get('auto_execute', False)\n        \n        if not query:\n            return jsonify({'error': 'query is required'}), 400\n        \n        if not semantic_search:\n            return jsonify({\n                'error': 'OPENAI_API_KEY is not set. Recall Mode requires an OpenAI API key to search for tasks.'\n            }), 400\n        \n        # Search for the most relevant task\n        try:\n            results = semantic_search.search_tasks(query, top_k=1)\n        except Exception as search_error:\n            error_msg = str(search_error)\n            if any(keyword in error_msg.lower() for keyword in ['api', 'key', 'embedding', 'openai', 'authentication', 'unauthorized']):\n                return jsonify({\n                    'error': f'OPENAI_API_KEY error: {error_msg}'\n                }), 400\n            raise\n        \n        if not results:\n            return jsonify({\n                'found': False,\n                'message': 'No matching tasks found. Consider creating a new task.'\n            })\n        \n        # Get the best match\n        best_match = results[0]\n        task_id = best_match['task_id']\n        similarity_score = best_match.get('similarity_score', 0)\n        \n        # If auto_execute is True and similarity is high enough, execute immediately\n        if auto_execute and similarity_score > 0.7:\n            # Execute the task\n            task = LearnedTask.get_by_id(task_id)\n            if not task:\n                return jsonify({'error': 'Task not found'}), 404\n            code = task.playwright_code\n            \n            # Create test history entry\n            conn = sqlite3.connect(app.config['DATABASE_PATH'])\n            c = conn.cursor()\n            c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                      (query, code, browser, mode, execution_location, 'pending'))\n            test_id = c.lastrowid\n            conn.commit()\n            conn.close()\n            \n            # Execute\n            if execution_location == 'server':\n                socketio.start_background_task(execute_on_server, test_id, code, browser, mode)\n            \n            return jsonify({\n                'found': True,\n                'executed': True,\n                'test_id': test_id,\n                'task': best_match,\n                'similarity_score': similarity_score\n            })\n        else:\n            # Return the best match for user confirmation\n            return jsonify({\n                'found': True,\n                'executed': False,\n                'task': best_match,\n                'similarity_score': similarity_score,\n                'message': 'Task found. Please confirm execution or adjust the query.'\n            })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# ========== Script Management API Endpoints ==========\n\n@app.route('/api/scripts/download/history/<int:history_id>', methods=['GET'])\ndef download_script_from_history(history_id):\n    \"\"\"Download a Playwright script from test history.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT command, generated_code, healed_code FROM test_history WHERE id=?', (history_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return jsonify({'error': 'History item not found'}), 404\n        \n        command, generated_code, healed_code = row\n        \n        # Use healed code if available, otherwise use generated code\n        script_code = healed_code if healed_code else generated_code\n        script_type = 'healed' if healed_code else 'generated'\n        \n        # Create a safe filename from the command\n        safe_command = re.sub(r'[^\\w\\s-]', '', command)[:50]\n        safe_command = re.sub(r'[-\\s]+', '_', safe_command)\n        filename = f\"automation_{safe_command}_{script_type}_{history_id}.py\"\n        \n        return Response(\n            script_code,\n            mimetype='text/x-python',\n            headers={'Content-Disposition': f'attachment; filename={filename}'}\n        )\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/scripts/download/task/<task_id>', methods=['GET'])\ndef download_script_from_task(task_id):\n    \"\"\"Download a Playwright script from a learned task.\"\"\"\n    try:\n        task = LearnedTask.get_by_id(task_id)\n        if not task:\n            return jsonify({'error': 'Task not found'}), 404\n        \n        # Create a safe filename from the task name\n        safe_name = re.sub(r'[^\\w\\s-]', '', task.task_name)[:50]\n        safe_name = re.sub(r'[-\\s]+', '_', safe_name)\n        filename = f\"task_{safe_name}.py\"\n        \n        return Response(\n            task.playwright_code,\n            mimetype='text/x-python',\n            headers={'Content-Disposition': f'attachment; filename={filename}'}\n        )\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/scripts/list', methods=['GET'])\ndef list_all_scripts():\n    \"\"\"List all available scripts from test history and learned tasks.\"\"\"\n    try:\n        scripts = []\n        \n        # Get scripts from test history\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('''SELECT id, command, status, created_at, generated_code, healed_code \n                     FROM test_history ORDER BY created_at DESC LIMIT 50''')\n        history_rows = c.fetchall()\n        \n        for row in history_rows:\n            history_id, command, status, created_at, generated_code, healed_code = row\n            has_healed = bool(healed_code)\n            \n            scripts.append({\n                'id': f'history_{history_id}',\n                'source': 'history',\n                'history_id': history_id,\n                'name': command[:100],\n                'description': 'Generated from natural language command',\n                'status': status,\n                'has_healed': has_healed,\n                'script_type': 'healed' if has_healed else 'generated',\n                'created_at': created_at,\n                'download_url': f'/api/scripts/download/history/{history_id}'\n            })\n        \n        # Get scripts from learned tasks\n        c.execute('''SELECT task_id, task_name, description, success_count, failure_count, \n                     created_at FROM learned_tasks ORDER BY created_at DESC LIMIT 50''')\n        task_rows = c.fetchall()\n        \n        for row in task_rows:\n            task_id, task_name, description, success_count, failure_count, created_at = row\n            success_rate = (success_count / (success_count + failure_count) * 100) if (success_count + failure_count) > 0 else 0\n            \n            scripts.append({\n                'id': f'task_{task_id}',\n                'source': 'task',\n                'task_id': task_id,\n                'name': task_name,\n                'description': description or 'Learned automation task',\n                'success_count': success_count,\n                'failure_count': failure_count,\n                'success_rate': round(success_rate, 1),\n                'created_at': created_at,\n                'download_url': f'/api/scripts/download/task/{task_id}'\n            })\n        \n        conn.close()\n        \n        return jsonify({'scripts': scripts})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/scripts/compare/<int:history_id>', methods=['GET'])\ndef compare_scripts(history_id):\n    \"\"\"Compare original and healed scripts to show what changed.\"\"\"\n    try:\n        conn = sqlite3.connect(app.config['DATABASE_PATH'])\n        c = conn.cursor()\n        c.execute('SELECT command, generated_code, healed_code FROM test_history WHERE id=?', (history_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return jsonify({'error': 'History item not found'}), 404\n        \n        command, generated_code, healed_code = row\n        \n        if not healed_code:\n            return jsonify({\n                'has_healed': False,\n                'message': 'No healing was performed on this script'\n            })\n        \n        # Simple diff - find differences\n        gen_lines = generated_code.split('\\n')\n        healed_lines = healed_code.split('\\n')\n        \n        changes = []\n        for i, (gen_line, healed_line) in enumerate(zip(gen_lines, healed_lines), 1):\n            if gen_line != healed_line:\n                changes.append({\n                    'line': i,\n                    'original': gen_line,\n                    'healed': healed_line\n                })\n        \n        return jsonify({\n            'has_healed': True,\n            'command': command,\n            'generated_code': generated_code,\n            'healed_code': healed_code,\n            'changes': changes,\n            'total_changes': len(changes)\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Teaching Mode Recording - Store recorded actions by session\nrecording_sessions = {}\n\n@app.route('/api/teaching/start', methods=['POST'])\ndef start_teaching_recording():\n    \"\"\"Start interactive recording session for Teaching Mode - routes to agent.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id') or str(uuid.uuid4())\n        # Don't provide default URL - let browser open blank (like Playwright codegen)\n        start_url = data.get('start_url', '')\n        \n        # Check if any agent is connected\n        if not connected_agents:\n            return jsonify({\n                'error': 'No agent connected. Please connect a local agent to use Teaching Mode.',\n                'session_id': session_id\n            }), 400\n        \n        # Initialize recording session\n        recording_sessions[session_id] = {\n            'actions': [],\n            'start_time': time.time(),\n            'start_url': start_url\n        }\n        \n        # Emit start_recording event to agent\n        socketio.emit('start_recording', {\n            'session_id': session_id,\n            'start_url': start_url\n        })\n        \n        print(f\"📤 Sent start_recording to agent for session {session_id}\")\n        \n        return jsonify({\n            'success': True,\n            'session_id': session_id,\n            'message': 'Recording request sent to agent. Browser will open on your machine.'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/navigate', methods=['POST'])\ndef teaching_navigate():\n    \"\"\"Navigate to a URL during recording.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        url = data.get('url')\n        \n        if not session_id or session_id not in active_recorders:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        recorder = active_recorders[session_id]\n        loop = active_loops.get(session_id)\n        \n        if not loop or not recorder.page:\n            return jsonify({'error': 'Recording session not ready'}), 400\n        \n        # Run navigation using the session's event loop\n        try:\n            asyncio.run_coroutine_threadsafe(recorder.page.goto(url), loop).result(timeout=10)\n            recorder.record_goto(url)\n            return jsonify({'success': True})\n        except Exception as e:\n            print(f\"Navigation error: {e}\")\n            return jsonify({'error': str(e)}), 500\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/actions', methods=['GET'])\ndef get_teaching_actions():\n    \"\"\"Get currently recorded actions.\"\"\"\n    try:\n        session_id = request.args.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'actions': []})\n        \n        session = recording_sessions[session_id]\n        return jsonify({'actions': session.get('actions', [])})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/stop', methods=['POST'])\ndef stop_teaching_recording():\n    \"\"\"Stop recording and return captured actions.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        \n        if not session_id or session_id not in recording_sessions:\n            return jsonify({'error': 'No active recording session'}), 400\n        \n        # Emit stop_recording event to agent\n        socketio.emit('stop_recording', {\n            'session_id': session_id\n        })\n        \n        print(f\"📤 Sent stop_recording to agent for session {session_id}\")\n        \n        # Return success - actual actions will come via recording_stopped event\n        return jsonify({\n            'success': True,\n            'message': 'Stop request sent to agent'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/teaching/save_to_library', methods=['POST'])\ndef save_recording_to_library():\n    \"\"\"Save a recorded session to the task library.\"\"\"\n    try:\n        data = request.json or {}\n        session_id = data.get('session_id')\n        task_name = data.get('task_name')\n        description = data.get('description', '')\n        tags = data.get('tags', [])\n        \n        if not session_id or not task_name:\n            return jsonify({'error': 'session_id and task_name are required'}), 400\n        \n        session = recording_sessions.get(session_id)\n        if not session:\n            return jsonify({'error': 'Recording session not found'}), 404\n        \n        playwright_code = session.get('playwright_code')\n        actions = session.get('actions', [])\n        \n        if not playwright_code:\n            return jsonify({'error': 'No recorded code available'}), 400\n        \n        task_id = str(uuid.uuid4())\n        \n        steps = [{'step': i+1, 'description': action.get('description', '')} \n                 for i, action in enumerate(actions)]\n        \n        task = LearnedTask(\n            task_id=task_id,\n            task_name=task_name,\n            playwright_code=playwright_code,\n            description=description,\n            steps=steps,\n            tags=tags + ['recorded', 'teaching-mode']\n        )\n        \n        task.save()\n        \n        if semantic_search:\n            try:\n                semantic_search.index_task(task)\n                print(f\"✅ Recorded task '{task_name}' indexed for semantic search\")\n            except Exception as e:\n                print(f\"⚠️ Failed to index task for search: {e}\")\n        \n        print(f\"✅ Recording saved to task library: {task_name} ({task_id})\")\n        \n        return jsonify({\n            'success': True,\n            'task': task.to_dict(),\n            'message': f'Task \"{task_name}\" saved to library'\n        })\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return jsonify({'error': str(e)}), 500\n\n\n@socketio.on('connect')\ndef handle_connect():\n    print(f'Client connected: {request.sid}')\n    emit('connected', {'sid': request.sid})\n    # Send current list of connected agents to newly connected web client\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print(f'Client disconnected: {request.sid}')\n    if request.sid in connected_agents:\n        del connected_agents[request.sid]\n        print(f'Updated connected_agents after disconnect: {connected_agents}')\n        socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_register')\ndef handle_agent_register(data):\n    agent_id = data.get('agent_id')\n    connected_agents[request.sid] = {\n        'agent_id': agent_id,\n        'browsers': data.get('browsers', []),\n        'connected_at': datetime.now().isoformat()\n    }\n    print(f'Agent registered: {agent_id}')\n    print(f'Updated connected_agents after register: {connected_agents}')\n    emit('agent_registered', {'status': 'success'})\n    print(f'Emitting agents_update: {list(connected_agents.values())}')\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_result')\ndef handle_agent_result(data):\n    test_id = data.get('test_id')\n    success = data.get('success')\n    logs = data.get('logs', [])\n    screenshot_data = data.get('screenshot')\n    \n    screenshot_path = None\n    if screenshot_data:\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        screenshot_bytes = base64.b64decode(screenshot_data)\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(screenshot_bytes)\n    \n    logs_json = json.dumps(logs)\n    status = 'success' if success else 'failed'\n    \n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': logs,\n        'screenshot_path': screenshot_path\n    })\n\n@socketio.on('agent_log')\ndef handle_agent_log(data):\n    socketio.emit('execution_status', {\n        'test_id': data.get('test_id'),\n        'status': 'running',\n        'message': data.get('message')\n    })\n\n\n@socketio.on('heartbeat')\ndef handle_heartbeat(data):\n    \"\"\"Handle heartbeat from agent to keep connection alive.\"\"\"\n    # Simply acknowledge - the ping/pong mechanism handles the rest\n    # This prevents timeout on idle connections\n    pass\n\n@socketio.on('recording_started')\ndef handle_recording_started(data):\n    \"\"\"Handle recording started event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        print(f\"✅ Recording session {session_id} started on agent\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'started',\n            'message': data.get('message', 'Browser opened on agent machine')\n        })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"❌ Recording session {session_id} failed to start: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_actions')\ndef handle_recording_actions(data):\n    \"\"\"Handle periodic action updates from agent.\"\"\"\n    session_id = data.get('session_id')\n    actions = data.get('actions', [])\n    \n    if session_id in recording_sessions:\n        recording_sessions[session_id]['actions'].extend(actions)\n        print(f\"📥 Received {len(actions)} actions for session {session_id}. Total: {len(recording_sessions[session_id]['actions'])}\")\n\n\n@socketio.on('recording_stopped')\ndef handle_recording_stopped(data):\n    \"\"\"Handle recording stopped event from agent.\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'success':\n        final_actions = data.get('final_actions', [])\n        \n        if session_id in recording_sessions:\n            # Add final actions\n            recording_sessions[session_id]['actions'].extend(final_actions)\n            all_actions = recording_sessions[session_id]['actions']\n            \n            print(f\"✅ Recording session {session_id} stopped. Total actions: {len(all_actions)}\")\n            \n            # Generate Playwright code from recorded actions\n            playwright_code = None\n            try:\n                if all_actions:\n                    playwright_code = generate_playwright_code_from_recording(all_actions)\n                    print(f\"✅ Generated Playwright code from {len(all_actions)} actions\")\n            except Exception as e:\n                print(f\"⚠️ Error generating Playwright code: {e}\")\n            \n            # Emit to web client with both actions and generated code\n            socketio.emit('recording_complete', {\n                'session_id': session_id,\n                'actions': all_actions,\n                'playwright_code': playwright_code\n            })\n    else:\n        error = data.get('error', 'Unknown error')\n        print(f\"❌ Recording session {session_id} stop failed: {error}\")\n        socketio.emit('recording_status', {\n            'session_id': session_id,\n            'status': 'error',\n            'error': error\n        })\n\n\n@socketio.on('recording_status')\ndef handle_recording_status(data):\n    \"\"\"Handle recording status updates from agent (including auto-stop on browser close).\"\"\"\n    session_id = data.get('session_id')\n    status = data.get('status')\n    \n    if status == 'stopped':\n        playwright_code = data.get('playwright_code')\n        actions = data.get('actions', [])\n        auto_stopped = data.get('auto_stopped', False)\n        \n        print(f\"✅ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped\")\n        print(f\"   Playwright code: {'Yes' if playwright_code else 'No'}\")\n        print(f\"   Actions extracted: {len(actions)}\")\n        \n        if session_id in recording_sessions:\n            recording_sessions[session_id]['playwright_code'] = playwright_code\n            recording_sessions[session_id]['actions'] = actions\n        else:\n            recording_sessions[session_id] = {\n                'playwright_code': playwright_code,\n                'actions': actions,\n                'start_time': time.time()\n            }\n        \n        socketio.emit('recording_complete', {\n            'session_id': session_id,\n            'playwright_code': playwright_code,\n            'actions': actions,\n            'auto_stopped': auto_stopped,\n            'message': 'Browser closed. Recording stopped automatically.' if auto_stopped else 'Recording stopped.'\n        })\n    else:\n        socketio.emit('recording_status', data)\n\n\n@socketio.on('element_selected')\ndef handle_element_selected(data):\n    test_id = data.get('test_id')\n    selector = data.get('selector')\n    failed_locator = data.get('failed_locator')  # Agent should send this\n    \n    print(f\"\\n✅ ELEMENT SELECTED EVENT RECEIVED:\")\n    print(f\"  test_id: {test_id}\")\n    print(f\"  selector: {selector}\")\n    print(f\"  failed_locator: {failed_locator}\", flush=True)\n    \n    # Get the generated code, browser, and mode from database\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT generated_code, browser, mode FROM test_history WHERE id=?', (test_id,))\n    row = c.fetchone()\n    \n    if not row:\n        print(f\"  ❌ Test {test_id} not found in database\", flush=True)\n        conn.close()\n        socketio.emit('error', {\n            'test_id': test_id,\n            'message': 'Test not found in database'\n        })\n        return\n    \n    generated_code, browser, mode = row\n    \n    # If failed_locator not provided by agent, try to extract from healing_executor\n    if not failed_locator and test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        if healing_executor.failed_locators:\n            failed_locator = healing_executor.failed_locators[-1]['locator']\n    \n    # Heal the script - replace the entire failed locator method call\n    healed_code = generated_code\n    \n    if failed_locator and selector:\n        import re\n        \n        # If failed_locator is a full method call (e.g., 'page.get_by_placeholder(\"Search\")'),\n        # replace the entire method call with the healed selector\n        if 'page.' in failed_locator or 'get_by_' in failed_locator or 'locator(' in failed_locator:\n            # Try flexible replacement that handles quote variations\n            replacement_made = False\n            \n            # Extract the method and selector from failed_locator\n            # E.g., page.locator(\"input[name=\\\"q\\\"]\") -> method=page.locator, selector_content=input[name=\"q\"]\n            # Handle complex locators with nested parentheses like: page.locator(\"button:has-text(\\\"Start Chat\\\")\")\n            method_match = re.search(r'(page\\.\\w+)\\((.+)\\)$', failed_locator)\n            if method_match:\n                method_name = method_match.group(1)\n                full_args = method_match.group(2)\n                \n                # Try to extract just the main selector string (first quoted argument)\n                selector_match = re.match(r'[\"\\'](.+?)[\"\\']', full_args)\n                if selector_match:\n                    selector_content = selector_match.group(1)\n                    # Escape special regex chars in selector content but not quotes\n                    escaped_selector = re.escape(selector_content).replace(r'\\\"', r'[\\\\]?\"').replace(r\"\\'\", r\"[\\\\]?'\")\n                    \n                    # Build flexible pattern that matches both single and double quotes\n                    flexible_pattern = rf'{re.escape(method_name)}\\([\"\\']' + escaped_selector + r'[\"\\'](?:,\\s*\\w+=.*?)?\\)'\n                    \n                    if re.search(flexible_pattern, healed_code):\n                        healed_code = re.sub(flexible_pattern, selector, healed_code, count=1)\n                        print(f\"  ✅ Replaced full method call (flexible): '{failed_locator}' -> '{selector}'\")\n                        replacement_made = True\n            \n            # Fallback to exact match if flexible didn't work\n            if not replacement_made:\n                escaped_failed = re.escape(failed_locator)\n                if re.search(escaped_failed, healed_code):\n                    healed_code = re.sub(escaped_failed, selector, healed_code, count=1)\n                    print(f\"  ✅ Replaced full method call (exact): '{failed_locator}' -> '{selector}'\")\n                    replacement_made = True\n            \n            # If still no replacement, try smart contextual replacement\n            if not replacement_made:\n                print(f\"  ⚠️  Could not find failed locator '{failed_locator}' in code\")\n                print(f\"  💡 Trying smart contextual replacement...\")\n                \n                # Extract key text from failed_locator (e.g., \"Start Chat\" from any locator method)\n                text_patterns = [\n                    r'name=\"([^\"]+)\"',  # name=\"Start Chat\"\n                    r'name=\\'([^\\']+)\\'',  # name='Start Chat'\n                    r':has-text\\([\"\\']([^\"\\']+)[\"\\']\\)',  # :has-text(\"Start Chat\")\n                    r'text=\"([^\"]+)\"',  # text=\"Start Chat\"\n                    r'text=\\'([^\\']+)\\'',  # text='Start Chat'\n                    r'[\"\\']([^\"\\']*(?:button|link|input)[^\"\\']*)[\"\\']',  # Any quoted text with element keywords\n                ]\n                \n                key_text = None\n                for pattern in text_patterns:\n                    match = re.search(pattern, failed_locator, re.IGNORECASE)\n                    if match:\n                        key_text = match.group(1)\n                        break\n                \n                if key_text:\n                    print(f\"  🔍 Extracted key text: '{key_text}'\")\n                    # Find any line containing this text in a locator\n                    # Match any page.* method call that contains this text\n                    context_pattern = rf'(await\\s+)?page\\.\\w+\\([^)]*{re.escape(key_text)}[^)]*\\)(?:\\.(?:click|fill|type|press|check|select_option)\\([^)]*\\))?'\n                    context_match = re.search(context_pattern, healed_code)\n                    \n                    if context_match:\n                        old_locator_call = context_match.group(0)\n                        # Replace the entire locator call with the new selector + action\n                        # Extract the action (click, fill, etc.) from the old call\n                        action_match = re.search(r'\\.(click|fill|type|press|check|select_option)\\(([^)]*)\\)', old_locator_call)\n                        if action_match:\n                            action = action_match.group(1)\n                            action_args = action_match.group(2)\n                            new_call = f\"await {selector}.{action}({action_args})\"\n                            healed_code = healed_code.replace(old_locator_call, new_call, 1)\n                            print(f\"  ✅ Smart replacement: Found context and replaced entire call\")\n                            print(f\"     Old: {old_locator_call}\")\n                            print(f\"     New: {new_call}\")\n                            replacement_made = True\n                        else:\n                            # No action, just replace the locator part\n                            healed_code = healed_code.replace(old_locator_call, f\"await {selector}\", 1)\n                            print(f\"  ✅ Smart replacement: Replaced locator without action\")\n                            replacement_made = True\n                    else:\n                        print(f\"  ⚠️  Could not find any locator containing '{key_text}'\")\n                \n                # Last fallback: try simple string replacement\n                if not replacement_made:\n                    locator_match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', failed_locator)\n                    if locator_match:\n                        locator_to_find = locator_match.group(1)\n                        if not (selector.startswith('page.') or selector.startswith('get_by_') or 'locator(' in selector):\n                            # Simple string replacement\n                            escaped_locator = re.escape(locator_to_find)\n                            replacement_patterns = [\n                                (rf'\"{escaped_locator}\"', f'\"{selector}\"'),\n                                (rf\"'{escaped_locator}'\", f\"'{selector}'\"),\n                            ]\n                            \n                            for pattern, replacement in replacement_patterns:\n                                if re.search(pattern, healed_code):\n                                    healed_code = re.sub(pattern, replacement, healed_code, count=1)\n                                    print(f\"  ✅ Replaced locator string: '{locator_to_find}' -> '{selector}'\")\n                                    replacement_made = True\n                                    break\n        else:\n            # Old logic: failed_locator is just a string selector\n            escaped_locator = re.escape(failed_locator)\n            replacement_patterns = [\n                (rf'\"{escaped_locator}\"', f'\"{selector}\"'),\n                (rf\"'{escaped_locator}'\", f\"'{selector}'\"),\n            ]\n            \n            replacement_made = False\n            for pattern, replacement in replacement_patterns:\n                if re.search(pattern, healed_code):\n                    old_code = healed_code\n                    healed_code = re.sub(pattern, replacement, healed_code, count=1)\n                    replacement_made = (healed_code != old_code)\n                    if replacement_made:\n                        print(f\"  ✅ Replaced locator: '{failed_locator}' -> '{selector}'\")\n                        break\n            \n            if not replacement_made:\n                print(f\"  ⚠️  Could not find locator '{failed_locator}' in generated code\")\n                print(f\"  💡 User may need to manually update the healed script\")\n    \n    print(f\"\\n🔧 HEALING SCRIPT IN handle_element_selected:\")\n    print(f\"  Failed locator: '{failed_locator}'\")\n    print(f\"  Healed locator: '{selector}'\")\n    print(f\"  Replacement successful: {healed_code != generated_code}\")\n    print(f\"  Healed code length: {len(healed_code)}\", flush=True)\n    \n    # Save healed code to database\n    c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    print(f\"  ✅ Healed code saved to database for test {test_id}\", flush=True)\n    \n    # Update healing executor if it exists\n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.set_user_selector(selector)\n        healing_executor.healed_script = healed_code\n    \n    # Emit confirmation to UI\n    socketio.emit('element_selected_confirmed', {\n        'test_id': test_id,\n        'selector': selector,\n        'failed_locator': failed_locator,\n        'healed_script': healed_code\n    })\n    \n    # FIX: Trigger re-execution with healed code (final attempt with user-selected locator)\n    print(f\"\\n🚀 TRIGGERING FINAL RETRY with user-selected locator...\")\n    print(f\"  Test ID: {test_id}\")\n    print(f\"  Browser: {browser}\")\n    print(f\"  Mode: {mode}\")\n    \n    # Get agent's session ID from healing executor or connected agents\n    agent_sid = None\n    if test_id in active_healing_executors:\n        agent_sid = active_healing_executors[test_id].agent_sid\n        print(f\"  Agent SID from executor: {agent_sid}\")\n    \n    if not agent_sid and connected_agents:\n        # Fallback to any connected agent\n        agent_sid = list(connected_agents.keys())[0]\n        print(f\"  Using first connected agent: {agent_sid}\")\n    \n    if agent_sid:\n        # This is the FINAL manual healing attempt - mark it specially\n        # and disable further healing if it fails\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': healed_code,\n            'browser': browser or 'chromium',\n            'mode': mode or 'headful',\n            'attempt': 999,  # Special marker: final manual attempt, no more healing\n            'final_manual_attempt': True  # Flag to prevent further healing requests\n        }, to=agent_sid)\n        print(f\"  ✅ FINAL manual healing attempt triggered with healed code to agent {agent_sid}\", flush=True)\n        \n        # Mark that manual healing has been attempted for this test\n        # to prevent multiple manual healing widgets\n        if test_id in active_healing_executors:\n            active_healing_executors[test_id].manual_healing_attempted = True\n    else:\n        print(f\"  ❌ No agent connected - cannot trigger retry\", flush=True)\n        socketio.emit('error', {\n            'test_id': test_id,\n            'message': 'No agent connected for retry execution'\n        })\n\n@socketio.on('request_ai_healing')\ndef handle_ai_healing_request(data):\n    \"\"\"\n    Handle AI healing request for code generation errors.\n    Automatically retries with improved AI prompting based on error type.\n    \"\"\"\n    test_id = data.get('test_id')\n    error_type = data.get('error_type')\n    error_info = data.get('error_info', {})\n    attempt = data.get('attempt', 1)\n    agent_sid = request.sid  # Get the agent's session ID\n    \n    print(f\"\\n🤖 AI HEALING REQUEST:\")\n    print(f\"  Test ID: {test_id}\")\n    print(f\"  Error Type: {error_type}\")\n    print(f\"  Attempt: {attempt}\")\n    print(f\"  Error Detail: {error_info.get('detail', error_info.get('full_error', 'N/A'))[:150]}\")\n    \n    # Get the original code from database\n    conn = sqlite3.connect(app.config['DATABASE_PATH'])\n    c = conn.cursor()\n    c.execute('SELECT generated_code, healed_code, browser, mode FROM test_history WHERE id=?', (test_id,))\n    row = c.fetchone()\n    \n    if not row:\n        print(f\"  ❌ Test {test_id} not found in database\")\n        conn.close()\n        return\n    \n    generated_code, existing_healed_code, browser, mode = row\n    current_code = existing_healed_code if existing_healed_code else generated_code\n    \n    # Get or create healing executor\n    if test_id not in active_healing_executors:\n        openai_key = os.environ.get('OPENAI_API_KEY')\n        healing_executor = HealingExecutor(socketio, api_key=openai_key, use_gpt4o=False)\n        healing_executor.agent_sid = agent_sid\n        active_healing_executors[test_id] = healing_executor\n    else:\n        healing_executor = active_healing_executors[test_id]\n        healing_executor.agent_sid = agent_sid\n    \n    # Extract error detail\n    error_detail = error_info.get('detail', error_info.get('full_error', 'Unknown error'))\n    failed_step = error_info.get('step', 0)\n    \n    # Check max retries (2 AI attempts, then manual widget)\n    max_retries = healing_executor.max_retries\n    if attempt >= max_retries:\n        print(f\"  ⚠️ Max AI healing attempts ({max_retries}) reached, triggering manual widget...\")\n        \n        # Trigger manual healing with special attempt number (999) for final manual attempt\n        # Agent will show manual widget when it receives attempt >= 999\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': current_code,\n            'browser': browser,\n            'mode': mode,\n            'attempt': 999,\n            'final_manual_attempt': True\n        }, to=agent_sid)\n        print(f\"  🎯 Sent manual healing trigger to agent (attempt 999 - final manual attempt)\")\n        conn.close()\n        return\n    \n    # Use AI to regenerate the code\n    print(f\"  🔄 Regenerating code with AI (attempt {attempt}/{max_retries})...\")\n    healed_code = healing_executor.regenerate_code_with_ai(\n        current_code,\n        error_detail,\n        failed_step,\n        attempt,\n        error_type=error_type\n    )\n    \n    if healed_code and healed_code != current_code:\n        # Save healed code to database\n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_code, test_id))\n        conn.commit()\n        print(f\"  ✅ AI regenerated code saved to database ({len(healed_code)} chars)\")\n        \n        # Send healed code back to agent for retry\n        socketio.emit('execute_healing_attempt', {\n            'test_id': test_id,\n            'code': healed_code,\n            'browser': browser,\n            'mode': mode,\n            'attempt': attempt + 1\n        }, to=agent_sid)\n        print(f\"  🚀 Sent healed code to agent for retry (attempt {attempt + 1}/{max_retries})\")\n    else:\n        print(f\"  ⚠️ AI regeneration failed or produced same code\")\n        # Mark as failed in database\n        c.execute('UPDATE test_history SET status=? WHERE id=?', ('failed', test_id))\n        conn.commit()\n        # Notify agent to close browser\n        socketio.emit('healing_complete', {\n            'test_id': test_id,\n            'success': False,\n            'reason': 'regeneration_failed'\n        }, to=agent_sid)\n    \n    conn.close()\n\n@socketio.on('healing_attempt_result')\ndef handle_healing_attempt_result(data):\n    \"\"\"Handle result from agent healing attempt execution.\"\"\"\n    test_id = data.get('test_id')\n    \n    if test_id in active_healing_executors:\n        healing_executor = active_healing_executors[test_id]\n        result = {\n            'success': data.get('success'),\n            'logs': data.get('logs', []),\n            'screenshot': data.get('screenshot')\n        }\n        # Set via both methods for compatibility\n        healing_executor.set_agent_result(result)\n        # Also set via gevent AsyncResult for cross-greenlet communication\n        if hasattr(healing_executor, 'agent_result_async'):\n            healing_executor.agent_result_async.set(result)\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 6890))\n    socketio.run(\n        app,\n        host='127.0.0.1',  # localhost\n        port=port,\n        debug=True,\n        allow_unsafe_werkzeug=True\n    )\n","size_bytes":107635},"visionvault/services/executor.py":{"content":"import asyncio\nimport sys\nfrom io import StringIO\nfrom visionvault.services.code_validator import CodeValidator\n\nclass ServerExecutor:\n    def execute(self, code, browser_name='chromium', headless=True):\n        try:\n            validator = CodeValidator()\n            if not validator.validate(code):\n                return {\n                    'success': False,\n                    'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                    'screenshot': None\n                }\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True,\n                    'False': False,\n                    'None': None,\n                    'dict': dict,\n                    'list': list,\n                    'str': str,\n                    'int': int,\n                    'float': float,\n                    'bool': bool,\n                    'len': len,\n                    'range': range,\n                    'enumerate': enumerate,\n                    'zip': zip,\n                    'Exception': Exception,\n                    'ValueError': ValueError,\n                    'TypeError': TypeError,\n                    'KeyError': KeyError,\n                    'AttributeError': AttributeError,\n                    'getattr': getattr,\n                    'setattr': setattr,\n                    'hasattr': hasattr,\n                    'print': print,\n                    '__import__': __import__,\n\n                }\n            }\n            \n            local_vars = {}\n            exec(code, restricted_globals, local_vars)\n            \n            if 'run_test' not in local_vars:\n                return {\n                    'success': False,\n                    'logs': ['Error: Generated code must contain a run_test function'],\n                    'screenshot': None\n                }\n            \n            run_test = local_vars['run_test']\n            \n            result = asyncio.run(run_test(browser_name=browser_name, headless=headless))\n            \n            return result\n        except Exception as e:\n            return {\n                'success': False,\n                'logs': [f'Execution error: {str(e)}'],\n                'screenshot': None\n            }\n","size_bytes":2270},"playwright_codegen_2.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPlaywright Codegen Locator Capture Script\n\nThis script replicates the core functionality of `npx playwright codegen` by:\n1. Launching a browser (Chromium)\n2. Opening a specified webpage\n3. Capturing and displaying locators for elements that the user clicks\n4. Properly closing the browser when finished\n\nBased on analysis of the Playwright source code:\n- packages/playwright-core/src/server/recorder.ts - Server-side recorder\n- packages/injected/src/recorder/recorder.ts - Browser-injected recorder\n- packages/injected/src/selectorGenerator.ts - Selector generation logic\n\"\"\"\n\nimport sys\nimport asyncio\nfrom playwright.async_api import async_playwright, Page, ElementHandle\n\nclass PlaywrightCodegenCapture:\n    \"\"\"\n    Captures and displays element locators similar to Playwright's codegen tool.\n\n    The selector generation follows Playwright's priority order:\n    1. Test ID attributes (data-testid, etc.)\n    2. Role-based locators (accessibility-first approach)\n    3. Text content\n    4. Label associations\n    5. Placeholder text\n    6. CSS selectors (fallback)\n    \"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        self.page = None\n        self.browser = None\n        self.context = None\n\n    async def generate_locator_suggestions(self, element: ElementHandle) -> dict:\n        \"\"\"\n        Generate multiple locator suggestions for an element.\n\n        This mimics the selector generation logic from:\n        packages/injected/src/selectorGenerator.ts\n\n        The generator prioritizes selectors in order of reliability:\n        - Test IDs (score: 1-2)\n        - Role with name (score: 100)\n        - Placeholder (score: 120)\n        - Label (score: 140)\n        - Alt text (score: 160)\n        - Text content (score: 180)\n        - CSS selectors (score: 500+)\n        \"\"\"\n        locators = {}\n\n        try:\n            # Strategy 1: Test ID attribute (highest priority)\n            # From selectorGenerator.ts: kTestIdScore = 1\n            test_id = await element.get_attribute('data-testid')\n            if test_id:\n                locators['testid'] = f'page.get_by_test_id(\"{test_id}\")'\n\n            # Strategy 2: Role-based locator (accessibility-first)\n            # From selectorGenerator.ts: kRoleWithNameScore = 100\n            role = await element.evaluate('''\n                element => {\n                    const role = element.getAttribute('role') ||\n                                 (element.tagName === 'BUTTON' ? 'button' :\n                                  element.tagName === 'A' ? 'link' :\n                                  element.tagName === 'INPUT' && element.type === 'text' ? 'textbox' :\n                                  element.tagName === 'INPUT' && element.type === 'checkbox' ? 'checkbox' :\n                                  null);\n                    const name = element.textContent?.trim() ||\n                                element.getAttribute('aria-label') ||\n                                element.getAttribute('title');\n                    return { role, name };\n                }\n            ''')\n\n            if role.get('role'):\n                if role.get('name'):\n                    locators['role_with_name'] = f'page.get_by_role(\"{role[\"role\"]}\", name=\"{role[\"name\"]}\")'\n                else:\n                    locators['role'] = f'page.get_by_role(\"{role[\"role\"]}\")'\n\n            # Strategy 3: Text content\n            # From selectorGenerator.ts: kTextScore = 180\n            text_content = await element.text_content()\n            if text_content and text_content.strip():\n                # Use exact match if short, otherwise use contains\n                text = text_content.strip()\n                if len(text) <= 50:\n                    locators['text'] = f'page.get_by_text(\"{text}\", exact=True)'\n                else:\n                    locators['text_partial'] = f'page.get_by_text(\"{text[:30]}...\", exact=False)'\n\n            # Strategy 4: Label (for form inputs)\n            # From selectorGenerator.ts: kLabelScore = 140\n            label = await element.evaluate('''\n                element => {\n                    if (element.id) {\n                        const label = document.querySelector(`label[for=\"${element.id}\"]`);\n                        if (label) return label.textContent?.trim();\n                    }\n                    const parentLabel = element.closest('label');\n                    if (parentLabel) return parentLabel.textContent?.trim();\n                    return null;\n                }\n            ''')\n            if label:\n                locators['label'] = f'page.get_by_label(\"{label}\")'\n\n            # Strategy 5: Placeholder\n            # From selectorGenerator.ts: kPlaceholderScore = 120\n            placeholder = await element.get_attribute('placeholder')\n            if placeholder:\n                locators['placeholder'] = f'page.get_by_placeholder(\"{placeholder}\")'\n\n            # Strategy 6: Alt text (for images)\n            # From selectorGenerator.ts: kAltTextScore = 160\n            alt_text = await element.get_attribute('alt')\n            if alt_text:\n                locators['alt'] = f'page.get_by_alt_text(\"{alt_text}\")'\n\n            # Strategy 7: CSS selector (fallback)\n            # From selectorGenerator.ts: kCSSFallbackScore = 10000000\n            tag_name = await element.evaluate('el => el.tagName.toLowerCase()')\n            css_id = await element.get_attribute('id')\n            css_class = await element.get_attribute('class')\n\n            if css_id:\n                locators['css_id'] = f'page.locator(\"#{css_id}\")'\n            elif css_class:\n                classes = css_class.strip().split()[0] if css_class.strip() else None\n                if classes:\n                    locators['css_class'] = f'page.locator(\"{tag_name}.{classes}\")'\n            else:\n                locators['css_tag'] = f'page.locator(\"{tag_name}\")'\n\n        except Exception as e:\n            locators['error'] = f'Error generating locators: {str(e)}'\n\n        return locators\n\n    async def verify_locator_uniqueness(self, locator_code: str) -> int:\n        \"\"\"\n        Verify how many elements a locator matches on the page.\n        Returns the count of matching elements.\n        \"\"\"\n        try:\n            # Extract the actual locator expression from the Python code\n            # Handle different locator types\n            if 'get_by_test_id' in locator_code:\n                test_id = locator_code.split('\"')[1]\n                count = await self.page.locator(f'[data-testid=\"{test_id}\"]').count()\n            elif 'get_by_role' in locator_code:\n                # Parse role and name if present\n                parts = locator_code.split('\"')\n                role = parts[1]\n                name = parts[3] if len(parts) > 3 and 'name=' in locator_code else None\n                if name:\n                    count = await self.page.get_by_role(role, name=name).count()\n                else:\n                    count = await self.page.get_by_role(role).count()\n            elif 'get_by_text' in locator_code:\n                text = locator_code.split('\"')[1]\n                exact = 'exact=True' in locator_code\n                count = await self.page.get_by_text(text, exact=exact).count()\n            elif 'get_by_placeholder' in locator_code:\n                placeholder = locator_code.split('\"')[1]\n                count = await self.page.get_by_placeholder(placeholder).count()\n            elif 'get_by_alt_text' in locator_code:\n                alt = locator_code.split('\"')[1]\n                count = await self.page.get_by_alt_text(alt).count()\n            elif 'get_by_title' in locator_code:\n                title = locator_code.split('\"')[1]\n                count = await self.page.get_by_title(title).count()\n            elif 'get_by_label' in locator_code:\n                label = locator_code.split('\"')[1]\n                count = await self.page.get_by_label(label).count()\n            elif 'page.locator' in locator_code:\n                # CSS or XPath\n                selector = locator_code.split('\"')[1]\n                count = await self.page.locator(selector).count()\n            elif '.filter(' in locator_code or '.get_by_text(' in locator_code:\n                # Chained locator - harder to evaluate, skip for now\n                count = 999\n            else:\n                count = 999\n\n            return count\n        except Exception as e:\n            # If we can't verify, assume it's not unique\n            return 999\n\n    async def generate_locators_from_info(self, info: dict) -> dict:\n        \"\"\"\n        Generate ALL possible locators from pre-captured element information.\n        Returns primary (best) locator and all valid secondary locators.\n        \"\"\"\n        primary = None\n        secondary = []\n\n        # Score tracking to determine primary locator (lower score = better)\n        scores = []\n\n        # 1. TEST ID LOCATORS (Score: 1 - highest priority)\n        if info.get('testId'):\n            loc = f'page.get_by_test_id(\"{info[\"testId\"]}\")'\n            scores.append((1, loc, 'testid'))\n\n        # 2. ROLE-BASED LOCATORS (Score: 100-150)\n        role = None\n        if info.get('role'):\n            role = info['role']\n        elif info['tag'] == 'button':\n            role = 'button'\n        elif info['tag'] == 'a':\n            role = 'link'\n        elif info['tag'] == 'input':\n            input_type = info.get('type', '')\n            if input_type == 'text' or input_type == '':\n                role = 'textbox'\n            elif input_type == 'checkbox':\n                role = 'checkbox'\n            elif input_type == 'radio':\n                role = 'radio'\n            elif input_type == 'submit':\n                role = 'button'\n        elif info['tag'] == 'img':\n            role = 'img'\n        elif info['tag'] == 'h1':\n            role = 'heading'\n        elif info['tag'] in ['h2', 'h3', 'h4', 'h5', 'h6']:\n            role = 'heading'\n\n        if role:\n            name = info.get('text') or info.get('ariaLabel')\n            if name:\n                loc = f'page.get_by_role(\"{role}\", name=\"{name}\")'\n                scores.append((100, loc, 'role_with_name'))\n                # Also add exact match variant\n                loc_exact = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)'\n                scores.append((105, loc_exact, 'role_with_name_exact'))\n            else:\n                loc = f'page.get_by_role(\"{role}\")'\n                scores.append((510, loc, 'role'))\n\n        # 3. LABEL LOCATORS (Score: 140)\n        # Note: We can't detect actual labels from pre-captured info, but include placeholder\n        if info.get('ariaLabel'):\n            loc = f'page.get_by_label(\"{info[\"ariaLabel\"]}\")'\n            scores.append((140, loc, 'label'))\n\n        # 4. PLACEHOLDER LOCATORS (Score: 120)\n        if info.get('placeholder'):\n            loc = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\")'\n            scores.append((120, loc, 'placeholder'))\n            loc_exact = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\", exact=True)'\n            scores.append((125, loc_exact, 'placeholder_exact'))\n\n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if info.get('alt'):\n            loc = f'page.get_by_alt_text(\"{info[\"alt\"]}\")'\n            scores.append((160, loc, 'alt'))\n            loc_exact = f'page.get_by_alt_text(\"{info[\"alt\"]}\", exact=True)'\n            scores.append((165, loc_exact, 'alt_exact'))\n\n        # 6. TEXT LOCATORS (Score: 180)\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                # Exact text match\n                loc = f'page.get_by_text(\"{text}\", exact=True)'\n                scores.append((185, loc, 'text_exact'))\n                # Partial text match\n                loc_partial = f'page.get_by_text(\"{text}\")'\n                scores.append((180, loc_partial, 'text'))\n                # Regex variant\n                if len(text) > 3:\n                    loc_regex = f'page.get_by_text(re.compile(r\"{text[:20]}\"))'\n                    scores.append((250, loc_regex, 'text_regex'))\n\n        # 7. TITLE LOCATORS (Score: 200)\n        if info.get('title'):\n            loc = f'page.get_by_title(\"{info[\"title\"]}\")'\n            scores.append((200, loc, 'title'))\n\n        # 8. CSS SELECTORS (Score: 500+)\n        css_selectors = []\n\n        # CSS by ID\n        if info.get('id'):\n            loc = f'page.locator(\"#{info[\"id\"]}\")'\n            scores.append((500, loc, 'css_id'))\n            css_selectors.append(f'#{info[\"id\"]}')\n\n        # CSS by class\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                # First class\n                loc = f'page.locator(\"{info[\"tag\"]}.{classes[0]}\")'\n                scores.append((520, loc, 'css_class'))\n                css_selectors.append(f'{info[\"tag\"]}.{classes[0]}')\n                # All classes\n                all_classes = '.'.join(classes)\n                loc_all = f'page.locator(\"{info[\"tag\"]}.{all_classes}\")'\n                scores.append((515, loc_all, 'css_all_classes'))\n                css_selectors.append(f'{info[\"tag\"]}.{all_classes}')\n\n        # CSS by tag + attributes\n        if info.get('type'):\n            loc = f'page.locator(\"{info[\"tag\"]}[type=\\\\\"{info[\"type\"]}\\\\\"]\")'\n            scores.append((520, loc, 'css_type'))\n            css_selectors.append(f'{info[\"tag\"]}[type=\"{info[\"type\"]}\"]')\n\n        if info.get('href'):\n            loc = f'page.locator(\"{info[\"tag\"]}[href=\\\\\"{info[\"href\"]}\\\\\"]\")'\n            scores.append((525, loc, 'css_href'))\n            css_selectors.append(f'{info[\"tag\"]}[href=\"{info[\"href\"]}\"]')\n\n        # CSS by tag only\n        loc = f'page.locator(\"{info[\"tag\"]}\")'\n        scores.append((530, loc, 'css_tag'))\n        css_selectors.append(info[\"tag\"])\n\n        # 9. XPATH SELECTORS (Score: 600+)\n        xpath_selectors = []\n\n        # XPath by ID\n        if info.get('id'):\n            loc = f'page.locator(\"xpath=//{info[\"tag\"]}[@id=\\\\\"{info[\"id\"]}\\\\\"]\")'\n            scores.append((600, loc, 'xpath_id'))\n            xpath_selectors.append(f'//{info[\"tag\"]}[@id=\"{info[\"id\"]}\"]')\n\n        # XPath by class\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                loc = f'page.locator(\"xpath=//{info[\"tag\"]}[contains(@class, \\\\\"{classes[0]}\\\\\")]\")'\n                scores.append((610, loc, 'xpath_class'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[contains(@class, \"{classes[0]}\")]')\n\n        # XPath by text\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.locator(\"xpath=//{info[\"tag\"]}[text()=\\\\\"{text}\\\\\"]\")'\n                scores.append((620, loc, 'xpath_text'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[text()=\"{text}\"]')\n                loc_contains = f'page.locator(\"xpath=//{info[\"tag\"]}[contains(text(), \\\\\"{text[:20]}\\\\\")]\")'\n                scores.append((625, loc_contains, 'xpath_text_contains'))\n                xpath_selectors.append(f'//{info[\"tag\"]}[contains(text(), \"{text[:20]}\")]')\n\n        # XPath by tag\n        loc = f'page.locator(\"xpath=//{info[\"tag\"]}\")'\n        scores.append((630, loc, 'xpath_tag'))\n        xpath_selectors.append(f'//{info[\"tag\"]}')\n\n        # 10. CHAINED LOCATORS (Score: 300+)\n        chained = []\n\n        # Chain: Role + Text filter\n        if role and info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.get_by_role(\"{role}\").filter(has_text=\"{text}\")'\n                scores.append((300, loc, 'chained_role_text'))\n                chained.append(loc)\n\n        # Chain: Locator + Text filter\n        if css_selectors and info.get('text'):\n            text = info['text'].strip()\n            if text and css_selectors[0]:\n                loc = f'page.locator(\"{css_selectors[0]}\").filter(has_text=\"{text}\")'\n                scores.append((310, loc, 'chained_css_text'))\n                chained.append(loc)\n\n        # Chain: Locator + get_by_text\n        if css_selectors and info.get('text'):\n            text = info['text'].strip()\n            if text and css_selectors[0]:\n                loc = f'page.locator(\"{css_selectors[0]}\").get_by_text(\"{text}\")'\n                scores.append((320, loc, 'chained_css_getbytext'))\n                chained.append(loc)\n\n        # INTELLIGENT PRIMARY LOCATOR SELECTION\n        # Sort by score (lower is better)\n        scores.sort(key=lambda x: x[0])\n\n        # Verify uniqueness for each locator and find the best unique one\n        primary = None\n        secondary = []\n        verified_scores = []\n\n        for score, locator, loc_type in scores:\n            # Check how many elements this locator matches\n            count = await self.verify_locator_uniqueness(locator)\n            verified_scores.append({\n                'locator': locator,\n                'type': loc_type,\n                'score': score,\n                'count': count,\n                'unique': count == 1\n            })\n\n        # Find the best UNIQUE locator (prioritize by score, but must be unique)\n        unique_locators = [v for v in verified_scores if v['unique']]\n\n        if unique_locators:\n            # Best unique locator becomes primary\n            primary = unique_locators[0]\n            # All others (unique or not) become secondary\n            secondary = [v for v in verified_scores if v != primary]\n        else:\n            # No unique locator found - use the best score but mark as non-unique\n            # Try to build a more specific CSS selector as fallback\n            if verified_scores:\n                primary = verified_scores[0]\n                primary['warning'] = f'⚠️  Matches {primary[\"count\"]} elements - not unique!'\n                secondary = verified_scores[1:]\n\n        return {\n            'primary': primary,\n            'secondary': secondary,\n            'css_selectors': css_selectors,\n            'xpath_selectors': xpath_selectors,\n            'chained': chained\n        }\n\n    async def setup_click_handler(self):\n        \"\"\"\n        Inject JavaScript to capture click events and highlight elements.\n\n        This mimics the behavior from:\n        packages/injected/src/recorder/recorder.ts - RecordActionTool class\n\n        The injected script:\n        1. Listens for click events on the page\n        2. Prevents default action temporarily\n        3. Sends element info back to Python\n        4. Highlights clicked elements\n        \"\"\"\n        if not self.page:\n            return\n\n        await self.page.evaluate('''\n            () => {\n                // Remove any existing listeners\n                if (window.__playwrightCodegenHandler) {\n                    document.removeEventListener('click', window.__playwrightCodegenHandler, true);\n                }\n\n                // Highlight element on hover (similar to Playwright Inspector)\n                let currentHighlight = null;\n\n                document.addEventListener('mouseover', (e) => {\n                    if (currentHighlight) {\n                        currentHighlight.style.outline = '';\n                        currentHighlight.style.backgroundColor = '';\n                    }\n\n                    // Highlight color from packages/injected/src/recorder/recorder.ts\n                    // HighlightColors.action = '#dc6f6f7f'\n                    e.target.style.outline = '2px solid #dc6f6f';\n                    e.target.style.backgroundColor = 'rgba(220, 111, 111, 0.1)';\n                    currentHighlight = e.target;\n                }, true);\n\n                // Click handler - captures element info WITHOUT triggering actions\n                // This mimics Playwright codegen behavior - record but don't execute\n                const clickHandler = (e) => {\n                    const element = e.target;\n\n                    // PREVENT default action (like codegen does)\n                    // This stops navigation, form submission, etc.\n                    e.preventDefault();\n                    e.stopPropagation();\n                    e.stopImmediatePropagation();\n\n                    // Capture element info for locator generation\n                    window.__lastClickedElementInfo = {\n                        tag: element.tagName.toLowerCase(),\n                        text: element.textContent?.trim().substring(0, 50),\n                        id: element.id || '',\n                        classes: element.className || '',\n                        testId: element.getAttribute('data-testid') || '',\n                        role: element.getAttribute('role') || '',\n                        ariaLabel: element.getAttribute('aria-label') || '',\n                        placeholder: element.getAttribute('placeholder') || '',\n                        alt: element.getAttribute('alt') || '',\n                        title: element.getAttribute('title') || '',\n                        type: element.getAttribute('type') || '',\n                        href: element.getAttribute('href') || '',\n                        timestamp: Date.now()\n                    };\n\n                    // Visual feedback - flash the element\n                    const originalBg = element.style.backgroundColor;\n                    element.style.backgroundColor = 'rgba(220, 111, 111, 0.3)';\n                    setTimeout(() => {\n                        element.style.backgroundColor = originalBg;\n                    }, 200);\n                };\n\n                window.__playwrightCodegenHandler = clickHandler;\n                document.addEventListener('click', clickHandler, true);\n\n                console.log('Playwright Codegen: Click capture enabled');\n            }\n        ''')\n\n    async def start_capture(self):\n        \"\"\"\n        Main capture loop - launches browser and listens for user interactions.\n\n        Flow mirrors Playwright's recorder:\n        1. Launch browser with recorder mode enabled\n        2. Navigate to target URL\n        3. Inject event listeners\n        4. Wait for user interactions\n        5. Generate and display locators\n        \"\"\"\n        async with async_playwright() as p:\n            print(\"🎭 Playwright Codegen Locator Capture\")\n            print(\"=\" * 60)\n            print(f\"Opening: {self.url}\")\n            print(\"\\nInstructions:\")\n            print(\"  • Click on any element to see its locators\")\n            print(\"  • Press Ctrl+C to exit\")\n            print(\"=\" * 60)\n            print()\n\n            # Launch browser in headed mode (similar to codegen)\n            # From recorder.ts: browser is launched with headful mode\n            self.browser = await p.chromium.launch(\n                headless=False,\n                args=['--disable-blink-features=AutomationControlled']\n            )\n\n            # Create context (similar to Recorder._create in recorder.ts)\n            self.context = await self.browser.new_context()\n            self.page = await self.context.new_page()\n\n            # Navigate to URL\n            await self.page.goto(self.url)\n\n            # Inject click capture handler\n            await self.setup_click_handler()\n\n            # Monitor for clicks (actions are prevented like codegen)\n            # Elements are recorded but not executed\n            last_processed_timestamp = 0\n\n            try:\n                while True:\n                    # Check if a new element was clicked\n                    element_info = await self.page.evaluate(\n                        '() => window.__lastClickedElementInfo'\n                    )\n\n                    if element_info and element_info.get('timestamp', 0) > last_processed_timestamp:\n                        last_processed_timestamp = element_info['timestamp']\n\n                        # Display element info\n                        print(f\"\\n{'='*70}\")\n                        print(f\"🎯 Element: <{element_info['tag']}>\")\n                        if element_info.get('id'):\n                            print(f\"   ID: {element_info['id']}\")\n                        if element_info.get('text'):\n                            print(f\"   Text: {element_info['text']}\")\n                        if element_info.get('href'):\n                            print(f\"   Href: {element_info['href']}\")\n                        print(f\"{'='*70}\")\n\n                        # Generate all possible locators (with uniqueness verification)\n                        result = await self.generate_locators_from_info(element_info)\n\n                        # Build locators dictionary\n                        primary_info = {\n                            'locator': result['primary']['locator'] if result['primary'] else None,\n                            'count': result['primary']['count'] if result['primary'] else 0,\n                            'unique': result['primary']['unique'] if result['primary'] else False\n                        }\n\n                        # Add warning if not unique\n                        if result['primary'] and result['primary'].get('warning'):\n                            primary_info['warning'] = result['primary']['warning']\n\n                        locators_dict = {\n                            'primary_locator': primary_info,\n                            'all_locators': {}\n                        }\n\n                        # Organize by method type\n                        by_role = []\n                        by_text = []\n                        by_label = []\n                        by_placeholder = []\n                        by_alt = []\n                        by_title = []\n                        by_testid = []\n                        css_locators = []\n                        xpath_locators = []\n                        chained_locators = []\n\n                        # Add primary (with uniqueness info)\n                        if result['primary']:\n                            loc_type = result['primary']['type']\n                            loc_str = result['primary']['locator']\n                            count = result['primary']['count']\n                            unique = result['primary']['unique']\n\n                            loc_with_info = {\n                                'locator': loc_str,\n                                'count': count,\n                                'unique': unique\n                            }\n\n                            if 'role' in loc_type:\n                                by_role.append(loc_with_info)\n                            elif 'text' in loc_type:\n                                by_text.append(loc_with_info)\n                            elif 'label' in loc_type:\n                                by_label.append(loc_with_info)\n                            elif 'placeholder' in loc_type:\n                                by_placeholder.append(loc_with_info)\n                            elif 'alt' in loc_type:\n                                by_alt.append(loc_with_info)\n                            elif 'title' in loc_type:\n                                by_title.append(loc_with_info)\n                            elif 'testid' in loc_type:\n                                by_testid.append(loc_with_info)\n                            elif 'css' in loc_type:\n                                css_locators.append(loc_with_info)\n                            elif 'xpath' in loc_type:\n                                xpath_locators.append(loc_with_info)\n                            elif 'chained' in loc_type:\n                                chained_locators.append(loc_with_info)\n\n                        # Add secondary (with uniqueness info)\n                        for sec in result['secondary']:\n                            loc_type = sec['type']\n                            loc_str = sec['locator']\n                            count = sec['count']\n                            unique = sec['unique']\n\n                            # Format: \"locator_string (count: N, unique: True/False)\"\n                            loc_with_info = {\n                                'locator': loc_str,\n                                'count': count,\n                                'unique': unique\n                            }\n\n                            if 'role' in loc_type:\n                                by_role.append(loc_with_info)\n                            elif 'text' in loc_type:\n                                by_text.append(loc_with_info)\n                            elif 'label' in loc_type:\n                                by_label.append(loc_with_info)\n                            elif 'placeholder' in loc_type:\n                                by_placeholder.append(loc_with_info)\n                            elif 'alt' in loc_type:\n                                by_alt.append(loc_with_info)\n                            elif 'title' in loc_type:\n                                by_title.append(loc_with_info)\n                            elif 'testid' in loc_type:\n                                by_testid.append(loc_with_info)\n                            elif 'css' in loc_type:\n                                css_locators.append(loc_with_info)\n                            elif 'xpath' in loc_type:\n                                xpath_locators.append(loc_with_info)\n                            elif 'chained' in loc_type:\n                                chained_locators.append(loc_with_info)\n\n                        # Build final dictionary\n                        if by_testid:\n                            locators_dict['all_locators']['getByTestId'] = by_testid\n                        if by_role:\n                            locators_dict['all_locators']['getByRole'] = by_role\n                        if by_text:\n                            locators_dict['all_locators']['getByText'] = by_text\n                        if by_label:\n                            locators_dict['all_locators']['getByLabel'] = by_label\n                        if by_placeholder:\n                            locators_dict['all_locators']['getByPlaceholder'] = by_placeholder\n                        if by_alt:\n                            locators_dict['all_locators']['getByAltText'] = by_alt\n                        if by_title:\n                            locators_dict['all_locators']['getByTitle'] = by_title\n                        if css_locators:\n                            locators_dict['all_locators']['locator_css'] = css_locators\n                        if xpath_locators:\n                            locators_dict['all_locators']['locator_xpath'] = xpath_locators\n                        if chained_locators:\n                            locators_dict['all_locators']['chained_locators'] = chained_locators\n\n                        # Also include raw CSS and XPath selectors\n                        if result['css_selectors']:\n                            locators_dict['css_selectors'] = result['css_selectors']\n                        if result['xpath_selectors']:\n                            locators_dict['xpath_selectors'] = result['xpath_selectors']\n\n                        # Display as formatted dictionary\n                        import json\n                        print(\"\\n📍 LOCATORS DICTIONARY:\")\n                        print(json.dumps(locators_dict, indent=2))\n                        print()\n\n                    # Small delay to prevent high CPU usage\n                    await asyncio.sleep(0.1)\n\n            except KeyboardInterrupt:\n                print(\"\\n\\n👋 Exiting Playwright Codegen Capture...\")\n            finally:\n                # Cleanup: close browser properly\n                # This mirrors the cleanup in recorder.ts\n                if self.context:\n                    await self.context.close()\n                if self.browser:\n                    await self.browser.close()\n                print(\"✓ Browser closed successfully\")\n\ndef main():\n    \"\"\"\n    Entry point - parses URL from command line arguments.\n\n    Usage:\n        python playwright_codegen.py <URL>\n        python playwright_codegen.py https://example.com\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: python playwright_codegen.py <URL>\")\n        print(\"\\nExample:\")\n        print(\"  python playwright_codegen.py https://example.com\")\n        print(\"  python playwright_codegen.py https://playwright.dev\")\n        sys.exit(1)\n\n    url = sys.argv[1]\n\n    # Ensure URL has a protocol\n    if not url.startswith(('http://', 'https://')):\n        url = 'https://' + url\n\n    # Create and run the capture tool\n    capture = PlaywrightCodegenCapture(url)\n\n    try:\n        asyncio.run(capture.start_capture())\n    except Exception as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":32786},"mcp/src/automation/task_executor.py":{"content":"from typing import Optional, Dict, Any, List\nfrom enum import Enum\nimport asyncio\nfrom dataclasses import dataclass\n\nfrom .browser_engine import BrowserEngine\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass TaskType(Enum):\n    NAVIGATE = \"navigate\"\n    CLICK = \"click\"\n    FILL = \"fill\"\n    EXTRACT_TEXT = \"extract_text\"\n    EXTRACT_LINKS = \"extract_links\"\n    SCREENSHOT = \"screenshot\"\n    WAIT = \"wait\"\n    SCROLL = \"scroll\"\n    EXECUTE_SCRIPT = \"execute_script\"\n\n\n@dataclass\nclass TaskResult:\n    success: bool\n    data: Any = None\n    error: Optional[str] = None\n\n\nclass TaskExecutor:\n    \n    def __init__(self, browser_engine: BrowserEngine):\n        self.browser = browser_engine\n    \n    async def execute_task(self, task_type: TaskType, params: Dict[str, Any]) -> TaskResult:\n        try:\n            if task_type == TaskType.NAVIGATE:\n                return await self._navigate(params)\n            elif task_type == TaskType.CLICK:\n                return await self._click(params)\n            elif task_type == TaskType.FILL:\n                return await self._fill(params)\n            elif task_type == TaskType.EXTRACT_TEXT:\n                return await self._extract_text(params)\n            elif task_type == TaskType.EXTRACT_LINKS:\n                return await self._extract_links(params)\n            elif task_type == TaskType.SCREENSHOT:\n                return await self._screenshot(params)\n            elif task_type == TaskType.WAIT:\n                return await self._wait(params)\n            elif task_type == TaskType.SCROLL:\n                return await self._scroll(params)\n            elif task_type == TaskType.EXECUTE_SCRIPT:\n                return await self._execute_script(params)\n            else:\n                return TaskResult(success=False, error=f\"Unknown task type: {task_type}\")\n        except Exception as e:\n            logger.error(f\"Task execution failed: {str(e)}\")\n            return TaskResult(success=False, error=str(e))\n    \n    async def _navigate(self, params: Dict[str, Any]) -> TaskResult:\n        url = params.get(\"url\")\n        if not url:\n            return TaskResult(success=False, error=\"URL is required\")\n        \n        success = await self.browser.navigate(url, params.get(\"wait_until\"))\n        return TaskResult(success=success)\n    \n    async def _click(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        success = await self.browser.click(selector)\n        return TaskResult(success=success)\n    \n    async def _fill(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        value = params.get(\"value\")\n        \n        if not selector or value is None:\n            return TaskResult(success=False, error=\"Selector and value are required\")\n        \n        success = await self.browser.fill(selector, str(value))\n        return TaskResult(success=success)\n    \n    async def _extract_text(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\")\n        if not selector:\n            return TaskResult(success=False, error=\"Selector is required\")\n        \n        all_elements = params.get(\"all\", False)\n        \n        if all_elements:\n            texts = await self.browser.get_all_text(selector)\n            return TaskResult(success=True, data=texts)\n        else:\n            text = await self.browser.get_text(selector)\n            return TaskResult(success=text is not None, data=text)\n    \n    async def _extract_links(self, params: Dict[str, Any]) -> TaskResult:\n        selector = params.get(\"selector\", \"a\")\n        \n        links = []\n        elements = await self.browser.get_all_text(selector)\n        \n        for i, _ in enumerate(elements):\n            href = await self.browser.get_attribute(f\"{selector}:nth-of-type({i+1})\", \"href\")\n            text = await self.browser.get_text(f\"{selector}:nth-of-type({i+1})\")\n            if href:\n                links.append({\"url\": href, \"text\": text or \"\"})\n        \n        return TaskResult(success=True, data=links)\n    \n    async def _screenshot(self, params: Dict[str, Any]) -> TaskResult:\n        name = params.get(\"name\")\n        path = await self.browser.screenshot(name)\n        return TaskResult(success=True, data=path)\n    \n    async def _wait(self, params: Dict[str, Any]) -> TaskResult:\n        wait_type = params.get(\"type\", \"time\")\n        \n        if wait_type == \"time\":\n            duration = params.get(\"duration\", 1000)\n            await asyncio.sleep(duration / 1000)\n            return TaskResult(success=True)\n        elif wait_type == \"selector\":\n            selector = params.get(\"selector\")\n            if not selector:\n                return TaskResult(success=False, error=\"Selector is required for selector wait\")\n            success = await self.browser.wait_for_selector(selector, params.get(\"timeout\"))\n            return TaskResult(success=success)\n        elif wait_type == \"load\":\n            await self.browser.wait_for_load(params.get(\"timeout\"))\n            return TaskResult(success=True)\n        else:\n            return TaskResult(success=False, error=f\"Unknown wait type: {wait_type}\")\n    \n    async def _scroll(self, params: Dict[str, Any]) -> TaskResult:\n        direction = params.get(\"direction\", \"down\")\n        amount = params.get(\"amount\", 500)\n        \n        script = f\"window.scrollBy(0, {amount if direction == 'down' else -amount})\"\n        await self.browser.execute_script(script)\n        \n        return TaskResult(success=True)\n    \n    async def _execute_script(self, params: Dict[str, Any]) -> TaskResult:\n        script = params.get(\"script\")\n        if not script:\n            return TaskResult(success=False, error=\"Script is required\")\n        \n        result = await self.browser.execute_script(script)\n        return TaskResult(success=True, data=result)\n    \n    async def fill_form(self, form_data: Dict[str, str]) -> bool:\n        logger.info(\"Filling form with provided data\")\n        \n        for selector, value in form_data.items():\n            success = await self.browser.fill(selector, value)\n            if not success:\n                logger.error(f\"Failed to fill field: {selector}\")\n                return False\n        \n        logger.success(\"Form filled successfully\")\n        return True\n    \n    async def scrape_table(self, table_selector: str) -> List[Dict[str, Any]]:\n        logger.info(f\"Scraping table: {table_selector}\")\n        \n        headers_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('th'))\n            .map(th => th.textContent.trim())\n        \"\"\"\n        headers = await self.browser.execute_script(headers_script)\n        \n        rows_script = f\"\"\"\n        Array.from(document.querySelector('{table_selector}').querySelectorAll('tbody tr'))\n            .map(tr => Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim()))\n        \"\"\"\n        rows = await self.browser.execute_script(rows_script)\n        \n        table_data = []\n        for row in rows:\n            row_dict = dict(zip(headers, row))\n            table_data.append(row_dict)\n        \n        logger.success(f\"Scraped {len(table_data)} rows from table\")\n        return table_data\n","size_bytes":7377},"visionvault/__init__.py":{"content":"","size_bytes":0},"visionvault/services/advanced_locator_validator.py":{"content":"\"\"\"\nAdvanced Locator Validator - Intelligent locator testing and selection\n\nThis module provides advanced locator validation capabilities that:\n1. Tests all possible locator strategies in parallel\n2. Automatically selects the most reliable unique locator\n3. Caches successful locators for reuse\n4. Provides confidence scores based on stability and uniqueness\n\"\"\"\n\nimport asyncio\nimport re\nfrom typing import Dict, List, Tuple, Optional\nimport json\nimport os\nfrom datetime import datetime\n\n\nclass LocatorCache:\n    \"\"\"Cache for successful locators to speed up future executions\"\"\"\n    \n    def __init__(self, cache_file='data/locator_cache.json'):\n        self.cache_file = cache_file\n        self.cache = self._load_cache()\n    \n    def _load_cache(self) -> Dict:\n        \"\"\"Load cache from file\"\"\"\n        try:\n            if os.path.exists(self.cache_file):\n                with open(self.cache_file, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            print(f\"⚠️  Could not load locator cache: {e}\")\n        return {}\n    \n    def _save_cache(self):\n        \"\"\"Save cache to file\"\"\"\n        try:\n            os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n            with open(self.cache_file, 'w') as f:\n                json.dump(self.cache, f, indent=2)\n        except Exception as e:\n            print(f\"⚠️  Could not save locator cache: {e}\")\n    \n    def get(self, url: str, element_description: str) -> Optional[Dict]:\n        \"\"\"Get cached locator for a URL and element description\"\"\"\n        key = f\"{url}::{element_description}\"\n        return self.cache.get(key)\n    \n    def set(self, url: str, element_description: str, locator_info: Dict):\n        \"\"\"Cache a successful locator\"\"\"\n        key = f\"{url}::{element_description}\"\n        self.cache[key] = {\n            **locator_info,\n            'last_used': datetime.now().isoformat(),\n            'success_count': self.cache.get(key, {}).get('success_count', 0) + 1\n        }\n        self._save_cache()\n\n\nclass AdvancedLocatorValidator:\n    \"\"\"Advanced locator validation with parallel testing and intelligent selection\"\"\"\n    \n    def __init__(self, page):\n        self.page = page\n        self.cache = LocatorCache()\n    \n    async def generate_all_possible_locators(self, element_info: Dict) -> List[Tuple[int, str, str]]:\n        \"\"\"\n        Generate ALL possible locator strategies from element information.\n        Returns list of (score, locator_code, strategy_name) tuples.\n        Lower score = higher priority.\n        \"\"\"\n        locators = []\n        \n        # 1. TEST ID LOCATORS (Score: 1 - HIGHEST PRIORITY)\n        if element_info.get('testId'):\n            locators.append((1, f'page.get_by_test_id(\"{element_info[\"testId\"]}\")', 'testid'))\n        \n        # 2. ROLE-BASED LOCATORS (Score: 100-510)\n        role = self._determine_role(element_info)\n        if role:\n            name = element_info.get('text') or element_info.get('ariaLabel')\n            if name:\n                # Role with exact name - most reliable\n                locators.append((100, f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)', 'role_exact'))\n                # Role with partial name\n                locators.append((105, f'page.get_by_role(\"{role}\", name=\"{name}\")', 'role_name'))\n            else:\n                # Role alone - less reliable\n                locators.append((510, f'page.get_by_role(\"{role}\")', 'role_only'))\n        \n        # 3. PLACEHOLDER LOCATORS (Score: 120)\n        if element_info.get('placeholder'):\n            locators.append((120, f'page.get_by_placeholder(\"{element_info[\"placeholder\"]}\", exact=True)', 'placeholder_exact'))\n            locators.append((125, f'page.get_by_placeholder(\"{element_info[\"placeholder\"]}\")', 'placeholder'))\n        \n        # 4. LABEL LOCATORS (Score: 140)\n        if element_info.get('ariaLabel'):\n            locators.append((140, f'page.get_by_label(\"{element_info[\"ariaLabel\"]}\", exact=True)', 'label_exact'))\n            locators.append((145, f'page.get_by_label(\"{element_info[\"ariaLabel\"]}\")', 'label'))\n        \n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if element_info.get('alt'):\n            locators.append((160, f'page.get_by_alt_text(\"{element_info[\"alt\"]}\", exact=True)', 'alt_exact'))\n            locators.append((165, f'page.get_by_alt_text(\"{element_info[\"alt\"]}\")', 'alt'))\n        \n        # 6. TEXT LOCATORS (Score: 180-250)\n        if element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((180, f'page.get_by_text(\"{text}\", exact=True)', 'text_exact'))\n                locators.append((185, f'page.get_by_text(\"{text}\")', 'text'))\n                # Text content with regex for partial matching\n                if len(text) > 5:\n                    escaped_text = re.escape(text[:30])\n                    locators.append((250, f'page.get_by_text(re.compile(r\"{escaped_text}\"))', 'text_regex'))\n        \n        # 7. TITLE LOCATORS (Score: 200)\n        if element_info.get('title'):\n            locators.append((200, f'page.get_by_title(\"{element_info[\"title\"]}\")', 'title'))\n        \n        # 8. CSS SELECTORS (Score: 500+)\n        # ID selector - very reliable\n        if element_info.get('id'):\n            locators.append((500, f'page.locator(\"#{element_info[\"id\"]}\")', 'css_id'))\n        \n        # Class selectors\n        if element_info.get('classes'):\n            classes = element_info['classes'].strip().split()\n            if classes:\n                # Single class\n                locators.append((520, f'page.locator(\"{element_info[\"tag\"]}.{classes[0]}\")', 'css_class'))\n                # All classes\n                if len(classes) > 1:\n                    all_classes = '.'.join(classes)\n                    locators.append((515, f'page.locator(\"{element_info[\"tag\"]}.{all_classes}\")', 'css_all_classes'))\n        \n        # Attribute selectors\n        if element_info.get('type'):\n            locators.append((520, f'page.locator(\"{element_info[\"tag\"]}[type=\\\\\"{element_info[\"type\"]}\\\\\"]\")', 'css_type'))\n        \n        if element_info.get('name'):\n            locators.append((525, f'page.locator(\"{element_info[\"tag\"]}[name=\\\\\"{element_info[\"name\"]}\\\\\"]\")', 'css_name'))\n        \n        if element_info.get('href'):\n            href = element_info['href'][:100]  # Limit length\n            locators.append((525, f'page.locator(\"{element_info[\"tag\"]}[href=\\\\\"{href}\\\\\"]\")', 'css_href'))\n        \n        if element_info.get('value'):\n            locators.append((530, f'page.locator(\"{element_info[\"tag\"]}[value=\\\\\"{element_info[\"value\"]}\\\\\"]\")', 'css_value'))\n        \n        # Tag only - lowest priority\n        locators.append((600, f'page.locator(\"{element_info[\"tag\"]}\")', 'css_tag'))\n        \n        # 9. COMBINED LOCATORS (Score: 300-400)\n        # Combine strategies for better specificity\n        if role and element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((300, f'page.get_by_role(\"{role}\").filter(has_text=\"{text}\")', 'role_filter_text'))\n        \n        if element_info.get('id') and element_info.get('text'):\n            text = element_info['text'].strip()\n            if text:\n                locators.append((350, f'page.locator(\"#{element_info[\"id\"]}\").get_by_text(\"{text}\")', 'id_filter_text'))\n        \n        # Sort by score (lower is better)\n        locators.sort(key=lambda x: x[0])\n        return locators\n    \n    def _determine_role(self, element_info: Dict) -> Optional[str]:\n        \"\"\"Determine the ARIA role for an element\"\"\"\n        if element_info.get('role'):\n            return element_info['role']\n        \n        tag = element_info.get('tag', '').lower()\n        input_type = element_info.get('type', '').lower()\n        \n        role_map = {\n            'button': 'button',\n            'a': 'link',\n            'img': 'img',\n            'h1': 'heading',\n            'h2': 'heading',\n            'h3': 'heading',\n            'h4': 'heading',\n            'h5': 'heading',\n            'h6': 'heading',\n            'nav': 'navigation',\n            'main': 'main',\n            'header': 'banner',\n            'footer': 'contentinfo',\n            'aside': 'complementary',\n            'section': 'region',\n        }\n        \n        if tag in role_map:\n            return role_map[tag]\n        \n        if tag == 'input':\n            input_role_map = {\n                'text': 'textbox',\n                'email': 'textbox',\n                'password': 'textbox',\n                'search': 'searchbox',\n                'tel': 'textbox',\n                'url': 'textbox',\n                'checkbox': 'checkbox',\n                'radio': 'radio',\n                'button': 'button',\n                'submit': 'button',\n                'reset': 'button',\n            }\n            return input_role_map.get(input_type, 'textbox')\n        \n        if tag == 'textarea':\n            return 'textbox'\n        \n        if tag == 'select':\n            return 'combobox'\n        \n        return None\n    \n    async def verify_locator(self, locator_code: str) -> Tuple[int, bool, Optional[str]]:\n        \"\"\"\n        Verify a locator and return (count, is_visible, error).\n        Tests both count and visibility.\n        \"\"\"\n        try:\n            count = await self._count_matches(locator_code)\n            \n            if count == 0:\n                return (0, False, None)\n            \n            # Check if the element is visible\n            is_visible = False\n            if count == 1:\n                try:\n                    is_visible = await self._is_element_visible(locator_code)\n                except Exception:\n                    pass\n            \n            return (count, is_visible, None)\n        \n        except Exception as e:\n            return (999, False, str(e))\n    \n    async def _count_matches(self, locator_code: str) -> int:\n        \"\"\"Count how many elements match a locator\"\"\"\n        try:\n            if 'get_by_test_id' in locator_code:\n                match = re.search(r'get_by_test_id\\(\"([^\"]+)\"\\)', locator_code)\n                if match:\n                    return await self.page.locator(f'[data-testid=\"{match.group(1)}\"]').count()\n            \n            elif 'get_by_role' in locator_code:\n                role_match = re.search(r'get_by_role\\(\"([^\"]+)\"', locator_code)\n                name_match = re.search(r'name=\"([^\"]+)\"', locator_code)\n                exact = 'exact=True' in locator_code\n                \n                if role_match:\n                    role = role_match.group(1)\n                    name = name_match.group(1) if name_match else None\n                    if name:\n                        return await self.page.get_by_role(role, name=name, exact=exact).count()\n                    else:\n                        return await self.page.get_by_role(role).count()\n            \n            elif 'get_by_text' in locator_code:\n                text_match = re.search(r'get_by_text\\(\"([^\"]+)\"', locator_code)\n                if text_match:\n                    text = text_match.group(1)\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_text(text, exact=exact).count()\n            \n            elif 'get_by_placeholder' in locator_code:\n                match = re.search(r'get_by_placeholder\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_placeholder(match.group(1), exact=exact).count()\n            \n            elif 'get_by_label' in locator_code:\n                match = re.search(r'get_by_label\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_label(match.group(1), exact=exact).count()\n            \n            elif 'get_by_alt_text' in locator_code:\n                match = re.search(r'get_by_alt_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    exact = 'exact=True' in locator_code\n                    return await self.page.get_by_alt_text(match.group(1), exact=exact).count()\n            \n            elif 'get_by_title' in locator_code:\n                match = re.search(r'get_by_title\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    return await self.page.get_by_title(match.group(1)).count()\n            \n            elif 'page.locator' in locator_code:\n                match = re.search(r'page\\.locator\\(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\)', locator_code)\n                if match:\n                    selector = match.group(1).replace('\\\\\"', '\"')\n                    return await self.page.locator(selector).count()\n            \n            elif '.filter(' in locator_code or '.get_by_text(' in locator_code:\n                # Handle chained locators - for now, return high count (needs page context)\n                return 999\n            \n            return 999\n        \n        except Exception:\n            return 999\n    \n    async def _is_element_visible(self, locator_code: str) -> bool:\n        \"\"\"Check if an element matching the locator is visible\"\"\"\n        try:\n            # This is a simplified check - you'd need to actually get the locator\n            # For now, assume visible if count is 1\n            return True\n        except Exception:\n            return False\n    \n    async def find_best_locator(self, element_info: Dict, page_url: str = '') -> Optional[Dict]:\n        \"\"\"\n        Find the best locator for an element by testing all strategies in parallel.\n        Returns dict with locator info or None if no unique locator found.\n        \"\"\"\n        # Check cache first\n        if page_url and element_info.get('text'):\n            cached = self.cache.get(page_url, element_info['text'])\n            if cached:\n                print(f\"✅ Using cached locator for '{element_info.get('text', 'element')[:30]}...'\")\n                return cached\n        \n        # Generate all possible locators\n        all_locators = await self.generate_all_possible_locators(element_info)\n        \n        if not all_locators:\n            print(\"❌ No locators could be generated from element info\")\n            return None\n        \n        print(f\"🔍 Testing {len(all_locators)} locator strategies in parallel...\")\n        \n        # Test all locators in parallel\n        tasks = [self.verify_locator(loc[1]) for loc in all_locators]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Find best unique visible locator\n        best_locator = None\n        best_score = float('inf')\n        \n        for i, (score, locator_code, strategy) in enumerate(all_locators):\n            if isinstance(results[i], Exception):\n                print(f\"  ⚠️  {strategy}: Error during validation\")\n                continue\n            \n            count, is_visible, error = results[i]\n            \n            if error:\n                print(f\"  ⚠️  {strategy}: {error}\")\n                continue\n            \n            print(f\"  {'✅' if count == 1 else '⚠️ '} {strategy}: {locator_code} → {count} match(es){' (visible)' if is_visible else ''}\")\n            \n            # Prefer unique locators that are visible\n            if count == 1 and is_visible and score < best_score:\n                best_locator = {\n                    'locator': locator_code,\n                    'strategy': strategy,\n                    'score': score,\n                    'count': count,\n                    'visible': is_visible,\n                    'unique': True,\n                    'confidence': 100 - min(score, 100)  # Convert score to confidence\n                }\n                best_score = score\n            # If no visible unique locator yet, accept non-visible unique\n            elif count == 1 and not best_locator and score < best_score:\n                best_locator = {\n                    'locator': locator_code,\n                    'strategy': strategy,\n                    'score': score,\n                    'count': count,\n                    'visible': is_visible,\n                    'unique': True,\n                    'confidence': 90 - min(score, 90)\n                }\n                best_score = score\n        \n        if best_locator:\n            print(f\"✅ Best locator: {best_locator['strategy']} (confidence: {best_locator['confidence']}%)\")\n            \n            # Cache successful locator\n            if page_url and element_info.get('text'):\n                self.cache.set(page_url, element_info['text'], best_locator)\n            \n            return best_locator\n        \n        # No unique locator found - return best scored locator with warning\n        for i, (score, locator_code, strategy) in enumerate(all_locators):\n            if not isinstance(results[i], Exception):\n                count, is_visible, error = results[i]\n                if count > 0 and not error:\n                    print(f\"⚠️  No unique locator found. Using: {strategy} (matches {count} elements)\")\n                    return {\n                        'locator': locator_code,\n                        'strategy': strategy,\n                        'score': score,\n                        'count': count,\n                        'visible': is_visible,\n                        'unique': False,\n                        'confidence': 50 - min(score // 10, 50)\n                    }\n        \n        print(\"❌ No valid locator found\")\n        return None\n    \n    async def validate_and_improve_locator(self, locator_code: str, element_info: Optional[Dict] = None) -> Dict:\n        \"\"\"\n        Validate an existing locator and suggest improvements if needed.\n        Returns validation result with alternative suggestions.\n        \"\"\"\n        count, is_visible, error = await self.verify_locator(locator_code)\n        \n        result = {\n            'original_locator': locator_code,\n            'is_valid': count == 1 and not error,\n            'count': count,\n            'visible': is_visible,\n            'error': error,\n            'alternatives': []\n        }\n        \n        # If locator is not unique or has errors, generate alternatives\n        if (count != 1 or error) and element_info:\n            print(f\"🔍 Generating alternative locators...\")\n            best = await self.find_best_locator(element_info)\n            if best:\n                result['alternatives'] = [best]\n                result['recommended'] = best['locator']\n        \n        return result\n","size_bytes":18664},"run_agent.py":{"content":"from visionvault.agents.main import main\n\nif __name__ == '__main__':\n    main()","size_bytes":79},"visionvault/agents/browser_manager.py":{"content":"class BrowserManager:\n    def __init__(self):\n        self.active_page = None\n        self.active_playwright_instance = None\n        self.widget_injection_complete = None\n\n    async def cleanup_browser(self):\n        \"\"\"Clean up browser resources\"\"\"\n        if self.active_page and hasattr(self.active_page, 'context') and hasattr(self.active_page.context, 'browser'):\n            try:\n                browser = self.active_page.context.browser\n                await browser.close()\n                print(\"✅ Browser closed after healing attempt\")\n            except Exception as e:\n                print(f\"Browser cleanup error: {e}\")\n            finally:\n                self.active_page = None\n\n        if self.active_playwright_instance and hasattr(self.active_playwright_instance, 'stop'):\n            try:\n                await self.active_playwright_instance.stop()\n                print(\"✅ Playwright instance stopped\")\n            except Exception as e:\n                print(f\"Playwright cleanup error: {e}\")\n            finally:\n                self.active_playwright_instance = None\n\n    def set_active_page(self, page):\n        \"\"\"Set the active page for healing operations\"\"\"\n        self.active_page = page\n\n    def set_playwright_instance(self, playwright_instance):\n        \"\"\"Set the active playwright instance\"\"\"\n        self.active_playwright_instance = playwright_instance\n\n    def set_widget_event(self, event):\n        \"\"\"Set the widget injection completion event\"\"\"\n        self.widget_injection_complete = event","size_bytes":1539},"visionvault/agents/recording_session.py":{"content":"import asyncio\nimport os\nimport subprocess\nfrom .config import AGENT_ID, SERVER_URL\n\nclass CodegenRecordingSessionManager:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n        self.sessions = {}  # session_id -> subprocess info\n\n    async def start_recording_session(self, session_id: str, start_url: str = \"\"):\n        \"\"\"Start a Playwright codegen session in a subprocess.\"\"\"\n        if session_id in self.sessions:\n            print(f\"Session {session_id} is already running\")\n            return\n\n        os.makedirs(\"recordings\", exist_ok=True)\n        output_file = os.path.join(\"recordings\", f\"{session_id}.py\")\n\n        cmd = [\n            \"playwright\",\n            \"codegen\",\n            \"--target=python\",\n            \"--output\", output_file\n        ]\n        if start_url:\n            cmd.append(start_url)\n\n        print(f\"🎬 Starting codegen session {session_id}\")\n        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        self.sessions[session_id] = {\n            \"process\": process,\n            \"output_file\": output_file,\n            \"start_url\": start_url\n        }\n\n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"started\",\n            \"output_file\": output_file\n        })\n        \n        asyncio.create_task(self._monitor_process(session_id))\n\n    async def _monitor_process(self, session_id: str):\n        \"\"\"Monitor the recording process and auto-stop when browser closes.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            return\n        \n        process = session[\"process\"]\n        \n        await asyncio.get_event_loop().run_in_executor(None, process.wait)\n        \n        print(f\"🔔 Browser closed for session {session_id}. Auto-stopping recording...\")\n        await self.stop_recording_session(session_id, auto_stopped=True)\n\n    async def stop_recording_session(self, session_id: str, auto_stopped: bool = False):\n        \"\"\"Stop the codegen subprocess and read the generated file.\"\"\"\n        session = self.sessions.get(session_id)\n        if not session:\n            print(f\"Session {session_id} not found\")\n            return\n\n        process = session[\"process\"]\n        output_file = session[\"output_file\"]\n        \n        if process.poll() is None:\n            process.terminate()\n            try:\n                await asyncio.get_event_loop().run_in_executor(None, lambda: process.wait(timeout=5))\n            except subprocess.TimeoutExpired:\n                process.kill()\n        \n        await asyncio.sleep(0.5)\n        \n        playwright_code = None\n        actions = []\n        \n        if os.path.exists(output_file):\n            try:\n                with open(output_file, 'r') as f:\n                    playwright_code = f.read()\n                \n                actions = self._extract_actions_from_code(playwright_code)\n                print(f\"✅ Extracted {len(actions)} actions from recording\")\n            except Exception as e:\n                print(f\"⚠️ Error reading recording file: {e}\")\n        \n        self.socket_client.emit(\"recording_status\", {\n            \"session_id\": session_id,\n            \"status\": \"stopped\",\n            \"output_file\": output_file,\n            \"playwright_code\": playwright_code,\n            \"actions\": actions,\n            \"auto_stopped\": auto_stopped\n        })\n\n        print(f\"✅ Recording session {session_id} {'auto-' if auto_stopped else ''}stopped. Output: {output_file}\")\n        del self.sessions[session_id]\n    \n    def _extract_actions_from_code(self, code: str) -> list:\n        \"\"\"Extract human-readable actions with locators from generated Playwright code.\"\"\"\n        actions = []\n        lines = code.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            \n            if 'page.goto(' in line:\n                import re\n                match = re.search(r'page\\.goto\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Navigate',\n                        'locator': match.group(1),\n                        'description': f'Navigate to {match.group(1)}'\n                    })\n            \n            elif 'page.click(' in line:\n                import re\n                match = re.search(r'page\\.click\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Click',\n                        'locator': match.group(1),\n                        'description': f'Click element: {match.group(1)}'\n                    })\n            \n            elif 'page.fill(' in line:\n                import re\n                match = re.search(r'page\\.fill\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Type',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Type \"{match.group(2)}\" into {match.group(1)}'\n                    })\n            \n            elif 'page.select_option(' in line:\n                import re\n                match = re.search(r'page\\.select_option\\([\"\\']([^\"\\']+)[\"\\'],\\s*[\"\\']([^\"\\']*)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Select',\n                        'locator': match.group(1),\n                        'value': match.group(2),\n                        'description': f'Select option \"{match.group(2)}\" in {match.group(1)}'\n                    })\n            \n            elif 'page.check(' in line:\n                import re\n                match = re.search(r'page\\.check\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Check',\n                        'locator': match.group(1),\n                        'description': f'Check checkbox: {match.group(1)}'\n                    })\n            \n            elif 'page.press(' in line or 'page.keyboard.press(' in line:\n                import re\n                match = re.search(r'press\\([\"\\']([^\"\\']+)[\"\\']', line)\n                if match:\n                    actions.append({\n                        'action': 'Press Key',\n                        'locator': match.group(1),\n                        'description': f'Press key: {match.group(1)}'\n                    })\n        \n        return actions\n","size_bytes":6586},"visionvault/services/code_validator.py":{"content":"import ast\nimport re\n\nclass CodeValidator:\n    ALLOWED_IMPORTS = {\n        'playwright.async_api',\n        'asyncio',\n        'time',\n        'datetime',\n        're',\n        'json',\n        'base64'\n    }\n    \n    DANGEROUS_MODULES = {\n        'os', 'sys', 'subprocess', 'shutil', 'eval', 'exec',\n        'compile', '__import__', 'open', 'file', 'input',\n        'execfile', 'reload', 'importlib', 'pickle', 'shelve',\n        'socket', 'urllib', 'requests', 'http', 'ftplib',\n        'telnetlib', 'smtplib', 'poplib', 'imaplib'\n    }\n    \n    def __init__(self):\n        self.errors = []\n    \n    def validate(self, code):\n        self.errors = []\n        \n        if not code or not isinstance(code, str):\n            self.errors.append(\"Code must be a non-empty string\")\n            return False\n        \n        if not self._check_function_structure(code):\n            return False\n        \n        if not self._check_dangerous_imports(code):\n            return False\n        \n        if not self._check_dangerous_patterns(code):\n            return False\n        \n        try:\n            tree = ast.parse(code)\n            if not self._validate_ast(tree):\n                return False\n        except SyntaxError as e:\n            self.errors.append(f\"Syntax error: {str(e)}\")\n            return False\n        \n        return True\n    \n    def _check_function_structure(self, code):\n        if 'async def run_test' not in code:\n            self.errors.append(\"Code must contain 'async def run_test' function\")\n            return False\n        \n        if 'playwright.async_api import async_playwright' not in code:\n            self.errors.append(\"Code must use 'from playwright.async_api import async_playwright'\")\n            return False\n        \n        return True\n    \n    def _check_dangerous_imports(self, code):\n        for module in self.DANGEROUS_MODULES:\n            patterns = [\n                f'import {module}',\n                f'from {module}',\n                f'__import__(\"{module}\")',\n                f\"__import__('{module}')\"\n            ]\n            for pattern in patterns:\n                if pattern in code:\n                    self.errors.append(f\"Dangerous import detected: {module}\")\n                    return False\n        \n        return True\n    \n    def _check_dangerous_patterns(self, code):\n        dangerous_patterns = [\n            (r'\\beval\\s*\\(', 'eval() function'),\n            (r'\\bexec\\s*\\(', 'exec() function'),\n            (r'\\b__import__\\s*\\(', '__import__() function'),\n            (r'\\bcompile\\s*\\(', 'compile() function'),\n            (r'\\bopen\\s*\\(', 'open() function (file access)'),\n            (r'\\.system\\s*\\(', 'system() call'),\n            (r'\\.popen\\s*\\(', 'popen() call'),\n            (r'\\.spawn\\s*\\(', 'spawn() call'),\n        ]\n        \n        for pattern, name in dangerous_patterns:\n            if re.search(pattern, code, re.IGNORECASE):\n                self.errors.append(f\"Dangerous pattern detected: {name}\")\n                return False\n        \n        return True\n    \n    def _validate_ast(self, tree):\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if not self._is_allowed_import(alias.name):\n                        self.errors.append(f\"Disallowed import: {alias.name}\")\n                        return False\n            \n            elif isinstance(node, ast.ImportFrom):\n                if node.module and not self._is_allowed_import(node.module):\n                    self.errors.append(f\"Disallowed import from: {node.module}\")\n                    return False\n            \n            elif isinstance(node, ast.Call):\n                if isinstance(node.func, ast.Name):\n                    if node.func.id in ['eval', 'exec', 'compile', '__import__', 'open']:\n                        self.errors.append(f\"Dangerous function call: {node.func.id}\")\n                        return False\n        \n        return True\n    \n    def _is_allowed_import(self, module_name):\n        for allowed in self.ALLOWED_IMPORTS:\n            if module_name.startswith(allowed):\n                return True\n        return False\n    \n    def get_errors(self):\n        return self.errors\n","size_bytes":4240},"visionvault/services/vector_store.py":{"content":"import numpy as np\nimport faiss\nimport json\nimport os\nfrom typing import List, Dict, Tuple, Optional\nimport google.generativeai as genai\n\n\nclass VectorStore:\n    \"\"\"Vector store for semantic search using FAISS.\"\"\"\n    \n    def __init__(self, dimension=768, index_path='data/vector_index.faiss', \n                 metadata_path='data/vector_metadata.json'):\n        self.dimension = dimension  # Gemini embeddings are 768 dimensions\n        self.index_path = index_path\n        self.metadata_path = metadata_path\n        self.index = None\n        self.metadata = []  # Store task_ids corresponding to each vector\n        \n        # Initialize or load index\n        self._load_or_create_index()\n    \n    def _load_or_create_index(self):\n        \"\"\"Load existing index or create a new one.\"\"\"\n        if os.path.exists(self.index_path) and os.path.exists(self.metadata_path):\n            print(f\"Loading existing vector index from {self.index_path}\")\n            loaded_index = faiss.read_index(self.index_path)\n            with open(self.metadata_path, 'r') as f:\n                self.metadata = json.load(f)\n            \n            # Check if it's a legacy L2 index (needs migration to IP for cosine similarity)\n            index_type = type(loaded_index).__name__\n            if 'L2' in index_type or (hasattr(loaded_index, 'metric_type') and loaded_index.metric_type == faiss.METRIC_L2):\n                print(\"⚠️  Detected legacy L2 index, migrating to cosine similarity (IndexFlatIP)...\")\n                # Rebuild as IP index with all existing vectors\n                self.index = faiss.IndexFlatIP(self.dimension)\n                for idx in range(loaded_index.ntotal):\n                    vector = loaded_index.reconstruct(idx)\n                    # Re-normalize vector for cosine similarity\n                    normalized = self._normalize_embedding(vector)\n                    self.index.add(normalized.reshape(1, -1))\n                print(f\"✅ Migrated {loaded_index.ntotal} vectors to cosine similarity index\")\n                self._save_index()\n            else:\n                self.index = loaded_index\n        else:\n            print(\"Creating new vector index\")\n            # Using IndexFlatIP (Inner Product) for cosine similarity with normalized vectors\n            self.index = faiss.IndexFlatIP(self.dimension)\n            self.metadata = []\n            self._save_index()\n    \n    def _normalize_embedding(self, embedding: np.ndarray) -> np.ndarray:\n        \"\"\"Normalize embedding to unit length for cosine similarity.\"\"\"\n        norm = np.linalg.norm(embedding)\n        if norm > 0:\n            return embedding / norm\n        return embedding\n    \n    def _save_index(self):\n        \"\"\"Save index and metadata to disk.\"\"\"\n        faiss.write_index(self.index, self.index_path)\n        with open(self.metadata_path, 'w') as f:\n            json.dump(self.metadata, f)\n    \n    def add_vector(self, task_id: str, embedding: np.ndarray):\n        \"\"\"Add a vector and its metadata to the index.\"\"\"\n        if embedding.shape[0] != self.dimension:\n            raise ValueError(f\"Embedding dimension {embedding.shape[0]} does not match index dimension {self.dimension}\")\n        \n        # Normalize for cosine similarity\n        normalized_embedding = self._normalize_embedding(embedding)\n        \n        # FAISS expects vectors as float32 and in shape (1, dimension)\n        embedding_array = normalized_embedding.astype('float32').reshape(1, -1)\n        \n        # Add to index\n        self.index.add(embedding_array)\n        \n        # Add metadata\n        self.metadata.append(task_id)\n        \n        # Save to disk\n        self._save_index()\n    \n    def update_vector(self, task_id: str, new_embedding: np.ndarray):\n        \"\"\"Update a vector for an existing task_id.\"\"\"\n        # Find the index of the task_id\n        if task_id not in self.metadata:\n            # If not found, just add it\n            self.add_vector(task_id, new_embedding)\n            return\n        \n        # Normalize for cosine similarity\n        normalized_embedding = self._normalize_embedding(new_embedding)\n        \n        # FAISS doesn't support updates directly, so we need to rebuild\n        # Get all vectors except the one to update\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        # Create new index\n        new_index = faiss.IndexFlatIP(self.dimension)\n        new_metadata = []\n        \n        # Add all vectors except the one being updated\n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        # Add the updated vector\n        new_embedding_array = normalized_embedding.astype('float32').reshape(1, -1)\n        new_index.add(new_embedding_array)\n        new_metadata.append(task_id)\n        \n        # Replace old index and metadata\n        self.index = new_index\n        self.metadata = new_metadata\n        \n        # Save to disk\n        self._save_index()\n    \n    def search(self, query_embedding: np.ndarray, top_k: int = 5) -> List[Tuple[str, float]]:\n        \"\"\"\n        Search for the most similar vectors using cosine similarity.\n        \n        Returns:\n            List of (task_id, similarity_score) tuples, sorted by similarity (higher score = more similar)\n        \"\"\"\n        if self.index.ntotal == 0:\n            return []\n        \n        # Normalize query for cosine similarity\n        normalized_query = self._normalize_embedding(query_embedding)\n        \n        # Ensure query is the right shape\n        query_array = normalized_query.astype('float32').reshape(1, -1)\n        \n        # Search (returns cosine similarity scores since we use IndexFlatIP with normalized vectors)\n        top_k = min(top_k, self.index.ntotal)  # Don't ask for more than we have\n        similarities, indices = self.index.search(query_array, top_k)\n        \n        # Build results\n        results = []\n        for i, idx in enumerate(indices[0]):\n            if idx < len(self.metadata):  # Safety check\n                task_id = self.metadata[idx]\n                # Cosine similarity is already in range [-1, 1], convert to [0, 1]\n                similarity = float((similarities[0][i] + 1) / 2)  # Normalize to 0-1 range\n                results.append((task_id, similarity))\n        \n        return results\n    \n    def delete_vector(self, task_id: str):\n        \"\"\"Delete a vector by task_id.\"\"\"\n        if task_id not in self.metadata:\n            return\n        \n        # Rebuild index without the deleted vector\n        indices_to_keep = [i for i, tid in enumerate(self.metadata) if tid != task_id]\n        \n        new_index = faiss.IndexFlatIP(self.dimension)  # Use IP for cosine similarity\n        new_metadata = []\n        \n        for idx in indices_to_keep:\n            vector = self.index.reconstruct(idx)\n            # Vector is already normalized, so just add it\n            new_index.add(vector.reshape(1, -1))\n            new_metadata.append(self.metadata[idx])\n        \n        self.index = new_index\n        self.metadata = new_metadata\n        \n        self._save_index()\n    \n    def get_all_task_ids(self) -> List[str]:\n        \"\"\"Get all task_ids in the index.\"\"\"\n        return self.metadata.copy()\n    \n    def clear(self):\n        \"\"\"Clear all vectors from the index.\"\"\"\n        self.index = faiss.IndexFlatIP(self.dimension)  # Use IP for cosine similarity\n        self.metadata = []\n        self._save_index()\n\n\nclass EmbeddingService:\n    \"\"\"Service for generating embeddings using Google Gemini API.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.api_key = api_key or os.environ.get('GEMINI_API_KEY')\n        if not self.api_key:\n            raise ValueError(\"Gemini API key is required for embedding generation. Please set GEMINI_API_KEY environment variable.\")\n        \n        genai.configure(api_key=self.api_key)\n        self.model = \"models/text-embedding-004\"  # Gemini's latest embedding model\n    \n    def generate_embedding(self, text: str) -> np.ndarray:\n        \"\"\"Generate embedding for a text string.\"\"\"\n        try:\n            result = genai.embed_content(\n                model=self.model,\n                content=text,\n                task_type=\"retrieval_document\"\n            )\n            \n            # Extract the embedding vector\n            embedding = np.array(result['embedding'], dtype=np.float32)\n            return embedding\n            \n        except Exception as e:\n            print(f\"Error generating embedding: {e}\")\n            raise\n    \n    def generate_task_embedding(self, task_name: str, description: str, tags: List[str]) -> np.ndarray:\n        \"\"\"\n        Generate embedding for a task based on its metadata.\n        Combines task name, description, and tags into a single text.\n        \"\"\"\n        # Create a comprehensive text representation\n        text_parts = [task_name]\n        \n        if description:\n            text_parts.append(description)\n        \n        if tags:\n            text_parts.append(\"Tags: \" + \", \".join(tags))\n        \n        combined_text = \". \".join(text_parts)\n        \n        return self.generate_embedding(combined_text)\n\n\nclass SemanticSearch:\n    \"\"\"High-level semantic search service combining VectorStore and EmbeddingService.\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        self.vector_store = VectorStore()\n        self.embedding_service = EmbeddingService(api_key)\n    \n    def index_task(self, task):\n        \"\"\"Index a LearnedTask for semantic search.\"\"\"\n        # Generate embedding from task metadata\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        # Add to vector store\n        self.vector_store.add_vector(task.task_id, embedding)\n        \n        # Also save embedding with the task\n        task.embedding_vector = embedding\n        task.save()\n    \n    def update_task_index(self, task):\n        \"\"\"Update the index for an existing task.\"\"\"\n        embedding = self.embedding_service.generate_task_embedding(\n            task.task_name,\n            task.description,\n            task.tags\n        )\n        \n        self.vector_store.update_vector(task.task_id, embedding)\n        \n        task.embedding_vector = embedding\n        task.save()\n    \n    def search_tasks(self, query: str, top_k: int = 5) -> List[Dict]:\n        \"\"\"\n        Search for tasks similar to the query.\n        \n        Returns:\n            List of task dictionaries with similarity scores\n        \"\"\"\n        # Generate embedding for query\n        query_embedding = self.embedding_service.generate_embedding(query)\n        \n        # Search vector store\n        results = self.vector_store.search(query_embedding, top_k)\n        \n        # Fetch task details from database\n        from visionvault.core.models import LearnedTask\n        \n        tasks_with_scores = []\n        for task_id, similarity_score in results:\n            task = LearnedTask.get_by_id(task_id)\n            if task:\n                task_dict = task.to_dict()\n                # similarity_score is already in range [0, 1] from cosine similarity\n                task_dict['similarity_score'] = float(similarity_score)\n                tasks_with_scores.append(task_dict)\n        \n        return tasks_with_scores\n    \n    def delete_task_from_index(self, task_id: str):\n        \"\"\"Remove a task from the search index.\"\"\"\n        self.vector_store.delete_vector(task_id)\n    \n    def reindex_all_tasks(self):\n        \"\"\"Rebuild the entire search index from scratch.\"\"\"\n        from visionvault.core.models import LearnedTask\n        \n        # Clear existing index\n        self.vector_store.clear()\n        \n        # Get all tasks\n        all_tasks = LearnedTask.get_all(limit=10000)\n        \n        # Index each task\n        for task in all_tasks:\n            try:\n                self.index_task(task)\n                print(f\"Indexed task: {task.task_name}\")\n            except Exception as e:\n                print(f\"Failed to index task {task.task_id}: {e}\")\n","size_bytes":12244},"visionvault/agents/main.py":{"content":"import asyncio\nimport time\nfrom .config import AGENT_ID, SERVER_URL\nfrom .socket_client import SocketClient\nfrom .test_executor import TestExecutor\nfrom .healing_engine import HealingEngine\nfrom .recording_session import CodegenRecordingSessionManager\nimport os\n\nclass VisionVaultAgent:\n    def __init__(self):\n        self.socket_client = SocketClient()\n        self.test_executor = TestExecutor(self.socket_client)\n        self.healing_engine = HealingEngine(self.socket_client)\n        self.recording_manager = CodegenRecordingSessionManager(self.socket_client)\n\n        # Set up event handlers\n        self._setup_event_handlers()\n\n    def _setup_event_handlers(self):\n        \"\"\"Setup all Socket.IO event handlers\"\"\"\n\n        @self.socket_client.sio.on('execute_on_agent')\n        def handle_execute(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.test_executor.execute_test(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode']\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('start_recording')\n        def handle_start_recording(data):\n            if self.socket_client.event_loop:\n                session_id = data['session_id']\n                start_url = data.get('start_url', '')\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.start_recording_session(\n                        session_id=session_id,\n                        start_url=start_url  # No output_file here\n                    ),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('execute_healing_attempt')\n        def handle_healing_attempt(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.execute_healing_attempt(\n                        data['test_id'],\n                        data['code'],\n                        data['browser'],\n                        data['mode'],\n                        data.get('attempt', 1),\n                        final_manual_attempt=data.get('final_manual_attempt', False)\n                    ),\n                    self.socket_client.event_loop\n                )\n        \n        @self.socket_client.sio.on('healing_complete')\n        def handle_healing_complete(data):\n            \"\"\"Handle healing completion - close browser and cleanup\"\"\"\n            test_id = data.get('test_id')\n            success = data.get('success', False)\n            reason = data.get('reason', 'unknown')\n            print(f\"\\n🏁 HEALING COMPLETE for test {test_id}\")\n            print(f\"   Success: {success}\")\n            print(f\"   Reason: {reason}\")\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.cleanup_browser(),\n                    self.socket_client.event_loop\n                )\n\n        @self.socket_client.sio.on('element_selector_needed')\n        def handle_element_selector_needed(data):\n            mode = data.get('mode', 'headless')\n            if mode == 'headful' and self.healing_engine.active_page and self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.healing_engine.inject_element_selector(\n                        data['test_id'],\n                        data['failed_locator']\n                    ),\n                    self.socket_client.event_loop\n                )\n            else:\n                print(f\"❌ Cannot inject widget (mode={mode}, page={'yes' if self.healing_engine.active_page else 'no'})\")\n\n        @self.socket_client.sio.on('stop_recording')\n        def handle_stop_recording(data):\n            if self.socket_client.event_loop:\n                asyncio.run_coroutine_threadsafe(\n                    self.recording_manager.stop_recording_session(data['session_id']),\n                    self.socket_client.event_loop\n                )\n\n    async def send_heartbeat(self):\n        while True:\n            try:\n                if self.socket_client.connected:\n                    browser_status = \"available\"\n                    active_sessions = len(getattr(self.recording_manager, 'sessions', {}))\n                    if active_sessions > 0:\n                        browser_status = f\"recording_{active_sessions}_sessions\"\n\n                    self.socket_client.emit('heartbeat', {\n                        'agent_id': AGENT_ID,\n                        'timestamp': time.time(),\n                        'browser_status': browser_status,\n                        'capabilities': {\n                            'recording': True,\n                            'comprehensive_recording': True,\n                            'test_execution': True,\n                            'healing': True\n                        }\n                    })\n                await asyncio.sleep(30)\n            except Exception as e:\n                print(f\"Heartbeat error: {e}\")\n                await asyncio.sleep(30)\n\n    async def initialize_agent(self):\n        try:\n            from .utils import detect_browsers\n            self.socket_client.emit('agent_register', {\n                'agent_id': AGENT_ID,\n                'browsers': detect_browsers(),\n                'capabilities': {\n                    'recording': True,\n                    'comprehensive_recording': True,\n                    'test_execution': True,\n                    'healing': True,\n                    'event_types': [\n                        'click', 'input', 'keypress', 'navigation',\n                        'form_submit', 'network_request', 'network_response',\n                        'console', 'page_error', 'page_created'\n                    ]\n                },\n                'status': 'ready'\n            })\n            print(\"✅ Agent registered with comprehensive recording capabilities\")\n        except Exception as e:\n            print(f\"❌ Agent initialization failed: {e}\")\n\n    def run(self):\n        print(\"=\" * 60)\n        print(\"  VisionVault Browser Automation Agent\")\n        print(\"=\" * 60)\n        print(f\"  Agent ID: {AGENT_ID}\")\n        print(f\"  Server URL: {SERVER_URL}\")\n        print()\n\n        try:\n            print(\"Connecting to server...\")\n            self.socket_client.connect()\n            print(\"Connection established! Initializing agent...\")\n\n            self.socket_client.event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.socket_client.event_loop)\n\n            self.socket_client.event_loop.run_until_complete(self.initialize_agent())\n            self.socket_client.event_loop.create_task(self.send_heartbeat())\n\n            print(\"✅ Agent ready! Waiting for tasks...\\n\")\n            self.socket_client.event_loop.run_forever()\n\n        except KeyboardInterrupt:\n            print(\"\\n🛑 Shutting down agent...\")\n            try:\n                for session_id in list(getattr(self.recording_manager, 'sessions', {}).keys()):\n                    print(f\"🛑 Stopping recording session: {session_id}\")\n                    asyncio.run_coroutine_threadsafe(\n                        self.recording_manager.stop_recording_session(session_id),\n                        self.socket_client.event_loop\n                    )\n            except Exception as e:\n                print(f\"⚠️ Error stopping recordings: {e}\")\n\n            self.socket_client.disconnect()\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n        except Exception as e:\n            print(f\"❌ Connection error: {e}\")\n            if self.socket_client.event_loop:\n                self.socket_client.event_loop.close()\n\n\ndef main():\n    agent = VisionVaultAgent()\n    agent.run()\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":8008},"visionvault/services/__init__.py":{"content":"","size_bytes":0},"scripts/run_both.py":{"content":"import subprocess\nimport sys\nimport os\nimport time\n\n# Paths to scripts\nmain_script = os.path.join(os.path.dirname(__file__), 'main.py')\nagent_script = os.path.join(os.path.dirname(__file__), 'local_agent.py')\n\n# Set environment variable for both processes\nenv = os.environ.copy()\nenv['AGENT_SERVER_URL'] = 'http://127.0.0.1:7890'\n\nprocesses = []\n\ntry:\n    # Start main.py\n    p1 = subprocess.Popen([sys.executable, main_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started main.py with PID {p1.pid}\")\n    processes.append((p1, 'main.py'))\n\n    # Start local_agent.py\n    p2 = subprocess.Popen([sys.executable, agent_script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    print(f\"Started local_agent.py with PID {p2.pid}\")\n    processes.append((p2, 'local_agent.py'))\n\n    # Print output from both processes\n    while True:\n        for proc, name in processes:\n            # Print all available lines from stdout\n            while True:\n                out = proc.stdout.readline()\n                if not out:\n                    break\n                print(f\"[{name}] {out.decode().rstrip()}\")\n            # Print all available lines from stderr\n            while True:\n                err = proc.stderr.readline()\n                if not err:\n                    break\n                print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n        # Check if any process has exited\n        for proc, name in processes[:]:\n            if proc.poll() is not None:\n                print(f\"Process {proc.pid} ({name}) exited.\")\n                # Print any remaining output after exit\n                for out in proc.stdout:\n                    print(f\"[{name}] {out.decode().rstrip()}\")\n                for err in proc.stderr:\n                    print(f\"[{name} ERROR] {err.decode().rstrip()}\")\n                processes.remove((proc, name))\n        if not processes:\n            print(\"All processes exited.\")\n            break\n        time.sleep(0.2)\nexcept KeyboardInterrupt:\n    print(\"Stopping processes...\")\n    for proc, _ in processes:\n        proc.terminate()\n","size_bytes":2108},"mcp/pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"mcp>=1.18.0\",\n    \"openai>=2.4.0\",\n    \"playwright>=1.55.0\",\n    \"pydantic>=2.12.2\",\n    \"python-dotenv>=1.1.1\",\n    \"rich>=14.2.0\",\n    \"tenacity>=9.1.2\",\n]\n","size_bytes":305},"mcp/src/automation/recorder.py":{"content":"\"\"\"\nBrowser Action Recorder\nCaptures user interactions and generates natural language commands + Playwright code\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom openai import AsyncOpenAI\n\n\n@dataclass\nclass RecordedAction:\n    \"\"\"Represents a single recorded browser action.\"\"\"\n    timestamp: str\n    action_type: str  # click, type, navigate, select, etc.\n    selector: Optional[str] = None\n    element_text: Optional[str] = None\n    element_tag: Optional[str] = None\n    value: Optional[str] = None  # For typing, selecting\n    url: Optional[str] = None  # For navigation\n    metadata: Optional[Dict[str, Any]] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\n\nclass BrowserRecorder:\n    \"\"\"Records browser interactions and generates automation code.\"\"\"\n    \n    def __init__(self, openai_api_key: str):\n        self.is_recording = False\n        self.recorded_actions: List[RecordedAction] = []\n        self.session_start_time: Optional[datetime] = None\n        self.client = AsyncOpenAI(api_key=openai_api_key)\n        self._fetched_count = 0  # Track how many events we've already fetched\n        \n        # JavaScript code to inject into browser for event capture\n        self.recorder_script = \"\"\"\n        (function() {\n            // Use sessionStorage to persist events across page loads\n            const STORAGE_KEY_EVENTS = '__recordedEvents';\n            const STORAGE_KEY_LAST_URL = '__lastRecordedUrl';\n            \n            // Load existing events from sessionStorage\n            let events = [];\n            try {\n                const stored = sessionStorage.getItem(STORAGE_KEY_EVENTS);\n                if (stored) {\n                    events = JSON.parse(stored);\n                }\n            } catch (e) {}\n            window.__recordedEvents = events;\n            \n            // Get last URL from storage\n            const lastUrl = sessionStorage.getItem(STORAGE_KEY_LAST_URL) || '';\n            const currentUrl = window.location.href;\n            \n            // If URL changed (full page load), record navigation\n            if (lastUrl && currentUrl !== lastUrl) {\n                window.__recordedEvents.push({\n                    type: 'navigate',\n                    url: currentUrl,\n                    timestamp: Date.now()\n                });\n                // Save immediately\n                try {\n                    sessionStorage.setItem(STORAGE_KEY_EVENTS, JSON.stringify(window.__recordedEvents));\n                } catch (e) {}\n            }\n            \n            // Update last URL in storage\n            try {\n                sessionStorage.setItem(STORAGE_KEY_LAST_URL, currentUrl);\n            } catch (e) {}\n            \n            // Helper to save events to sessionStorage\n            function saveEvents() {\n                try {\n                    sessionStorage.setItem(STORAGE_KEY_EVENTS, JSON.stringify(window.__recordedEvents));\n                } catch (e) {}\n            }\n            \n            // Prevent duplicate listener registration\n            if (window.__recorderInjected) return;\n            window.__recorderInjected = true;\n            \n            // Helper to get unique selector for element\n            function getSelector(el) {\n                if (!el) return null;\n                \n                // Try ID first\n                if (el.id) return '#' + el.id;\n                \n                // Try name attribute\n                if (el.name) return `[name=\"${el.name}\"]`;\n                \n                // Try aria-label\n                if (el.getAttribute('aria-label')) {\n                    return `[aria-label=\"${el.getAttribute('aria-label')}\"]`;\n                }\n                \n                // Try placeholder\n                if (el.placeholder) return `[placeholder=\"${el.placeholder}\"]`;\n                \n                // Try text content for buttons/links\n                if (['BUTTON', 'A'].includes(el.tagName)) {\n                    const text = el.innerText?.trim();\n                    if (text && text.length < 50) {\n                        return `text=${text}`;\n                    }\n                }\n                \n                // Try role\n                const role = el.getAttribute('role');\n                if (role) return `[role=\"${role}\"]`;\n                \n                // Fallback to tag + nth-child\n                let selector = el.tagName.toLowerCase();\n                if (el.className) {\n                    const classes = el.className.split(' ').filter(c => c).slice(0, 2);\n                    if (classes.length) {\n                        selector += '.' + classes.join('.');\n                    }\n                }\n                \n                return selector;\n            }\n            \n            // Track navigation events\n            function recordNavigation(url) {\n                const lastUrl = sessionStorage.getItem(STORAGE_KEY_LAST_URL) || '';\n                if (url !== lastUrl) {\n                    window.__recordedEvents.push({\n                        type: 'navigate',\n                        url: url,\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                    try {\n                        sessionStorage.setItem(STORAGE_KEY_LAST_URL, url);\n                    } catch (e) {}\n                }\n            }\n            \n            // Listen for URL changes (SPA navigation)\n            window.addEventListener('popstate', function() {\n                recordNavigation(window.location.href);\n            });\n            \n            // Intercept pushState and replaceState\n            const originalPushState = history.pushState;\n            const originalReplaceState = history.replaceState;\n            \n            history.pushState = function() {\n                originalPushState.apply(this, arguments);\n                recordNavigation(window.location.href);\n            };\n            \n            history.replaceState = function() {\n                originalReplaceState.apply(this, arguments);\n                recordNavigation(window.location.href);\n            };\n            \n            // Record click events\n            document.addEventListener('click', function(e) {\n                const el = e.target;\n                window.__recordedEvents.push({\n                    type: 'click',\n                    selector: getSelector(el),\n                    text: el.innerText?.trim().substring(0, 100) || null,\n                    tag: el.tagName.toLowerCase(),\n                    timestamp: Date.now()\n                });\n                saveEvents();\n            }, true);\n            \n            // Record input events (text, email, password, search, etc.)\n            document.addEventListener('input', function(e) {\n                const el = e.target;\n                if (['INPUT', 'TEXTAREA'].includes(el.tagName)) {\n                    window.__recordedEvents.push({\n                        type: 'type',\n                        selector: getSelector(el),\n                        value: el.value,\n                        tag: el.tagName.toLowerCase(),\n                        inputType: el.type || 'text',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                }\n            }, true);\n            \n            // Record change events (checkboxes, radios, selects)\n            document.addEventListener('change', function(e) {\n                const el = e.target;\n                \n                if (el.tagName === 'SELECT') {\n                    window.__recordedEvents.push({\n                        type: 'select',\n                        selector: getSelector(el),\n                        value: el.value,\n                        text: el.options[el.selectedIndex]?.text,\n                        tag: 'select',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                } else if (el.type === 'checkbox') {\n                    window.__recordedEvents.push({\n                        type: 'check',\n                        selector: getSelector(el),\n                        checked: el.checked,\n                        tag: 'checkbox',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                } else if (el.type === 'radio') {\n                    window.__recordedEvents.push({\n                        type: 'radio',\n                        selector: getSelector(el),\n                        value: el.value,\n                        tag: 'radio',\n                        timestamp: Date.now()\n                    });\n                    saveEvents();\n                }\n            }, true);\n            \n            // Record form submissions\n            document.addEventListener('submit', function(e) {\n                const form = e.target;\n                window.__recordedEvents.push({\n                    type: 'submit',\n                    selector: getSelector(form),\n                    tag: 'form',\n                    timestamp: Date.now()\n                });\n                saveEvents();\n            }, true);\n            \n            console.log('🎥 Browser recorder activated - all interactions are being captured');\n        })();\n        \"\"\"\n    \n    async def start_recording(self, mcp_client) -> str:\n        \"\"\"Start recording browser interactions.\"\"\"\n        self.is_recording = True\n        self.recorded_actions = []\n        self._fetched_count = 0  # Reset offset\n        self.session_start_time = datetime.now()\n        \n        # Clear any stale sessionStorage data from previous sessions\n        try:\n            await mcp_client.evaluate(\"\"\"\n                sessionStorage.removeItem('__recordedEvents');\n                sessionStorage.removeItem('__lastRecordedUrl');\n                window.__recordedEvents = [];\n            \"\"\")\n        except Exception:\n            pass\n        \n        return \"Recording started - perform your actions in the browser\"\n    \n    def stop_recording(self) -> str:\n        \"\"\"Stop recording browser interactions.\"\"\"\n        self.is_recording = False\n        action_count = len(self.recorded_actions)\n        return f\"Recording stopped - captured {action_count} actions\"\n    \n    async def maintain_recording(self, mcp_client) -> None:\n        \"\"\"Periodically reinject recorder script and pull events to Python.\n        This ensures events are persisted even across cross-origin navigations.\n        Should be called in a background loop while recording is active.\n        \"\"\"\n        if not self.is_recording:\n            return\n        \n        try:\n            # Reinject the script to capture any new page loads\n            await mcp_client.evaluate(self.recorder_script)\n            \n            # Pull events from browser to Python (backup for cross-origin navigation)\n            await self.fetch_recorded_events(mcp_client, clear_after_fetch=False)\n        except Exception:\n            pass  # Silently fail if page is not ready\n    \n    def get_recorder_script(self) -> str:\n        \"\"\"Get the JavaScript to inject for recording.\"\"\"\n        return self.recorder_script\n    \n    async def fetch_recorded_events(self, mcp_client, clear_after_fetch: bool = True) -> List[RecordedAction]:\n        \"\"\"Fetch NEW events from browser and convert to RecordedAction objects.\n        \n        Args:\n            mcp_client: The MCP client to use for evaluation\n            clear_after_fetch: If True, clears events from browser after fetching (default)\n                             If False, only fetches new events since last fetch (for periodic backups)\n        \"\"\"\n        try:\n            # Get events from browser\n            if clear_after_fetch:\n                # Final fetch - only get NEW events we haven't fetched yet, then clear\n                result = await mcp_client.evaluate(f\"\"\"\n                    (function() {{\n                        const allEvents = window.__recordedEvents || [];\n                        const newEvents = allEvents.slice({self._fetched_count});\n                        window.__recordedEvents = [];  // Clear after fetching\n                        sessionStorage.removeItem('__recordedEvents');  // Clear storage too\n                        return newEvents;\n                    }})();\n                \"\"\")\n                self._fetched_count = 0  # Reset offset\n            else:\n                # Periodic fetch - only get new events since last fetch\n                result = await mcp_client.evaluate(f\"\"\"\n                    (function() {{\n                        const allEvents = window.__recordedEvents || [];\n                        const newEvents = allEvents.slice({self._fetched_count});\n                        return newEvents;\n                    }})();\n                \"\"\")\n            \n            if isinstance(result, list) and len(result) > 0:\n                # Convert events to RecordedAction objects\n                for event in result:\n                    metadata = {}\n                    if event.get('inputType'):\n                        metadata['inputType'] = event['inputType']\n                    if 'checked' in event:\n                        metadata['checked'] = event['checked']\n                    \n                    action = RecordedAction(\n                        timestamp=datetime.fromtimestamp(event.get('timestamp', 0) / 1000).isoformat(),\n                        action_type=event.get('type', 'unknown'),\n                        selector=event.get('selector'),\n                        element_text=event.get('text'),\n                        element_tag=event.get('tag'),\n                        value=event.get('value'),\n                        url=event.get('url'),\n                        metadata=metadata if metadata else None\n                    )\n                    self.recorded_actions.append(action)\n                \n                # Update fetched count if doing periodic fetch\n                if not clear_after_fetch:\n                    self._fetched_count += len(result)\n            \n            return self.recorded_actions\n        except Exception as e:\n            print(f\"Error fetching recorded events: {e}\")\n            return []\n    \n    def _deduplicate_actions(self, actions: List[RecordedAction]) -> List[RecordedAction]:\n        \"\"\"Remove duplicate/redundant actions (e.g., multiple type events for same field).\"\"\"\n        if not actions:\n            return []\n        \n        deduplicated = []\n        i = 0\n        \n        while i < len(actions):\n            current = actions[i]\n            \n            # For 'type' actions, merge consecutive types on same element\n            if current.action_type == 'type':\n                # Look ahead for more type actions on same selector\n                j = i + 1\n                while j < len(actions) and actions[j].action_type == 'type' and actions[j].selector == current.selector:\n                    # Use the last value (final text)\n                    current.value = actions[j].value\n                    j += 1\n                i = j\n            else:\n                i += 1\n            \n            deduplicated.append(current)\n        \n        return deduplicated\n    \n    async def generate_natural_language(self, actions: List[RecordedAction]) -> str:\n        \"\"\"Use AI to generate natural language description of recorded actions.\"\"\"\n        if not actions:\n            return \"No actions recorded\"\n        \n        # Deduplicate first\n        actions = self._deduplicate_actions(actions)\n        \n        # Create a summary of actions\n        action_summary = []\n        for action in actions:\n            if action.action_type == 'navigate':\n                action_summary.append(f\"Navigated to {action.url}\")\n            elif action.action_type == 'click':\n                desc = f\"Clicked {action.element_tag}\"\n                if action.element_text:\n                    desc += f\" with text '{action.element_text[:50]}'\"\n                action_summary.append(desc)\n            elif action.action_type == 'type':\n                desc = f\"Typed '{action.value}' into {action.element_tag}\"\n                if action.selector:\n                    desc += f\" ({action.selector})\"\n                action_summary.append(desc)\n            elif action.action_type == 'select':\n                action_summary.append(f\"Selected '{action.value}' from dropdown\")\n            elif action.action_type == 'check':\n                action_summary.append(f\"{'Checked' if action.metadata and action.metadata.get('checked') else 'Unchecked'} checkbox\")\n            elif action.action_type == 'radio':\n                action_summary.append(f\"Selected radio button '{action.value}'\")\n            elif action.action_type == 'submit':\n                action_summary.append(\"Submitted form\")\n        \n        # Use AI to create natural language command\n        prompt = f\"\"\"Convert these browser actions into a single, clear natural language automation command:\n\nActions performed:\n{chr(10).join(f'{i+1}. {a}' for i, a in enumerate(action_summary))}\n\nGenerate a concise natural language command that describes this workflow (1-2 sentences max).\nFocus on the user's intent, not technical details.\n\nExamples:\n- \"Search for Python tutorials on Google\"\n- \"Fill out contact form and submit\"\n- \"Login with credentials and navigate to dashboard\"\n\nNatural language command:\"\"\"\n\n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                temperature=0.7,\n                max_tokens=100\n            )\n            content = response.choices[0].message.content\n            return content.strip() if content else \"\"\n        except Exception as e:\n            # Fallback to simple concatenation\n            return \" and \".join(action_summary[:5])\n    \n    def generate_playwright_code(self, actions: List[RecordedAction]) -> str:\n        \"\"\"Generate clean Playwright Python code from recorded actions.\"\"\"\n        if not actions:\n            return \"# No actions recorded\"\n        \n        # Deduplicate actions\n        actions = self._deduplicate_actions(actions)\n        \n        code_lines = [\n            \"# Generated from recorded browser interactions\",\n            f\"# Recorded: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\",\n            \"\",\n            \"from playwright.async_api import async_playwright\",\n            \"\",\n            \"async def recorded_workflow():\",\n            \"    async with async_playwright() as p:\",\n            \"        browser = await p.chromium.launch(headless=True)\",\n            \"        page = await browser.new_page()\",\n            \"\"\n        ]\n        \n        for action in actions:\n            if action.action_type == 'navigate':\n                code_lines.append(f\"        # Navigate to page\")\n                code_lines.append(f\"        await page.goto('{action.url}')\")\n                \n            elif action.action_type == 'click':\n                code_lines.append(f\"        # Click element\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').click()\")\n                else:\n                    code_lines.append(f\"        # TODO: Add proper selector for click\")\n                    \n            elif action.action_type == 'type':\n                code_lines.append(f\"        # Type into field\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').fill('{action.value}')\")\n                else:\n                    code_lines.append(f\"        # TODO: Add proper selector for input\")\n                    \n            elif action.action_type == 'select':\n                code_lines.append(f\"        # Select dropdown option\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').select_option('{action.value}')\")\n                    \n            elif action.action_type == 'check':\n                checked = action.metadata and action.metadata.get('checked', False)\n                code_lines.append(f\"        # {'Check' if checked else 'Uncheck'} checkbox\")\n                if action.selector:\n                    if checked:\n                        code_lines.append(f\"        await page.locator('{action.selector}').check()\")\n                    else:\n                        code_lines.append(f\"        await page.locator('{action.selector}').uncheck()\")\n                        \n            elif action.action_type == 'radio':\n                code_lines.append(f\"        # Select radio button\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').check()\")\n                    \n            elif action.action_type == 'submit':\n                code_lines.append(f\"        # Submit form\")\n                if action.selector:\n                    code_lines.append(f\"        await page.locator('{action.selector}').press('Enter')\")\n            \n            code_lines.append(\"\")\n        \n        code_lines.extend([\n            \"        await browser.close()\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            \"    import asyncio\",\n            \"    asyncio.run(recorded_workflow())\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    def export_recording(self, actions: List[RecordedAction], format: str = 'json') -> str:\n        \"\"\"Export recorded actions in various formats.\"\"\"\n        if format == 'json':\n            return json.dumps([a.to_dict() for a in actions], indent=2)\n        else:\n            return str(actions)\n    \n    def clear_recording(self):\n        \"\"\"Clear all recorded actions.\"\"\"\n        self.recorded_actions = []\n        self.session_start_time = None\n","size_bytes":22053},"mcp/src/automation/browser_engine.py":{"content":"import asyncio\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom playwright.async_api import async_playwright, Browser, BrowserContext, Page, Playwright\nfrom tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nimport json\nfrom datetime import datetime\n\nfrom .config import BrowserConfig, AutomationConfig\nfrom .logger import get_logger\nfrom .selectors import SmartSelector, SelectorOptions\n\nlogger = get_logger()\n\n\nclass BrowserEngine:\n    \n    def __init__(\n        self,\n        browser_config: Optional[BrowserConfig] = None,\n        automation_config: Optional[AutomationConfig] = None\n    ):\n        self.browser_config = browser_config or BrowserConfig()\n        self.automation_config = automation_config or AutomationConfig()\n        \n        self.playwright: Optional[Playwright] = None\n        self.browser: Optional[Browser] = None\n        self.context: Optional[BrowserContext] = None\n        self.page: Optional[Page] = None\n        \n        self._setup_directories()\n    \n    def _setup_directories(self):\n        for dir_path in [\n            self.automation_config.screenshot_dir,\n            self.automation_config.video_dir,\n            self.automation_config.session_dir\n        ]:\n            Path(dir_path).mkdir(parents=True, exist_ok=True)\n    \n    async def start(self):\n        logger.info(f\"Starting browser engine with {self.browser_config.browser_type.value}\")\n        \n        self.playwright = await async_playwright().start()\n        \n        browser_type = getattr(self.playwright, self.browser_config.browser_type.value)\n        \n        launch_options = {\n            \"headless\": self.browser_config.headless,\n            \"slow_mo\": self.browser_config.slow_mo,\n        }\n        \n        if self.browser_config.proxy:\n            launch_options[\"proxy\"] = self.browser_config.proxy\n        \n        if self.browser_config.downloads_path:\n            Path(self.browser_config.downloads_path).mkdir(parents=True, exist_ok=True)\n        \n        self.browser = await browser_type.launch(**launch_options)\n        \n        context_options = {\n            \"viewport\": {\n                \"width\": self.browser_config.viewport_width,\n                \"height\": self.browser_config.viewport_height\n            },\n            \"locale\": self.browser_config.locale,\n            \"timezone_id\": self.browser_config.timezone,\n            \"ignore_https_errors\": self.browser_config.ignore_https_errors,\n        }\n        \n        if self.browser_config.user_agent:\n            context_options[\"user_agent\"] = self.browser_config.user_agent\n        \n        if self.browser_config.video_recording:\n            context_options[\"record_video_dir\"] = self.automation_config.video_dir\n        \n        if self.automation_config.save_session:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            if session_file.exists():\n                with open(session_file, 'r') as f:\n                    storage_state = json.load(f)\n                    context_options[\"storage_state\"] = storage_state\n                    logger.info(f\"Loaded session from {session_file}\")\n        \n        self.context = await self.browser.new_context(**context_options)\n        \n        if self.browser_config.trace_recording:\n            await self.context.tracing.start(screenshots=True, snapshots=True)\n        \n        self.page = await self.context.new_page()\n        \n        self.page.set_default_timeout(self.browser_config.timeout)\n        \n        logger.success(\"Browser engine started successfully\")\n    \n    async def stop(self):\n        logger.info(\"Stopping browser engine\")\n        \n        if self.automation_config.save_session and self.context:\n            session_file = Path(self.automation_config.session_dir) / f\"{self.automation_config.session_name}.json\"\n            storage_state = await self.context.storage_state()\n            with open(session_file, 'w') as f:\n                json.dump(storage_state, f)\n            logger.info(f\"Saved session to {session_file}\")\n        \n        if self.browser_config.trace_recording and self.context:\n            trace_file = f\"traces/trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip\"\n            Path(\"traces\").mkdir(parents=True, exist_ok=True)\n            await self.context.tracing.stop(path=trace_file)\n            logger.info(f\"Saved trace to {trace_file}\")\n        \n        if self.page:\n            await self.page.close()\n        \n        if self.context:\n            await self.context.close()\n        \n        if self.browser:\n            await self.browser.close()\n        \n        if self.playwright:\n            await self.playwright.stop()\n        \n        logger.success(\"Browser engine stopped successfully\")\n    \n    @retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=2, max=10),\n        retry=retry_if_exception_type(Exception)\n    )\n    async def navigate(self, url: str, wait_until: str = None) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started. Call start() first.\")\n        \n        wait_until = wait_until or self.automation_config.wait_strategy\n        \n        try:\n            logger.info(f\"Navigating to {url}\")\n            await self.page.goto(url, wait_until=wait_until, timeout=self.browser_config.timeout)\n            logger.success(f\"Successfully navigated to {url}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Navigation failed: {str(e)}\")\n            if self.browser_config.screenshot_on_error:\n                await self.screenshot(f\"error_navigate_{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n            raise\n    \n    async def screenshot(self, name: str = None) -> str:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        if name is None:\n            name = f\"screenshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        \n        screenshot_path = Path(self.automation_config.screenshot_dir) / f\"{name}.png\"\n        await self.page.screenshot(path=str(screenshot_path), full_page=True)\n        logger.info(f\"Screenshot saved to {screenshot_path}\")\n        return str(screenshot_path)\n    \n    async def wait_for_selector(\n        self,\n        selector: str,\n        timeout: Optional[int] = None,\n        state: str = \"visible\"\n    ) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        try:\n            options = SelectorOptions(timeout=timeout or self.browser_config.timeout, state=state)\n            element = await SmartSelector.find_element(self.page, selector, options)\n            if element:\n                await element.first.wait_for(state=state, timeout=timeout or self.browser_config.timeout)\n                return True\n        except Exception as e:\n            logger.error(f\"Wait for selector failed: {str(e)}\")\n        return False\n    \n    async def click(self, selector: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_click(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def fill(self, selector: str, value: str, **kwargs) -> bool:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.safe_fill(self.page, selector, value, SelectorOptions(**kwargs))\n    \n    async def get_text(self, selector: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_text(self.page, selector, SelectorOptions(**kwargs))\n    \n    async def get_attribute(self, selector: str, attribute: str, **kwargs) -> Optional[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await SmartSelector.get_attribute(self.page, selector, attribute, SelectorOptions(**kwargs))\n    \n    async def get_all_text(self, selector: str, **kwargs) -> List[str]:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        elements = await SmartSelector.find_all(self.page, selector, SelectorOptions(**kwargs))\n        texts = []\n        for element in elements:\n            text = await element.text_content()\n            if text:\n                texts.append(text.strip())\n        return texts\n    \n    async def execute_script(self, script: str) -> Any:\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.page.evaluate(script)\n    \n    async def wait_for_load(self, timeout: Optional[int] = None):\n        if not self.page:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.page.wait_for_load_state(\"networkidle\", timeout=timeout or self.browser_config.timeout)\n    \n    async def new_page(self) -> Page:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        page = await self.context.new_page()\n        page.set_default_timeout(self.browser_config.timeout)\n        return page\n    \n    async def get_cookies(self) -> List[Dict[str, Any]]:\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        return await self.context.cookies()\n    \n    async def set_cookies(self, cookies: List[Dict[str, Any]]):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.add_cookies(cookies)\n        logger.info(f\"Set {len(cookies)} cookies\")\n    \n    async def clear_cookies(self):\n        if not self.context:\n            raise RuntimeError(\"Browser not started\")\n        \n        await self.context.clear_cookies()\n        logger.info(\"Cleared all cookies\")\n","size_bytes":9914},"mcp/src/automation/vision_analyzer.py":{"content":"import os\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\n\ntry:\n    from openai import AsyncOpenAI\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .advanced_tools import PageContext\n\nlogger = get_logger()\n\n\n@dataclass\nclass ElementLocation:\n    \"\"\"Location and description of an element found via vision.\"\"\"\n    description: str\n    suggested_selector: str\n    confidence: float\n    position: str  # e.g., \"top-left\", \"center\", \"bottom-right\"\n    element_type: str  # e.g., \"button\", \"link\", \"input\"\n\n\nclass VisionPageAnalyzer:\n    \"\"\"\n    Uses GPT-4 Vision to understand page structure and locate elements.\n    Provides intelligent element detection when traditional selectors fail.\n    \"\"\"\n    \n    def __init__(self):\n        self.client = None\n        api_key = os.getenv(\"OPENAI_API_KEY\")\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n        elif not api_key:\n            logger.warning(\"OPENAI_API_KEY not set for vision analysis\")\n        else:\n            self.client = AsyncOpenAI(api_key=api_key)\n    \n    async def analyze_page_structure(self, context: PageContext) -> Dict[str, Any]:\n        \"\"\"\n        Analyze page structure using vision to understand layout and elements.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            logger.warning(\"Vision analysis not available\")\n            return {}\n        \n        logger.info(\"Analyzing page structure with vision...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",  # Using mini for cost efficiency, upgrade to gpt-4o for better vision\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots.\nIdentify all interactive elements, their types, positions, and suggest CSS selectors.\nDescribe the page layout and main sections.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Analyze this web page screenshot. \n\nPage URL: {context.url}\nPage Title: {context.title}\nVisible Elements Count: {len(context.visible_elements)}\n\nProvide:\n1. Page layout description\n2. Main sections identified\n3. All interactive elements (buttons, links, forms, inputs)\n4. Suggested selectors for key elements\n5. Any notable UI patterns or frameworks detected\n\nFormat as JSON.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=1500,\n                temperature=0.3\n            )\n            \n            content = response.choices[0].message.content\n            logger.success(\"Vision analysis completed\")\n            \n            return {\"analysis\": content, \"model_used\": \"gpt-4o-mini\"}\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n    \n    async def find_element_by_description(self, context: PageContext, \n                                         description: str) -> Optional[ElementLocation]:\n        \"\"\"\n        Find an element on the page using visual analysis and natural language description.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Finding element by vision: {description}\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at locating elements in web page screenshots.\nGiven a description, identify the element's position and suggest the best CSS selector.\nRespond in JSON format with: description, selector, confidence, position, type.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Find this element: \"{description}\"\n\nPage context:\n- URL: {context.url}\n- Title: {context.title}\n- Visible elements: {len(context.visible_elements)}\n\nProvide JSON with:\n- description: what you found\n- suggested_selector: CSS selector to locate it\n- confidence: 0.0 to 1.0\n- position: where on page (top-left, center, etc)\n- element_type: button, link, input, etc.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            import json\n            content = response.choices[0].message.content\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            data = json.loads(content)\n            \n            location = ElementLocation(\n                description=data.get(\"description\", description),\n                suggested_selector=data.get(\"suggested_selector\", \"\"),\n                confidence=float(data.get(\"confidence\", 0.5)),\n                position=data.get(\"position\", \"unknown\"),\n                element_type=data.get(\"element_type\", \"unknown\")\n            )\n            \n            logger.success(f\"Vision found element: {location.suggested_selector} (confidence: {location.confidence})\")\n            return location\n            \n        except Exception as e:\n            logger.error(f\"Vision element finding error: {e}\")\n            return None\n    \n    async def suggest_next_action(self, context: PageContext, goal: str) -> Optional[str]:\n        \"\"\"\n        Use vision to suggest the next best action to achieve a goal.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(f\"Getting vision suggestion for goal: {goal}\")\n        \n        try:\n            dom_context = \"\"\n            if context.visible_elements:\n                dom_context = \"Visible elements:\\n\" + \"\\n\".join(context.visible_elements[:20])\n            \n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at browser automation.\nAnalyze the page and suggest the next action to achieve the user's goal.\nBe specific about which element to interact with and what action to take.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"Goal: {goal}\n\nCurrent page:\n- URL: {context.url}\n- Title: {context.title}\n\n{dom_context}\n\nWhat should be the next action? Suggest one specific action with element selector.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=200,\n                temperature=0.3\n            )\n            \n            suggestion = response.choices[0].message.content\n            logger.info(f\"Vision suggestion: {suggestion}\")\n            return suggestion\n            \n        except Exception as e:\n            logger.error(f\"Vision suggestion error: {e}\")\n            return None\n    \n    async def diagnose_error(self, context: PageContext, error_message: str, \n                            failed_selector: str) -> Optional[str]:\n        \"\"\"\n        Use vision to diagnose why an action failed and suggest corrections.\n        \"\"\"\n        if not self.client or not context.screenshot_base64:\n            return None\n        \n        logger.info(\"Using vision to diagnose error...\")\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at debugging browser automation failures.\nAnalyze the screenshot and error to determine what went wrong and suggest a fix.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"\"\"An automation action failed:\n\nError: {error_message}\nFailed selector: {failed_selector}\nPage URL: {context.url}\nPage Title: {context.title}\n\nWhy did it fail? What selector should be used instead?\nProvide a corrected selector and explanation.\"\"\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.3\n            )\n            \n            diagnosis = response.choices[0].message.content\n            logger.info(f\"Vision diagnosis: {diagnosis}\")\n            return diagnosis\n            \n        except Exception as e:\n            logger.error(f\"Vision diagnosis error: {e}\")\n            return None\n\n\nclass VisionAnalyzer:\n    \"\"\"Simplified vision analyzer for MCP automation.\"\"\"\n    \n    def __init__(self, api_key: str):\n        self.client = None\n        try:\n            from openai import AsyncOpenAI\n            self.client = AsyncOpenAI(api_key=api_key)\n        except ImportError:\n            logger.warning(\"OpenAI package not available for vision analysis\")\n    \n    async def analyze_page(self, screenshot_b64: str, instruction: str) -> Dict[str, Any]:\n        \"\"\"Analyze page screenshot and suggest selectors for the given instruction.\"\"\"\n        if not self.client:\n            return {}\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert at analyzing web page screenshots for automation.\nGiven a user instruction, analyze the screenshot and suggest the best CSS selector to use.\nRespond with JSON containing: {\"suggested_selector\": \"...\", \"element_type\": \"...\", \"confidence\": 0.0-1.0}\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"image_url\",\n                                \"image_url\": {\n                                    \"url\": f\"data:image/png;base64,{screenshot_b64}\"\n                                }\n                            },\n                            {\n                                \"type\": \"text\",\n                                \"text\": f\"Task: {instruction}\\n\\nWhat selector should be used to accomplish this task?\"\n                            }\n                        ]\n                    }\n                ],\n                max_tokens=300,\n                temperature=0.2\n            )\n            \n            content = response.choices[0].message.content or \"{}\"\n            \n            if content.startswith(\"```json\"):\n                content = content[7:-3]\n            elif content.startswith(\"```\"):\n                content = content[3:-3]\n            content = content.strip()\n            \n            import json\n            return json.loads(content)\n            \n        except Exception as e:\n            logger.error(f\"Vision analysis error: {e}\")\n            return {}\n","size_bytes":11998},"mcp/src/automation/config_loader.py":{"content":"\"\"\"\nConfiguration loader for reading from config.ini file\n\"\"\"\nimport configparser\nimport os\nfrom pathlib import Path\nfrom typing import Optional\n\n\nclass ConfigLoader:\n    \"\"\"Load and manage configuration from config.ini file\"\"\"\n    \n    def __init__(self, config_file: str = \"config.ini\"):\n        self.config_file = config_file\n        self.config = configparser.ConfigParser()\n        self._load_config()\n    \n    def _load_config(self):\n        \"\"\"Load configuration from .ini file\"\"\"\n        if not Path(self.config_file).exists():\n            raise FileNotFoundError(f\"Configuration file {self.config_file} not found!\")\n        \n        self.config.read(self.config_file)\n    \n    def _get_value(self, section: str, key: str, fallback: Optional[str] = None) -> Optional[str]:\n        \"\"\"Get a value from config, supporting environment variable substitution\"\"\"\n        value = self.config.get(section, key, fallback=fallback)\n        \n        if value and value.startswith(\"${\") and value.endswith(\"}\"):\n            # Environment variable substitution\n            env_var = value[2:-1]\n            return os.getenv(env_var, fallback)\n        \n        return value\n    \n    def _get_bool(self, section: str, key: str, fallback: bool = False) -> bool:\n        \"\"\"Get a boolean value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        return value.lower() in ('true', 'yes', '1', 'on') if value else fallback\n    \n    def _get_int(self, section: str, key: str, fallback: int = 0) -> int:\n        \"\"\"Get an integer value from config\"\"\"\n        value = self._get_value(section, key, str(fallback))\n        try:\n            return int(value) if value else fallback\n        except ValueError:\n            return fallback\n    \n    # OpenAI Configuration\n    @property\n    def openai_api_key(self) -> Optional[str]:\n        return self._get_value('OpenAI', 'api_key')\n    \n    @property\n    def openai_model(self) -> str:\n        return self._get_value('OpenAI', 'model', 'gpt-4o-mini') or 'gpt-4o-mini'\n    \n    # Browser Configuration\n    @property\n    def browser_type(self) -> str:\n        return self._get_value('Browser', 'browser_type', 'chromium') or 'chromium'\n    \n    @property\n    def browser_headless(self) -> bool:\n        return self._get_bool('Browser', 'headless', False)\n    \n    @property\n    def browser_timeout(self) -> int:\n        return self._get_int('Browser', 'timeout', 30000)\n    \n    @property\n    def screenshot_on_error(self) -> bool:\n        return self._get_bool('Browser', 'screenshot_on_error', True)\n    \n    # Automation Configuration\n    @property\n    def max_retries(self) -> int:\n        return self._get_int('Automation', 'max_retries', 3)\n    \n    @property\n    def retry_delay(self) -> int:\n        return self._get_int('Automation', 'retry_delay', 2)\n    \n    @property\n    def log_level(self) -> str:\n        return self._get_value('Automation', 'log_level', 'INFO') or 'INFO'\n    \n    @property\n    def enable_vision(self) -> bool:\n        return self._get_bool('Automation', 'enable_vision', True)\n    \n    # Paths Configuration\n    @property\n    def screenshots_dir(self) -> str:\n        return self._get_value('Paths', 'screenshots_dir', 'screenshots') or 'screenshots'\n    \n    @property\n    def logs_dir(self) -> str:\n        return self._get_value('Paths', 'logs_dir', 'logs') or 'logs'\n    \n    # MCP Configuration\n    @property\n    def auto_refresh_dom(self) -> bool:\n        return self._get_bool('MCP', 'auto_refresh_dom', True)\n    \n    @property\n    def autonomous_execution(self) -> bool:\n        return self._get_bool('MCP', 'autonomous_execution', True)\n\n\n# Singleton instance\n_config_instance: Optional[ConfigLoader] = None\n\n\ndef get_config() -> ConfigLoader:\n    \"\"\"Get the global configuration instance\"\"\"\n    global _config_instance\n    if _config_instance is None:\n        _config_instance = ConfigLoader()\n    return _config_instance\n","size_bytes":3929},"visionvault/core/models.py":{"content":"import sqlite3\nimport json\nfrom datetime import datetime\n\nclass Database:\n    def __init__(self, db_path='data/automation.db'):\n        self.db_path = db_path\n        self.init_db()\n    \n    def init_db(self):\n        \"\"\"Initialize all database tables.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        \n        # Existing test_history table\n        c.execute('''CREATE TABLE IF NOT EXISTS test_history\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      command TEXT NOT NULL,\n                      generated_code TEXT NOT NULL,\n                      healed_code TEXT,\n                      browser TEXT,\n                      mode TEXT,\n                      execution_location TEXT,\n                      status TEXT,\n                      logs TEXT,\n                      screenshot_path TEXT,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # New learned_tasks table for persistent learning\n        c.execute('''CREATE TABLE IF NOT EXISTS learned_tasks\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT UNIQUE NOT NULL,\n                      task_name TEXT NOT NULL,\n                      description TEXT,\n                      steps TEXT,\n                      playwright_code TEXT NOT NULL,\n                      tags TEXT,\n                      embedding_vector BLOB,\n                      version INTEGER DEFAULT 1,\n                      parent_task_id TEXT,\n                      success_count INTEGER DEFAULT 0,\n                      failure_count INTEGER DEFAULT 0,\n                      last_executed TIMESTAMP,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # Task execution history for feedback loop\n        c.execute('''CREATE TABLE IF NOT EXISTS task_executions\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      task_id TEXT NOT NULL,\n                      execution_result TEXT,\n                      success BOOLEAN,\n                      error_message TEXT,\n                      execution_time_ms INTEGER,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                      FOREIGN KEY (task_id) REFERENCES learned_tasks(task_id))''')\n        \n        # Create indices for faster queries\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_id ON learned_tasks(task_id)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_task_name ON learned_tasks(task_name)')\n        c.execute('CREATE INDEX IF NOT EXISTS idx_created_at ON learned_tasks(created_at)')\n        \n        conn.commit()\n        conn.close()\n\n\nclass LearnedTask:\n    \"\"\"Model for a learned automation task.\"\"\"\n    \n    def __init__(self, task_id, task_name, playwright_code, description='', steps=None, \n                 tags=None, embedding_vector=None, version=1, parent_task_id=None):\n        self.task_id = task_id\n        self.task_name = task_name\n        self.description = description\n        self.steps = steps or []\n        self.playwright_code = playwright_code\n        self.tags = tags or []\n        self.embedding_vector = embedding_vector\n        self.version = version\n        self.parent_task_id = parent_task_id\n        self.success_count = 0\n        self.failure_count = 0\n        self.last_executed = None\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n    \n    def to_dict(self):\n        \"\"\"Convert task to dictionary.\"\"\"\n        return {\n            'task_id': self.task_id,\n            'task_name': self.task_name,\n            'description': self.description,\n            'steps': self.steps,\n            'playwright_code': self.playwright_code,\n            'tags': self.tags,\n            'version': self.version,\n            'parent_task_id': self.parent_task_id,\n            'success_count': self.success_count,\n            'failure_count': self.failure_count,\n            'last_executed': self.last_executed.isoformat() if self.last_executed else None,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save task to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Serialize complex fields\n        steps_json = json.dumps(self.steps)\n        tags_json = json.dumps(self.tags)\n        \n        # Serialize embedding vector if present\n        embedding_blob = None\n        if self.embedding_vector is not None:\n            import numpy as np\n            embedding_blob = self.embedding_vector.tobytes()\n        \n        c.execute('''INSERT OR REPLACE INTO learned_tasks \n                     (task_id, task_name, description, steps, playwright_code, tags, \n                      embedding_vector, version, parent_task_id, success_count, \n                      failure_count, last_executed, updated_at)\n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',\n                  (self.task_id, self.task_name, self.description, steps_json, \n                   self.playwright_code, tags_json, embedding_blob, self.version,\n                   self.parent_task_id, self.success_count, self.failure_count,\n                   self.last_executed, datetime.now()))\n        \n        conn.commit()\n        conn.close()\n    \n    @staticmethod\n    def get_by_id(task_id, db_path='data/automation.db'):\n        \"\"\"Retrieve task by ID.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks WHERE task_id=?', (task_id,))\n        row = c.fetchone()\n        conn.close()\n        \n        if not row:\n            return None\n        \n        return LearnedTask._from_row(row)\n    \n    @staticmethod\n    def get_all(db_path='data/automation.db', limit=100):\n        \"\"\"Retrieve all tasks.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        c.execute('SELECT * FROM learned_tasks ORDER BY created_at DESC LIMIT ?', (limit,))\n        rows = c.fetchall()\n        conn.close()\n        \n        return [LearnedTask._from_row(row) for row in rows]\n    \n    @staticmethod\n    def search_by_tags(tags, db_path='data/automation.db'):\n        \"\"\"Search tasks by tags.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        # Simple tag search - checks if any tag is present in the tags JSON\n        tasks = []\n        c.execute('SELECT * FROM learned_tasks')\n        rows = c.fetchall()\n        \n        for row in rows:\n            task_tags = json.loads(row[6]) if row[6] else []\n            if any(tag in task_tags for tag in tags):\n                tasks.append(LearnedTask._from_row(row))\n        \n        conn.close()\n        return tasks\n    \n    @staticmethod\n    def _from_row(row):\n        \"\"\"Create LearnedTask from database row.\"\"\"\n        import numpy as np\n        \n        task = LearnedTask(\n            task_id=row[1],\n            task_name=row[2],\n            description=row[3],\n            steps=json.loads(row[4]) if row[4] else [],\n            playwright_code=row[5],\n            tags=json.loads(row[6]) if row[6] else [],\n            version=row[8],\n            parent_task_id=row[9]\n        )\n        \n        # Deserialize embedding vector\n        if row[7]:\n            task.embedding_vector = np.frombuffer(row[7], dtype=np.float32)\n        \n        task.success_count = row[10] or 0\n        task.failure_count = row[11] or 0\n        task.last_executed = datetime.fromisoformat(row[12]) if row[12] else None\n        task.created_at = datetime.fromisoformat(row[13]) if row[13] else datetime.now()\n        task.updated_at = datetime.fromisoformat(row[14]) if row[14] else datetime.now()\n        \n        return task\n\n\nclass TaskExecution:\n    \"\"\"Model for task execution record.\"\"\"\n    \n    def __init__(self, task_id, execution_result, success, error_message=None, execution_time_ms=0):\n        self.task_id = task_id\n        self.execution_result = execution_result\n        self.success = success\n        self.error_message = error_message\n        self.execution_time_ms = execution_time_ms\n        self.created_at = datetime.now()\n    \n    def save(self, db_path='data/automation.db'):\n        \"\"\"Save execution record to database.\"\"\"\n        conn = sqlite3.connect(db_path)\n        c = conn.cursor()\n        \n        c.execute('''INSERT INTO task_executions \n                     (task_id, execution_result, success, error_message, execution_time_ms)\n                     VALUES (?, ?, ?, ?, ?)''',\n                  (self.task_id, self.execution_result, self.success, \n                   self.error_message, self.execution_time_ms))\n        \n        conn.commit()\n        conn.close()\n","size_bytes":8928},"config/gunicorn.conf.py":{"content":"import logging\nimport signal\n\n# Bind to 0.0.0.0:5000 (required for Replit environment)\nbind = \"0.0.0.0:5000\"\n\n# Worker class for async support with SocketIO\nworker_class = \"gevent\"\n\n# Number of workers\nworkers = 1\n\n# Set log level to WARNING to suppress SIGWINCH INFO messages\nloglevel = \"warning\"\n\n# Custom logger class to filter out SIGWINCH messages\nclass FilteredGunicornLogger(logging.Logger):\n    def log(self, level, msg, *args, **kwargs):\n        if \"Handling signal: winch\" not in str(msg):\n            super().log(level, msg, *args, **kwargs)\n\nlogconfig_dict = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'generic': {\n            'format': '%(asctime)s [%(process)d] [%(levelname)s] %(message)s',\n            'datefmt': '[%Y-%m-%d %H:%M:%S %z]',\n        },\n    },\n    'filters': {\n        'winch_filter': {\n            '()': lambda: type('WinchFilter', (), {\n                'filter': lambda self, record: 'Handling signal: winch' not in record.getMessage()\n            })()\n        }\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': 'generic',\n            'filters': ['winch_filter'],\n            'stream': 'ext://sys.stdout'\n        },\n    },\n    'root': {\n        'level': 'INFO',\n        'handlers': ['console']\n    },\n    'loggers': {\n        'gunicorn.error': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        },\n        'gunicorn.access': {\n            'level': 'INFO',\n            'handlers': ['console'],\n            'propagate': False,\n        }\n    }\n}\n","size_bytes":1643},"visionvault/agents/utils.py":{"content":"import os\nimport sys\nimport subprocess\nimport re\nimport base64\n\n\ndef detect_browsers():\n    \"\"\"Detect available browsers on the system\"\"\"\n    browsers = []\n    try:\n        if sys.platform == 'win32':\n            paths = [\n                r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\",\n                r\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"\n            ]\n            if any(os.path.exists(p) for p in paths):\n                browsers.append('chromium')\n        elif sys.platform == 'darwin':\n            if os.path.exists('/Applications/Google Chrome.app'):\n                browsers.append('chromium')\n            if os.path.exists('/Applications/Firefox.app'):\n                browsers.append('firefox')\n            if os.path.exists('/Applications/Safari.app'):\n                browsers.append('webkit')\n        else:\n            if subprocess.run(['which', 'google-chrome'], capture_output=True).returncode == 0:\n                browsers.append('chromium')\n            if subprocess.run(['which', 'firefox'], capture_output=True).returncode == 0:\n                browsers.append('firefox')\n        if not browsers:\n            browsers = ['chromium']\n    except Exception as e:\n        print(f\"Browser detection error: {e}\")\n        browsers = ['chromium']\n\n    print(f\"Detected browsers: {browsers}\")\n    return browsers\n\n\ndef extract_failed_locator_local(error_message):\n    \"\"\"\n    Enhanced error detection - catches ALL types of automation errors.\n    Returns a dict with error type and details for intelligent healing.\n    \"\"\"\n    if not error_message:\n        return None\n    \n    error_info = {\n        'type': 'unknown',\n        'locator': None,\n        'full_error': error_message,\n        'is_healable': False\n    }\n    \n    # 1. API Misuse Errors (NEW - catches code generation bugs)\n    api_errors = [\n        (r\"'(\\w+)' object has no attribute '(\\w+)'\", 'api_misuse'),\n        (r\"takes (\\d+) positional argument.*?but (\\d+) (?:were|was) given\", 'api_misuse'),\n        (r\"unexpected keyword argument\", 'api_misuse'),\n        (r\"missing \\d+ required positional argument\", 'api_misuse'),\n    ]\n    \n    for pattern, error_type in api_errors:\n        if re.search(pattern, error_message, re.IGNORECASE):\n            error_info['type'] = error_type\n            error_info['is_healable'] = True\n            error_info['detail'] = re.search(pattern, error_message, re.IGNORECASE).group(0)\n            return error_info\n    \n    # 2. Locator/Element Not Found Errors (existing patterns enhanced)\n    locator_patterns = [\n        (r'locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'locator_not_found'),\n        (r'waiting for locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'timeout'),\n        (r'Timeout.*?locator\\([\"\\']([^\"\\']+)[\"\\']\\)', 'timeout'),\n        (r'Error: (?:element )?not found: ([^\\n]+)', 'element_not_found'),\n        (r'strict mode violation.*?(\\d+) elements', 'multiple_matches'),\n    ]\n    \n    for pattern, error_type in locator_patterns:\n        match = re.search(pattern, error_message, re.IGNORECASE)\n        if match:\n            error_info['type'] = error_type\n            error_info['locator'] = match.group(1)\n            error_info['is_healable'] = True\n            return error_info\n    \n    # 3. Timeout Errors (general)\n    if re.search(r'timeout|timed out', error_message, re.IGNORECASE):\n        error_info['type'] = 'timeout'\n        error_info['is_healable'] = True\n        return error_info\n    \n    # 4. Navigation/Page Errors\n    if re.search(r'navigation|net::|ERR_', error_message, re.IGNORECASE):\n        error_info['type'] = 'navigation_error'\n        error_info['is_healable'] = False\n        return error_info\n    \n    # 5. Any error is potentially healable with AI retry\n    if 'Error at STEP' in error_message or 'error' in error_message.lower():\n        error_info['type'] = 'general_error'\n        error_info['is_healable'] = True\n        return error_info\n    \n    return error_info if error_info['is_healable'] else None\n\n\ndef encode_screenshot(screenshot_bytes):\n    \"\"\"Encode screenshot to base64 string\"\"\"\n    if screenshot_bytes:\n        return base64.b64encode(screenshot_bytes).decode('utf-8')\n    return None","size_bytes":4178},"mcp/src/automation/advanced_tools.py":{"content":"import base64\nimport asyncio\nfrom typing import Optional, Dict, Any, List, Union\nfrom pathlib import Path\nfrom dataclasses import dataclass\n\nfrom playwright.async_api import Page, Frame, ElementHandle\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass PageContext:\n    \"\"\"Rich context about the current page state.\"\"\"\n    url: str\n    title: str\n    has_iframes: bool\n    has_popups: bool\n    has_alerts: bool\n    visible_elements: List[str]\n    dom_snapshot: Optional[str] = None\n    screenshot_base64: Optional[str] = None\n\n\nclass AdvancedPlaywrightTools:\n    \"\"\"\n    Advanced Playwright tools with intelligent capabilities:\n    - Vision-based element detection\n    - Dynamic content handling\n    - iframe/popup management\n    - File upload/download\n    - Smart waiting strategies\n    - DOM inspection\n    \"\"\"\n    \n    def __init__(self, page: Page):\n        self.page = page\n        self.frames: List[Frame] = []\n        self.context_history: List[PageContext] = []\n    \n    async def get_page_context(self, include_screenshot: bool = False, \n                               include_dom: bool = False) -> PageContext:\n        \"\"\"\n        Get comprehensive context about the current page.\n        \"\"\"\n        try:\n            url = self.page.url\n            title = await self.page.title()\n            \n            frames = self.page.frames\n            has_iframes = len(frames) > 1\n            \n            has_alerts = False\n            has_popups = len(self.page.context.pages) > 1\n            \n            visible_elements = await self._get_visible_elements()\n            \n            dom_snapshot = None\n            if include_dom:\n                dom_snapshot = await self._get_dom_snapshot()\n            \n            screenshot_base64 = None\n            if include_screenshot:\n                screenshot_base64 = await self._capture_screenshot_base64()\n            \n            context = PageContext(\n                url=url,\n                title=title,\n                has_iframes=has_iframes,\n                has_popups=has_popups,\n                has_alerts=has_alerts,\n                visible_elements=visible_elements,\n                dom_snapshot=dom_snapshot,\n                screenshot_base64=screenshot_base64\n            )\n            \n            self.context_history.append(context)\n            if len(self.context_history) > 10:\n                self.context_history.pop(0)\n            \n            return context\n            \n        except Exception as e:\n            logger.error(f\"Error getting page context: {e}\")\n            return PageContext(\n                url=\"unknown\",\n                title=\"unknown\",\n                has_iframes=False,\n                has_popups=False,\n                has_alerts=False,\n                visible_elements=[]\n            )\n    \n    async def _get_visible_elements(self) -> List[str]:\n        \"\"\"Get list of visible interactive elements on the page.\"\"\"\n        script = \"\"\"\n        () => {\n            const elements = [];\n            const selectors = [\n                'button', 'a', 'input', 'textarea', 'select',\n                '[role=\"button\"]', '[onclick]', '[href]',\n                'h1', 'h2', 'h3', 'form', 'nav'\n            ];\n            \n            selectors.forEach(selector => {\n                document.querySelectorAll(selector).forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        const text = el.textContent?.trim().substring(0, 50) || '';\n                        const id = el.id ? `#${el.id}` : '';\n                        const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                        elements.push({\n                            tag: el.tagName.toLowerCase(),\n                            id: id,\n                            class: className,\n                            text: text,\n                            type: el.type || '',\n                            visible: true\n                        });\n                    }\n                });\n            });\n            \n            return elements.slice(0, 50);\n        }\n        \"\"\"\n        \n        try:\n            elements = await self.page.evaluate(script)\n            return [\n                f\"{el['tag']}{el['id']}{el['class']} - {el['text']}\"\n                for el in elements\n            ]\n        except Exception as e:\n            logger.error(f\"Error getting visible elements: {e}\")\n            return []\n    \n    async def _get_dom_snapshot(self) -> str:\n        \"\"\"Get simplified DOM snapshot for AI analysis.\"\"\"\n        script = \"\"\"\n        () => {\n            const getSnapshot = (el, depth = 0, maxDepth = 3) => {\n                if (depth > maxDepth) return '';\n                \n                const indent = '  '.repeat(depth);\n                const tag = el.tagName.toLowerCase();\n                const id = el.id ? `#${el.id}` : '';\n                const className = el.className ? `.${el.className.split(' ')[0]}` : '';\n                const text = el.childNodes.length === 1 && el.childNodes[0].nodeType === 3\n                    ? ` \"${el.textContent.trim().substring(0, 30)}\"`\n                    : '';\n                \n                let result = `${indent}<${tag}${id}${className}${text}>\\\\n`;\n                \n                for (const child of el.children) {\n                    result += getSnapshot(child, depth + 1, maxDepth);\n                }\n                \n                return result;\n            };\n            \n            return getSnapshot(document.body);\n        }\n        \"\"\"\n        \n        try:\n            snapshot = await self.page.evaluate(script)\n            return snapshot[:5000]\n        except Exception as e:\n            logger.error(f\"Error getting DOM snapshot: {e}\")\n            return \"\"\n    \n    async def _capture_screenshot_base64(self) -> str:\n        \"\"\"Capture screenshot as base64 for vision analysis.\"\"\"\n        try:\n            screenshot_bytes = await self.page.screenshot(full_page=False)\n            return base64.b64encode(screenshot_bytes).decode('utf-8')\n        except Exception as e:\n            logger.error(f\"Error capturing screenshot: {e}\")\n            return \"\"\n    \n    async def smart_find_element(self, description: str) -> Optional[str]:\n        \"\"\"\n        Find element using intelligent strategies based on natural language description.\n        Returns the best selector found.\n        \"\"\"\n        logger.info(f\"Smart finding element: {description}\")\n        \n        # Order strategies from most specific to least specific\n        strategies = [\n            self._find_by_aria_label(description),\n            self._find_by_placeholder(description),\n            self._find_by_id_or_class(description),\n            self._find_by_type(description),\n            self._find_by_text(description)\n        ]\n        \n        for strategy in strategies:\n            try:\n                selector = await strategy\n                if selector and await self._element_exists(selector):\n                    logger.success(f\"Found element using {strategy.__name__}: {selector}\")\n                    return selector\n            except Exception as e:\n                logger.debug(f\"Strategy {strategy.__name__} failed: {e}\")\n                continue\n        \n        logger.warning(f\"Could not find element: {description}\")\n        return None\n    \n    async def _find_by_text(self, description: str) -> Optional[str]:\n        \"\"\"Find element by visible text content.\"\"\"\n        keywords = description.lower().split()\n        \n        for keyword in keywords:\n            if len(keyword) < 3:\n                continue\n            \n            selector = f\"text={keyword}\"\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_aria_label(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ARIA label.\"\"\"\n        selector = f\"[aria-label*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_placeholder(self, description: str) -> Optional[str]:\n        \"\"\"Find input by placeholder text.\"\"\"\n        selector = f\"[placeholder*='{description}' i]\"\n        return selector if await self._element_exists(selector) else None\n    \n    async def _find_by_id_or_class(self, description: str) -> Optional[str]:\n        \"\"\"Find element by ID or class name.\"\"\"\n        clean_desc = description.lower().replace(' ', '-')\n        \n        selectors = [\n            f\"#{clean_desc}\",\n            f\".{clean_desc}\",\n            f\"[id*='{clean_desc}']\",\n            f\"[class*='{clean_desc}']\"\n        ]\n        \n        for selector in selectors:\n            if await self._element_exists(selector):\n                return selector\n        \n        return None\n    \n    async def _find_by_type(self, description: str) -> Optional[str]:\n        \"\"\"Find element by type (button, link, input, etc.).\"\"\"\n        type_map = {\n            'button': 'button, [role=\"button\"], input[type=\"submit\"]',\n            'link': 'a[href]',\n            'search': 'input[type=\"search\"], input[name*=\"search\"], input[name*=\"q\"], textarea[name*=\"search\"]',\n            'input': 'input:not([type=\"submit\"]):not([type=\"button\"]):not([type=\"hidden\"]), textarea',\n            'text': 'input[type=\"text\"], input:not([type]), textarea',\n            'email': 'input[type=\"email\"], input[name*=\"email\"]',\n            'password': 'input[type=\"password\"]',\n            'submit': 'button[type=\"submit\"], input[type=\"submit\"]',\n            'form': 'form',\n            'heading': 'h1, h2, h3, h4, h5, h6'\n        }\n        \n        desc_lower = description.lower()\n        \n        # Prioritize search-specific selectors\n        if 'search' in desc_lower or 'query' in desc_lower:\n            if await self._element_exists(type_map['search']):\n                return type_map['search']\n        \n        for keyword, selector in type_map.items():\n            if keyword in desc_lower:\n                if await self._element_exists(selector):\n                    return selector\n        \n        return None\n    \n    async def _element_exists(self, selector: str) -> bool:\n        \"\"\"Check if element exists and is visible.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                is_visible = await element.is_visible()\n                return is_visible\n            return False\n        except Exception:\n            return False\n    \n    async def handle_iframe(self, iframe_selector: Optional[str] = None) -> Optional[Frame]:\n        \"\"\"Switch context to iframe for automation.\"\"\"\n        try:\n            if iframe_selector:\n                frame_element = await self.page.query_selector(iframe_selector)\n                if frame_element:\n                    frame = await frame_element.content_frame()\n                    if frame:\n                        logger.info(f\"Switched to iframe: {iframe_selector}\")\n                        return frame\n            else:\n                frames = self.page.frames\n                if len(frames) > 1:\n                    logger.info(f\"Found {len(frames)} frames\")\n                    return frames[1]\n            \n            return None\n        except Exception as e:\n            logger.error(f\"Error handling iframe: {e}\")\n            return None\n    \n    async def handle_popup(self) -> Optional[Page]:\n        \"\"\"Handle popup windows.\"\"\"\n        try:\n            pages = self.page.context.pages\n            if len(pages) > 1:\n                popup = pages[-1]\n                logger.info(f\"Switched to popup: {popup.url}\")\n                return popup\n            return None\n        except Exception as e:\n            logger.error(f\"Error handling popup: {e}\")\n            return None\n    \n    async def wait_for_dynamic_content(self, timeout: int = 10000):\n        \"\"\"Wait for dynamic content to load (AJAX, lazy loading, etc.).\"\"\"\n        try:\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            \n            await self.page.wait_for_function(\n                \"\"\"() => {\n                    return document.readyState === 'complete' &&\n                           performance.timing.loadEventEnd > 0;\n                }\"\"\",\n                timeout=timeout\n            )\n            \n            logger.info(\"Dynamic content loaded\")\n        except Exception as e:\n            logger.warning(f\"Timeout waiting for dynamic content: {e}\")\n    \n    async def scroll_to_element(self, selector: str):\n        \"\"\"Scroll element into view.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.scroll_into_view_if_needed()\n                logger.info(f\"Scrolled to element: {selector}\")\n        except Exception as e:\n            logger.error(f\"Error scrolling to element: {e}\")\n    \n    async def handle_file_upload(self, selector: str, file_path: str):\n        \"\"\"Handle file upload.\"\"\"\n        try:\n            element = await self.page.query_selector(selector)\n            if element:\n                await element.set_input_files(file_path)\n                logger.success(f\"File uploaded: {file_path}\")\n                return True\n            return False\n        except Exception as e:\n            logger.error(f\"Error uploading file: {e}\")\n            return False\n    \n    async def extract_table_data(self, table_selector: str = \"table\") -> List[Dict[str, Any]]:\n        \"\"\"Extract structured data from HTML tables.\"\"\"\n        script = f\"\"\"\n        (selector) => {{\n            const table = document.querySelector(selector);\n            if (!table) return [];\n            \n            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent.trim());\n            const rows = Array.from(table.querySelectorAll('tbody tr'));\n            \n            return rows.map(row => {{\n                const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());\n                const rowData = {{}};\n                headers.forEach((header, i) => {{\n                    rowData[header] = cells[i] || '';\n                }});\n                return rowData;\n            }});\n        }}\n        \"\"\"\n        \n        try:\n            data = await self.page.evaluate(script, table_selector)\n            logger.info(f\"Extracted {len(data)} rows from table\")\n            return data\n        except Exception as e:\n            logger.error(f\"Error extracting table data: {e}\")\n            return []\n    \n    async def extract_links(self, filter_text: Optional[str] = None) -> List[Dict[str, str]]:\n        \"\"\"Extract all links from page, optionally filtered by text.\"\"\"\n        script = \"\"\"\n        (filterText) => {\n            const links = Array.from(document.querySelectorAll('a[href]'));\n            return links\n                .filter(a => !filterText || a.textContent.toLowerCase().includes(filterText.toLowerCase()))\n                .map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    title: a.title || ''\n                }))\n                .slice(0, 100);\n        }\n        \"\"\"\n        \n        try:\n            links = await self.page.evaluate(script, filter_text)\n            logger.info(f\"Extracted {len(links)} links\")\n            return links\n        except Exception as e:\n            logger.error(f\"Error extracting links: {e}\")\n            return []\n    \n    async def wait_for_navigation_complete(self, timeout: int = 30000):\n        \"\"\"Wait for page navigation to complete fully.\"\"\"\n        try:\n            await self.page.wait_for_load_state('domcontentloaded', timeout=timeout)\n            await self.page.wait_for_load_state('load', timeout=timeout)\n            await self.page.wait_for_load_state('networkidle', timeout=timeout)\n            logger.info(\"Navigation completed\")\n        except Exception as e:\n            logger.warning(f\"Navigation timeout: {e}\")\n","size_bytes":16127},"scripts/tred.py":{"content":"import asyncio\nimport base64\nfrom playwright.async_api import async_playwright\n\n# ---------------- Dummy Test Code ----------------\ndummy_code = \"\"\"\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    success = False\n\n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            await page.goto(\"https://example.com\")\n            logs.append(\"Page loaded successfully\")\n\n            # Try finding a widget that may fail\n            try:\n                await page.wait_for_selector(\"#nonexistent-widget\", timeout=2000)\n                logs.append(\"Widget found!\")\n            except:\n                logs.append(\"Widget not found, requires healing.\")\n\n            screenshot = await page.screenshot()\n            success = True\n            await browser.close()\n    except Exception as e:\n        logs.append(f\"Error: {e}\")\n\n    return {\"success\": success, \"logs\": logs, \"screenshot\": screenshot}\n\"\"\"\n\n# ---------------- Test Execution ----------------\nasync def execute_test(test_id, code, browser_name=\"chromium\", headless=True):\n    print(f\"\\n=== Executing Test {test_id} ===\")\n    local_vars = {}\n    exec(code, {}, local_vars)\n\n    if \"run_test\" not in local_vars:\n        print(\"Error: run_test function not found in code\")\n        return\n\n    run_test = local_vars[\"run_test\"]\n    result = await run_test(browser_name=browser_name, headless=headless)\n\n    print(f\"Test {test_id} Result: {'SUCCESS' if result['success'] else 'FAILED'}\")\n    for log in result[\"logs\"]:\n        print(f\" - {log}\")\n\n    if result[\"screenshot\"]:\n        filename = f\"screenshot_{test_id}.png\"\n        with open(filename, \"wb\") as f:\n            f.write(result[\"screenshot\"])\n        print(f\"Screenshot saved as {filename}\")\n\n# ---------------- Healing Execution ----------------\nasync def execute_healing(test_id, code, browser_name=\"chromium\", headless=True, attempt=1):\n    print(f\"\\n=== Healing Attempt {attempt} for Test {test_id} ===\")\n    await execute_test(f\"{test_id}_healing_{attempt}\", code, browser_name, headless)\n\n# ---------------- Main ----------------\nif __name__ == \"__main__\":\n    asyncio.run(execute_test(\"test1\", dummy_code))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=1))\n    asyncio.run(execute_healing(\"test1\", dummy_code, attempt=2))\n","size_bytes":2490},"mcp/test_automation.py":{"content":"import asyncio\nfrom src.automation import BrowserEngine, TaskExecutor\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger\n\nlogger = get_logger()\n\n\nasync def test_basic_automation():\n    logger.info(\"Testing basic browser automation framework\")\n    \n    browser_config = BrowserConfig(\n        headless=True,\n        timeout=30000,\n        screenshot_on_error=True\n    )\n    \n    automation_config = AutomationConfig(\n        max_retries=3,\n        log_level=\"INFO\"\n    )\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        logger.info(\"Starting browser...\")\n        await browser.start()\n        logger.success(\"Browser started successfully!\")\n        \n        logger.info(\"Navigating to Python.org...\")\n        await browser.navigate(\"https://www.python.org\")\n        await browser.wait_for_load()\n        logger.success(\"Navigation successful!\")\n        \n        logger.info(\"Extracting page title...\")\n        title = await browser.get_text(\"h1\")\n        logger.success(f\"Page title: {title}\")\n        \n        logger.info(\"Taking screenshot...\")\n        screenshot_path = await browser.screenshot(\"test_python_org\")\n        logger.success(f\"Screenshot saved to: {screenshot_path}\")\n        \n        logger.info(\"\\n\" + \"=\"*50)\n        logger.success(\"✅ All tests passed! Framework is working correctly.\")\n        logger.info(\"=\"*50 + \"\\n\")\n        \n    except Exception as e:\n        logger.exception(f\"❌ Test failed: {e}\")\n        return False\n    finally:\n        logger.info(\"Stopping browser...\")\n        await browser.stop()\n        logger.success(\"Browser stopped successfully!\")\n    \n    return True\n\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_basic_automation())\n    exit(0 if success else 1)\n","size_bytes":1858},"mcp/nrw.py":{"content":"import tenacity\nprint(tenacity.__version__)","size_bytes":43},"visionvault/agents/test_executor.py":{"content":"import asyncio\nfrom .utils import encode_screenshot\n\n\nclass TestExecutor:\n    def __init__(self, socket_client):\n        self.socket_client = socket_client\n\n    async def execute_test(self, test_id, code, browser_name, mode):\n        \"\"\"Execute a test case\"\"\"\n        headless = mode == 'headless'\n\n        try:\n            self.socket_client.emit('agent_log', {\n                'test_id': test_id,\n                'message': f'Preparing to execute test in {mode} mode...'\n            })\n\n            local_vars = {}\n            exec(code, {}, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('agent_result', {\n                    'test_id': test_id,\n                    'success': False,\n                    'logs': ['Error: run_test missing'],\n                    'screenshot': None\n                })\n                return\n\n            run_test = local_vars['run_test']\n            result = await run_test(browser_name=browser_name, headless=headless)\n\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': result.get('success', False),\n                'logs': result.get('logs', []),\n                'screenshot': screenshot_b64\n            })\n\n            print(f\"Test {test_id} completed: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n        except Exception as e:\n            print(f\"Execution error: {e}\")\n            self.socket_client.emit('agent_result', {\n                'test_id': test_id,\n                'success': False,\n                'logs': [str(e)],\n                'screenshot': None\n            })","size_bytes":1717},"visionvault/core/__init__.py":{"content":"","size_bytes":0},"visionvault/web/__init__.py":{"content":"","size_bytes":0},"scripts/reindex_tasks.py":{"content":"#!/usr/bin/env python3\n\"\"\"Re-index all learned tasks for semantic search.\"\"\"\n\nimport sys\nimport os\n\n# Add parent directory to path\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom visionvault.core.models import LearnedTask\nfrom visionvault.services.vector_store import SemanticSearch\nimport google.generativeai as genai\n\ndef reindex_all_tasks():\n    \"\"\"Re-index all learned tasks in the vector store.\"\"\"\n    \n    # Check for API key\n    gemini_api_key = os.environ.get('GEMINI_API_KEY')\n    if not gemini_api_key:\n        print(\"❌ Error: GEMINI_API_KEY is not set. Please set it to enable semantic search.\")\n        return\n    \n    try:\n        # Initialize semantic search\n        print(\"🔧 Initializing semantic search service...\")\n        semantic_search = SemanticSearch(api_key=gemini_api_key)\n        \n        # Clear existing index\n        print(\"🗑️  Clearing existing vector index...\")\n        semantic_search.vector_store.clear()\n        \n        # Get all learned tasks\n        print(\"📚 Loading all learned tasks from database...\")\n        tasks = LearnedTask.get_all()\n        \n        if not tasks:\n            print(\"⚠️  No tasks found in the database.\")\n            return\n        \n        print(f\"Found {len(tasks)} tasks to index\")\n        \n        # Index each task\n        indexed_count = 0\n        for i, task in enumerate(tasks, 1):\n            try:\n                print(f\"[{i}/{len(tasks)}] Indexing task: '{task.task_name}'\")\n                semantic_search.index_task(task)\n                indexed_count += 1\n            except Exception as e:\n                print(f\"  ❌ Failed to index task {task.task_id}: {e}\")\n        \n        print(f\"\\n✅ Successfully indexed {indexed_count}/{len(tasks)} tasks!\")\n        print(f\"📊 Vector index now contains {len(semantic_search.vector_store.metadata)} vectors\")\n        \n    except Exception as e:\n        print(f\"❌ Error during re-indexing: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == '__main__':\n    print(\"=\" * 60)\n    print(\"Re-indexing Learned Tasks for Semantic Search\")\n    print(\"=\" * 60)\n    reindex_all_tasks()\n","size_bytes":2180},"mcp/src/automation/ai_generator.py":{"content":"import os\nfrom typing import Optional\ntry:\n    from openai import AsyncOpenAI, OpenAIError\n    OPENAI_AVAILABLE = True\nexcept ImportError:\n    OPENAI_AVAILABLE = False\n\nfrom .logger import get_logger\nfrom .config import AutomationConfig\n\nlogger = get_logger()\n\n\nclass AITaskGenerator:\n    \n    def __init__(self, automation_config: Optional[AutomationConfig] = None):\n        self.config = automation_config or AutomationConfig()\n        self.api_key = os.getenv(\"OPENAI_API_KEY\")\n        self.client = None\n        \n        if not OPENAI_AVAILABLE:\n            logger.warning(\"OpenAI package not available. Install with: pip install openai\")\n        elif not self.api_key:\n            logger.warning(\"OPENAI_API_KEY not set. AI code generation will not be available.\")\n        else:\n            self.client = AsyncOpenAI(api_key=self.api_key)\n    \n    async def generate_playwright_code(self, task_description: str) -> Optional[str]:\n        if not OPENAI_AVAILABLE:\n            logger.error(\"Cannot generate code: OpenAI package not installed\")\n            return None\n        \n        if not self.client:\n            logger.error(\"Cannot generate code: OPENAI_API_KEY not set\")\n            return None\n        \n        logger.info(f\"Generating Playwright code for: {task_description}\")\n        \n        try:\n            system_prompt = \"\"\"You are an expert Python developer and Playwright automation engineer.\nGenerate complete, runnable Python scripts using Playwright.\nUse realistic and working CSS or XPath selectors.\nProvide only valid code with proper imports, async functions, and browser handling.\nMake the code robust with error handling and logging.\nUse best practices for browser automation.\nReturn ONLY the Python code, no explanations or markdown formatting.\"\"\"\n\n            user_prompt = f\"\"\"Generate a complete Python Playwright script for this task:\n\n{task_description}\n\nRequirements:\n- Use async/await with Playwright\n- Include proper imports\n- Add error handling\n- Use realistic selectors\n- Make it production-ready\n- Add logging where appropriate\"\"\"\n\n            response = await self.client.chat.completions.create(\n                model=self.config.openai_model,\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.7,\n                max_tokens=2000\n            )\n            \n            code = response.choices[0].message.content\n            logger.success(\"Code generation completed\")\n            return code\n            \n        except Exception as e:\n            logger.error(f\"Error during code generation: {e}\")\n            return None\n    \n    async def generate_scraping_code(self, url: str, data_description: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to scrape data from {url}. \"\n            f\"Extract the following data: {data_description}. \"\n            f\"Return the data as a list of dictionaries and print it in JSON format.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_form_filling_code(self, url: str, form_fields: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to fill out a form at {url}. \"\n            f\"The form has these fields: {form_fields}. \"\n            f\"Fill the form with appropriate test data and submit it.\"\n        )\n        return await self.generate_playwright_code(task)\n    \n    async def generate_login_code(self, url: str, username_field: str, password_field: str) -> Optional[str]:\n        task = (\n            f\"Generate Python Playwright code to log in to {url}. \"\n            f\"Username field selector: {username_field}, Password field selector: {password_field}. \"\n            f\"Include error handling and session management.\"\n        )\n        return await self.generate_playwright_code(task)\n","size_bytes":3944},"mcp/src/automation/mcp_client.py":{"content":"import asyncio\nimport os\nfrom contextlib import AsyncExitStack\nfrom typing import Optional, Dict, Any, List\nimport json\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nfrom .logger import get_logger\nfrom .execution_tracer import ExecutionTracer, ExecutionTrace\n\nlogger = get_logger()\n\n\nclass PlaywrightMCPClient:\n    \"\"\"\n    Client for communicating with Playwright MCP server.\n    Provides browser automation capabilities via Model Context Protocol.\n    \"\"\"\n    \n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.session: Optional[ClientSession] = None\n        self.exit_stack = AsyncExitStack()\n        self.tools: List[Dict[str, Any]] = []\n        self.tracer = tracer or ExecutionTracer()\n        \n    async def connect(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"\n        Connect to Playwright MCP server.\n        \n        Args:\n            browser: Browser type (chromium, firefox, webkit)\n            headless: Whether to run in headless mode\n        \"\"\"\n        try:\n            logger.info(f\"Connecting to Playwright MCP server (browser={browser}, headless={headless})\")\n            \n            # Set up environment for npx command (fix NixOS env issues)\n            env = os.environ.copy()\n            env.setdefault(\"XDG_CONFIG_HOME\", os.path.expanduser(\"~/.config\"))\n            env.setdefault(\"XDG_DATA_HOME\", os.path.expanduser(\"~/.local/share\"))\n            env.setdefault(\"XDG_CACHE_HOME\", os.path.expanduser(\"~/.cache\"))\n            \n            # Build args (only add --headless if headless mode is enabled)\n            args = [\"@playwright/mcp@latest\", \"--browser\", browser]\n            if headless:\n                args.append(\"--headless\")\n            \n            server_params = StdioServerParameters(\n                command=\"npx\",\n                args=args,\n                env=env\n            )\n            \n            stdio_transport = await self.exit_stack.enter_async_context(\n                stdio_client(server_params)\n            )\n            read_stream, write_stream = stdio_transport\n            \n            self.session = await self.exit_stack.enter_async_context(\n                ClientSession(read_stream, write_stream)\n            )\n            \n            await self.session.initialize()\n            \n            response = await self.session.list_tools()\n            self.tools = [\n                {\n                    \"name\": tool.name,\n                    \"description\": tool.description,\n                    \"input_schema\": tool.inputSchema\n                }\n                for tool in response.tools\n            ]\n            \n            logger.success(f\"Connected to Playwright MCP! Available tools: {[t['name'] for t in self.tools]}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to connect to Playwright MCP: {e}\")\n            raise\n    \n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any], trace: Optional[ExecutionTrace] = None) -> Any:\n        \"\"\"\n        Call a Playwright MCP tool.\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Tool arguments\n            trace: Optional execution trace to update with result\n            \n        Returns:\n            Tool result\n        \"\"\"\n        if not self.session:\n            raise RuntimeError(\"Not connected to MCP server. Call connect() first.\")\n        \n        try:\n            logger.info(f\"Calling MCP tool: {tool_name} with args: {arguments}\")\n            \n            result = await self.session.call_tool(tool_name, arguments)\n            \n            if result.content:\n                content = result.content[0]\n                if hasattr(content, 'text'):\n                    return_value = content.text\n                    try:\n                        return_value = json.loads(return_value)\n                    except json.JSONDecodeError:\n                        pass\n                    logger.success(f\"Tool {tool_name} completed successfully\")\n                    \n                    # Update trace with success\n                    if trace:\n                        trace.mark_success(return_value)\n                    \n                    return return_value\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Tool {tool_name} failed: {e}\")\n            \n            # Update trace with failure\n            if trace:\n                trace.mark_failure(str(e))\n            \n            raise\n    \n    async def navigate(self, url: str) -> Dict[str, Any]:\n        \"\"\"Navigate to a URL.\"\"\"\n        trace = self.tracer.record_navigation(url) if self.tracer.is_tracing() else None\n        result = await self.call_tool(\"browser_navigate\", {\"url\": url}, trace)\n        if trace:\n            trace.mark_success(result)\n        return result\n    \n    async def click(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Click an element.\"\"\"\n        trace = self.tracer.record_click(selector) if self.tracer.is_tracing() else None\n        result = await self.call_tool(\"browser_click\", {\"selector\": selector}, trace)\n        if trace:\n            trace.mark_success(result)\n        return result\n    \n    async def fill(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Fill an input field.\"\"\"\n        trace = self.tracer.record_fill(selector, value) if self.tracer.is_tracing() else None\n        result = await self.call_tool(\"browser_fill_form\", {\n            \"selector\": selector,\n            \"value\": value\n        }, trace)\n        if trace:\n            trace.mark_success(result)\n        return result\n    \n    async def screenshot(self, path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Take a screenshot.\"\"\"\n        args = {}\n        if path:\n            args[\"path\"] = path\n        return await self.call_tool(\"browser_take_screenshot\", args)\n    \n    async def evaluate(self, expression: str) -> Any:\n        \"\"\"Execute JavaScript in the browser.\"\"\"\n        return await self.call_tool(\"browser_evaluate\", {\"expression\": expression})\n    \n    async def get_page_content(self) -> str:\n        \"\"\"Get the current page HTML content.\"\"\"\n        result = await self.call_tool(\"browser_snapshot\", {})\n        return result if isinstance(result, str) else \"\"\n    \n    async def extract_text(self, selector: str) -> str:\n        \"\"\"Extract text from an element using JavaScript.\"\"\"\n        js_code = f\"document.querySelector('{selector}')?.innerText || ''\"\n        result = await self.evaluate(js_code)\n        return str(result) if result else \"\"\n    \n    async def extract_all_text(self, selector: str) -> List[str]:\n        \"\"\"Extract text from multiple elements.\"\"\"\n        js_code = f\"Array.from(document.querySelectorAll('{selector}')).map(el => el.innerText)\"\n        result = await self.evaluate(js_code)\n        return result if isinstance(result, list) else []\n    \n    async def wait_for_selector(self, selector: str, timeout: int = 30000) -> Dict[str, Any]:\n        \"\"\"Wait for a selector to appear on the page.\"\"\"\n        return await self.call_tool(\"browser_wait_for\", {\n            \"selector\": selector,\n            \"timeout\": timeout\n        })\n    \n    async def type_text(self, selector: str, text: str, delay: int = 50) -> Dict[str, Any]:\n        \"\"\"Type text into an element with delay between keystrokes.\"\"\"\n        return await self.call_tool(\"browser_type\", {\n            \"selector\": selector,\n            \"text\": text,\n            \"delay\": delay\n        })\n    \n    async def select_dropdown(self, selector: str, value: str) -> Dict[str, Any]:\n        \"\"\"Select a dropdown option.\"\"\"\n        return await self.call_tool(\"browser_select_option\", {\n            \"selector\": selector,\n            \"value\": value\n        })\n    \n    async def hover(self, selector: str) -> Dict[str, Any]:\n        \"\"\"Hover over an element.\"\"\"\n        return await self.call_tool(\"browser_hover\", {\"selector\": selector})\n    \n    async def press_key(self, key: str) -> Dict[str, Any]:\n        \"\"\"Press a keyboard key.\"\"\"\n        return await self.call_tool(\"browser_press_key\", {\"key\": key})\n    \n    async def get_console_messages(self) -> List[str]:\n        \"\"\"Get browser console messages.\"\"\"\n        result = await self.call_tool(\"browser_console_messages\", {})\n        return result if isinstance(result, list) else []\n    \n    async def get_network_requests(self) -> List[Dict[str, Any]]:\n        \"\"\"Get network requests made by the page.\"\"\"\n        result = await self.call_tool(\"browser_network_requests\", {})\n        return result if isinstance(result, list) else []\n    \n    async def upload_file(self, selector: str, file_path: str) -> Dict[str, Any]:\n        \"\"\"Upload a file to an input element.\"\"\"\n        return await self.call_tool(\"browser_file_upload\", {\n            \"selector\": selector,\n            \"filePath\": file_path\n        })\n    \n    async def handle_dialog(self, action: str = \"accept\", text: str = \"\") -> Dict[str, Any]:\n        \"\"\"Handle browser dialog (alert, confirm, prompt).\"\"\"\n        args: Dict[str, Any] = {\"action\": action}\n        if text:\n            args[\"text\"] = text\n        return await self.call_tool(\"browser_handle_dialog\", args)\n    \n    async def go_back(self) -> Dict[str, Any]:\n        \"\"\"Navigate back in browser history.\"\"\"\n        return await self.call_tool(\"browser_navigate_back\", {})\n    \n    async def resize_viewport(self, width: int, height: int) -> Dict[str, Any]:\n        \"\"\"Resize browser viewport.\"\"\"\n        return await self.call_tool(\"browser_resize\", {\n            \"width\": width,\n            \"height\": height\n        })\n    \n    async def get_tabs(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of open browser tabs.\"\"\"\n        result = await self.call_tool(\"browser_tabs\", {})\n        return result if isinstance(result, list) else []\n    \n    async def close_browser(self) -> Dict[str, Any]:\n        \"\"\"Close the browser.\"\"\"\n        return await self.call_tool(\"browser_close\", {})\n    \n    async def close(self):\n        \"\"\"Close the MCP client connection.\"\"\"\n        try:\n            await self.exit_stack.aclose()\n            logger.info(\"MCP client connection closed\")\n        except Exception as e:\n            logger.error(f\"Error closing MCP client: {e}\")\n    \n    def get_available_tools(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of available MCP tools.\"\"\"\n        return self.tools\n","size_bytes":10472},"mcp/src/automation/selectors.py":{"content":"from typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom playwright.async_api import Page, Locator\nfrom .config import SelectorStrategy\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\n@dataclass\nclass SelectorOptions:\n    strategy: SelectorStrategy = SelectorStrategy.AUTO\n    timeout: int = 10000\n    state: str = \"visible\"\n    strict: bool = False\n\n\nclass SmartSelector:\n    \n    @staticmethod\n    async def find_element(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[Locator]:\n        if options is None:\n            options = SelectorOptions()\n        \n        if options.strategy == SelectorStrategy.AUTO:\n            return await SmartSelector._auto_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.CSS:\n            return await SmartSelector._css_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.XPATH:\n            return await SmartSelector._xpath_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.TEXT:\n            return await SmartSelector._text_select(page, selector, options)\n        elif options.strategy == SelectorStrategy.ARIA:\n            return await SmartSelector._aria_select(page, selector, options)\n    \n    @staticmethod\n    async def _auto_select(page: Page, selector: str, options: SelectorOptions) -> Optional[Locator]:\n        strategies = [\n            (SelectorStrategy.CSS, SmartSelector._css_select),\n            (SelectorStrategy.XPATH, SmartSelector._xpath_select),\n            (SelectorStrategy.TEXT, SmartSelector._text_select),\n            (SelectorStrategy.ARIA, SmartSelector._aria_select),\n        ]\n        \n        for strategy_type, strategy_func in strategies:\n            try:\n                logger.debug(f\"Trying {strategy_type.value} selector: {selector}\")\n                element = await strategy_func(page, selector, options)\n                if element:\n                    count = await element.count()\n                    if count > 0:\n                        logger.success(f\"Found element using {strategy_type.value} selector\")\n                        return element\n            except Exception as e:\n                logger.debug(f\"{strategy_type.value} selector failed: {str(e)}\")\n                continue\n        \n        logger.warning(f\"Could not find element with any strategy: {selector}\")\n        return None\n    \n    @staticmethod\n    async def _css_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.locator(selector)\n    \n    @staticmethod\n    async def _xpath_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        if not selector.startswith('//') and not selector.startswith('('):\n            selector = f\"//{selector}\"\n        return page.locator(f\"xpath={selector}\")\n    \n    @staticmethod\n    async def _text_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_text(selector)\n    \n    @staticmethod\n    async def _aria_select(page: Page, selector: str, options: SelectorOptions) -> Locator:\n        return page.get_by_role(selector)\n    \n    @staticmethod\n    async def find_all(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> List[Locator]:\n        locator = await SmartSelector.find_element(page, selector, options)\n        if locator:\n            count = await locator.count()\n            return [locator.nth(i) for i in range(count)]\n        return []\n    \n    @staticmethod\n    async def safe_click(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.click(timeout=options.timeout if options else 10000)\n                logger.success(f\"Clicked element: {selector}\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to click element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def safe_fill(\n        page: Page,\n        selector: str,\n        value: str,\n        options: Optional[SelectorOptions] = None\n    ) -> bool:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                await element.first.fill(value, timeout=options.timeout if options else 10000)\n                logger.success(f\"Filled element {selector} with value\")\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to fill element {selector}: {str(e)}\")\n        return False\n    \n    @staticmethod\n    async def get_text(\n        page: Page,\n        selector: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                text = await element.first.text_content(timeout=options.timeout if options else 10000)\n                return text\n        except Exception as e:\n            logger.error(f\"Failed to get text from {selector}: {str(e)}\")\n        return None\n    \n    @staticmethod\n    async def get_attribute(\n        page: Page,\n        selector: str,\n        attribute: str,\n        options: Optional[SelectorOptions] = None\n    ) -> Optional[str]:\n        try:\n            element = await SmartSelector.find_element(page, selector, options)\n            if element:\n                attr_value = await element.first.get_attribute(attribute, timeout=options.timeout if options else 10000)\n                return attr_value\n        except Exception as e:\n            logger.error(f\"Failed to get attribute {attribute} from {selector}: {str(e)}\")\n        return None\n","size_bytes":5951},"visionvault/agents/__init__.py":{"content":"\"\"\"VisionVault Browser Automation Agent\"\"\"\n\n__version__ = \"1.0.0\"","size_bytes":65},"mcp/main.py":{"content":"import asyncio\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.automation import BrowserEngine, TaskExecutor, AITaskGenerator, AI_AVAILABLE\nfrom src.automation.config import BrowserConfig, AutomationConfig\nfrom src.automation.logger import get_logger, console\nfrom rich.prompt import Prompt, Confirm\nfrom rich.table import Table\nfrom rich.panel import Panel\n\nlogger = get_logger()\n\n\nasync def run_web_automation_demo():\n    console.print(Panel.fit(\"Web Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to automate\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        page_title = await browser.get_text(\"h1\")\n        if page_title:\n            logger.success(f\"Page heading: {page_title}\")\n        \n        links = await browser.get_all_text(\"a\")\n        if links:\n            console.print(f\"\\n[cyan]Found {len(links)} links on the page[/cyan]\")\n            \n            table = Table(title=\"First 10 Links\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=3)\n            table.add_column(\"Link Text\", style=\"cyan\")\n            \n            for i, link_text in enumerate(links[:10], 1):\n                if link_text.strip():\n                    table.add_row(str(i), link_text.strip()[:80])\n            \n            console.print(table)\n        \n        screenshot_path = await browser.screenshot(\"web_automation_demo\")\n        logger.success(f\"Screenshot saved to {screenshot_path}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_ai_code_generation():\n    console.print(Panel.fit(\"AI Code Generation Demo\", style=\"bold cyan\"))\n    \n    if not AI_AVAILABLE:\n        console.print(\"[red]AI code generation is not available due to package compatibility issues.[/red]\")\n        console.print(\"[yellow]The core automation framework works without AI features.[/yellow]\")\n        return\n    \n    task_description = Prompt.ask(\n        \"Describe the automation task\"\n    )\n    \n    config = AutomationConfig(openai_model=\"gpt-4o-mini\", mcp_timeout=300)\n    generator = AITaskGenerator(config)\n    \n    console.print(\"\\n[yellow]Generating code... This may take a moment.[/yellow]\\n\")\n    \n    code = await generator.generate_playwright_code(task_description)\n    \n    if code:\n        console.print(Panel(code, title=\"Generated Code\", border_style=\"green\"))\n        \n        if Confirm.ask(\"Save to file?\", default=True):\n            filename = Prompt.ask(\"Filename\", default=\"generated_automation.py\")\n            with open(filename, 'w') as f:\n                f.write(code)\n            logger.success(f\"Code saved to {filename}\")\n    else:\n        logger.error(\"Failed to generate code. Make sure OPENAI_API_KEY is set.\")\n\n\nasync def run_form_automation_demo():\n    console.print(Panel.fit(\"Form Automation Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter form URL\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    executor = TaskExecutor(browser)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        console.print(\"\\n[yellow]You can now define form fields to fill[/yellow]\")\n        console.print(\"[dim]Example: input[name='email'] = test@example.com[/dim]\\n\")\n        \n        form_data = {}\n        \n        while True:\n            selector = Prompt.ask(\"Enter CSS selector (or press Enter to finish)\", default=\"\")\n            if not selector:\n                break\n            \n            value = Prompt.ask(f\"Enter value for '{selector}'\")\n            form_data[selector] = value\n        \n        if form_data:\n            success = await executor.fill_form(form_data)\n            if success:\n                logger.success(\"Form filled successfully!\")\n                \n                screenshot_path = await browser.screenshot(\"form_filled\")\n                logger.success(f\"Screenshot saved to {screenshot_path}\")\n        else:\n            logger.info(\"No form data provided\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def run_data_extraction_demo():\n    console.print(Panel.fit(\"Data Extraction Demo\", style=\"bold cyan\"))\n    \n    url = Prompt.ask(\"Enter URL to extract data from\")\n    selector = Prompt.ask(\"Enter CSS selector for elements to extract\")\n    \n    browser_config = BrowserConfig(headless=True, screenshot_on_error=True)\n    automation_config = AutomationConfig(log_level=\"INFO\")\n    \n    browser = BrowserEngine(browser_config, automation_config)\n    \n    try:\n        await browser.start()\n        \n        logger.info(f\"Navigating to {url}\")\n        await browser.navigate(url)\n        await browser.wait_for_load()\n        \n        texts = await browser.get_all_text(selector)\n        \n        if texts:\n            console.print(f\"\\n[cyan]Found {len(texts)} elements matching '{selector}'[/cyan]\\n\")\n            \n            table = Table(title=\"Extracted Data\", show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"#\", style=\"dim\", width=5)\n            table.add_column(\"Content\", style=\"green\")\n            \n            for i, text in enumerate(texts[:20], 1):\n                if text.strip():\n                    table.add_row(str(i), text.strip()[:100])\n            \n            console.print(table)\n            \n            if Confirm.ask(\"\\nSave to file?\", default=False):\n                filename = Prompt.ask(\"Filename\", default=\"extracted_data.txt\")\n                with open(filename, 'w') as f:\n                    for text in texts:\n                        f.write(f\"{text}\\n\")\n                logger.success(f\"Data saved to {filename}\")\n        else:\n            logger.warning(f\"No elements found matching selector: {selector}\")\n            \n    except Exception as e:\n        logger.exception(f\"Error during automation: {e}\")\n    finally:\n        await browser.stop()\n\n\nasync def main():\n    console.print(Panel.fit(\n        \"[bold cyan]Browser Automation Framework[/bold cyan]\\n\"\n        \"[dim]Universal web automation for any site[/dim]\",\n        border_style=\"cyan\"\n    ))\n    \n    options = {\n        \"1\": (\"Web Automation Demo\", run_web_automation_demo),\n        \"2\": (\"Form Automation Demo\", run_form_automation_demo),\n        \"3\": (\"Data Extraction Demo\", run_data_extraction_demo),\n        \"4\": (f\"AI Code Generation {'[dim](unavailable)[/dim]' if not AI_AVAILABLE else ''}\", run_ai_code_generation),\n        \"5\": (\"Exit\", None)\n    }\n    \n    while True:\n        console.print(\"\\n[bold]Available Demos:[/bold]\")\n        for key, (name, _) in options.items():\n            console.print(f\"  {key}. {name}\")\n        \n        choice = Prompt.ask(\"\\nSelect an option\", choices=list(options.keys()), default=\"1\")\n        \n        if choice == \"5\":\n            console.print(\"\\n[cyan]Goodbye![/cyan]\")\n            break\n        \n        _, func = options[choice]\n        if func:\n            try:\n                await func()\n            except KeyboardInterrupt:\n                console.print(\"\\n[yellow]Operation cancelled[/yellow]\")\n            except Exception as e:\n                logger.exception(f\"Unexpected error: {e}\")\n        \n        console.print()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Program terminated[/yellow]\")\n","size_bytes":8117},"visionvault/services/dom_inspector.py":{"content":"\"\"\"\nDOM Inspector Service\nAnalyzes web pages to extract element information for intelligent locator selection.\n\"\"\"\nimport asyncio\nimport re\nfrom typing import Dict, List, Optional\nfrom playwright.async_api import async_playwright, Page\n\n\nclass DOMInspector:\n    \"\"\"Inspects DOM structure to help AI select perfect locators\"\"\"\n    \n    def __init__(self):\n        self.browser = None\n        self.context = None\n        self.page = None\n    \n    async def analyze_page(self, url: str, user_command: str) -> Dict:\n        \"\"\"\n        Navigate to a page and extract element information for intelligent locator selection.\n        \n        Args:\n            url: The URL to analyze\n            user_command: The user's natural language command to understand intent\n            \n        Returns:\n            Dict containing available elements, their attributes, and recommended locators\n        \"\"\"\n        try:\n            async with async_playwright() as p:\n                browser = await p.chromium.launch(headless=True)\n                page = await browser.new_page()\n                \n                # Navigate to the page\n                await page.goto(url, timeout=15000, wait_until='domcontentloaded')\n                \n                # Extract page information\n                page_info = {\n                    'url': url,\n                    'title': await page.title(),\n                    'interactive_elements': await self._extract_interactive_elements(page),\n                    'form_elements': await self._extract_form_elements(page),\n                    'navigation_elements': await self._extract_navigation_elements(page),\n                    'intent_matched_elements': await self._match_user_intent(page, user_command)\n                }\n                \n                await browser.close()\n                return page_info\n                \n        except Exception as e:\n            return {\n                'error': str(e),\n                'url': url,\n                'message': 'Could not inspect DOM, AI will use standard locator strategies'\n            }\n    \n    async def _extract_interactive_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract all interactive elements (buttons, links, inputs)\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Buttons\n                document.querySelectorAll('button, input[type=\"button\"], input[type=\"submit\"]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {  // Only visible elements\n                        elements.push({\n                            type: 'button',\n                            text: el.textContent.trim() || el.value || '',\n                            role: el.getAttribute('role') || 'button',\n                            name: el.getAttribute('aria-label') || el.textContent.trim() || el.value || '',\n                            id: el.id,\n                            testid: el.getAttribute('data-testid'),\n                            classes: el.className\n                        });\n                    }\n                });\n                \n                // Links\n                document.querySelectorAll('a').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'link',\n                            text: el.textContent.trim(),\n                            href: el.href,\n                            role: el.getAttribute('role') || 'link',\n                            name: el.getAttribute('aria-label') || el.textContent.trim(),\n                            id: el.id,\n                            testid: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _extract_form_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract form inputs with their labels and attributes\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Text inputs, textareas\n                document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], input[type=\"search\"], input:not([type]), textarea').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        // Find associated label\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        if (!labelText) {\n                            const parentLabel = el.closest('label');\n                            if (parentLabel) labelText = parentLabel.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: 'input',\n                            inputType: el.type || 'text',\n                            placeholder: el.placeholder,\n                            label: labelText,\n                            role: el.getAttribute('role') || (el.type === 'search' ? 'combobox' : 'textbox'),\n                            name: el.getAttribute('aria-label') || labelText || el.placeholder || '',\n                            id: el.id,\n                            testid: el.getAttribute('data-testid'),\n                            autocomplete: el.autocomplete\n                        });\n                    }\n                });\n                \n                // Checkboxes and radios\n                document.querySelectorAll('input[type=\"checkbox\"], input[type=\"radio\"]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: el.type,\n                            label: labelText,\n                            role: el.type,\n                            name: el.getAttribute('aria-label') || labelText || '',\n                            id: el.id,\n                            testid: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                // Select dropdowns\n                document.querySelectorAll('select').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        let labelText = '';\n                        if (el.id) {\n                            const label = document.querySelector(`label[for=\"${el.id}\"]`);\n                            if (label) labelText = label.textContent.trim();\n                        }\n                        \n                        elements.push({\n                            type: 'select',\n                            label: labelText,\n                            role: 'combobox',\n                            name: el.getAttribute('aria-label') || labelText || '',\n                            id: el.id,\n                            testid: el.getAttribute('data-testid')\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _extract_navigation_elements(self, page: Page) -> List[Dict]:\n        \"\"\"Extract navigation elements (nav links, menus)\"\"\"\n        try:\n            elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                document.querySelectorAll('nav a, [role=\"navigation\"] a').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'nav-link',\n                            text: el.textContent.trim(),\n                            href: el.href,\n                            role: 'link',\n                            name: el.textContent.trim()\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            return elements\n        except:\n            return []\n    \n    async def _match_user_intent(self, page: Page, user_command: str) -> List[Dict]:\n        \"\"\"\n        Match user intent to specific elements on the page.\n        For example: \"search for cats\" -> find search box\n        \"\"\"\n        command_lower = user_command.lower()\n        matched_elements = []\n        \n        # Search intent\n        if any(word in command_lower for word in ['search', 'find', 'look for', 'query']):\n            search_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Find search inputs\n                document.querySelectorAll('input[type=\"search\"], input[name*=\"search\" i], input[placeholder*=\"search\" i], input[aria-label*=\"search\" i]').forEach(el => {\n                    const rect = el.getBoundingClientRect();\n                    if (rect.width > 0 && rect.height > 0) {\n                        elements.push({\n                            type: 'search-input',\n                            placeholder: el.placeholder,\n                            role: el.getAttribute('role') || 'combobox',\n                            name: el.getAttribute('aria-label') || el.placeholder || 'Search',\n                            testid: el.getAttribute('data-testid'),\n                            id: el.id,\n                            recommended_locator: el.getAttribute('aria-label') \n                                ? `get_by_role(\"combobox\", name=\"${el.getAttribute('aria-label')}\")`\n                                : (el.placeholder ? `get_by_placeholder(\"${el.placeholder}\")` : null)\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(search_elements)\n        \n        # Login intent\n        if any(word in command_lower for word in ['login', 'log in', 'sign in', 'signin']):\n            login_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                // Find login buttons\n                document.querySelectorAll('button, a, input[type=\"submit\"]').forEach(el => {\n                    const text = el.textContent.trim() || el.value || '';\n                    if (text.match(/log ?in|sign ?in/i)) {\n                        elements.push({\n                            type: 'login-button',\n                            text: text,\n                            role: 'button',\n                            name: text,\n                            recommended_locator: `get_by_role(\"button\", name=\"${text}\")`\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(login_elements)\n        \n        # Submit intent\n        if any(word in command_lower for word in ['submit', 'send', 'post']):\n            submit_elements = await page.evaluate('''() => {\n                const elements = [];\n                \n                document.querySelectorAll('button[type=\"submit\"], input[type=\"submit\"], button').forEach(el => {\n                    const text = el.textContent.trim() || el.value || '';\n                    if (text.match(/submit|send|post|continue|next/i)) {\n                        elements.push({\n                            type: 'submit-button',\n                            text: text,\n                            role: 'button',\n                            name: text,\n                            recommended_locator: `get_by_role(\"button\", name=\"${text}\")`\n                        });\n                    }\n                });\n                \n                return elements;\n            }''')\n            matched_elements.extend(submit_elements)\n        \n        return matched_elements\n    \n    def generate_locator_recommendations(self, page_info: Dict) -> str:\n        \"\"\"\n        Generate a detailed report of available locators for the AI to use.\n        \"\"\"\n        if 'error' in page_info:\n            return \"\"\n        \n        recommendations = []\n        recommendations.append(\"=== REAL PAGE ANALYSIS ===\")\n        recommendations.append(f\"Page: {page_info.get('title', 'Unknown')} ({page_info.get('url', '')})\")\n        recommendations.append(\"\")\n        \n        # Intent-matched elements (highest priority)\n        if page_info.get('intent_matched_elements'):\n            recommendations.append(\"🎯 ELEMENTS MATCHING USER INTENT (Use these first!):\")\n            for elem in page_info['intent_matched_elements'][:5]:\n                if elem.get('recommended_locator'):\n                    recommendations.append(f\"  • {elem['type']}: {elem.get('text', elem.get('name', ''))} → {elem['recommended_locator']}\")\n                else:\n                    recommendations.append(f\"  • {elem['type']}: {elem.get('text', elem.get('name', ''))}\")\n            recommendations.append(\"\")\n        \n        # Form elements\n        if page_info.get('form_elements'):\n            recommendations.append(\"📝 FORM ELEMENTS AVAILABLE:\")\n            for elem in page_info['form_elements'][:10]:\n                locators = []\n                if elem.get('testid'):\n                    locators.append(f\"get_by_test_id(\\\"{elem['testid']}\\\")\")\n                if elem.get('label'):\n                    locators.append(f\"get_by_label(\\\"{elem['label']}\\\")\")\n                if elem.get('placeholder'):\n                    locators.append(f\"get_by_placeholder(\\\"{elem['placeholder']}\\\")\")\n                if elem.get('role') and elem.get('name'):\n                    locators.append(f\"get_by_role(\\\"{elem['role']}\\\", name=\\\"{elem['name']}\\\")\")\n                \n                if locators:\n                    recommendations.append(f\"  • {elem.get('type', 'input')} ({elem.get('inputType', '')}): {' OR '.join(locators[:2])}\")\n            recommendations.append(\"\")\n        \n        # Interactive elements\n        if page_info.get('interactive_elements'):\n            recommendations.append(\"🔘 BUTTONS & LINKS AVAILABLE:\")\n            for elem in page_info['interactive_elements'][:10]:\n                locators = []\n                if elem.get('testid'):\n                    locators.append(f\"get_by_test_id(\\\"{elem['testid']}\\\")\")\n                if elem.get('role') and elem.get('name'):\n                    locators.append(f\"get_by_role(\\\"{elem['role']}\\\", name=\\\"{elem['name']}\\\")\")\n                if elem.get('text'):\n                    locators.append(f\"get_by_text(\\\"{elem['text']}\\\", exact=True)\")\n                \n                if locators:\n                    recommendations.append(f\"  • {elem.get('type', 'element')}: {locators[0]}\")\n            recommendations.append(\"\")\n        \n        recommendations.append(\"✅ USE THESE EXACT LOCATORS - They are confirmed to exist on the page!\")\n        recommendations.append(\"=\" * 60)\n        \n        return \"\\n\".join(recommendations)\n\n\n# Singleton instance\ndom_inspector = DOMInspector()\n","size_bytes":16004},"mcp/nl_automation_mcp.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nEnhanced Natural Language Browser Automation using Playwright MCP Server\nFeatures: Vision-based intelligence, smart error recovery, session memory, advanced web handling\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nimport base64\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\nfrom src.automation.mcp_client import PlaywrightMCPClient\nfrom src.automation.logger import get_logger\nfrom src.automation.vision_analyzer import VisionAnalyzer\nfrom src.automation.session_memory import SessionMemory\nfrom src.automation.recorder import BrowserRecorder\nfrom openai import AsyncOpenAI\n\nlogger = get_logger()\n\n\nclass EnhancedMCPAutomation:\n    \"\"\"Enhanced natural language automation with vision, memory, and intelligent error recovery.\"\"\"\n    \n    def __init__(self, api_key: str, enable_vision: bool = True, max_retries: int = 3, screenshots_dir: str = \"screenshots\"):\n        self.client = AsyncOpenAI(api_key=api_key)\n        self.mcp = PlaywrightMCPClient()\n        self.conversation_history = []\n        self.enable_vision = enable_vision\n        self.vision_analyzer = VisionAnalyzer(api_key) if enable_vision else None\n        self.session_memory = SessionMemory()\n        self.recorder = BrowserRecorder(api_key)\n        self.max_retries = max_retries\n        self.screenshot_count = 0\n        self.screenshots_dir = screenshots_dir\n        self._recording_task: Optional[asyncio.Task] = None\n    \n    async def initialize(self, browser: str = \"chromium\", headless: bool = True):\n        \"\"\"Initialize MCP connection.\"\"\"\n        # Create screenshots folder if it doesn't exist\n        Path(self.screenshots_dir).mkdir(parents=True, exist_ok=True)\n        logger.info(f\"Created screenshots folder: {self.screenshots_dir}\")\n        \n        await self.mcp.connect(browser=browser, headless=headless)\n        logger.success(\"Enhanced MCP automation initialized with vision and memory!\")\n    \n    async def _take_screenshot(self, context: str = \"debug\") -> Optional[str]:\n        \"\"\"Take a screenshot and return base64 encoded image.\"\"\"\n        try:\n            self.screenshot_count += 1\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            screenshot_path = f\"screenshots/mcp_{context}_{timestamp}_{self.screenshot_count}.png\"\n            \n            result = await self.mcp.call_tool(\"browser_take_screenshot\", {\"path\": screenshot_path})\n            \n            if Path(screenshot_path).exists():\n                with open(screenshot_path, \"rb\") as f:\n                    return base64.b64encode(f.read()).decode()\n            return None\n        except Exception as e:\n            logger.error(f\"Screenshot failed: {e}\")\n            return None\n    \n    async def _analyze_page_with_vision(self, instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Use vision to analyze the page and get better selectors.\"\"\"\n        if not self.vision_analyzer:\n            return None\n        \n        try:\n            screenshot_b64 = await self._take_screenshot(\"vision_analysis\")\n            if not screenshot_b64:\n                return None\n            \n            analysis = await self.vision_analyzer.analyze_page(screenshot_b64, instruction)\n            logger.info(f\"Vision analysis: {analysis}\")\n            return analysis\n        except Exception as e:\n            logger.error(f\"Vision analysis failed: {e}\")\n            return None\n    \n    async def _get_page_context(self) -> str:\n        \"\"\"Get current page context for better decision making.\"\"\"\n        try:\n            snapshot = await self.mcp.call_tool(\"browser_snapshot\", {})\n            if isinstance(snapshot, str):\n                return snapshot[:2000]  # Smaller limit for speed\n            return \"\"\n        except Exception as e:\n            logger.debug(f\"Failed to get page context: {e}\")\n            return \"\"\n    \n    async def _wait_for_stable_page(self, timeout: int = 10000) -> bool:\n        \"\"\"Wait for page to stabilize (network idle, DOM ready).\"\"\"\n        try:\n            # Wait for network to be idle (no pending requests)\n            await self.mcp.call_tool(\"browser_wait_for\", {\n                \"state\": \"networkidle\",\n                \"timeout\": timeout\n            })\n            logger.info(\"✓ Page stabilized (network idle)\")\n            return True\n        except Exception as e:\n            logger.debug(f\"Network idle wait failed: {e}\")\n            # Fallback: just wait a bit\n            await asyncio.sleep(1)\n            return False\n    \n    async def _recover_with_page_refresh(self, instruction: str) -> bool:\n        \"\"\"Attempt to recover from critical failures by refreshing the page.\"\"\"\n        try:\n            logger.warning(\"⚠️ Attempting recovery with page refresh...\")\n            # Get current URL\n            current_url = await self.mcp.evaluate(\"window.location.href\")\n            if current_url:\n                # Refresh by navigating to same URL\n                await self.mcp.call_tool(\"browser_navigate\", {\"url\": current_url})\n                await self._wait_for_stable_page()\n                logger.success(\"✓ Page refreshed successfully\")\n                return True\n        except Exception as e:\n            logger.error(f\"Page refresh recovery failed: {e}\")\n        return False\n    \n    async def _get_page_elements_catalog(self) -> Dict[str, List[Dict[str, str]]]:\n        \"\"\"Get catalog of interactive elements on the page for smart retries.\"\"\"\n        try:\n            js_code = \"\"\"\n            (function() {\n                const elements = {\n                    buttons: [],\n                    links: [],\n                    inputs: [],\n                    selects: []\n                };\n                \n                // Catalog buttons\n                document.querySelectorAll('button, input[type=\"submit\"], input[type=\"button\"]').forEach(el => {\n                    elements.buttons.push({\n                        text: (el.innerText || el.value || '').trim().substring(0, 50),\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || '',\n                        type: el.type || 'button'\n                    });\n                });\n                \n                // Catalog links\n                document.querySelectorAll('a[href]').forEach(el => {\n                    elements.links.push({\n                        text: (el.innerText || '').trim().substring(0, 50),\n                        href: el.href || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog inputs\n                document.querySelectorAll('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], input[type=\"search\"], textarea').forEach(el => {\n                    elements.inputs.push({\n                        type: el.type || 'text',\n                        placeholder: el.placeholder || '',\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                // Catalog selects\n                document.querySelectorAll('select').forEach(el => {\n                    elements.selects.push({\n                        name: el.name || '',\n                        id: el.id || '',\n                        ariaLabel: el.getAttribute('aria-label') || ''\n                    });\n                });\n                \n                return elements;\n            })()\n            \"\"\"\n            result = await self.mcp.evaluate(js_code)\n            return result if isinstance(result, dict) else {}\n        except Exception as e:\n            logger.debug(f\"Could not get elements catalog: {e}\")\n            return {}\n    \n    async def _smart_retry_with_vision(self, tool_name: str, tool_args: Dict[str, Any], error: str, instruction: str, retry_attempt: int = 1) -> tuple[Any, Dict[str, Any]]:\n        \"\"\"Retry failed action with vision-based correction and intelligent catalog matching.\n        Returns: (result, modified_tool_args_that_worked)\n        \"\"\"\n        logger.info(f\"Attempting smart retry #{retry_attempt} for {tool_name}...\")\n        \n        # Strategy 1: Vision-based selector correction (ONLY ON FIRST RETRY for speed + success)\n        vision_analysis = None\n        if retry_attempt == 1 and self.enable_vision:\n            logger.info(f\"🔍 First retry - activating GPT-4 Vision for intelligent element detection...\")\n            vision_analysis = await self._analyze_page_with_vision(instruction)\n        else:\n            if retry_attempt > 1:\n                logger.info(f\"Retry #{retry_attempt} - using element catalog (vision already attempted)\")\n        \n        if vision_analysis and vision_analysis.get(\"suggested_selector\"):\n            new_selector = vision_analysis[\"suggested_selector\"]\n            logger.info(f\"Vision suggests selector: {new_selector}\")\n            \n            if \"selector\" in tool_args:\n                tool_args[\"selector\"] = new_selector\n                try:\n                    result = await self.mcp.call_tool(tool_name, tool_args)\n                    return (result, tool_args)  # Return the modified args that worked\n                except Exception as e:\n                    logger.debug(f\"Vision selector failed: {e}\")\n        \n        # Strategy 2: Use element catalog based on TOOL TYPE\n        elements_catalog = await self._get_page_elements_catalog()\n        original_selector = tool_args.get(\"selector\", \"\")\n        \n        # Extract keywords from both instruction and original selector\n        search_keywords = set(instruction.lower().split() + original_selector.lower().split())\n        \n        # Determine element type from tool name\n        if tool_name in [\"browser_click\"]:\n            # Try buttons first, then links\n            logger.info(\"Retrying click action - searching buttons and links\")\n            \n            for btn in elements_catalog.get(\"buttons\", []):\n                if btn.get(\"text\") and any(word in btn[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={btn['text']}\", f\"role=button[name=/{btn['text']}/i]\"]\n                    if btn.get(\"id\"):\n                        selectors.append(f\"#{btn['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying button selector: {sel}\")\n                            result = await self.mcp.call_tool(tool_name, tool_args)\n                            return (result, tool_args)  # Return modified args that worked\n                        except:\n                            continue\n            \n            for link in elements_catalog.get(\"links\", []):\n                if link.get(\"text\") and any(word in link[\"text\"].lower() for word in search_keywords):\n                    selectors = [f\"text={link['text']}\", f\"role=link[name=/{link['text']}/i]\"]\n                    if link.get(\"id\"):\n                        selectors.append(f\"#{link['id']}\")\n                    \n                    for sel in selectors:\n                        tool_args[\"selector\"] = sel\n                        try:\n                            logger.info(f\"Trying link selector: {sel}\")\n                            result = await self.mcp.call_tool(tool_name, tool_args)\n                            return (result, tool_args)  # Return modified args that worked\n                        except:\n                            continue\n        \n        elif tool_name in [\"browser_type\", \"browser_fill_form\"]:\n            # Looking for input fields\n            logger.info(\"Retrying fill/type action - searching inputs\")\n            \n            for inp in elements_catalog.get(\"inputs\", []):\n                selectors = []\n                # Match by placeholder, name, or keywords\n                if inp.get(\"placeholder\") and any(word in inp[\"placeholder\"].lower() for word in search_keywords):\n                    selectors.append(f\"[placeholder*='{inp['placeholder']}']\")\n                if inp.get(\"name\"):\n                    selectors.append(f\"[name='{inp['name']}']\")\n                    # Also try text matching on name\n                    if any(word in inp[\"name\"].lower() for word in search_keywords):\n                        selectors.insert(0, f\"[name='{inp['name']}']\")\n                if inp.get(\"id\"):\n                    selectors.append(f\"#{inp['id']}\")\n                if inp.get(\"ariaLabel\") and any(word in inp[\"ariaLabel\"].lower() for word in search_keywords):\n                    selectors.insert(0, f\"[aria-label='{inp['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying input selector: {sel}\")\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        elif tool_name in [\"browser_select_option\"]:\n            # Looking for select elements\n            logger.info(\"Retrying select action - searching selects\")\n            \n            for sel_elem in elements_catalog.get(\"selects\", []):\n                selectors = []\n                if sel_elem.get(\"name\"):\n                    selectors.append(f\"[name='{sel_elem['name']}']\")\n                if sel_elem.get(\"id\"):\n                    selectors.append(f\"#{sel_elem['id']}\")\n                if sel_elem.get(\"ariaLabel\"):\n                    selectors.append(f\"[aria-label='{sel_elem['ariaLabel']}']\")\n                \n                for sel in selectors:\n                    tool_args[\"selector\"] = sel\n                    try:\n                        logger.info(f\"Trying select selector: {sel}\")\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        else:\n            # For other tools, try generic matching\n            logger.info(f\"Retrying {tool_name} - trying generic element matching\")\n            all_elements = (\n                elements_catalog.get(\"buttons\", []) + \n                elements_catalog.get(\"links\", []) + \n                elements_catalog.get(\"inputs\", [])\n            )\n            \n            for elem in all_elements:\n                if elem.get(\"id\") and any(word in elem[\"id\"].lower() for word in search_keywords):\n                    tool_args[\"selector\"] = f\"#{elem['id']}\"\n                    try:\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        return (result, tool_args)  # Return modified args that worked\n                    except:\n                        continue\n        \n        raise Exception(f\"All vision and element catalog strategies exhausted for {tool_name}\")\n    \n    async def execute_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language command using AI + MCP with enhanced capabilities.\n        \n        Args:\n            command: Natural language instruction\n            \n        Returns:\n            Dict with status, summary, and continuation info\n        \"\"\"\n        logger.info(f\"Processing command: {command}\")\n        \n        # Check session memory for similar successful patterns\n        similar_patterns = self.session_memory.get_similar_patterns(command)\n        memory_context = self.session_memory.get_context_for_instruction(command)\n        if similar_patterns:\n            logger.info(f\"Found {len(similar_patterns)} similar patterns from memory\")\n        \n        # Get page context for better decisions\n        page_context = await self._get_page_context()\n        \n        # Get available MCP tools\n        tools = self.mcp.get_available_tools()\n        \n        # Format tools for OpenAI\n        openai_tools: list = [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool[\"description\"],\n                    \"parameters\": tool[\"input_schema\"]\n                }\n            }\n            for tool in tools\n        ]\n        \n        # Enhanced system prompt with aggressive intelligence\n        system_prompt = f\"\"\"You are an ULTRA-INTELLIGENT browser automation AI with MAXIMUM TASK COMPLETION capability.\n\nMISSION: Complete ANY valid task at all costs using all available strategies.\n\nPOWER FEATURES:\n- 21+ Playwright MCP tools for total browser control\n- GPT-4 Vision analysis activates on FIRST retry for intelligent element detection\n- 5 retry attempts with progressive intelligence escalation\n- Smart element catalog with fuzzy matching across buttons/links/inputs/selects\n- Session memory learns from every successful execution\n- Autonomous multi-step execution without user interruption\n\nAGGRESSIVE COMPLETION STRATEGY:\n1. ALWAYS use browser_snapshot first to deeply understand page structure\n2. For navigation: browser_navigate with full URLs, wait for network idle\n3. For element interactions: Use MULTIPLE selector strategies in parallel:\n   - Text selectors: text=exact_text (most reliable)\n   - Role selectors: role=button[name=/pattern/i]\n   - Attribute selectors: [placeholder*='value'], [aria-label='value']\n   - ID/Class: #id, .class\n4. For waiting: browser_wait_for with networkidle/load states for dynamic content\n5. For data extraction: browser_evaluate with robust JavaScript\n6. For forms: browser_fill_form for complex multi-field forms\n7. For failures: System auto-retries with vision + element catalog + fuzzy matching\n\nINTELLIGENT ADAPTATIONS:\n- If selector fails → Vision AI finds element → Element catalog suggests alternatives\n- If page changes → Auto-refresh DOM context → Re-analyze structure\n- If timing issue → Wait for network idle → Retry with extended timeout\n- If element hidden → Scroll into view → Wait for visibility → Click\n- If multiple matches → Use most specific selector → Verify with text content\n\nCURRENT PAGE:\n{page_context[:800] if page_context else 'No context - use browser_snapshot first!'}\n\nSUCCESS PATTERNS FROM MEMORY:\n{memory_context if memory_context else 'No patterns yet - creating new one!'}\n\nEXECUTE WITH MAXIMUM INTELLIGENCE. Never give up until task completes or all 5 retries exhausted.\"\"\"\n\n        # Add to conversation history\n        self.conversation_history.append({\n            \"role\": \"user\",\n            \"content\": command\n        })\n        \n        # Call OpenAI to determine which tools to use\n        response = await self.client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": system_prompt},\n                *self.conversation_history\n            ],\n            tools=openai_tools,\n            tool_choice=\"required\",  # Force AI to use tools instead of returning text\n            temperature=0.3  # Lower temperature for more consistent automation\n        )\n        \n        message = response.choices[0].message\n        results = []\n        tool_execution_log = []\n        \n        # Check if AI returned tool calls (should always be true with tool_choice=\"required\")\n        if not message.tool_calls:\n            error_msg = f\"AI did not return tool calls. Response: {message.content}\"\n            logger.error(error_msg)\n            self.session_memory.record_execution(\n                instruction=command,\n                success=False,\n                steps=[],\n                error=error_msg\n            )\n            return {\n                \"status\": \"error\",\n                \"summary\": \"AI failed to generate tool calls\",\n                \"should_continue\": False\n            }\n        \n        # Execute tool calls with smart retry\n        if message.tool_calls:\n            for tool_call in message.tool_calls:\n                if hasattr(tool_call, 'function'):\n                    tool_name = tool_call.function.name  # type: ignore\n                    try:\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                    except json.JSONDecodeError as e:\n                        logger.error(f\"Failed to parse tool arguments: {e}\")\n                        continue\n                else:\n                    continue\n                \n                logger.info(f\"⚡ Executing: {tool_name}({tool_args})\")\n                \n                # Ensure screenshots go to screenshots folder with unique names\n                if tool_name == \"browser_take_screenshot\":\n                    self.screenshot_count += 1\n                    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                    filename = tool_args.get(\"filename\", f\"screenshot_{timestamp}_{self.screenshot_count}.png\")\n                    # Ensure it's saved in screenshots folder\n                    if not filename.startswith(f\"{self.screenshots_dir}/\"):\n                        filename = f\"{self.screenshots_dir}/{filename}\"\n                    tool_args[\"path\"] = filename\n                    logger.info(f\"Screenshot will be saved to: {filename}\")\n                \n                # Try executing with retries\n                retry_count = 0\n                while retry_count < self.max_retries:\n                    try:\n                        result = await self.mcp.call_tool(tool_name, tool_args)\n                        logger.success(f\"✓ {tool_name} succeeded\")\n                        results.append(f\"✓ {tool_name}: {result}\")\n                        \n                        # Log successful execution\n                        tool_execution_log.append({\n                            \"tool\": tool_name,\n                            \"args\": tool_args,\n                            \"success\": True\n                        })\n                        \n                        # Add tool result to conversation\n                        self.conversation_history.append({\n                            \"role\": \"assistant\",\n                            \"content\": None,\n                            \"tool_calls\": [tool_call]\n                        })\n                        self.conversation_history.append({\n                            \"role\": \"tool\",\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": str(result)\n                        })\n                        \n                        # Auto-refresh DOM context after navigation with intelligent waiting\n                        if tool_name in [\"browser_navigate\", \"browser_navigate_back\", \"browser_navigate_forward\"]:\n                            # Wait for page to stabilize (network idle)\n                            await self._wait_for_stable_page()\n                            fresh_context = await self._get_page_context()\n                            if fresh_context:\n                                logger.info(f\"📊 Refreshed DOM context after navigation\")\n                                # Update conversation with fresh context (smaller for speed)\n                                self.conversation_history.append({\n                                    \"role\": \"system\",\n                                    \"content\": f\"Page context updated: {fresh_context[:300]}\"\n                                })\n                            \n                            # Re-inject recorder script if recording is active\n                            if self.recorder.is_recording:\n                                try:\n                                    await self.mcp.evaluate(self.recorder.get_recorder_script())\n                                    logger.info(\"🎥 Recorder script re-injected after navigation\")\n                                except Exception as e:\n                                    logger.warning(f\"Failed to re-inject recorder script: {e}\")\n                        \n                        # Inform AI about screenshot location\n                        if tool_name == \"browser_take_screenshot\":\n                            screenshot_path = tool_args.get(\"path\", \"unknown\")\n                            self.conversation_history.append({\n                                \"role\": \"system\",\n                                \"content\": f\"Screenshot saved to: {screenshot_path}\"\n                            })\n                            logger.success(f\"📸 Screenshot saved to: {screenshot_path}\")\n                        \n                        break  # Success, exit retry loop\n                        \n                    except Exception as e:\n                        retry_count += 1\n                        error_msg = f\"✗ {tool_name} failed (attempt {retry_count}/{self.max_retries}): {e}\"\n                        logger.warning(error_msg)\n                        \n                        if retry_count < self.max_retries:\n                            # Try smart retry with vision activated on first retry\n                            try:\n                                result, working_args = await self._smart_retry_with_vision(tool_name, tool_args.copy(), str(e), command, retry_count)\n                                results.append(f\"✓ {tool_name} (retry): {result}\")\n                                \n                                # Log successful retry WITH THE WORKING ARGS!\n                                # Extract the working selector for logging\n                                working_selector = working_args.get(\"selector\", \"\")\n                                if working_selector and working_selector != tool_args.get(\"selector\", \"\"):\n                                    logger.success(f\"✓ Found working selector: '{working_selector}' (original failed)\")\n                                \n                                tool_execution_log.append({\n                                    \"tool\": tool_name,\n                                    \"args\": working_args,  # Use the modified args that actually worked\n                                    \"success\": True,\n                                    \"retry\": True\n                                })\n                                \n                                break\n                            except Exception as retry_error:\n                                if retry_count == self.max_retries - 1:\n                                    # FINAL FALLBACK: Try page refresh recovery\n                                    logger.warning(\"⚠️ All retries exhausted, attempting page refresh recovery...\")\n                                    if await self._recover_with_page_refresh(command):\n                                        # One more try after refresh - try with vision-suggested selector if available\n                                        try:\n                                            # Try one more smart retry after refresh\n                                            result, final_working_args = await self._smart_retry_with_vision(tool_name, tool_args.copy(), str(retry_error), command, retry_count)\n                                            results.append(f\"✓ {tool_name} (after refresh): {result}\")\n                                            tool_execution_log.append({\n                                                \"tool\": tool_name,\n                                                \"args\": final_working_args,  # Use the working args, not original\n                                                \"success\": True,\n                                                \"recovery\": \"page_refresh\"\n                                            })\n                                            break\n                                        except:\n                                            pass\n                                    \n                                    results.append(error_msg)\n                                    tool_execution_log.append({\n                                        \"tool\": tool_name,\n                                        \"args\": tool_args,\n                                        \"success\": False,\n                                        \"error\": str(retry_error)\n                                    })\n                        else:\n                            results.append(error_msg)\n                            tool_execution_log.append({\n                                \"tool\": tool_name,\n                                \"args\": tool_args,\n                                \"success\": False,\n                                \"error\": str(e)\n                            })\n        \n        # Generate Playwright code from successful executions\n        playwright_code = self._generate_playwright_code(tool_execution_log, command)\n        \n        # Save execution to memory\n        success = any(log[\"success\"] for log in tool_execution_log)\n        error_msg = None\n        if not success:\n            failed_logs = [log for log in tool_execution_log if not log[\"success\"]]\n            if failed_logs:\n                error_msg = failed_logs[0].get(\"error\", \"Unknown error\")\n        \n        self.session_memory.record_execution(\n            instruction=command,\n            success=success,\n            steps=tool_execution_log,\n            error=error_msg\n        )\n        \n        # Determine if we need to continue autonomously or ask user\n        if results:\n            # Ask AI if task is complete or needs more steps\n            decision_response = await self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": f\"\"\"Analyze the ORIGINAL user request against what has been accomplished so far.\n\nORIGINAL REQUEST: \"{command}\"\n\nCompare this against the conversation history to determine if ALL parts of the request are complete.\n\nRespond with JSON:\n{{\n  \"status\": \"complete\" | \"continue\",\n  \"summary\": \"brief summary of current progress\",\n  \"next_action\": \"specific next command to execute (required if status is continue)\"\n}}\n\nRules:\n- Use \"continue\" if ANY part of the original request is incomplete\n- Use \"complete\" ONLY when every part of the request is fully done\n- When continuing, next_action must be a specific command, not a description\n- Execute ALL steps of the request autonomously without asking user\n\nExamples:\n- Request: \"open google and search for dogs\" → Opened Google → status: \"continue\", next_action: \"search for dogs\"\n- Request: \"navigate to github.com and take screenshot\" → Navigated → status: \"continue\", next_action: \"take screenshot\"  \n- Request: \"search for cars\" → Already searched and on results → status: \"complete\"\n\nDO NOT ask the user to continue - execute next steps autonomously.\"\"\"\n                    },\n                    *self.conversation_history\n                ],\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            try:\n                decision = json.loads(decision_response.choices[0].message.content or \"{}\")\n                status = decision.get(\"status\", \"complete\")\n                summary = decision.get(\"summary\", \"Task completed\")\n                next_action = decision.get(\"next_action\")\n                \n                logger.success(f\"Status: {status} - {summary}\")\n                \n                # Return result with continuation info and Playwright code\n                return {\n                    \"status\": status,\n                    \"summary\": summary,\n                    \"next_action\": next_action,\n                    \"should_continue\": status == \"continue\",\n                    \"playwright_code\": playwright_code\n                }\n            except:\n                # Fallback to simple summary\n                return {\n                    \"status\": \"complete\",\n                    \"summary\": \"Task completed\",\n                    \"should_continue\": False,\n                    \"playwright_code\": playwright_code\n                }\n        else:\n            # This should never happen with tool_choice=\"required\"\n            logger.warning(\"No tool calls executed (should not happen)\")\n            return {\n                \"status\": \"error\", \n                \"summary\": \"No actions executed\",\n                \"should_continue\": False,\n                \"playwright_code\": None\n            }\n    \n    def _generate_playwright_code(self, tool_execution_log: List[Dict[str, Any]], instruction: str) -> Optional[str]:\n        \"\"\"Generate Playwright Python code from successful tool executions.\n        \n        IMPORTANT: Uses ACTUAL WORKING SELECTORS from execution, not AI's initial guesses!\n        - If initial selector failed, the retry mechanism found the working one\n        - All selectors in this code are VERIFIED to work on the target page\n        \"\"\"\n        successful_steps = [step for step in tool_execution_log if step.get(\"success\")]\n        \n        if not successful_steps:\n            return None\n        \n        code_lines = [\n            \"# Generated Playwright code with VERIFIED WORKING SELECTORS\",\n            f\"# Original instruction: {instruction}\",\n            \"# NOTE: All selectors below were tested and confirmed working on the page\",\n            \"\",\n            \"from playwright.async_api import async_playwright\",\n            \"\",\n            \"async def run():\",\n            \"    async with async_playwright() as p:\",\n            \"        browser = await p.chromium.launch(headless=True)\",\n            \"        page = await browser.new_page()\",\n            \"\"\n        ]\n        \n        for step in successful_steps:\n            tool = step.get(\"tool\", \"\")\n            args = step.get(\"args\", {})\n            \n            if tool == \"browser_navigate\":\n                url = args.get(\"url\", \"\")\n                code_lines.append(f\"        # Navigate to {url}\")\n                code_lines.append(f\"        await page.goto('{url}')\")\n                \n            elif tool == \"browser_click\":\n                selector = args.get(\"selector\", \"\")\n                was_retry = step.get(\"retry\", False)\n                comment = \"Click element (working selector)\" if was_retry else \"Click element\"\n                code_lines.append(f\"        # {comment}\")\n                code_lines.append(f\"        await page.locator('{selector}').click()\")\n                \n            elif tool == \"browser_type\":\n                selector = args.get(\"selector\", \"\")\n                text = args.get(\"text\", \"\")\n                was_retry = step.get(\"retry\", False)\n                comment = \"Type text (working selector)\" if was_retry else \"Type text into element\"\n                code_lines.append(f\"        # {comment}\")\n                code_lines.append(f\"        await page.locator('{selector}').fill('{text}')\")\n                \n            elif tool == \"browser_fill_form\":\n                form_data = args.get(\"formData\", {})\n                code_lines.append(f\"        # Fill form\")\n                for field_selector, value in form_data.items():\n                    code_lines.append(f\"        await page.locator('{field_selector}').fill('{value}')\")\n                    \n            elif tool == \"browser_press_key\":\n                key = args.get(\"key\", \"\")\n                code_lines.append(f\"        # Press key: {key}\")\n                code_lines.append(f\"        await page.keyboard.press('{key}')\")\n                \n            elif tool == \"browser_take_screenshot\":\n                path = args.get(\"path\", \"screenshot.png\")\n                code_lines.append(f\"        # Take screenshot\")\n                code_lines.append(f\"        await page.screenshot(path='{path}')\")\n                \n            elif tool == \"browser_evaluate\":\n                script = args.get(\"script\", \"\")\n                code_lines.append(f\"        # Execute JavaScript\")\n                code_lines.append(f\"        result = await page.evaluate('''{script}''')\")\n                \n            elif tool == \"browser_wait_for\":\n                selector = args.get(\"selector\", \"\")\n                code_lines.append(f\"        # Wait for element\")\n                code_lines.append(f\"        await page.locator('{selector}').wait_for()\")\n                \n            elif tool == \"browser_select_option\":\n                selector = args.get(\"selector\", \"\")\n                value = args.get(\"value\", \"\")\n                code_lines.append(f\"        # Select dropdown option\")\n                code_lines.append(f\"        await page.locator('{selector}').select_option('{value}')\")\n                \n            elif tool == \"browser_hover\":\n                selector = args.get(\"selector\", \"\")\n                code_lines.append(f\"        # Hover over element\")\n                code_lines.append(f\"        await page.locator('{selector}').hover()\")\n            \n            code_lines.append(\"\")\n        \n        code_lines.extend([\n            \"        await browser.close()\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            \"    import asyncio\",\n            \"    asyncio.run(run())\"\n        ])\n        \n        return \"\\n\".join(code_lines)\n    \n    async def _recording_maintenance_loop(self):\n        \"\"\"Background task to keep recorder script injected and pull events frequently.\"\"\"\n        while self.recorder.is_recording:\n            try:\n                await self.recorder.maintain_recording(self.mcp)\n                await asyncio.sleep(0.2)  # Poll every 200ms to minimize cross-origin loss\n            except asyncio.CancelledError:\n                break\n            except Exception:\n                pass  # Continue even if injection fails\n    \n    def start_recording_maintenance(self):\n        \"\"\"Start background task to maintain recording across navigations.\"\"\"\n        if self._recording_task is None or self._recording_task.done():\n            self._recording_task = asyncio.create_task(self._recording_maintenance_loop())\n    \n    def stop_recording_maintenance(self):\n        \"\"\"Stop the recording maintenance background task.\"\"\"\n        if self._recording_task and not self._recording_task.done():\n            self._recording_task.cancel()\n            self._recording_task = None\n    \n    async def cleanup(self):\n        \"\"\"Clean up resources.\"\"\"\n        self.stop_recording_maintenance()\n        await self.mcp.close()\n        logger.info(\"MCP automation cleaned up successfully\")\n\n\nasync def main():\n    \"\"\"Main entry point for enhanced MCP automation.\"\"\"\n    from src.automation.config_loader import get_config\n    \n    # Load configuration from config.ini\n    config = get_config()\n    \n    # Get OpenAI API key from config\n    api_key = config.openai_api_key\n    if not api_key:\n        logger.error(\"OPENAI_API_KEY not set in config.ini or environment!\")\n        logger.error(\"Please set it in config.ini or as an environment variable\")\n        sys.exit(1)\n    \n    # Display configuration banner\n    print(\"\\n\" + \"=\"*70)\n    print(\"🚀 ENHANCED Playwright MCP Natural Language Automation\")\n    print(\"=\"*70)\n    print(\"\\nConfiguration:\")\n    print(f\"  • Config file: config.ini\")\n    print(f\"  • AI Model: {config.openai_model}\")\n    print(f\"  • Browser: {config.browser_type} (headless: {config.browser_headless})\")\n    print(f\"  • Vision: {'Enabled' if config.enable_vision else 'Disabled'}\")\n    print(f\"  • Screenshots: {config.screenshots_dir}/\")\n    print(f\"  • Max Retries: {config.max_retries}\")\n    print(\"\\nFeatures:\")\n    print(\"  ✓ Vision-based intelligent page analysis\")\n    print(\"  ✓ Smart error recovery with automatic retries\")\n    print(\"  ✓ Session memory learns from successful patterns\")\n    print(\"  ✓ Advanced web handling (forms, tables, iframes, dynamic content)\")\n    print(\"  ✓ Multi-strategy element detection\")\n    print(\"  ✓ Auto-refresh DOM context after navigation\")\n    print(\"  ✓ Autonomous multi-step execution without interruptions\")\n    print(f\"  ✓ Screenshots automatically saved to {config.screenshots_dir}/ folder\")\n    print(\"=\"*70)\n    \n    # Create automation instance with config settings\n    automation = EnhancedMCPAutomation(\n        api_key=api_key,\n        enable_vision=config.enable_vision,\n        max_retries=config.max_retries,\n        screenshots_dir=config.screenshots_dir\n    )\n    \n    try:\n        # Initialize MCP\n        logger.info(\"Initializing Enhanced Playwright MCP server...\")\n        await automation.initialize(\n            browser=config.browser_type,\n            headless=config.browser_headless\n        )\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"💡 POWERFUL AUTOMATION EXAMPLES:\")\n        print(\"=\"*70)\n        print(\"\\n🌐 Navigation & Search:\")\n        print(\"  • Go to google.com and search for Python tutorials\")\n        print(\"  • Navigate to news.ycombinator.com and get top 5 stories\")\n        print(\"  • Visit github.com and click on the trending repositories\")\n        \n        print(\"\\n📝 Forms & Data Entry:\")\n        print(\"  • Fill out the contact form with name John and email john@example.com\")\n        print(\"  • Search for apartments in New York on realtor.com\")\n        print(\"  • Login with username testuser and password testpass\")\n        \n        print(\"\\n📊 Data Extraction:\")\n        print(\"  • Extract all product names and prices from this page\")\n        print(\"  • Get all the article headlines from this news site\")\n        print(\"  • Scrape the table data and export it\")\n        \n        print(\"\\n🔧 Complex Tasks:\")\n        print(\"  • Take a screenshot of the current page\")\n        print(\"  • Click all 'Accept' buttons on this page\")\n        print(\"  • Navigate through the pagination and collect all items\")\n        \n        print(\"\\n\" + \"=\"*70)\n        print(\"Type 'quit', 'exit', or 'q' to stop.\\n\")\n        \n        # Interactive mode with autonomous continuation\n        while True:\n            try:\n                command = input(\"💬 Command: \").strip()\n                \n                if command.lower() in ['quit', 'exit', 'q']:\n                    print(\"\\n👋 Goodbye!\")\n                    break\n                \n                if not command:\n                    continue\n                \n                # Execute command and check if we should continue autonomously\n                while True:\n                    result = await automation.execute_command(command)\n                    \n                    # Handle result (could be string or dict)\n                    if isinstance(result, dict):\n                        summary = result.get(\"summary\", \"\")\n                        should_continue = result.get(\"should_continue\", False)\n                        next_action = result.get(\"next_action\")\n                        playwright_code = result.get(\"playwright_code\")\n                        \n                        # Show progress without interrupting\n                        if should_continue and next_action:\n                            print(f\"  ⚡ {summary}\")\n                            command = next_action  # Continue with next action\n                            await asyncio.sleep(0.5)  # Brief pause\n                        else:\n                            print(f\"\\n✅ {summary}\\n\")\n                            \n                            # Display generated Playwright code\n                            if playwright_code:\n                                print(\"=\" * 70)\n                                print(\"📝 GENERATED PLAYWRIGHT CODE (with working locators):\")\n                                print(\"=\" * 70)\n                                print(playwright_code)\n                                print(\"=\" * 70)\n                                print()\n                            \n                            break\n                    else:\n                        print(f\"\\n✅ {result}\\n\")\n                        break\n                \n            except KeyboardInterrupt:\n                print(\"\\n\\n👋 Interrupted. Goodbye!\")\n                break\n            except Exception as e:\n                logger.error(f\"Error: {e}\")\n                print(f\"\\n❌ Error: {e}\\n\")\n    \n    finally:\n        await automation.cleanup()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":44561},"mcp/src/automation/__init__.py":{"content":"from .browser_engine import BrowserEngine\nfrom .task_executor import TaskExecutor\nfrom .ai_generator import AITaskGenerator\nfrom .advanced_tools import AdvancedPlaywrightTools\nfrom .vision_analyzer import VisionPageAnalyzer\nfrom .mcp_client import PlaywrightMCPClient\nfrom .config_loader import ConfigLoader, get_config\n\ntry:\n    from openai import AsyncOpenAI\n    AI_AVAILABLE = True\nexcept ImportError:\n    AI_AVAILABLE = False\n\n__all__ = [\n    'BrowserEngine', \n    'TaskExecutor', \n    'AITaskGenerator', \n    'AdvancedPlaywrightTools',\n    'VisionPageAnalyzer',\n    'PlaywrightMCPClient',\n    'ConfigLoader',\n    'get_config',\n    'AI_AVAILABLE'\n]\n","size_bytes":653},"visionvault/services/multi_strategy_healer.py":{"content":"\"\"\"\nMulti-Strategy Parallel Healing\n\nThis module implements advanced healing that:\n1. Generates multiple fix strategies simultaneously\n2. Tests all strategies in parallel\n3. Automatically selects the best working solution\n4. Learns from successful strategies for future use\n\"\"\"\n\nimport asyncio\nfrom typing import Dict, List, Optional, Tuple\nfrom openai import OpenAI\nimport json\nimport os\n\n\nclass MultiStrategyHealer:\n    \"\"\"Advanced healing with parallel strategy execution\"\"\"\n    \n    def __init__(self, openai_client: Optional[OpenAI] = None):\n        self.client = openai_client\n        self.strategy_success_history = self._load_history()\n    \n    def _load_history(self) -> Dict:\n        \"\"\"Load history of successful strategies\"\"\"\n        history_file = 'data/strategy_history.json'\n        try:\n            if os.path.exists(history_file):\n                with open(history_file, 'r') as f:\n                    return json.load(f)\n        except Exception:\n            pass\n        return {}\n    \n    def _save_history(self):\n        \"\"\"Save strategy success history\"\"\"\n        try:\n            os.makedirs('data', exist_ok=True)\n            with open('data/strategy_history.json', 'w') as f:\n                json.dump(self.strategy_success_history, f, indent=2)\n        except Exception as e:\n            print(f\"⚠️  Could not save strategy history: {e}\")\n    \n    def generate_multiple_strategies(\n        self,\n        failed_code: str,\n        error_message: str,\n        failed_step: int,\n        page_content: str = ''\n    ) -> List[Dict]:\n        \"\"\"\n        Generate multiple different healing strategies in parallel.\n        Each strategy uses a different approach to fix the same issue.\n        \"\"\"\n        if not self.client:\n            return self._generate_fallback_strategies(failed_code, error_message)\n        \n        try:\n            # Identify the type of failure\n            failure_type = self._classify_error(error_message)\n            \n            # Generate multiple strategies using GPT-4o-mini\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at generating MULTIPLE different strategies to fix automation failures.\n\nYour task: Generate 3-4 DIFFERENT approaches to fix the same issue. Each strategy should use a fundamentally different technique.\n\nSTRATEGY TYPES TO CONSIDER:\n\n1. LOCATOR-BASED STRATEGY\n   - Use different locator types (role, text, placeholder, label, CSS, XPath)\n   - Try multiple selectors for redundancy\n   - Use chained locators or filters\n\n2. TIMING-BASED STRATEGY\n   - Add longer waits and timeouts\n   - Wait for specific states (load, networkidle, visible, attached)\n   - Add delays before interactions\n   - Wait for animations to complete\n\n3. NAVIGATION-BASED STRATEGY\n   - Scroll element into view\n   - Handle overlays/modals first\n   - Navigate through page differently\n   - Use keyboard navigation instead of clicks\n\n4. ROBUST-APPROACH STRATEGY\n   - Try multiple locators with fallback logic\n   - Add retry loops with exponential backoff\n   - Check element state before interaction\n   - Handle dynamic content explicitly\n\nFor each strategy, provide:\n1. Strategy name and type\n2. Confidence score (0-100)\n3. Complete fixed code for the failed step\n4. Explanation of why this approach should work\n\nReturn as JSON array:\n[\n  {\n    \"name\": \"Strategy name\",\n    \"type\": \"locator/timing/navigation/robust\",\n    \"confidence\": 85,\n    \"code\": \"Fixed code here\",\n    \"explanation\": \"Why this works\"\n  }\n]\n\nGenerate 3-4 diverse strategies that attack the problem from different angles.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed automation needs multiple fix strategies:\n\nFAILED STEP {failed_step}:\n```python\n{self._extract_failed_step_code(failed_code, failed_step)}\n```\n\nERROR:\n{error_message}\n\nPAGE CONTEXT:\n{page_content[:1000] if page_content else 'Not available'}\n\nGenerate 3-4 different strategies to fix this issue.\"\"\"}\n                ],\n                temperature=0.4,  # Slightly higher for diversity\n                response_format={\"type\": \"json_object\"}\n            )\n            \n            result = response.choices[0].message.content.strip()\n            strategies_data = json.loads(result)\n            \n            # Extract strategies array (handle both array and object responses)\n            if isinstance(strategies_data, dict) and 'strategies' in strategies_data:\n                strategies = strategies_data['strategies']\n            elif isinstance(strategies_data, list):\n                strategies = strategies_data\n            else:\n                strategies = [strategies_data]\n            \n            # Sort by confidence\n            strategies.sort(key=lambda x: x.get('confidence', 0), reverse=True)\n            \n            print(f\"\\n🎯 Generated {len(strategies)} healing strategies:\")\n            for i, strat in enumerate(strategies, 1):\n                print(f\"   {i}. {strat.get('name', 'Strategy')} ({strat.get('type', 'unknown')}) - Confidence: {strat.get('confidence', 0)}%\")\n            \n            return strategies\n        \n        except Exception as e:\n            print(f\"⚠️  Multi-strategy generation error: {e}\")\n            return self._generate_fallback_strategies(failed_code, error_message)\n    \n    def _classify_error(self, error_message: str) -> str:\n        \"\"\"Classify the type of error\"\"\"\n        error_lower = error_message.lower()\n        \n        if 'timeout' in error_lower or 'timed out' in error_lower:\n            return 'timeout'\n        elif 'not found' in error_lower or 'no element' in error_lower:\n            return 'element_not_found'\n        elif 'not visible' in error_lower or 'not attached' in error_lower:\n            return 'visibility'\n        elif 'not clickable' in error_lower or 'intercept' in error_lower:\n            return 'not_clickable'\n        else:\n            return 'unknown'\n    \n    def _extract_failed_step_code(self, code: str, step_num: int) -> str:\n        \"\"\"Extract just the failed step code\"\"\"\n        lines = code.split('\\n')\n        step_lines = []\n        in_step = False\n        \n        for line in lines:\n            if f'STEP {step_num}:' in line or f'Step {step_num}:' in line:\n                in_step = True\n            elif in_step and ('STEP' in line or 'Step' in line) and str(step_num) not in line:\n                break\n            \n            if in_step:\n                step_lines.append(line)\n        \n        return '\\n'.join(step_lines) if step_lines else code[:500]\n    \n    def _generate_fallback_strategies(self, failed_code: str, error_message: str) -> List[Dict]:\n        \"\"\"Generate basic strategies without AI\"\"\"\n        return [\n            {\n                'name': 'Extended Timeout',\n                'type': 'timing',\n                'confidence': 60,\n                'code': 'await element.click(timeout=15000)',\n                'explanation': 'Increase timeout to handle slow loading'\n            },\n            {\n                'name': 'Wait for Visible',\n                'type': 'timing',\n                'confidence': 55,\n                'code': 'await element.wait_for(state=\"visible\", timeout=10000)\\nawait element.click()',\n                'explanation': 'Explicitly wait for element visibility'\n            },\n            {\n                'name': 'Scroll Into View',\n                'type': 'navigation',\n                'confidence': 50,\n                'code': 'await element.scroll_into_view_if_needed()\\nawait element.click()',\n                'explanation': 'Ensure element is in viewport'\n            }\n        ]\n    \n    async def test_strategy(\n        self,\n        strategy: Dict,\n        full_code: str,\n        failed_step: int,\n        executor_function\n    ) -> Tuple[bool, Dict, str]:\n        \"\"\"\n        Test a single strategy by executing it.\n        Returns: (success, result, strategy_name)\n        \"\"\"\n        strategy_name = strategy.get('name', 'Unknown')\n        \n        try:\n            print(f\"   🧪 Testing: {strategy_name}...\")\n            \n            # Apply the strategy to the code\n            healed_code = self._apply_strategy(full_code, failed_step, strategy)\n            \n            # Execute the healed code\n            result = await executor_function(healed_code)\n            \n            success = result.get('success', False)\n            \n            if success:\n                print(f\"   ✅ {strategy_name} SUCCEEDED!\")\n                # Record success\n                self._record_success(strategy)\n            else:\n                print(f\"   ❌ {strategy_name} failed\")\n            \n            return (success, result, strategy_name)\n        \n        except Exception as e:\n            print(f\"   ❌ {strategy_name} error: {e}\")\n            return (False, {'success': False, 'error': str(e)}, strategy_name)\n    \n    def _apply_strategy(self, full_code: str, failed_step: int, strategy: Dict) -> str:\n        \"\"\"Apply a strategy to the code\"\"\"\n        # Find and replace the failed step with the strategy's code\n        lines = full_code.split('\\n')\n        new_lines = []\n        in_failed_step = False\n        step_replaced = False\n        \n        for line in lines:\n            # Check if we're at the failed step\n            if f'STEP {failed_step}:' in line or f'Step {failed_step}:' in line:\n                in_failed_step = True\n                new_lines.append(line)  # Keep the comment\n                # Add the strategy code\n                strategy_code = strategy.get('code', '')\n                for strategy_line in strategy_code.split('\\n'):\n                    new_lines.append(' ' * 12 + strategy_line)  # Proper indentation\n                step_replaced = True\n                continue\n            \n            # Skip original failed step code\n            if in_failed_step:\n                # Check if we've moved to next step\n                if ('STEP' in line or 'Step' in line) and str(failed_step) not in line:\n                    in_failed_step = False\n                    new_lines.append(line)\n                elif not line.strip().startswith('#'):\n                    # Skip the original failed code\n                    continue\n                else:\n                    new_lines.append(line)\n            else:\n                new_lines.append(line)\n        \n        if not step_replaced:\n            # Fallback: just append strategy at the end\n            return full_code + '\\n' + strategy.get('code', '')\n        \n        return '\\n'.join(new_lines)\n    \n    def _record_success(self, strategy: Dict):\n        \"\"\"Record a successful strategy\"\"\"\n        strategy_type = strategy.get('type', 'unknown')\n        \n        if strategy_type not in self.strategy_success_history:\n            self.strategy_success_history[strategy_type] = {\n                'total_attempts': 0,\n                'successes': 0,\n                'success_rate': 0.0\n            }\n        \n        self.strategy_success_history[strategy_type]['total_attempts'] += 1\n        self.strategy_success_history[strategy_type]['successes'] += 1\n        self.strategy_success_history[strategy_type]['success_rate'] = (\n            self.strategy_success_history[strategy_type]['successes'] /\n            self.strategy_success_history[strategy_type]['total_attempts'] * 100\n        )\n        \n        self._save_history()\n    \n    async def heal_with_parallel_strategies(\n        self,\n        failed_code: str,\n        error_message: str,\n        failed_step: int,\n        page_content: str,\n        executor_function\n    ) -> Dict:\n        \"\"\"\n        Main healing function: Generate and test multiple strategies in parallel.\n        Returns the best working solution.\n        \"\"\"\n        print(f\"\\n🚀 Multi-Strategy Parallel Healing...\")\n        \n        # Generate multiple strategies\n        strategies = self.generate_multiple_strategies(\n            failed_code,\n            error_message,\n            failed_step,\n            page_content\n        )\n        \n        if not strategies:\n            return {\n                'success': False,\n                'error': 'No strategies generated'\n            }\n        \n        # Test strategies in parallel\n        print(f\"\\n🧪 Testing {len(strategies)} strategies in parallel...\")\n        \n        tasks = [\n            self.test_strategy(strategy, failed_code, failed_step, executor_function)\n            for strategy in strategies\n        ]\n        \n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Find the first successful strategy\n        for success, result, strategy_name in results:\n            if isinstance((success, result, strategy_name), Exception):\n                continue\n            \n            if success:\n                print(f\"\\n✅ SUCCESS! {strategy_name} worked!\")\n                return {\n                    'success': True,\n                    'healed_code': result.get('healed_code'),\n                    'strategy_used': strategy_name,\n                    'result': result\n                }\n        \n        # If no strategy worked, return the result from the highest confidence strategy\n        print(f\"\\n❌ All strategies failed. Using highest confidence attempt.\")\n        if results and not isinstance(results[0], Exception):\n            _, result, strategy_name = results[0]\n            return {\n                'success': False,\n                'attempted_strategies': len(strategies),\n                'best_strategy': strategy_name,\n                'result': result\n            }\n        \n        return {\n            'success': False,\n            'error': 'All strategies failed'\n        }\n","size_bytes":13750},"mcp/src/automation/config.py":{"content":"from dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Dict, Any\nimport os\n\n\nclass BrowserType(Enum):\n    CHROMIUM = \"chromium\"\n    FIREFOX = \"firefox\"\n    WEBKIT = \"webkit\"\n\n\nclass SelectorStrategy(Enum):\n    CSS = \"css\"\n    XPATH = \"xpath\"\n    TEXT = \"text\"\n    ARIA = \"aria\"\n    AUTO = \"auto\"\n\n\n@dataclass\nclass BrowserConfig:\n    browser_type: BrowserType = BrowserType.CHROMIUM\n    headless: bool = True\n    timeout: int = 30000\n    viewport_width: int = 1920\n    viewport_height: int = 1080\n    user_agent: Optional[str] = None\n    locale: str = \"en-US\"\n    timezone: str = \"America/New_York\"\n    \n    screenshot_on_error: bool = True\n    video_recording: bool = False\n    trace_recording: bool = False\n    \n    slow_mo: int = 0\n    \n    proxy: Optional[Dict[str, str]] = None\n    \n    ignore_https_errors: bool = True\n    \n    downloads_path: Optional[str] = None\n\n\n@dataclass\nclass AutomationConfig:\n    max_retries: int = 3\n    retry_delay: int = 2\n    wait_strategy: str = \"networkidle\"\n    \n    screenshot_dir: str = \"screenshots\"\n    video_dir: str = \"videos\"\n    session_dir: str = \"sessions\"\n    \n    log_level: str = \"INFO\"\n    log_file: Optional[str] = \"automation.log\"\n    \n    save_session: bool = False\n    session_name: str = \"default\"\n    \n    openai_model: str = \"gpt-4o-mini\"\n    mcp_timeout: int = 300\n\n\ndef load_config_from_env() -> Dict[str, Any]:\n    return {\n        \"browser_type\": BrowserType(os.getenv(\"BROWSER_TYPE\", \"chromium\")),\n        \"headless\": os.getenv(\"HEADLESS\", \"true\").lower() == \"true\",\n        \"timeout\": int(os.getenv(\"TIMEOUT\", \"30000\")),\n        \"max_retries\": int(os.getenv(\"MAX_RETRIES\", \"3\")),\n        \"log_level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),\n    }\n","size_bytes":1735},"visionvault/services/self_learning_engine.py":{"content":"\"\"\"\nSelf-Learning Engine\n\nThis module enables the system to:\n1. Learn from successful executions and failures\n2. Build a knowledge base of working patterns\n3. Adapt strategies based on past performance\n4. Predict success probability for new commands\n5. Continuously improve over time\n\"\"\"\n\nimport json\nimport os\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport hashlib\n\n\nclass SelfLearningEngine:\n    \"\"\"AI system that learns from experience and improves over time\"\"\"\n    \n    def __init__(self, knowledge_file='data/learned_knowledge.json'):\n        self.knowledge_file = knowledge_file\n        self.knowledge_base = self._load_knowledge()\n        self.session_learnings = []\n    \n    def _load_knowledge(self) -> Dict:\n        \"\"\"Load accumulated knowledge from disk\"\"\"\n        try:\n            if os.path.exists(self.knowledge_file):\n                with open(self.knowledge_file, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            print(f\"⚠️  Could not load knowledge base: {e}\")\n        \n        return {\n            'successful_patterns': {},  # Patterns that consistently work\n            'failure_patterns': {},      # Patterns that consistently fail\n            'locator_success_rates': {}, # Success rate per locator type\n            'website_patterns': {},      # Learned patterns per website\n            'command_patterns': {},      # Common command structures\n            'strategy_performance': {},  # MCP vs CodeGen performance by task type\n            'total_executions': 0,\n            'total_successes': 0,\n            'total_failures': 0,\n            'success_rate': 0.0\n        }\n    \n    def _save_knowledge(self):\n        \"\"\"Persist knowledge to disk\"\"\"\n        try:\n            os.makedirs(os.path.dirname(self.knowledge_file), exist_ok=True)\n            \n            # Update success rate\n            if self.knowledge_base['total_executions'] > 0:\n                self.knowledge_base['success_rate'] = (\n                    self.knowledge_base['total_successes'] / \n                    self.knowledge_base['total_executions'] * 100\n                )\n            \n            with open(self.knowledge_file, 'w') as f:\n                json.dump(self.knowledge_base, f, indent=2)\n        except Exception as e:\n            print(f\"⚠️  Could not save knowledge base: {e}\")\n    \n    def learn_from_execution(\n        self,\n        command: str,\n        code: str,\n        result: Dict,\n        healing_attempts: int = 0,\n        url: str = ''\n    ):\n        \"\"\"Learn from a completed execution (successful or failed)\"\"\"\n        \n        success = result.get('success', False)\n        \n        # Update global stats\n        self.knowledge_base['total_executions'] += 1\n        if success:\n            self.knowledge_base['total_successes'] += 1\n        else:\n            self.knowledge_base['total_failures'] += 1\n        \n        # Extract patterns\n        command_pattern = self._extract_command_pattern(command)\n        locators_used = self._extract_locators(code)\n        website = self._extract_website(url or code)\n        \n        # Learn command patterns\n        if command_pattern not in self.knowledge_base['command_patterns']:\n            self.knowledge_base['command_patterns'][command_pattern] = {\n                'total': 0,\n                'successes': 0,\n                'avg_healing_attempts': 0.0,\n                'best_locators': []\n            }\n        \n        pattern_data = self.knowledge_base['command_patterns'][command_pattern]\n        pattern_data['total'] += 1\n        if success:\n            pattern_data['successes'] += 1\n        \n        # Update average healing attempts\n        pattern_data['avg_healing_attempts'] = (\n            (pattern_data['avg_healing_attempts'] * (pattern_data['total'] - 1) + healing_attempts) /\n            pattern_data['total']\n        )\n        \n        # Learn locator success rates\n        for locator_type in locators_used:\n            if locator_type not in self.knowledge_base['locator_success_rates']:\n                self.knowledge_base['locator_success_rates'][locator_type] = {\n                    'total': 0,\n                    'successes': 0,\n                    'success_rate': 0.0\n                }\n            \n            loc_data = self.knowledge_base['locator_success_rates'][locator_type]\n            loc_data['total'] += 1\n            if success:\n                loc_data['successes'] += 1\n            loc_data['success_rate'] = (loc_data['successes'] / loc_data['total'] * 100)\n            \n            # Track best locators for this command pattern\n            if success and locator_type not in pattern_data['best_locators']:\n                pattern_data['best_locators'].append(locator_type)\n        \n        # Learn website-specific patterns\n        if website:\n            if website not in self.knowledge_base['website_patterns']:\n                self.knowledge_base['website_patterns'][website] = {\n                    'total_visits': 0,\n                    'successful_locators': [],\n                    'common_issues': [],\n                    'best_practices': []\n                }\n            \n            site_data = self.knowledge_base['website_patterns'][website]\n            site_data['total_visits'] += 1\n            \n            if success:\n                for loc in locators_used:\n                    if loc not in site_data['successful_locators']:\n                        site_data['successful_locators'].append(loc)\n        \n        # Record session learning\n        self.session_learnings.append({\n            'command': command,\n            'success': success,\n            'healing_attempts': healing_attempts,\n            'timestamp': datetime.now().isoformat()\n        })\n        \n        # Save knowledge\n        self._save_knowledge()\n        \n        print(f\"📚 Learning recorded: {command_pattern} ({'✅ Success' if success else '❌ Failed'})\")\n    \n    def _extract_command_pattern(self, command: str) -> str:\n        \"\"\"Extract high-level pattern from command\"\"\"\n        command_lower = command.lower()\n        \n        patterns = {\n            'search': ['search', 'find', 'look for', 'query'],\n            'login': ['login', 'sign in', 'log in', 'authenticate'],\n            'form_fill': ['fill', 'enter', 'type', 'input'],\n            'navigation': ['go to', 'navigate', 'open', 'visit'],\n            'click': ['click', 'press', 'select', 'choose'],\n            'purchase': ['buy', 'purchase', 'order', 'checkout'],\n            'extract': ['get', 'extract', 'scrape', 'collect']\n        }\n        \n        for pattern, keywords in patterns.items():\n            if any(kw in command_lower for kw in keywords):\n                return pattern\n        \n        return 'general'\n    \n    def _extract_locators(self, code: str) -> List[str]:\n        \"\"\"Extract locator types used in code\"\"\"\n        locators = []\n        \n        locator_patterns = {\n            'get_by_test_id': 'testid',\n            'get_by_role': 'role',\n            'get_by_text': 'text',\n            'get_by_placeholder': 'placeholder',\n            'get_by_label': 'label',\n            'get_by_alt_text': 'alt',\n            'get_by_title': 'title',\n            'page.locator': 'css_selector'\n        }\n        \n        for pattern, loc_type in locator_patterns.items():\n            if pattern in code:\n                locators.append(loc_type)\n        \n        return list(set(locators))  # Unique locators\n    \n    def _extract_website(self, url_or_code: str) -> str:\n        \"\"\"Extract website domain\"\"\"\n        import re\n        \n        # Try to find URL in string\n        url_pattern = r'https?://(?:www\\.)?([^/\\s]+)'\n        match = re.search(url_pattern, url_or_code)\n        \n        if match:\n            domain = match.group(1)\n            # Remove common subdomains\n            domain = domain.replace('www.', '')\n            return domain\n        \n        return ''\n    \n    def get_recommendations(self, command: str, url: str = '') -> Dict:\n        \"\"\"Get learned recommendations for a command\"\"\"\n        \n        pattern = self._extract_command_pattern(command)\n        website = self._extract_website(url)\n        \n        recommendations = {\n            'predicted_success_rate': self.knowledge_base.get('success_rate', 70.0),\n            'recommended_locators': [],\n            'potential_issues': [],\n            'best_practices': [],\n            'confidence': 70.0\n        }\n        \n        # Get command pattern recommendations\n        if pattern in self.knowledge_base['command_patterns']:\n            pattern_data = self.knowledge_base['command_patterns'][pattern]\n            \n            if pattern_data['total'] > 0:\n                pattern_success_rate = (pattern_data['successes'] / pattern_data['total'] * 100)\n                recommendations['predicted_success_rate'] = pattern_success_rate\n                recommendations['recommended_locators'] = pattern_data['best_locators']\n                recommendations['confidence'] = min(90, 50 + pattern_data['total'] * 5)\n        \n        # Get website-specific recommendations\n        if website and website in self.knowledge_base['website_patterns']:\n            site_data = self.knowledge_base['website_patterns'][website]\n            recommendations['recommended_locators'].extend(site_data['successful_locators'])\n            recommendations['potential_issues'] = site_data.get('common_issues', [])\n            recommendations['best_practices'] = site_data.get('best_practices', [])\n        \n        # Get best performing locators overall\n        best_locators = sorted(\n            self.knowledge_base['locator_success_rates'].items(),\n            key=lambda x: x[1]['success_rate'],\n            reverse=True\n        )[:3]\n        \n        for loc_type, data in best_locators:\n            if loc_type not in recommendations['recommended_locators']:\n                recommendations['recommended_locators'].append(loc_type)\n        \n        return recommendations\n    \n    def get_learning_stats(self) -> Dict:\n        \"\"\"Get learning statistics\"\"\"\n        return {\n            'total_executions': self.knowledge_base['total_executions'],\n            'overall_success_rate': self.knowledge_base['success_rate'],\n            'patterns_learned': len(self.knowledge_base['command_patterns']),\n            'websites_learned': len(self.knowledge_base['website_patterns']),\n            'locator_types_tracked': len(self.knowledge_base['locator_success_rates']),\n            'best_locators': self._get_best_locators(3),\n            'session_learnings': len(self.session_learnings)\n        }\n    \n    def _get_best_locators(self, top_n: int = 3) -> List[Dict]:\n        \"\"\"Get top N best performing locators\"\"\"\n        locators = [\n            {\n                'type': loc_type,\n                'success_rate': data['success_rate'],\n                'total_uses': data['total']\n            }\n            for loc_type, data in self.knowledge_base['locator_success_rates'].items()\n            if data['total'] >= 3  # Minimum 3 uses for statistical significance\n        ]\n        \n        # Sort by success rate, then by total uses\n        locators.sort(key=lambda x: (x['success_rate'], x['total_uses']), reverse=True)\n        \n        return locators[:top_n]\n    \n    def learn_strategy_outcome(\n        self,\n        command: str,\n        strategy: str,  # 'mcp_direct' or 'code_gen'\n        complexity: str,  # 'simple', 'moderate', 'complex', 'advanced'\n        success: bool,\n        attempts: int = 1\n    ):\n        \"\"\"Learn which strategy worked best for a given task type\"\"\"\n        \n        pattern = self._extract_command_pattern(command)\n        \n        # Initialize strategy tracking for this pattern\n        if pattern not in self.knowledge_base['strategy_performance']:\n            self.knowledge_base['strategy_performance'][pattern] = {\n                'mcp_direct': {'total': 0, 'successes': 0, 'avg_attempts': 0.0},\n                'code_gen': {'total': 0, 'successes': 0, 'avg_attempts': 0.0},\n                'by_complexity': {\n                    'simple': {'mcp_direct': 0, 'code_gen': 0},\n                    'moderate': {'mcp_direct': 0, 'code_gen': 0},\n                    'complex': {'mcp_direct': 0, 'code_gen': 0},\n                    'advanced': {'mcp_direct': 0, 'code_gen': 0}\n                }\n            }\n        \n        strategy_data = self.knowledge_base['strategy_performance'][pattern]\n        \n        # Update strategy stats\n        if strategy in strategy_data:\n            strategy_data[strategy]['total'] += 1\n            if success:\n                strategy_data[strategy]['successes'] += 1\n            \n            # Update average attempts\n            total = strategy_data[strategy]['total']\n            strategy_data[strategy]['avg_attempts'] = (\n                (strategy_data[strategy]['avg_attempts'] * (total - 1) + attempts) / total\n            )\n            \n            # Track by complexity\n            if complexity in strategy_data['by_complexity']:\n                strategy_data['by_complexity'][complexity][strategy] += (1 if success else 0)\n        \n        self._save_knowledge()\n        \n        success_str = '✅' if success else '❌'\n        print(f\"📈 Strategy learned: {pattern} + {strategy} + {complexity} = {success_str}\")\n    \n    def recommend_strategy(self, command: str, complexity: str) -> Dict:\n        \"\"\"Recommend best strategy based on historical performance\"\"\"\n        \n        pattern = self._extract_command_pattern(command)\n        \n        recommendation = {\n            'recommended_strategy': 'mcp_direct',  # Default to MCP\n            'confidence': 50.0,\n            'reasoning': [],\n            'mcp_success_rate': 0.0,\n            'codegen_success_rate': 0.0\n        }\n        \n        # Check if we have learned data for this pattern\n        if pattern in self.knowledge_base['strategy_performance']:\n            strategy_data = self.knowledge_base['strategy_performance'][pattern]\n            \n            # Calculate success rates\n            for strategy in ['mcp_direct', 'code_gen']:\n                if strategy_data[strategy]['total'] > 0:\n                    rate = (strategy_data[strategy]['successes'] / \n                           strategy_data[strategy]['total'] * 100)\n                    \n                    if strategy == 'mcp_direct':\n                        recommendation['mcp_success_rate'] = rate\n                    else:\n                        recommendation['codegen_success_rate'] = rate\n            \n            # Check complexity-specific performance\n            if complexity in strategy_data['by_complexity']:\n                complexity_data = strategy_data['by_complexity'][complexity]\n                mcp_score = complexity_data.get('mcp_direct', 0)\n                codegen_score = complexity_data.get('code_gen', 0)\n                \n                if mcp_score + codegen_score > 0:\n                    # Choose strategy with better performance for this complexity\n                    if codegen_score > mcp_score:\n                        recommendation['recommended_strategy'] = 'code_gen'\n                        recommendation['reasoning'].append(\n                            f\"Code generation has {codegen_score} successes vs {mcp_score} for {complexity} tasks\"\n                        )\n                    else:\n                        recommendation['reasoning'].append(\n                            f\"MCP has {mcp_score} successes vs {codegen_score} for {complexity} tasks\"\n                        )\n                    \n                    # Confidence based on sample size\n                    total_samples = mcp_score + codegen_score\n                    recommendation['confidence'] = min(95, 50 + total_samples * 10)\n        \n        # Add general reasoning\n        if not recommendation['reasoning']:\n            if complexity == 'simple':\n                recommendation['reasoning'].append(\"MCP is faster for simple tasks\")\n            elif complexity in ['complex', 'advanced']:\n                recommendation['recommended_strategy'] = 'code_gen'\n                recommendation['reasoning'].append(\"Code generation provides better control for complex tasks\")\n        \n        return recommendation\n","size_bytes":16296},"mcp/src/automation/logger.py":{"content":"import logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\nfrom rich.console import Console\nfrom rich.logging import RichHandler\nfrom rich.theme import Theme\n\n\ncustom_theme = Theme({\n    \"info\": \"cyan\",\n    \"warning\": \"yellow\",\n    \"error\": \"red bold\",\n    \"success\": \"green bold\",\n})\n\nconsole = Console(theme=custom_theme)\n\n\nclass AutomationLogger:\n    def __init__(self, name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(getattr(logging, log_level.upper()))\n        \n        if not self.logger.handlers:\n            console_handler = RichHandler(\n                console=console,\n                rich_tracebacks=True,\n                tracebacks_show_locals=True,\n                show_time=True,\n                show_path=True\n            )\n            console_handler.setLevel(getattr(logging, log_level.upper()))\n            self.logger.addHandler(console_handler)\n            \n            if log_file:\n                log_path = Path(log_file)\n                log_path.parent.mkdir(parents=True, exist_ok=True)\n                file_handler = logging.FileHandler(log_file)\n                file_handler.setLevel(logging.DEBUG)\n                formatter = logging.Formatter(\n                    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n                )\n                file_handler.setFormatter(formatter)\n                self.logger.addHandler(file_handler)\n    \n    def info(self, message: str):\n        self.logger.info(message)\n    \n    def success(self, message: str):\n        console.print(f\"✅ {message}\", style=\"success\")\n        self.logger.info(message)\n    \n    def warning(self, message: str):\n        self.logger.warning(message)\n    \n    def error(self, message: str):\n        self.logger.error(message)\n    \n    def debug(self, message: str):\n        self.logger.debug(message)\n    \n    def exception(self, message: str):\n        self.logger.exception(message)\n\n\ndef get_logger(name: str = \"automation\", log_level: str = \"INFO\", log_file: Optional[str] = None) -> AutomationLogger:\n    return AutomationLogger(name, log_level, log_file)\n","size_bytes":2198},"visionvault/services/healing_executor.py":{"content":"import asyncio\nimport json\nimport re\nfrom visionvault.services.code_validator import CodeValidator\nfrom openai import OpenAI\nimport os\nfrom gevent.event import AsyncResult\nimport gevent\n\n# Import advanced locator validator\ntry:\n    from visionvault.services.advanced_locator_validator import AdvancedLocatorValidator\n    ADVANCED_VALIDATOR_AVAILABLE = True\nexcept ImportError:\n    ADVANCED_VALIDATOR_AVAILABLE = False\n    print(\"⚠️  Advanced locator validator not available\")\n\n# Import multi-strategy healer\ntry:\n    from visionvault.services.multi_strategy_healer import MultiStrategyHealer\n    MULTI_STRATEGY_HEALER_AVAILABLE = True\nexcept ImportError:\n    MULTI_STRATEGY_HEALER_AVAILABLE = False\n    print(\"⚠️  Multi-strategy healer not available\")\n\nclass HealingExecutor:\n    def __init__(self, socketio, api_key=None, use_gpt4o=False, mcp_manager=None):\n        self.socketio = socketio\n        # Use provided API key or fallback to environment variable\n        openai_key = api_key or os.environ.get('OPENAI_API_KEY')\n        self.client = OpenAI(api_key=openai_key) if openai_key else None\n        self.healed_script = None\n        self.failed_locators = []\n        self.retry_count = 0\n        self.max_retries = 2  # AI healing attempts before manual intervention\n        self.user_selector_event = None\n        self.user_selected_selector = None\n        self.execution_mode = 'server'  # 'server' or 'agent'\n        self.agent_result = None\n        self.agent_result_event = None\n        self.agent_sid = None  # Agent session ID for targeted emits\n        \n        # GPT-4o usage is DECOUPLED from validator availability\n        # Always use GPT-4o for better accuracy (not conditional)\n        self.use_gpt4o = use_gpt4o\n        \n        # Advanced validator is OPTIONAL and independent of GPT-4o\n        self.use_advanced_validator = ADVANCED_VALIDATOR_AVAILABLE\n        self.advanced_validator = None  # Will be initialized when page is available\n        \n        # Multi-strategy healer is OPTIONAL and independent of GPT-4o\n        self.use_multi_strategy = MULTI_STRATEGY_HEALER_AVAILABLE\n        if self.use_multi_strategy and self.client:\n            self.multi_strategy_healer = MultiStrategyHealer(openai_client=self.client)\n        else:\n            self.multi_strategy_healer = None\n        \n        # MCP-based healing (NEW!)\n        self.mcp_manager = mcp_manager\n        self.use_mcp_healing = mcp_manager is not None\n        \n        # AI healing request tracking (set by handle_ai_healing_request)\n        self.ai_healing_requested = False\n        self.error_context = None\n        \n        # Log configuration\n        features = []\n        if self.use_gpt4o:\n            features.append(\"GPT-4o\")\n        if self.use_advanced_validator:\n            features.append(\"Advanced Validator\")\n        if self.use_multi_strategy:\n            features.append(\"Multi-Strategy Healing\")\n        if self.use_mcp_healing:\n            features.append(\"MCP-Based Healing\")\n        \n        features_str = \" + \".join(features) if features else \"GPT-4o-mini\"\n        print(f\"✅ Enhanced AI healing enabled ({features_str} + 2 attempts)\")\n        \n    def parse_code_steps(self, code):\n        \"\"\"Parse code to extract individual steps with their line numbers.\"\"\"\n        steps = []\n        lines = code.split('\\n')\n        current_step = None\n        current_step_lines = []\n        \n        for i, line in enumerate(lines):\n            # Check for STEP comment markers\n            if '# STEP' in line and ':' in line:\n                # Save previous step if exists\n                if current_step is not None and current_step_lines:\n                    steps.append({\n                        'step_num': current_step,\n                        'lines': current_step_lines.copy(),\n                        'start_line': current_step_lines[0][0] if current_step_lines else i,\n                        'end_line': current_step_lines[-1][0] if current_step_lines else i\n                    })\n                \n                # Extract step number\n                try:\n                    step_match = re.search(r'STEP\\s+(\\d+)', line)\n                    if step_match:\n                        current_step = int(step_match.group(1))\n                        current_step_lines = [(i, line)]\n                except:\n                    pass\n            elif current_step is not None:\n                # Add line to current step\n                current_step_lines.append((i, line))\n        \n        # Save last step\n        if current_step is not None and current_step_lines:\n            steps.append({\n                'step_num': current_step,\n                'lines': current_step_lines.copy(),\n                'start_line': current_step_lines[0][0],\n                'end_line': current_step_lines[-1][0]\n            })\n        \n        return steps\n    \n    def extract_page_locators(self, page_html, max_length=3000):\n        \"\"\"Extract available locators from page HTML for AI analysis.\"\"\"\n        import re\n        \n        # Extract elements with useful locator attributes\n        locators = []\n        \n        # Find elements with data-testid\n        test_ids = re.findall(r'data-testid=\"([^\"]+)\"', page_html)\n        for tid in test_ids[:10]:  # Limit to 10\n            locators.append(f\"get_by_test_id('{tid}')\")\n        \n        # Find elements with placeholder\n        placeholders = re.findall(r'placeholder=\"([^\"]+)\"', page_html)\n        for ph in placeholders[:10]:\n            locators.append(f\"get_by_placeholder('{ph}')\")\n        \n        # Find elements with aria-label\n        aria_labels = re.findall(r'aria-label=\"([^\"]+)\"', page_html)\n        for al in aria_labels[:10]:\n            locators.append(f\"get_by_label('{al}')\")\n        \n        # Find buttons with text\n        button_texts = re.findall(r'<button[^>]*>([^<]+)</button>', page_html)\n        for bt in button_texts[:10]:\n            if bt.strip():\n                locators.append(f\"get_by_role('button', name='{bt.strip()}')\")\n        \n        # Find links with text\n        link_texts = re.findall(r'<a[^>]*>([^<]+)</a>', page_html)\n        for lt in link_texts[:10]:\n            if lt.strip() and len(lt.strip()) > 2:\n                locators.append(f\"get_by_role('link', name='{lt.strip()}')\")\n        \n        # Find input fields with name or id\n        input_names = re.findall(r'<input[^>]*(?:name|id)=\"([^\"]+)\"[^>]*>', page_html)\n        for inp in input_names[:10]:\n            locators.append(f\"get_by_role('textbox', name='{inp}')\")\n        \n        return locators[:30]  # Return top 30 locators\n    \n    def regenerate_failed_step_only(self, original_code, error_message, failed_step=0, attempt_num=1, page_context=''):\n        \"\"\"Use AI to regenerate ONLY the failed step, preserving successful ones.\"\"\"\n        if not self.client or failed_step == 0:\n            return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n        \n        try:\n            print(f\"\\n🎯 STEP-BY-STEP HEALING (Attempt {attempt_num}/3)\")\n            print(f\"   Targeting STEP {failed_step} only\")\n            print(f\"   Preserving all successful steps\")\n            \n            # Parse code to find the failed step\n            steps = self.parse_code_steps(original_code)\n            failed_step_content = None\n            \n            for step in steps:\n                if step['step_num'] == failed_step:\n                    failed_step_content = '\\n'.join([line[1] for line in step['lines']])\n                    break\n            \n            if not failed_step_content:\n                print(f\"⚠️ Could not isolate step {failed_step}, falling back to full regeneration\")\n                return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n            \n            # Extract available locators from page if context provided\n            available_locators = []\n            if page_context:\n                available_locators = self.extract_page_locators(page_context)\n                print(f\"   📊 Found {len(available_locators)} available locators on page\")\n            \n            locators_hint = \"\"\n            if available_locators:\n                locators_hint = f\"\"\"\n\nAVAILABLE LOCATORS ON PAGE (use these if they match your target):\n{chr(10).join([f\"- {loc}\" for loc in available_locators[:15]])}\"\"\"\n            \n            # ALWAYS use GPT-4o for better accuracy (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at fixing specific Playwright automation steps by analyzing the actual page.\n\nYour job is to fix ONLY the failed step while preserving all other steps exactly as they are.\n\nCRITICAL RULES:\n1. Analyze the available locators from the page and choose the best match\n2. Return ONLY the fixed code for the specific step mentioned\n3. Use better locators (get_by_role, get_by_text, get_by_placeholder, get_by_label, etc.)\n4. Add explicit timeouts (10000ms) to all operations for reliability\n5. Add proper wait strategies (wait_for_load_state, wait_for_selector with visible state)\n6. Maintain the step number and structure\n7. Keep the same log messages format\n8. Return ONLY the replacement code lines, nothing else\n\nLOCATOR PRIORITY (prefer in this order):\n1. get_by_test_id (most reliable - 99% success rate)\n2. get_by_role with exact name (accessibility-first - 95% success rate)\n3. get_by_placeholder with exact match (for inputs - 90% success rate)\n4. get_by_label (for form fields - 85% success rate)\n5. get_by_text with exact match (for unique text - 80% success rate)\n6. CSS selectors with IDs (last resort - 70% success rate)\n\nBEST PRACTICES:\n- Always add .wait_for(state='visible', timeout=10000) before interacting\n- Use exact=True for text/name matches when possible\n- Combine multiple strategies (e.g., role + filter by text)\n- Add error handling for dynamic content\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"This specific step failed during execution:\n\nFAILED STEP {failed_step}:\n```python\n{failed_step_content}\n```\n\nError: {error_message}{locators_hint}\n\nAnalyze the available locators above and generate ONLY the fixed code for STEP {failed_step}. Include:\n1. The # STEP {failed_step}: comment\n2. The current_step = {failed_step} line\n3. The fixed Playwright operations with better locators from the page\n4. The success log message\n\nReturn only the replacement code for this step:\"\"\"}\n                ],\n                temperature=0.3,\n                max_tokens=1000\n            )\n            \n            fixed_step = response.choices[0].message.content.strip()\n            \n            # Clean up formatting\n            if fixed_step.startswith('```'):\n                lines = fixed_step.split('\\n')\n                fixed_step = '\\n'.join(lines[1:-1] if lines[-1].startswith('```') else lines[1:])\n            \n            # Replace the failed step in the original code\n            lines = original_code.split('\\n')\n            for step in steps:\n                if step['step_num'] == failed_step:\n                    # Replace lines\n                    start = step['start_line']\n                    end = step['end_line'] + 1\n                    fixed_lines = fixed_step.split('\\n')\n                    lines[start:end] = fixed_lines\n                    break\n            \n            improved_code = '\\n'.join(lines)\n            \n            if 'async def run_test' in improved_code:\n                print(f\"✅ Fixed STEP {failed_step}, preserved all other steps\")\n                return improved_code\n            else:\n                print(f\"⚠️ Step fix invalid, falling back to full regeneration\")\n                return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n                \n        except Exception as e:\n            print(f\"❌ Step-by-step healing error: {e}\")\n            return self.regenerate_code_with_ai(original_code, error_message, failed_step, attempt_num)\n\n    def regenerate_code_with_ai(self, original_code, error_message, failed_step=0, attempt_num=1, error_type='unknown'):\n        \"\"\"Use AI to regenerate improved code based on execution failure.\"\"\"\n        if not self.client:\n            print(\"⚠️ OpenAI client not available, cannot regenerate code\")\n            return original_code\n            \n        try:\n            print(f\"\\n🤖 AI CODE REGENERATION (Attempt {attempt_num}/{self.max_retries})\")\n            print(f\"   Error type: {error_type}\")\n            print(f\"   Failed at step: {failed_step}\")\n            print(f\"   Error: {error_message[:200]}...\")\n            print(f\"   Using model: {'GPT-4o' if self.use_gpt4o else 'GPT-4o-mini'}\")\n            \n            # ALWAYS use GPT-4o for better accuracy (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            # Determine if this is a locator-related error or not\n            is_locator_error = error_type in ['locator_not_found', 'timeout', 'element_not_found', 'multiple_matches']\n            \n            if is_locator_error:\n                # For locator errors: Focus on improving the failed locator\n                fix_focus = \"\"\"1. Better locator for the failed step (more specific, robust, or alternative strategy)\n2. Appropriate waits and timeouts for that specific step\n3. Maintaining all other steps and their locators EXACTLY as they are\n4. Keeping the same return structure\"\"\"\n            else:\n                # For non-locator errors (API misuse, general errors): Preserve ALL locators\n                fix_focus = f\"\"\"1. Fix the {error_type} issue (API usage, syntax, logic error, etc.)\n2. PRESERVE ALL EXISTING LOCATORS - do NOT change any locator unless it's directly related to the error\n3. Add appropriate error handling or waits if needed\n4. Maintain all steps unchanged except for the specific code issue\n5. Keep the same return structure\n\n⚠️ CRITICAL: This is NOT a locator error - do NOT modify working locators!\"\"\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at debugging and fixing Playwright automation code.\n\nWhen code fails, you MUST:\n1. Analyze the error message to understand what went wrong\n2. Identify the problematic step and the root cause\n3. Generate improved code with targeted fixes\n4. Maintain the same overall structure and step numbering\n5. Add explicit timeouts (5000ms) to LOCATOR action methods only (click, fill, locator.press, etc.)\n   NEVER add timeout to: locator() calls, page.keyboard.press(), page.mouse methods\n   Examples:\n   ✅ CORRECT: await page.get_by_role(\"button\").click(timeout=5000)\n   ✅ CORRECT: await page.keyboard.press(\"Enter\")  # NO timeout!\n   ❌ WRONG: await page.keyboard.press(\"Enter\", timeout=5000)\n6. Use robust locator strategies (text content, role-based, data-testid) when changing locators\n7. Add appropriate waits before interactions if timing issues detected\n\nCRITICAL: Return ONLY the complete improved function code, no explanations.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"This Playwright code failed during execution:\n\n```python\n{original_code}\n```\n\nError type: {error_type}\nError occurred at STEP {failed_step}:\n{error_message}\n\nGenerate the COMPLETE improved code with fixes. Focus on:\n{fix_focus}\n\nReturn only the improved Python code:\"\"\"}\n                ],\n                temperature=0.3,\n                max_tokens=2000\n            )\n            \n            improved_code = response.choices[0].message.content.strip()\n            \n            # Clean up code formatting\n            if improved_code.startswith('```python'):\n                improved_code = improved_code[9:]\n            elif improved_code.startswith('```'):\n                improved_code = improved_code[3:]\n            if improved_code.endswith('```'):\n                improved_code = improved_code[:-3]\n            \n            improved_code = improved_code.strip()\n            \n            if improved_code and 'async def run_test' in improved_code:\n                print(f\"✅ AI generated improved code ({len(improved_code)} chars)\")\n                return improved_code\n            else:\n                print(f\"⚠️ AI response invalid, using original code\")\n                return original_code\n                \n        except Exception as e:\n            print(f\"❌ AI code regeneration error: {e}\")\n            return original_code\n    \n    def improve_locator_with_ai(self, failed_locator, error_message, page_html_snippet=''):\n        \"\"\"Use AI to suggest better locator strategies.\"\"\"\n        try:\n            # ALWAYS use GPT-4o for better locator suggestions (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at web automation and CSS/XPath selectors.\nWhen a locator fails, suggest better, more robust alternatives. Consider:\n1. Using text content locators when possible\n2. Using data-testid or aria-labels\n3. Using role-based selectors\n4. Creating more specific CSS selectors\n5. Using XPath as last resort\n\nReturn ONLY the improved locator string, nothing else.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed locator: {failed_locator}\nError: {error_message}\nPage context: {page_html_snippet[:500] if page_html_snippet else 'Not available'}\n\nSuggest a better locator:\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            improved = response.choices[0].message.content.strip()\n            if improved.startswith('```'):\n                improved = improved.split('\\n')[1]\n            if improved.endswith('```'):\n                improved = improved.rsplit('\\n', 1)[0]\n                \n            return improved.strip('\"\\'')\n        except Exception as e:\n            print(f\"AI locator improvement error: {e}\")\n            return failed_locator\n    \n    def heal_script(self, original_code, failed_locator, healed_locator):\n        \"\"\"Replace failed locator with healed one in the script.\"\"\"\n        print(f\"\\n🔧 HEALING SCRIPT:\")\n        print(f\"  Failed locator: '{failed_locator}'\")\n        print(f\"  Healed locator: '{healed_locator}'\")\n        print(f\"  Searching for '{failed_locator}' in code...\")\n        print(f\"  Found: {failed_locator in original_code}\")\n        \n        healed = original_code.replace(failed_locator, healed_locator)\n        self.healed_script = healed\n        \n        print(f\"  Replacement successful: {healed != original_code}\")\n        if healed != original_code:\n            print(f\"  Code changed from {len(original_code)} to {len(healed)} chars\")\n        else:\n            print(f\"  ⚠️  WARNING: Code unchanged after replacement!\")\n        \n        return healed\n    \n    async def wait_for_user_selector(self, timeout=300):\n        \"\"\"Wait for user to select an element interactively.\"\"\"\n        self.user_selector_event = asyncio.Event()\n        self.user_selected_selector = None\n        \n        try:\n            await asyncio.wait_for(self.user_selector_event.wait(), timeout=timeout)\n            return self.user_selected_selector\n        except asyncio.TimeoutError:\n            return None\n    \n    def set_user_selector(self, selector):\n        \"\"\"Called when user selects an element.\"\"\"\n        self.user_selected_selector = selector\n        if self.user_selector_event:\n            self.user_selector_event.set()\n    \n    def set_agent_result(self, result):\n        \"\"\"Called when agent returns result.\"\"\"\n        self.agent_result = result\n        self.agent_result_ready = True  # Simple flag for polling\n\n    async def _execute_on_agent(self, code, browser_name, headless, test_id, attempt_num, logs):\n        \"\"\"Execute code on agent and wait for result.\"\"\"\n        import base64\n\n        # Setup polling flags to wait for agent result (gevent-compatible)\n        self.agent_result_ready = False\n        self.agent_result = None\n\n        # For headful mode, use modified code that keeps browser open\n        execution_code = code\n        if not headless:\n            # Add a small delay to ensure browser is ready for widget injection\n            execution_code = code.replace(\n                \"async def run_test(browser_name='chromium', headless=True):\",\n                \"async def run_test(browser_name='chromium', headless=True):\\n    import asyncio\\n    await asyncio.sleep(1)  # Ensure browser is ready\"\n            )\n\n        # Emit execution request to agent (targeted to specific agent)\n        mode = 'headless' if headless else 'headful'\n        if self.agent_sid:\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            }, to=self.agent_sid)\n        else:\n            # Fallback to broadcast if no specific agent\n            self.socketio.emit('execute_healing_attempt', {\n                'test_id': test_id,\n                'code': execution_code,\n                'browser': browser_name,\n                'mode': mode,\n                'attempt': attempt_num + 1\n            })\n\n        # Wait for agent result - use gevent AsyncResult if available (cross-greenlet)\n        timeout = 180 if not headless else 120  # 3 minutes for headful, 2 for headless\n        \n        if hasattr(self, 'agent_result_async'):\n            # Use gevent AsyncResult for proper cross-greenlet communication\n            # Run in executor to avoid blocking asyncio event loop\n            loop = asyncio.get_event_loop()\n            try:\n                # Run blocking gevent call in thread pool\n                result = await asyncio.wait_for(\n                    loop.run_in_executor(None, lambda: self.agent_result_async.get(timeout=timeout)),\n                    timeout=timeout + 5  # Add 5s buffer\n                )\n            except (asyncio.TimeoutError, Exception) as e:\n                # Handle both asyncio timeout and gevent timeout\n                return {\n                    'success': False,\n                    'logs': logs + [f'❌ Agent execution timeout: {str(e)}'],\n                    'screenshot': None,\n                    'can_heal': False\n                }\n        else:\n            # Fallback to polling\n            poll_interval = 0.1  # Check every 100ms\n            elapsed = 0\n            \n            while not self.agent_result_ready and elapsed < timeout:\n                await asyncio.sleep(poll_interval)\n                elapsed += poll_interval\n            \n            if not self.agent_result_ready:\n                return {\n                    'success': False,\n                    'logs': logs + ['❌ Agent execution timeout'],\n                    'screenshot': None,\n                    'can_heal': False\n                }\n            \n            result = self.agent_result\n        if not result:\n            return {\n                'success': False,\n                'logs': logs + ['❌ No result from agent'],\n                'screenshot': None,\n                'can_heal': False\n            }\n        \n        # Decode screenshot if present\n        screenshot = None\n        if result.get('screenshot'):\n            try:\n                screenshot = base64.b64decode(result['screenshot'])\n            except:\n                pass\n        \n        logs.extend(result.get('logs', []))\n        \n        if result.get('success'):\n            logs.append(\"✅ Execution completed successfully\")\n            return {\n                'success': True,\n                'logs': logs,\n                'screenshot': screenshot\n            }\n        else:\n            # Extract failed locator and step from error\n            error_msg = ' '.join(result.get('logs', []))\n            failed_locator = self.extract_failed_locator(error_msg)\n            failed_step = self.extract_failed_step(error_msg)\n            \n            if failed_locator:\n                self.failed_locators.append({\n                    'locator': failed_locator,\n                    'error': error_msg,\n                    'attempt': attempt_num + 1,\n                    'step': failed_step\n                })\n                \n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': True,\n                    'failed_locator': failed_locator,\n                    'failed_step': failed_step,\n                    'error_message': error_msg,\n                    'page_content': ''\n                }\n            else:\n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': screenshot,\n                    'can_heal': False\n                }\n    \n    async def execute_with_healing(self, code, browser_name, headless, test_id):\n        \"\"\"Execute code with advanced AI-guided healing and retry on failures.\n        \n        Each failed step gets up to 3 AI-guided retry attempts before user intervention.\n        \"\"\"\n        validator = CodeValidator()\n        if not validator.validate(code):\n            return {\n                'success': False,\n                'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                'screenshot': None,\n                'healed_script': None\n            }\n        \n        self.healed_script = code\n        current_code = code\n        result = {'success': False, 'logs': [], 'screenshot': None}\n        all_logs = []  # Accumulate logs across all attempts\n        \n        for attempt in range(self.max_retries):\n            result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt)\n            \n            # Accumulate logs from this attempt\n            if result.get('logs'):\n                all_logs.extend(result['logs'])\n            \n            if result['success']:\n                final_result = {\n                    'success': True,\n                    'logs': all_logs,  # Return all accumulated logs\n                    'screenshot': result['screenshot'],\n                    'healed_script': self.healed_script if self.healed_script != code else None,\n                    'failed_locators': self.failed_locators\n                }\n                \n                if self.failed_locators:\n                    await self.report_failures_to_ai(test_id)\n                    final_result['logs'].append(\"📊 AI analysis complete - check insights for improvement recommendations\")\n                \n                return final_result\n            \n            if not result.get('can_heal'):\n                result['logs'] = all_logs  # Return accumulated logs even on failure\n                return result\n            \n            # Extract error details BEFORE any processing (needed for both healing paths)\n            error_message = result.get('error_message', '')\n            failed_step = result.get('failed_step', 0)  # Get from result, fallback to 0\n            failed_locator = result.get('failed_locator')\n            \n            import sys\n            print(f\"\\n🔍 HEALING ATTEMPT {attempt + 1}/{self.max_retries}:\", flush=True)\n            print(f\"   Failed step: {failed_step}\", flush=True)\n            print(f\"   Failed locator: {failed_locator}\", flush=True)\n            print(f\"   Mode: {'headful' if not headless else 'headless'}\", flush=True)\n            sys.stdout.flush()\n            \n            # Add log entry for this attempt\n            all_logs.append(f\"\\n🔄 Attempt {attempt + 1}/{self.max_retries}: Healing failed step {failed_step} with locator: {failed_locator}\")\n            \n            # CHECK FOR AI HEALING REQUEST (from agent's request_ai_healing event)\n            if self.ai_healing_requested and self.error_context:\n                error_type = self.error_context.get('error_type', 'unknown')\n                print(f\"\\n🤖 AI HEALING REQUEST DETECTED:\", flush=True)\n                print(f\"   Error type: {error_type}\", flush=True)\n                print(f\"   Regenerating code with AI...\", flush=True)\n                \n                # Use error context from the request, with safe fallback\n                error_detail = self.error_context.get('error_info', {}).get('detail', '') or error_message or 'Unknown error'\n                \n                # Regenerate entire code with AI based on error\n                # Pass error type to help AI know whether to preserve locators\n                regenerated_code = self.regenerate_code_with_ai(\n                    current_code, \n                    error_detail, \n                    failed_step, \n                    attempt + 1,\n                    error_type=error_type\n                )\n                \n                if regenerated_code != current_code:\n                    current_code = regenerated_code\n                    self.healed_script = regenerated_code\n                    all_logs.append(f\"✅ AI regenerated complete code based on error analysis\")\n                    print(f\"   ✅ Code regenerated successfully ({len(regenerated_code)} chars)\", flush=True)\n                    \n                    self.socketio.emit('script_healed', {\n                        'test_id': test_id,\n                        'healed_script': current_code,\n                        'failed_locator': failed_locator or '',\n                        'healed_locator': 'AI regenerated',\n                        'attempt': attempt + 1,\n                        'method': 'ai_healing_request'\n                    })\n                else:\n                    print(f\"   ⚠️ AI regeneration produced same code\", flush=True)\n                \n                # Reset the flag\n                self.ai_healing_requested = False\n                self.error_context = None\n                \n                # Continue to next attempt with regenerated code\n                continue\n            \n            # ENHANCED AI-GUIDED RETRY STRATEGY\n            # Attempts 1-2: Step-by-step healing\n            # Attempt 3: Multi-strategy parallel healing (if available)\n            # Attempt 4: Advanced locator validation\n            # Attempt 5: User intervention (only as last resort)\n            \n            if attempt < 4:  # First 4 attempts: Automated AI healing\n                healing_mode = \"Enhanced (GPT-4o)\" if self.use_gpt4o else \"Standard (GPT-4o-mini)\"\n                if attempt == 2 and self.use_multi_strategy:\n                    healing_mode = \"Multi-Strategy Parallel Healing\"\n                elif self.use_advanced_validator:\n                    healing_mode += \" + Validator\"\n                all_logs.append(f\"🤖 AI Retry {attempt + 1}/4: {healing_mode}...\")\n                \n                # Get page content for analysis\n                page_content = result.get('page_content', '')\n                if page_content:\n                    all_logs.append(f\"📊 Captured page context ({len(page_content)} chars) for locator analysis\")\n                \n                # Try step-by-step healing first (preserves successful steps)\n                regenerated_code = self.regenerate_failed_step_only(\n                    current_code, \n                    error_message, \n                    failed_step, \n                    attempt + 1,\n                    page_content\n                )\n                \n                if regenerated_code != current_code:\n                    current_code = regenerated_code\n                    self.healed_script = regenerated_code\n                    all_logs.append(f\"✅ Fixed STEP {failed_step}, all other steps preserved\")\n                    \n                    self.socketio.emit('script_healed', {\n                        'test_id': test_id,\n                        'healed_script': current_code,\n                        'failed_locator': failed_locator or '',\n                        'healed_locator': f'Step {failed_step} fixed',\n                        'attempt': attempt + 1,\n                        'method': 'step_by_step_healing'\n                    })\n                else:\n                    # Fallback to locator improvement if step regeneration failed\n                    all_logs.append(f\"⚠️ Step healing unchanged, trying locator improvement...\")\n                    if failed_locator:\n                        improved_locator = self.improve_locator_with_ai(\n                            failed_locator, \n                            error_message,\n                            result.get('page_content', '')\n                        )\n                        current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                        all_logs.append(f\"🔧 Trying improved locator: {failed_locator} → {improved_locator}\")\n                \n            # Final attempt (5th): Show user widget in headful mode as last resort\n            elif attempt >= 4:  # 5th attempt: User intervention only as last resort\n                if failed_locator:\n                    improved_locator = None\n                    \n                    if not headless:\n                        # User widget intervention\n                        mode = 'headful' if not headless else 'headless'\n                        print(f\"🔔 SERVER: Emitting element_selector_needed (final attempt) for test {test_id}\", flush=True)\n                        sys.stdout.flush()\n                        \n                        all_logs.append(f\"👆 Final attempt: Requesting user help to locate element...\")\n                        \n                        if self.agent_sid:\n                            self.socketio.emit('element_selector_needed', {\n                                'test_id': test_id,\n                                'failed_locator': failed_locator,\n                                'failed_step': failed_step,\n                                'error': error_message,\n                                'attempt': attempt + 1,\n                                'mode': mode\n                            }, to=self.agent_sid)\n                        else:\n                            self.socketio.emit('element_selector_needed', {\n                                'test_id': test_id,\n                                'failed_locator': failed_locator,\n                                'failed_step': failed_step,\n                                'error': error_message,\n                                'attempt': attempt + 1,\n                                'mode': mode\n                            })\n                        \n                        user_selector = await self.wait_for_user_selector(timeout=300)\n                        \n                        if user_selector:\n                            improved_locator = user_selector\n                            print(f\"\\n✅ USER SELECTED: '{improved_locator}'\", flush=True)\n                            all_logs.append(f\"✅ User selected element: {improved_locator}\")\n                        else:\n                            all_logs.append(f\"⏱️ User selection timeout, final AI attempt...\")\n                            improved_locator = self.improve_locator_with_ai(\n                                failed_locator, \n                                error_message,\n                                result.get('page_content', '')\n                            )\n                            all_logs.append(f\"🤖 Final AI suggestion: {improved_locator}\")\n                    else:\n                        # Headless mode: Final AI attempt\n                        all_logs.append(f\"🤖 Final AI retry in headless mode...\")\n                        improved_locator = self.improve_locator_with_ai(\n                            failed_locator, \n                            error_message,\n                            result.get('page_content', '')\n                        )\n                        all_logs.append(f\"🔧 Trying final locator: {failed_locator} → {improved_locator}\")\n                    \n                    if improved_locator:\n                        current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                        self.healed_script = current_code\n                        \n                        self.socketio.emit('script_healed', {\n                            'test_id': test_id,\n                            'healed_script': current_code,\n                            'failed_locator': failed_locator,\n                            'healed_locator': improved_locator,\n                            'attempt': attempt + 1,\n                            'method': 'user_selection' if not headless else 'final_ai'\n                        })\n                        \n                        # Execute the healed code immediately (final attempt after user help)\n                        all_logs.append(f\"🔄 Re-executing with user-provided locator...\")\n                        final_result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt + 1)\n                        \n                        if final_result.get('logs'):\n                            all_logs.extend(final_result['logs'])\n                        \n                        if final_result['success']:\n                            return {\n                                'success': True,\n                                'logs': all_logs,\n                                'screenshot': final_result['screenshot'],\n                                'healed_script': self.healed_script,\n                                'failed_locators': self.failed_locators\n                            }\n                \n                await asyncio.sleep(0.5)\n        \n        print(f\"\\n❌ HEALING FAILED after {self.max_retries} attempts\")\n        print(f\"  self.healed_script is None: {self.healed_script is None}\")\n        print(f\"  self.healed_script length: {len(self.healed_script) if self.healed_script else 0}\", flush=True)\n        \n        all_logs.append(f'❌ Failed after {self.max_retries} healing attempts')\n        final_result = {\n            'success': False,\n            'logs': all_logs,  # Use accumulated logs\n            'screenshot': result.get('screenshot'),\n            'healed_script': self.healed_script,\n            'failed_locators': self.failed_locators\n        }\n        \n        if self.failed_locators:\n            await self.report_failures_to_ai(test_id)\n        \n        return final_result\n    \n    async def _execute_single_attempt(self, code, browser_name, headless, test_id, attempt_num):\n        \"\"\"Execute a single attempt of the automation code.\"\"\"\n        logs = [f\"▶️  Attempt {attempt_num + 1}: Executing automation...\"]\n        screenshot = None\n        page_content = ''\n        \n        # If agent execution mode, delegate to agent\n        if self.execution_mode == 'agent':\n            return await self._execute_on_agent(code, browser_name, headless, test_id, attempt_num, logs)\n        \n        try:\n            from playwright.async_api import TimeoutError as PlaywrightTimeout\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True, 'False': False, 'None': None,\n                    'dict': dict, 'list': list, 'str': str, 'int': int,\n                    'float': float, 'bool': bool, 'len': len,\n                    'Exception': Exception, '__import__': __import__,\n                }\n            }\n            \n            local_vars = {}\n            \n            try:\n                exec(code, restricted_globals, local_vars)\n                \n                if 'run_test' not in local_vars:\n                    logs.append(\"❌ Error: Generated code must contain a run_test function\")\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': None,\n                        'can_heal': False\n                    }\n                \n                result = await local_vars['run_test'](browser_name=browser_name, headless=headless)\n                logs.extend(result.get('logs', []))\n                screenshot = result.get('screenshot')\n                page_content = result.get('page_html', '')  # Get page HTML if available\n                \n                if result.get('success'):\n                    logs.append(\"✅ Execution completed successfully\")\n                    return {\n                        'success': True,\n                        'logs': logs,\n                        'screenshot': screenshot\n                    }\n                else:\n                    error_msg = ' '.join(result.get('logs', []))\n                    failed_locator = self.extract_failed_locator(error_msg)\n                    failed_step = self.extract_failed_step(error_msg)\n                    \n                    if failed_locator:\n                        self.failed_locators.append({\n                            'locator': failed_locator,\n                            'error': error_msg,\n                            'attempt': attempt_num + 1,\n                            'step': failed_step\n                        })\n                        \n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': True,\n                            'failed_locator': failed_locator,\n                            'failed_step': failed_step,\n                            'error_message': error_msg,\n                            'page_content': page_content\n                        }\n                    else:\n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': False\n                        }\n                        \n            except PlaywrightTimeout as e:\n                error_msg = str(e)\n                logs.append(f\"⏱️  Timeout error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                failed_step = self.extract_failed_step(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1,\n                        'step': failed_step\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'failed_step': failed_step,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n            except Exception as e:\n                error_msg = str(e)\n                logs.append(f\"❌ Execution error: {error_msg}\")\n                \n                failed_locator = self.extract_failed_locator(error_msg)\n                failed_step = self.extract_failed_step(error_msg)\n                \n                if failed_locator:\n                    self.failed_locators.append({\n                        'locator': failed_locator,\n                        'error': error_msg,\n                        'attempt': attempt_num + 1,\n                        'step': failed_step\n                    })\n                    \n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': True,\n                        'failed_locator': failed_locator,\n                        'failed_step': failed_step,\n                        'error_message': error_msg,\n                        'page_content': page_content\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'logs': logs,\n                        'screenshot': screenshot,\n                        'can_heal': False\n                    }\n            \n        except Exception as e:\n            logs.append(f'💥 Fatal error: {str(e)}')\n            return {\n                'success': False,\n                'logs': logs,\n                'screenshot': screenshot,\n                'can_heal': False\n            }\n    \n    def extract_failed_step(self, error_message):\n        \"\"\"Extract the failed step number from error message.\"\"\"\n        # Look for patterns like \"Error at STEP 3:\" or \"STEP 2:\" in the error\n        patterns = [\n            r'Error at STEP\\s+(\\d+)',\n            r'STEP\\s+(\\d+):',\n            r'step\\s+(\\d+)',\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return int(match.group(1))\n        \n        return 0  # Default to 0 if no step found\n    \n    def extract_failed_locator(self, error_message):\n        \"\"\"Extract the failed locator from error message.\"\"\"\n        patterns = [\n            r'locator\\(\"([^\"]+)\"\\)',\n            r'selector \"([^\"]+)\"',\n            r'element \"([^\"]+)\"',\n            r'get_by_text\\(\"([^\"]+)\"\\)',\n            r'get_by_role\\(\"([^\"]+)\"\\)',\n            r\"locator\\('([^']+)'\\)\",\n            r\"selector '([^']+)'\",\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        \n        return None\n    \n    async def report_failures_to_ai(self, test_id):\n        \"\"\"Report all failures and healing attempts to AI for continuous improvement.\"\"\"\n        if not self.failed_locators or not self.client:\n            return\n        \n        try:\n            failure_report = {\n                'test_id': test_id,\n                'total_failures': len(self.failed_locators),\n                'failures': self.failed_locators,\n                'healed_script': self.healed_script\n            }\n            \n            # ALWAYS use GPT-4o for better analysis (decoupled from validator)\n            model = \"gpt-4o\" if self.use_gpt4o else \"gpt-4o-mini\"\n            \n            response = self.client.chat.completions.create(\n                model=model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an automation quality analyst. \nAnalyze the failures and healing attempts to provide insights for improving automation scripts.\nIdentify patterns, suggest best practices, and recommend preventive measures.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Analyze these automation failures and healing attempts:\n\nTest ID: {test_id}\nTotal Failures: {len(self.failed_locators)}\n\nFailures:\n{json.dumps(self.failed_locators, indent=2)}\n\nFinal Healed Script:\n{self.healed_script[:500] if self.healed_script else 'None'}\n\nProvide:\n1. Key insights about failure patterns\n2. Recommendations for better locator strategies\n3. Preventive measures for future scripts\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            insights = response.choices[0].message.content.strip()\n            \n            self.socketio.emit('ai_insights', {\n                'test_id': test_id,\n                'insights': insights,\n                'failure_count': len(self.failed_locators)\n            })\n            \n            return insights\n        except Exception as e:\n            print(f\"AI feedback error: {e}\")\n            return None\n","size_bytes":48577},"visionvault/agents/healing_engine.py":{"content":"import re\nimport asyncio\nfrom .browser_manager import BrowserManager\nfrom .utils import extract_failed_locator_local\n\n\nclass HealingEngine(BrowserManager):\n    def __init__(self, socket_client):\n        super().__init__()\n        self.socket_client = socket_client\n\n    def modify_code_for_healing(self, code):\n        \"\"\"Transform code to keep browser open by removing async with context manager\"\"\"\n        import re\n\n        # Step 1: Find the async with line and its indentation\n        lines = code.split('\\n')\n        new_lines = []\n        in_async_with_block = False\n        async_with_indent = 0\n        block_indent = 0\n\n        for i, line in enumerate(lines):\n            # Check if this line contains 'async with async_playwright() as var:'\n            async_with_match = re.match(r'^(\\s*)async with async_playwright\\(\\) as (\\w+):\\s*$', line)\n\n            if async_with_match and not in_async_with_block:\n                # Found the async with line - replace it\n                indent = async_with_match.group(1)\n                var_name = async_with_match.group(2)\n                async_with_indent = len(indent)\n\n                # Replace with two lines at the same indentation\n                new_lines.append(f'{indent}{var_name} = await async_playwright().start()')\n                new_lines.append(f'{indent}globals()[\"__p_instance__\"] = {var_name}')\n\n                in_async_with_block = True\n                # Determine the block indentation\n                if i + 1 < len(lines) and lines[i + 1].strip():\n                    block_indent = len(lines[i + 1]) - len(lines[i + 1].lstrip())\n                else:\n                    block_indent = async_with_indent + 4\n\n            elif in_async_with_block:\n                # Check if this line is still part of the async with block\n                if line.strip():\n                    current_indent = len(line) - len(line.lstrip())\n\n                    # If indentation decreased to or below async_with level, we've exited the block\n                    if current_indent <= async_with_indent:\n                        in_async_with_block = False\n                        new_lines.append(line)\n                    else:\n                        # Dedent by one level\n                        dedent_amount = block_indent - async_with_indent\n                        if current_indent >= block_indent:\n                            dedented_line = line[dedent_amount:]\n                            new_lines.append(dedented_line)\n                        else:\n                            new_lines.append(line)\n                else:\n                    new_lines.append(line)\n            else:\n                new_lines.append(line)\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 2: Inject page capture after page creation\n        lines = modified_code.split('\\n')\n        new_lines = []\n        page_captured = False\n\n        for line in lines:\n            new_lines.append(line)\n            # Match any variable name pattern: var = await browser.new_page()\n            if re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line) and not page_captured:\n                indent = len(line) - len(line.lstrip())\n                var_match = re.search(r'(\\w+)\\s*=\\s*await\\s+\\w+\\.new_page\\(\\)', line)\n                if var_match:\n                    var_name = var_match.group(1)\n                    new_lines.append(f'{\" \" * indent}globals()[\"__healing_page__\"] = {var_name}')\n                    page_captured = True\n                    print(f\"✅ Added page capture injection for variable '{var_name}'\")\n\n        modified_code = '\\n'.join(new_lines)\n\n        # Step 3: Replace browser.close() with pass to keep browser open for healing\n        modified_code = re.sub(\n            r'^(\\s*)(await\\s+)?browser\\.close\\(\\)',\n            r'\\1pass  # browser.close() commented for healing',\n            modified_code,\n            flags=re.MULTILINE\n        )\n\n        print(\"✅ Code transformation: async with removed, body dedented, browser stays open for healing\")\n        return modified_code\n\n    async def execute_healing_attempt(self, test_id, code, browser_name, mode, attempt, final_manual_attempt=False):\n        \"\"\"Execute a healing attempt with widget injection on failure\"\"\"\n        headless = mode == 'headless'\n        \n        # Store final_manual_attempt flag for later use\n        self.final_manual_attempt = final_manual_attempt\n        \n        if final_manual_attempt:\n            print(f\"🎯 Starting FINAL MANUAL healing attempt for test {test_id} in {'headless' if headless else 'headful'} mode\")\n            print(f\"   ⚠️  This is the last attempt - no further healing will be requested if it fails\")\n        else:\n            print(f\"🎯 Starting healing attempt {attempt} for test {test_id} in {'headless' if headless else 'headful'} mode\")\n\n        try:\n\n            # Clean up any previous instances\n            await self.cleanup_browser()\n\n            # Use original code for headless, modified for headful\n            if headless:\n                modified_code = code\n            else:\n                modified_code = self.modify_code_for_healing(code)\n                print(\"✅ Code modified for headful healing mode\")\n\n            global_vars = {'__healing_page__': None, '__p_instance__': None}\n            local_vars = {}\n\n            # Execute the code\n            exec(modified_code, global_vars, local_vars)\n\n            if 'run_test' not in local_vars:\n                self.socket_client.emit('healing_attempt_result',\n                                        {'test_id': test_id, 'success': False, 'logs': ['Error: run_test missing'],\n                                         'screenshot': None})\n                return\n\n            run_test = local_vars['run_test']\n\n            # Execute with timeout\n            try:\n                result = await asyncio.wait_for(\n                    run_test(browser_name=browser_name, headless=headless),\n                    timeout=60.0\n                )\n            except asyncio.TimeoutError:\n                print(f\"⏱️  Execution timeout for test {test_id}\")\n                result = {\n                    'success': False,\n                    'logs': ['Execution timeout - browser took too long to respond'],\n                    'screenshot': None\n                }\n\n            # Store page reference for headful mode\n            if not headless and global_vars.get('__healing_page__'):\n                self.set_active_page(global_vars['__healing_page__'])\n                if self.active_page and hasattr(self.active_page, 'url') and hasattr(self.active_page, 'is_closed'):\n                    print(\n                        f\"✅ Page captured for healing - URL: {self.active_page.url if not self.active_page.is_closed() else 'CLOSED'}\")\n                else:\n                    print(f\"✅ Page captured for healing - but no valid URL or is_closed method\")\n            else:\n                print(\n                    f\"ℹ️  No page captured (headless: {headless}, page available: {bool(global_vars.get('__healing_page__'))})\")\n\n            # Handle screenshot\n            from .utils import encode_screenshot\n            screenshot_b64 = encode_screenshot(result.get('screenshot'))\n\n            print(f\"Healing attempt {attempt} for test {test_id}: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n            # ENHANCED HEALING: Works for BOTH headless and headful modes\n            # - Headless: AI healing only (all 5 attempts)\n            # - Headful: AI healing (attempts 1-4) + manual widget (attempt 5 for locator errors only)\n            if not result.get('success'):\n                # Extract error details using enhanced detection\n                error_msg = ' '.join(result.get('logs', []))\n                error_info = extract_failed_locator_local(error_msg)\n\n                if error_info and error_info.get('is_healable'):\n                    error_type = error_info.get('type', 'unknown')\n                    print(f\"🔍 DETECTED ERROR TYPE: {error_type}\")\n                    print(f\"📋 Error details: {error_info.get('detail', error_info.get('full_error', 'No details'))[:200]}\")\n\n                    # Handle different error types with appropriate healing strategy\n                    if error_type in ['api_misuse', 'general_error']:\n                        # Check if this is the final manual attempt - no more healing allowed\n                        if self.final_manual_attempt:\n                            print(f\"❌ Final manual attempt failed with API/Code error - no further healing\")\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': False,\n                                'logs': result.get('logs', []) + ['❌ Final manual healing attempt failed - no more retries'],\n                                'screenshot': screenshot_b64\n                            })\n                            await self.cleanup_browser()\n                            return\n                        \n                        # API/Code errors: Request AI regeneration (works WITHOUT page)\n                        print(f\"🤖 API/Code error detected - requesting AI regeneration\")\n                        print(f\"💡 Server will automatically retry with improved code generation\")\n                        # Emit AI healing request FIRST (before result) to avoid race condition\n                        self.socket_client.emit('request_ai_healing', {\n                            'test_id': test_id,\n                            'error_type': error_type,\n                            'error_info': error_info,\n                            'attempt': attempt\n                        })\n                        # Then emit result to server for tracking\n                        self.socket_client.emit('healing_attempt_result', {\n                            'test_id': test_id,\n                            'success': result.get('success', False),\n                            'logs': result.get('logs', []),\n                            'screenshot': screenshot_b64\n                        })\n                        # Close browser, server will retry with new code\n                        await self.cleanup_browser()\n                        return  # Early return to avoid sending result twice\n                        \n                    elif error_type in ['locator_not_found', 'timeout', 'element_not_found', 'multiple_matches']:\n                        # Locator errors: Different handling for headless vs headful\n                        # Extract actual failed locator for healing\n                        actual_failed_locator = error_info.get('locator') or result.get('failed_locator')\n                        \n                        # If no locator found, extract from error detail/message\n                        if not actual_failed_locator:\n                            error_detail = error_info.get('detail', '') or error_msg\n                            import re\n                            # Extract locator from patterns like \"waiting for get_by_placeholder(\"Search\")\"\n                            if 'get_by_' in error_detail:\n                                match = re.search(r'(get_by_[^(]+\\([^)]+\\))', error_detail)\n                                if match:\n                                    # Add 'page.' prefix if not present to match code\n                                    locator = match.group(1)\n                                    if not locator.startswith('page.'):\n                                        locator = 'page.' + locator\n                                    actual_failed_locator = locator\n                            # Extract from patterns like 'locator(\"selector\")' including escaped quotes\n                            elif 'locator(' in error_detail:\n                                # Match locator(...) handling nested parentheses and escaped quotes\n                                # Look for 'locator(' followed by content until we hit keywords like ' to ', ' Call'\n                                match = re.search(r'locator\\(([\"\\'])(.+?)\\1\\)(?=\\s+(?:to|Call|$))', error_detail, re.DOTALL)\n                                if not match:\n                                    # Fallback: match any locator() call more greedily\n                                    match = re.search(r'(locator\\([^)]+(?:\\([^)]*\\))*[^)]*\\))', error_detail)\n                                    if match:\n                                        # Extract the full locator call\n                                        locator_call = match.group(1)\n                                        actual_failed_locator = f'page.{locator_call}'\n                                else:\n                                    quote_char = match.group(1)\n                                    selector = match.group(2)\n                                    # Add 'page.' prefix to match code\n                                    actual_failed_locator = f'page.locator({quote_char}{selector}{quote_char})'\n                        \n                        # For widget display: use actual locator or friendly fallback\n                        display_locator = actual_failed_locator or error_info.get('detail') or 'element selector'\n                        if not display_locator or display_locator == 'None':\n                            display_locator = error_msg.split('locator')[0].strip() if 'locator' in error_msg else 'element selector'\n                        \n                        print(f\"🎯 LOCATOR ERROR: {display_locator} (attempt {attempt}, mode: {'headless' if headless else 'headful'})\")\n                        print(f\"   Actual failed locator for healing: {actual_failed_locator or 'None (will be extracted by server)'}\")\n                        \n                        # Check if widget was already shown for this test\n                        widget_already_shown = hasattr(self, 'widget_shown_for_test') and self.widget_shown_for_test == test_id\n                        \n                        # HEADFUL MODE: Widget shown when max AI attempts exhausted (attempt >= 999 = final manual)\n                        # Only show widget once per test\n                        if not headless and attempt >= 999 and self.active_page and not widget_already_shown:\n                            print(f\"🚀 HEADFUL FINAL ATTEMPT - Showing manual element selector widget...\")\n                            self.widget_shown_for_test = test_id  # Mark widget as shown for this test\n                            self.set_widget_event(asyncio.Event())\n                            \n                            try:\n                                # Pass display locator to widget for UI, but store actual for healing\n                                self.actual_failed_locator = actual_failed_locator  # Store for later use\n                                await self.inject_element_selector(test_id, display_locator)\n                                print(f\"⏳ Waiting for user to select element (300s timeout)...\")\n                                try:\n                                    await asyncio.wait_for(self.widget_injection_complete.wait(), timeout=300.0)\n                                    print(f\"✅ User selection completed\")\n                                    # Fix: Don't close browser yet - wait for server to send healed code for retry\n                                    print(f\"⏳ Keeping browser open, waiting for server to send healed code...\")\n                                except asyncio.TimeoutError:\n                                    print(f\"⏱️  User selection timeout (300s)\")\n                                    # Only close browser on timeout\n                                    self.set_widget_event(None)\n                                    self.socket_client.emit('healing_attempt_result', {\n                                        'test_id': test_id,\n                                        'success': result.get('success', False),\n                                        'logs': result.get('logs', []),\n                                        'screenshot': screenshot_b64\n                                    })\n                                    await self.cleanup_browser()\n                            except Exception as widget_error:\n                                print(f\"❌ Widget error: {widget_error}\")\n                                self.set_widget_event(None)\n                                self.socket_client.emit('healing_attempt_result', {\n                                    'test_id': test_id,\n                                    'success': result.get('success', False),\n                                    'logs': result.get('logs', []),\n                                    'screenshot': screenshot_b64\n                                })\n                                await self.cleanup_browser()\n                        else:\n                            # Widget not shown (either headless, widget already shown, or no page)\n                            if widget_already_shown:\n                                print(f\"⚠️  Manual widget already shown for test {test_id} - marking as failed without showing again\")\n                            \n                            # Check if this is the final manual attempt - no more healing allowed\n                            if self.final_manual_attempt:\n                                print(f\"❌ Final manual attempt failed with locator error - no further healing\")\n                                self.socket_client.emit('healing_attempt_result', {\n                                    'test_id': test_id,\n                                    'success': False,\n                                    'logs': result.get('logs', []) + ['❌ Final manual healing attempt failed - no more retries'],\n                                    'screenshot': screenshot_b64\n                                })\n                                await self.cleanup_browser()\n                                return\n                            \n                            # HEADLESS MODE or HEADFUL AI attempts: Always use AI healing\n                            mode_desc = \"HEADLESS\" if headless else f\"HEADFUL ATTEMPT {attempt}\"\n                            print(f\"🤖 {mode_desc} - Using AI healing for locator issue: {display_locator}\")\n                            \n                            # Request AI healing\n                            self.socket_client.emit('request_ai_healing', {\n                                'test_id': test_id,\n                                'error_type': error_type,\n                                'error_info': error_info,\n                                'attempt': attempt\n                            })\n                            # Send result for tracking\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': result.get('success', False),\n                                'logs': result.get('logs', []),\n                                'screenshot': screenshot_b64\n                            })\n                            \n                            # Browser lifecycle: Keep open in headful for retry, close in headless after AI request\n                            if headless:\n                                print(f\"🧹 HEADLESS - Closing browser, server will retry with healed code\")\n                                await self.cleanup_browser()\n                            else:\n                                print(f\"⏳ HEADFUL - Browser kept open, waiting for server's AI-healed code retry...\")\n                            return\n                    else:\n                        # Check if this is the final manual attempt - no more healing allowed\n                        if self.final_manual_attempt:\n                            print(f\"❌ Final manual attempt failed with unknown error type - no further healing\")\n                            self.socket_client.emit('healing_attempt_result', {\n                                'test_id': test_id,\n                                'success': False,\n                                'logs': result.get('logs', []) + ['❌ Final manual healing attempt failed - no more retries'],\n                                'screenshot': screenshot_b64\n                            })\n                            await self.cleanup_browser()\n                            return\n                        \n                        # Unknown error type: Use AI healing for both headless and headful\n                        print(f\"⚠️  Unknown healable error type: {error_type} - requesting AI healing\")\n                        self.socket_client.emit('request_ai_healing', {\n                            'test_id': test_id,\n                            'error_type': error_type,\n                            'error_info': error_info,\n                            'attempt': attempt\n                        })\n                        self.socket_client.emit('healing_attempt_result', {\n                            'test_id': test_id,\n                            'success': result.get('success', False),\n                            'logs': result.get('logs', []),\n                            'screenshot': screenshot_b64\n                        })\n                        \n                        # Browser lifecycle\n                        if headless:\n                            print(f\"🧹 HEADLESS - Closing browser, server will retry with healed code\")\n                            await self.cleanup_browser()\n                        else:\n                            print(f\"⏳ HEADFUL - Browser kept open, waiting for server's AI-healed code retry...\")\n                        return\n                else:\n                    # No healable error detected - cleanup and exit\n                    print(f\"ℹ️  No healable error detected (non-recoverable)\")\n                    self.socket_client.emit('healing_attempt_result', {\n                        'test_id': test_id,\n                        'success': result.get('success', False),\n                        'logs': result.get('logs', []),\n                        'screenshot': screenshot_b64\n                    })\n                    await self.cleanup_browser()\n            else:\n                # Success case - send result and cleanup\n                print(f\"✅ Execution successful!\")\n                self.socket_client.emit('healing_attempt_result', {\n                    'test_id': test_id,\n                    'success': True,\n                    'logs': result.get('logs', []),\n                    'screenshot': screenshot_b64\n                })\n\n        except Exception as e:\n            print(f\"💥 Healing attempt error: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.socket_client.emit('healing_attempt_result',\n                                    {'test_id': test_id, 'success': False, 'logs': [str(e)], 'screenshot': None})\n            await self.cleanup_browser()\n\n    async def verify_locator_uniqueness(self, locator_code: str) -> int:\n        \"\"\"\n        Verify how many elements a locator matches on the page.\n        Returns the count of matching elements.\n        From playwright_codegen_2.py - Fixed to handle attribute selectors correctly\n        \"\"\"\n        if not self.active_page:\n            return 999\n            \n        try:\n            # Use regex to extract selector strings properly, handling escaped quotes\n            import re\n            \n            # Extract the actual locator expression from the Python code\n            if 'get_by_test_id' in locator_code:\n                # Extract: page.get_by_test_id(\"value\")\n                match = re.search(r'get_by_test_id\\(\"([^\"]+)\"\\)', locator_code)\n                if match:\n                    test_id = match.group(1)\n                    count = await self.active_page.locator(f'[data-testid=\"{test_id}\"]').count()\n                else:\n                    return 999\n            elif 'get_by_role' in locator_code:\n                # Extract: page.get_by_role(\"role\", name=\"name\")\n                role_match = re.search(r'get_by_role\\(\"([^\"]+)\"', locator_code)\n                name_match = re.search(r'name=\"([^\"]+)\"', locator_code)\n                if role_match:\n                    role = role_match.group(1)\n                    name = name_match.group(1) if name_match else None\n                    if name:\n                        count = await self.active_page.get_by_role(role, name=name).count()\n                    else:\n                        count = await self.active_page.get_by_role(role).count()\n                else:\n                    return 999\n            elif 'get_by_text' in locator_code:\n                # Extract: page.get_by_text(\"text\", exact=True)\n                match = re.search(r'get_by_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    text = match.group(1)\n                    exact = 'exact=True' in locator_code\n                    count = await self.active_page.get_by_text(text, exact=exact).count()\n                else:\n                    return 999\n            elif 'get_by_placeholder' in locator_code:\n                # Extract: page.get_by_placeholder(\"placeholder\")\n                match = re.search(r'get_by_placeholder\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    placeholder = match.group(1)\n                    count = await self.active_page.get_by_placeholder(placeholder).count()\n                else:\n                    return 999\n            elif 'get_by_alt_text' in locator_code:\n                # Extract: page.get_by_alt_text(\"alt\")\n                match = re.search(r'get_by_alt_text\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    alt = match.group(1)\n                    count = await self.active_page.get_by_alt_text(alt).count()\n                else:\n                    return 999\n            elif 'get_by_title' in locator_code:\n                # Extract: page.get_by_title(\"title\")\n                match = re.search(r'get_by_title\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    title = match.group(1)\n                    count = await self.active_page.get_by_title(title).count()\n                else:\n                    return 999\n            elif 'get_by_label' in locator_code:\n                # Extract: page.get_by_label(\"label\")\n                match = re.search(r'get_by_label\\(\"([^\"]+)\"', locator_code)\n                if match:\n                    label = match.group(1)\n                    count = await self.active_page.get_by_label(label).count()\n                else:\n                    return 999\n            elif 'page.locator' in locator_code:\n                # CSS or XPath - handle escaped quotes properly\n                # Extract: page.locator(\"selector\") where selector may contain \\\" \n                match = re.search(r'page\\.locator\\(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\)', locator_code)\n                if match:\n                    selector = match.group(1).replace('\\\\\"', '\"')  # Unescape quotes\n                    count = await self.active_page.locator(selector).count()\n                else:\n                    return 999\n            else:\n                count = 999\n\n            return count\n        except Exception as e:\n            print(f\"⚠️  Locator verification error for '{locator_code}': {e}\")\n            # If we can't verify, assume it's not unique\n            return 999\n\n    async def generate_best_locator(self, info: dict):\n        \"\"\"\n        Generate ALL possible locators from pre-captured element information.\n        Returns the best UNIQUE locator with highest success rate.\n        Based on playwright_codegen_2.py logic\n        \"\"\"\n        # Score tracking to determine primary locator (lower score = better)\n        scores = []\n\n        # 1. TEST ID LOCATORS (Score: 1 - highest priority)\n        if info.get('testId'):\n            loc = f'page.get_by_test_id(\"{info[\"testId\"]}\")'\n            scores.append((1, loc, 'testid'))\n\n        # 2. ROLE-BASED LOCATORS (Score: 100-150)\n        role = None\n        if info.get('role'):\n            role = info['role']\n        elif info['tag'] == 'button':\n            role = 'button'\n        elif info['tag'] == 'a':\n            role = 'link'\n        elif info['tag'] == 'input':\n            input_type = info.get('type', '')\n            if input_type == 'text' or input_type == '':\n                role = 'textbox'\n            elif input_type == 'checkbox':\n                role = 'checkbox'\n            elif input_type == 'radio':\n                role = 'radio'\n            elif input_type == 'submit':\n                role = 'button'\n\n        if role:\n            name = info.get('text') or info.get('ariaLabel')\n            if name:\n                loc = f'page.get_by_role(\"{role}\", name=\"{name}\")'\n                scores.append((100, loc, 'role_with_name'))\n                loc_exact = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)'\n                scores.append((105, loc_exact, 'role_with_name_exact'))\n            else:\n                loc = f'page.get_by_role(\"{role}\")'\n                scores.append((510, loc, 'role'))\n\n        # 3. PLACEHOLDER LOCATORS (Score: 120)\n        if info.get('placeholder'):\n            loc = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\")'\n            scores.append((120, loc, 'placeholder'))\n            loc_exact = f'page.get_by_placeholder(\"{info[\"placeholder\"]}\", exact=True)'\n            scores.append((125, loc_exact, 'placeholder_exact'))\n\n        # 4. LABEL LOCATORS (Score: 140)\n        if info.get('ariaLabel'):\n            loc = f'page.get_by_label(\"{info[\"ariaLabel\"]}\")'\n            scores.append((140, loc, 'label'))\n\n        # 5. ALT TEXT LOCATORS (Score: 160)\n        if info.get('alt'):\n            loc = f'page.get_by_alt_text(\"{info[\"alt\"]}\")'\n            scores.append((160, loc, 'alt'))\n            loc_exact = f'page.get_by_alt_text(\"{info[\"alt\"]}\", exact=True)'\n            scores.append((165, loc_exact, 'alt_exact'))\n\n        # 6. TEXT LOCATORS (Score: 180)\n        if info.get('text'):\n            text = info['text'].strip()\n            if text:\n                loc = f'page.get_by_text(\"{text}\", exact=True)'\n                scores.append((185, loc, 'text_exact'))\n                loc_partial = f'page.get_by_text(\"{text}\")'\n                scores.append((180, loc_partial, 'text'))\n\n        # 7. TITLE LOCATORS (Score: 200)\n        if info.get('title'):\n            loc = f'page.get_by_title(\"{info[\"title\"]}\")'\n            scores.append((200, loc, 'title'))\n\n        # 8. CSS SELECTORS (Score: 500+)\n        if info.get('id'):\n            loc = f'page.locator(\"#{info[\"id\"]}\")'\n            scores.append((500, loc, 'css_id'))\n\n        if info.get('classes'):\n            classes = info['classes'].strip().split()\n            if classes:\n                loc = f'page.locator(\"{info[\"tag\"]}.{classes[0]}\")'\n                scores.append((520, loc, 'css_class'))\n\n        if info.get('type'):\n            loc = f'page.locator(\"{info[\"tag\"]}[type=\\\\\"{info[\"type\"]}\\\\\"]\")'\n            scores.append((520, loc, 'css_type'))\n\n        # 9. Fallback to tag\n        loc = f'page.locator(\"{info[\"tag\"]}\")'\n        scores.append((530, loc, 'css_tag'))\n\n        # Sort by score (lower is better)\n        scores.sort(key=lambda x: x[0])\n\n        # Verify uniqueness for each locator and find the best unique one\n        print(f\"🔍 Testing {len(scores)} locator strategies for uniqueness...\")\n        \n        for score, locator, loc_type in scores:\n            # Check how many elements this locator matches\n            count = await self.verify_locator_uniqueness(locator)\n            print(f\"  - {loc_type}: {locator} → matches {count} element(s)\")\n            \n            if count == 1:\n                # Found a unique locator!\n                return {\n                    'locator': locator,\n                    'type': loc_type,\n                    'score': score,\n                    'count': count,\n                    'unique': True\n                }\n\n        # No unique locator found - use the best score but warn\n        if scores:\n            score, locator, loc_type = scores[0]\n            count = await self.verify_locator_uniqueness(locator)\n            print(f\"⚠️  No unique locator found. Using best score: {loc_type} (matches {count} elements)\")\n            return {\n                'locator': locator,\n                'type': loc_type,\n                'score': score,\n                'count': count,\n                'unique': False\n            }\n\n        return None\n\n    async def inject_element_selector(self, test_id, failed_locator):\n        \"\"\"Inject element selector widget into the page\"\"\"\n        if not self.active_page:\n            print(f\"❌ No active page for element selection (test {test_id})\")\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()\n            return\n\n        try:\n            if hasattr(self.active_page, 'is_closed') and self.active_page.is_closed():\n                print(f\"❌ Page already closed for test {test_id}\")\n                self.set_active_page(None)\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            if hasattr(self.active_page, 'url'):\n                print(f\"🎯 Injecting element selector widget for test {test_id} on page: {self.active_page.url}\")\n            else:\n                print(f\"🎯 Injecting element selector widget for test {test_id} on page: [no url]\")\n\n            # JavaScript to inject element selector overlay\n            selector_script = \"\"\"\n            (failedLocator) => {\n                console.log('🔧 Injecting element selector for locator:', failedLocator);\n                \n                // Remove any existing overlays first\n                const existingOverlay = document.getElementById('playwright-element-selector-overlay');\n                if (existingOverlay) {\n                    existingOverlay.remove();\n                }\n                \n                // Create overlay (non-blocking)\n                const overlay = document.createElement('div');\n                overlay.id = 'playwright-element-selector-overlay';\n                overlay.style.cssText = `\n                    position: fixed !important;\n                    top: 0 !important;\n                    left: 0 !important;\n                    width: 100% !important;\n                    height: 100% !important;\n                    background: rgba(0, 0, 0, 0.3) !important;\n                    z-index: 2147483647 !important;\n                    cursor: crosshair !important;\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;\n                    pointer-events: none !important;\n                `;\n                \n                // Create draggable header with instructions\n                const header = document.createElement('div');\n                header.style.cssText = `\n                    position: fixed !important;\n                    top: 20px !important;\n                    left: 50% !important;\n                    transform: translateX(-50%) !important;\n                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;\n                    color: white !important;\n                    padding: 16px 24px !important;\n                    border-radius: 12px !important;\n                    font-size: 15px !important;\n                    font-weight: 600 !important;\n                    z-index: 2147483648 !important;\n                    box-shadow: 0 8px 24px rgba(0,0,0,0.4) !important;\n                    text-align: left !important;\n                    cursor: move !important;\n                    user-select: none !important;\n                    pointer-events: auto !important;\n                    backdrop-filter: blur(10px) !important;\n                    border: 1px solid rgba(255,255,255,0.1) !important;\n                `;\n                header.innerHTML = `\n                    <div style=\"display: flex; align-items: center; gap: 12px; margin-bottom: 8px;\">\n                        <span style=\"font-size: 20px;\">🎯</span>\n                        <span style=\"font-size: 16px;\">Element Selector Mode</span>\n                    </div>\n                    <div style=\"font-size: 13px; font-weight: normal; opacity: 0.95; line-height: 1.5;\">\n                        <div style=\"margin-bottom: 4px;\">Failed locator: <code style=\"background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px; font-family: monospace;\">${failedLocator}</code></div>\n                        <div style=\"opacity: 0.85;\">Click on the element you want to select</div>\n                        <div style=\"font-size: 11px; opacity: 0.7; margin-top: 6px;\">💡 Drag this panel to move it</div>\n                    </div>\n                `;\n                \n                // Make header draggable\n                let isDragging = false;\n                let dragOffsetX = 0;\n                let dragOffsetY = 0;\n                \n                header.addEventListener('mousedown', (e) => {\n                    if (e.target.tagName !== 'BUTTON') {\n                        isDragging = true;\n                        const rect = header.getBoundingClientRect();\n                        dragOffsetX = e.clientX - rect.left;\n                        dragOffsetY = e.clientY - rect.top;\n                        header.style.transition = 'none';\n                    }\n                });\n                \n                document.addEventListener('mousemove', (e) => {\n                    if (isDragging) {\n                        e.preventDefault();\n                        const newX = e.clientX - dragOffsetX;\n                        const newY = e.clientY - dragOffsetY;\n                        header.style.left = newX + 'px';\n                        header.style.top = newY + 'px';\n                        header.style.transform = 'none';\n                    }\n                });\n                \n                document.addEventListener('mouseup', () => {\n                    isDragging = false;\n                });\n                \n                // Create cancel button inside header\n                const cancelBtn = document.createElement('button');\n                cancelBtn.textContent = '✕';\n                cancelBtn.style.cssText = `\n                    position: absolute !important;\n                    top: 12px !important;\n                    right: 12px !important;\n                    background: rgba(255,255,255,0.2) !important;\n                    color: white !important;\n                    border: none !important;\n                    width: 28px !important;\n                    height: 28px !important;\n                    border-radius: 50% !important;\n                    cursor: pointer !important;\n                    font-size: 16px !important;\n                    font-weight: bold !important;\n                    display: flex !important;\n                    align-items: center !important;\n                    justify-content: center !important;\n                    transition: background 0.2s !important;\n                    pointer-events: auto !important;\n                `;\n                cancelBtn.onmouseover = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.3)';\n                };\n                cancelBtn.onmouseout = () => {\n                    cancelBtn.style.background = 'rgba(255,255,255,0.2)';\n                };\n                cancelBtn.onclick = (e) => {\n                    e.stopPropagation();\n                    overlay.remove();\n                    header.remove();\n                    window.__selectedSelector = null;\n                };\n                header.appendChild(cancelBtn);\n                \n                // Track highlighted element\n                let highlightedElement = null;\n                let highlightBox = null;\n                \n                // Mouse move handler to highlight elements\n                document.addEventListener('mousemove', (e) => {\n                    if (!isDragging) {\n                        const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (elementUnderCursor && elementUnderCursor !== overlay && !header.contains(elementUnderCursor)) {\n                            if (highlightedElement !== elementUnderCursor) {\n                                highlightedElement = elementUnderCursor;\n                                \n                                // Remove old highlight box\n                                if (highlightBox) {\n                                    highlightBox.remove();\n                                }\n                                \n                                // Create new highlight box\n                                const rect = highlightedElement.getBoundingClientRect();\n                                highlightBox = document.createElement('div');\n                                highlightBox.style.cssText = `\n                                    position: fixed !important;\n                                    top: ${rect.top}px !important;\n                                    left: ${rect.left}px !important;\n                                    width: ${rect.width}px !important;\n                                    height: ${rect.height}px !important;\n                                    border: 2px solid #667eea !important;\n                                    background: rgba(102, 126, 234, 0.1) !important;\n                                    z-index: 2147483646 !important;\n                                    pointer-events: none !important;\n                                    box-shadow: 0 0 20px rgba(102, 126, 234, 0.4) !important;\n                                    border-radius: 4px !important;\n                                `;\n                                document.body.appendChild(highlightBox);\n                            }\n                        }\n                    }\n                });\n                \n                // Click handler to select element - Comprehensive info capture\n                document.addEventListener('click', function selectHandler(e) {\n                    if (!header.contains(e.target)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        \n                        const element = document.elementFromPoint(e.clientX, e.clientY);\n                        \n                        if (element && element !== overlay && !header.contains(element)) {\n                            // Capture comprehensive element information\n                            // This follows the approach from playwright_codegen_2.py\n                            window.__selectedElementInfo = {\n                                tag: element.tagName.toLowerCase(),\n                                text: element.textContent?.trim().substring(0, 100) || '',\n                                id: element.id || '',\n                                classes: element.className || '',\n                                testId: element.getAttribute('data-testid') || element.getAttribute('data-test') || '',\n                                role: element.getAttribute('role') || '',\n                                ariaLabel: element.getAttribute('aria-label') || '',\n                                placeholder: element.getAttribute('placeholder') || '',\n                                alt: element.getAttribute('alt') || '',\n                                title: element.getAttribute('title') || '',\n                                type: element.getAttribute('type') || '',\n                                href: element.getAttribute('href') || '',\n                                name: element.getAttribute('name') || '',\n                                value: element.getAttribute('value') || '',\n                                timestamp: Date.now()\n                            };\n                            \n                            console.log('✅ Element info captured:', window.__selectedElementInfo);\n                            \n                            // Clean up\n                            overlay.remove();\n                            header.remove();\n                            if (highlightBox) {\n                                highlightBox.remove();\n                            }\n                            document.removeEventListener('click', selectHandler);\n                        }\n                    }\n                }, true);\n                \n                // Add to DOM\n                document.body.appendChild(overlay);\n                document.body.appendChild(header);\n                \n                console.log('✅ Element selector widget injected successfully');\n            }\n            \"\"\"\n\n            # Inject the script\n            if hasattr(self.active_page, 'evaluate'):\n                await self.active_page.evaluate(selector_script, failed_locator)\n                print(\"✅ Element selector widget injected successfully\")\n            else:\n                print(\"❌ Cannot inject selector widget: active_page has no evaluate method\")\n                if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                    self.widget_injection_complete.set()\n                return\n\n            # Poll for user selection\n            print(\"⏳ Polling for user element selection...\")\n            for i in range(600):\n                await asyncio.sleep(0.2)\n                element_info = None\n                if hasattr(self.active_page, 'evaluate'):\n                    element_info = await self.active_page.evaluate('() => window.__selectedElementInfo')\n                if element_info:\n                    print(f\"✅ Element info captured: {element_info}\")\n                    \n                    # Generate all possible locators with scoring and uniqueness verification\n                    best_locator = await self.generate_best_locator(element_info)\n                    \n                    # Use actual_failed_locator (stored earlier) for healing, not the display fallback\n                    # If actual_failed_locator is None, send None (not display text) so server can try to extract\n                    healing_locator = getattr(self, 'actual_failed_locator', None)\n                    # Only use failed_locator if it's not a generic fallback display text\n                    if not healing_locator and failed_locator and failed_locator not in ['element selector', 'None', '']:\n                        healing_locator = failed_locator\n                    \n                    if best_locator:\n                        print(f\"✅ Best locator selected: {best_locator['locator']} (type: {best_locator['type']}, score: {best_locator['score']}, unique: {best_locator['unique']})\")\n                        self.socket_client.emit('element_selected', {\n                            'test_id': test_id,\n                            'selector': best_locator['locator'],\n                            'failed_locator': healing_locator,  # Use actual locator for healing\n                            'locator_type': best_locator['type'],\n                            'score': best_locator['score'],\n                            'unique': best_locator['unique']\n                        })\n                    else:\n                        print(\"⚠️  No unique locator found, using fallback\")\n                        self.socket_client.emit('element_selected', {\n                            'test_id': test_id,\n                            'selector': f\"#{element_info.get('id')}\" if element_info.get('id') else element_info.get('tag', 'div'),\n                            'failed_locator': healing_locator  # Use actual locator for healing\n                        })\n                    \n                    if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                        self.widget_injection_complete.set()\n                    return\n            print(\"⏱️  Element selection polling complete (300s)\")\n        except Exception as e:\n            print(f\"❌ Element selector injection error: {e}\")\n        finally:\n            if self.widget_injection_complete and hasattr(self.widget_injection_complete, 'set'):\n                self.widget_injection_complete.set()","size_bytes":48914},"run_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"Entry point for running the VisionVault server.\"\"\"\n\nfrom visionvault.web.app import app, socketio\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 5000))\n    socketio.run(app, host='0.0.0.0', port=port, debug=False, allow_unsafe_werkzeug=True)","size_bytes":300},"mcp/src/automation/session_memory.py":{"content":"import json\nimport os\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .logger import get_logger\n\nlogger = get_logger()\n\n\nclass SessionMemory:\n    \"\"\"\n    Persistent storage for automation execution history.\n    Tracks successful patterns and failures to improve future executions.\n    \"\"\"\n    \n    def __init__(self, session_dir: str = \"sessions\"):\n        self.session_dir = Path(session_dir)\n        self.session_dir.mkdir(exist_ok=True)\n        self.memory_file = self.session_dir / \"execution_memory.json\"\n        self.memory: Dict[str, Any] = self._load_memory()\n    \n    def _load_memory(self) -> Dict[str, Any]:\n        \"\"\"Load execution memory from disk.\"\"\"\n        if self.memory_file.exists():\n            try:\n                with open(self.memory_file, 'r') as f:\n                    data = json.load(f)\n                    logger.debug(f\"Loaded {len(data.get('executions', []))} executions from memory\")\n                    return data\n            except Exception as e:\n                logger.error(f\"Failed to load memory: {e}\")\n                return {\"executions\": [], \"patterns\": {}}\n        return {\"executions\": [], \"patterns\": {}}\n    \n    def _save_memory(self):\n        \"\"\"Save execution memory to disk.\"\"\"\n        try:\n            with open(self.memory_file, 'w') as f:\n                json.dump(self.memory, f, indent=2)\n            logger.debug(\"Memory saved to disk\")\n        except Exception as e:\n            logger.error(f\"Failed to save memory: {e}\")\n    \n    def record_execution(self, instruction: str, success: bool, \n                        steps: List[Dict[str, Any]], error: Optional[str] = None):\n        \"\"\"Record an execution attempt.\"\"\"\n        execution = {\n            \"instruction\": instruction,\n            \"success\": success,\n            \"steps\": steps,\n            \"error\": error,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        self.memory[\"executions\"].append(execution)\n        \n        if len(self.memory[\"executions\"]) > 100:\n            self.memory[\"executions\"] = self.memory[\"executions\"][-100:]\n        \n        if success:\n            self._update_patterns(instruction, steps)\n        \n        self._save_memory()\n        logger.info(f\"Recorded {'successful' if success else 'failed'} execution\")\n    \n    def _update_patterns(self, instruction: str, steps: List[Dict[str, Any]]):\n        \"\"\"Learn from successful patterns.\"\"\"\n        instruction_lower = instruction.lower()\n        \n        key_phrases = [\"search\", \"login\", \"click\", \"fill\", \"navigate\", \"extract\", \"scrape\"]\n        \n        for phrase in key_phrases:\n            if phrase in instruction_lower:\n                if phrase not in self.memory[\"patterns\"]:\n                    self.memory[\"patterns\"][phrase] = []\n                \n                pattern = {\n                    \"instruction\": instruction,\n                    \"steps\": steps,\n                    \"timestamp\": datetime.now().isoformat()\n                }\n                \n                self.memory[\"patterns\"][phrase].append(pattern)\n                \n                if len(self.memory[\"patterns\"][phrase]) > 5:\n                    self.memory[\"patterns\"][phrase] = self.memory[\"patterns\"][phrase][-5:]\n    \n    def get_similar_patterns(self, instruction: str) -> List[Dict[str, Any]]:\n        \"\"\"Get similar successful patterns based on instruction.\"\"\"\n        instruction_lower = instruction.lower()\n        similar = []\n        \n        for phrase, patterns in self.memory[\"patterns\"].items():\n            if phrase in instruction_lower:\n                similar.extend(patterns)\n        \n        return similar\n    \n    def get_recent_successes(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent successful executions.\"\"\"\n        successes = [e for e in self.memory[\"executions\"] if e[\"success\"]]\n        return successes[-limit:]\n    \n    def get_recent_failures(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get recent failed executions.\"\"\"\n        failures = [e for e in self.memory[\"executions\"] if not e[\"success\"]]\n        return failures[-limit:]\n    \n    def get_context_for_instruction(self, instruction: str) -> str:\n        \"\"\"Build context string for similar instructions.\"\"\"\n        similar = self.get_similar_patterns(instruction)\n        \n        if not similar:\n            return \"\"\n        \n        context_parts = [\"Similar successful patterns:\"]\n        for pattern in similar[-3:]:\n            context_parts.append(f\"- {pattern['instruction']}: {len(pattern['steps'])} steps\")\n        \n        return \"\\n\".join(context_parts)\n    \n    def clear_memory(self):\n        \"\"\"Clear all execution memory.\"\"\"\n        self.memory = {\"executions\": [], \"patterns\": {}}\n        self._save_memory()\n        logger.info(\"Memory cleared\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get statistics about executions.\"\"\"\n        total = len(self.memory[\"executions\"])\n        successes = len([e for e in self.memory[\"executions\"] if e[\"success\"]])\n        failures = total - successes\n        \n        return {\n            \"total_executions\": total,\n            \"successes\": successes,\n            \"failures\": failures,\n            \"success_rate\": (successes / total * 100) if total > 0 else 0,\n            \"learned_patterns\": len(self.memory[\"patterns\"])\n        }\n","size_bytes":5397},"replit.md":{"content":"# VisionVault - AI-Powered Browser Automation\n\n## Overview\nVisionVault is an intelligent browser automation platform that converts natural language commands into executable Playwright code. It features advanced AI capabilities including self-healing, vision-based analysis, and continuous learning from past executions.\n\n## Current State\n✅ **Fully configured and running on Replit**\n- Flask web server running on port 5000\n- Playwright with Chromium browser installed\n- All Python dependencies installed\n- System dependencies configured for browser automation\n- Database initialized\n\n## Project Architecture\n\n### Core Components\n1. **Web Interface** (`visionvault/web/`)\n   - Flask-SocketIO web application\n   - Real-time browser automation dashboard\n   - Teaching mode for recording interactions\n   - Task library with semantic search\n\n2. **Browser Automation** (`visionvault/agents/`)\n   - Playwright-based test executor\n   - Self-healing execution engine\n   - Recording session manager\n   - Browser manager with context handling\n\n3. **AI Services** (`visionvault/services/`)\n   - Code validator and generator\n   - DOM inspector for intelligent element detection\n   - Multi-strategy healing engine\n   - Self-learning engine that improves over time\n   - Vector store for semantic task search\n   - Intelligent planner for pre-execution analysis\n   - MCP automation manager for enhanced browser control\n\n4. **MCP Integration** (`mcp/`)\n   - Model Context Protocol for advanced automation\n   - Vision analyzer using GPT-4\n   - Session memory and browser recorder\n   - Natural language automation interface\n\n### Key Features\n- **Intelligent Unified Engine**: Automatically selects the best automation strategy (MCP Direct or Code Generation) based on task complexity and historical performance\n- **Natural Language Commands**: Convert plain English to browser actions\n- **Adaptive Learning**: System learns which approach works best for different task types and improves over time\n- **Headless/Headful Modes**: Toggle between invisible background execution or visible browser window\n- **Self-Healing**: Automatically fixes failed automation attempts with progressive escalation\n- **Vision Analysis**: Uses GPT-4 Vision to understand page structure\n- **Teaching Mode**: Record browser interactions to generate code\n- **Persistent Learning**: Learns from successes and failures, tracks strategy performance\n- **Semantic Search**: Find similar tasks using AI embeddings\n- **Real-time Updates**: WebSocket-based live execution monitoring with progress streaming\n\n## Intelligent Automation System\n\nVisionVault uses a **Unified Automation Engine** that intelligently combines two powerful approaches:\n\n### Adaptive Strategy Selection\nThe system automatically analyzes each task and chooses the best approach:\n\n**🚀 MCP Direct (Model Context Protocol)**\n- **When used**: Simple tasks, single actions, high-confidence operations\n- **How it works**: AI directly controls the browser via intelligent action planning\n- **Advantages**: Fast execution, minimal overhead, real-time adaptation\n- **Features**: Vision-based analysis, DOM scanning, fuzzy element matching\n\n**🔧 Code Generation (Playwright)**\n- **When used**: Complex multi-step workflows, tasks requiring code review\n- **How it works**: AI generates executable Playwright Python code\n- **Advantages**: Full control, debuggable, reusable, modifiable\n- **Features**: Self-healing, intelligent code reuse, semantic similarity matching\n\n### Progressive Escalation\nIf the primary strategy fails, the system automatically escalates:\n1. **First attempt**: Selected strategy (MCP or CodeGen)\n2. **Healing**: DOM scanning → Vision analysis → Multi-strategy healing\n3. **Alternative strategy**: Falls back to the other approach if needed\n4. **Manual widget**: Headful mode allows manual element selection\n\n### Continuous Learning\nThe system tracks which strategy works best for different task patterns and automatically improves its decision-making over time.\n\n**Browser Modes**:\n- **Headless**: Invisible browser, faster execution, ideal for background tasks\n- **Headful**: Visible browser window, watch automation in real-time (requires local agent)\n\n## Configuration\n\n### Required API Keys (Optional but Recommended)\nThe application works without API keys but features are limited:\n\n- `OPENAI_API_KEY` - Enables AI code generation, MCP automation, and self-healing\n- `GEMINI_API_KEY` - Enables semantic task search and embeddings\n- `SESSION_SECRET` - Already configured for Flask sessions\n\n**To enable full features:**\n1. Click the \"Secrets\" tab in Replit\n2. Add `OPENAI_API_KEY` with your OpenAI API key\n3. Add `GEMINI_API_KEY` with your Google AI API key\n\nWithout these keys, the app gracefully degrades:\n- ⚠️ AI code generation disabled (requires OPENAI_API_KEY)\n- ⚠️ MCP automation disabled (requires OPENAI_API_KEY)\n- ⚠️ Semantic search disabled (requires GEMINI_API_KEY)\n- ⚠️ Intelligent planner disabled (requires OPENAI_API_KEY)\n- ✅ Manual Playwright code execution still works\n- ✅ Teaching mode recording still works\n\n### Workflows\n- **Server**: Runs Flask application on port 5000\n  - Command: `python run_server.py`\n  - Serves web interface and API endpoints\n  - Handles WebSocket connections for real-time updates\n\n### Database\n- SQLite database at `data/automation.db`\n- Stores execution history, learned tasks, and task executions\n- Automatically initialized on first run\n- Vector embeddings stored in `data/vector_index.faiss`\n\n## Development\n\n### File Structure\n```\nvisionvault/\n├── web/              # Flask web application\n│   ├── app.py       # Main Flask app with routes\n│   └── templates/   # HTML templates\n├── agents/          # Agent components\n│   ├── main.py      # Main agent entry point\n│   ├── test_executor.py\n│   └── healing_engine.py\n├── services/        # AI and automation services\n│   ├── executor.py\n│   ├── healing_executor.py\n│   ├── self_learning_engine.py\n│   └── vector_store.py\n└── core/            # Core models and database\n\nmcp/                 # Model Context Protocol\n├── src/automation/  # Automation modules\n│   ├── ai_generator.py\n│   ├── vision_analyzer.py\n│   └── browser_engine.py\n└── nl_automation_mcp.py\n\ndata/                # Data storage\n├── automation.db    # SQLite database\n├── vector_index.faiss\n└── uploads/         # Screenshots and logs\n```\n\n### Running Locally\nThe server auto-starts via the workflow. To run manually:\n```bash\npython run_server.py\n```\n\n### Running an Agent (Optional)\nTo enable distributed execution with agents:\n```bash\npython run_agent.py\n```\n\n## Deployment\nConfigured for Replit Autoscale deployment:\n- Uses Gunicorn with gevent workers\n- Optimized for stateless web requests\n- Automatic scaling based on traffic\n\n## Technology Stack\n- **Backend**: Python 3.11, Flask, Flask-SocketIO\n- **Browser Automation**: Playwright\n- **AI**: OpenAI GPT-4, Google Gemini\n- **Database**: SQLite, FAISS vector store\n- **ML**: scikit-learn, numpy\n- **Frontend**: HTML, CSS, JavaScript (Socket.IO client)\n\n## Usage Examples\n\n1. **Natural Language Automation**\n   - Navigate to the dashboard\n   - Enter: \"Go to Google and search for Python tutorials\"\n   - Click \"Execute Automation\"\n   - Watch AI generate and execute Playwright code\n\n2. **Teaching Mode**\n   - Click \"Teaching Mode\" in sidebar\n   - Perform actions in the browser\n   - System records and generates code automatically\n\n3. **Task Library**\n   - Browse previously executed tasks\n   - Search similar tasks semantically\n   - Reuse and adapt existing code\n\n## Notes\n- Playwright runs in headless mode by default for performance\n- Screenshots are captured for all executions\n- The system learns from every execution to improve accuracy\n- Self-healing attempts up to 2 retries before manual intervention\n\n## Recent Changes\n- **2025-10-19**: Unified Automation Engine Complete\n  - **Merged Legacy Playwright and MCP into ONE intelligent system**\n  - Created UnifiedAutomationEngine with adaptive strategy selection\n  - Implemented intelligent scoring system (analyzes complexity, confidence, DOM availability)\n  - Built progressive escalation: MCP → CodeGen → Multi-strategy healing → Manual widget\n  - Extended SelfLearningEngine to track strategy performance by task type\n  - Added historical learning: System recommends strategies based on past success rates\n  - **Simplified UI**: Removed manual engine selector - system auto-selects best approach\n  - Updated Flask `/api/execute` endpoint to use unified orchestration\n  - Added real-time strategy selection notifications via Socket.IO\n  - Continuous learning: System improves decision-making over time\n  - Maintained full backward compatibility with agents\n\n- **2025-10-19**: MCP Integration\n  - Integrated Model Context Protocol (MCP) as second automation engine\n  - Implemented headless/headful browser mode toggle\n  - Created MCPAutomationManager service for async execution\n  - Added real-time progress streaming via Socket.IO\n  - Installed Python MCP SDK and required dependencies\n\n- **2025-10-18**: Initial Replit setup\n  - Installed Python 3.11 and all dependencies\n  - Configured Playwright with Chromium browser\n  - Set up system dependencies for browser automation\n  - Created Flask server workflow on port 5000\n","size_bytes":9429},"visionvault/services/mcp_manager.py":{"content":"\"\"\"\nMCP Automation Manager\nOrchestrates EnhancedMCPAutomation with lifecycle management and SocketIO integration\n\"\"\"\n\nimport asyncio\nimport os\nimport sys\nimport base64\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\nimport traceback\n\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../mcp'))\n\nfrom src.automation.mcp_client import PlaywrightMCPClient\nfrom src.automation.execution_tracer import ExecutionTracer\nfrom src.automation.logger import get_logger\nfrom openai import AsyncOpenAI\nfrom visionvault.services.hybrid_codegen import HybridCodeGenerator\n\nlogger = get_logger()\n\n\nclass MCPAutomationManager:\n    \"\"\"\n    Manager for MCP-based browser automation with:\n    - Lifecycle management (start/stop/cleanup)\n    - SocketIO progress streaming\n    - Screenshot and result handling\n    - Integration with existing VisionVault infrastructure\n    \"\"\"\n    \n    def __init__(self, socketio, openai_api_key: Optional[str] = None):\n        self.socketio = socketio\n        self.openai_api_key = openai_api_key or os.environ.get('OPENAI_API_KEY')\n        self.active_sessions: Dict[str, Dict[str, Any]] = {}\n        self.screenshots_dir = \"data/uploads/screenshots\"\n        Path(self.screenshots_dir).mkdir(parents=True, exist_ok=True)\n        self.hybrid_codegen = HybridCodeGenerator()\n    \n    def emit_progress(self, test_id: str, message: str, level: str = \"info\"):\n        \"\"\"Emit progress update via SocketIO\"\"\"\n        self.socketio.emit('automation_update', {\n            'test_id': test_id,\n            'type': 'log',\n            'message': message,\n            'level': level,\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    def emit_screenshot(self, test_id: str, screenshot_path: str):\n        \"\"\"Emit screenshot update via SocketIO\"\"\"\n        try:\n            if os.path.exists(screenshot_path):\n                with open(screenshot_path, 'rb') as f:\n                    screenshot_base64 = base64.b64encode(f.read()).decode()\n                self.socketio.emit('automation_update', {\n                    'test_id': test_id,\n                    'type': 'screenshot',\n                    'screenshot': screenshot_base64,\n                    'timestamp': datetime.now().isoformat()\n                })\n        except Exception as e:\n            logger.error(f\"Failed to emit screenshot: {e}\")\n    \n    async def execute_automation(\n        self,\n        test_id: str,\n        command: str,\n        browser: str = \"chromium\",\n        headless: bool = True,\n        enable_tracing: bool = False\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute MCP automation with real-time progress updates\n        \n        Args:\n            test_id: Unique test identifier\n            command: Natural language automation command\n            browser: Browser type (chromium, firefox, webkit)\n            headless: Whether to run in headless mode\n            enable_tracing: Enable execution tracing for hybrid code generation\n            \n        Returns:\n            Result dictionary with success status, logs, screenshot, and optional generated code\n        \"\"\"\n        logs = []\n        screenshot = None\n        success = False\n        mcp_client = None\n        tracer = None\n        generated_code = None\n        \n        try:\n            self.emit_progress(test_id, f\"🚀 Starting MCP automation (mode: {'headless' if headless else 'headful'})\", \"info\")\n            if enable_tracing:\n                self.emit_progress(test_id, \"🎬 Tracing enabled - will generate Playwright code\", \"info\")\n            self.emit_progress(test_id, f\"📋 Command: {command}\", \"info\")\n            \n            # Check if OpenAI API key is available\n            if not self.openai_api_key:\n                error_msg = \"OPENAI_API_KEY is required for MCP automation. Please add it to Secrets.\"\n                logs.append(error_msg)\n                self.emit_progress(test_id, f\"❌ {error_msg}\", \"error\")\n                return {\n                    'success': False,\n                    'logs': logs,\n                    'screenshot': None,\n                    'error': error_msg\n                }\n            \n            # Initialize tracer if enabled\n            if enable_tracing:\n                tracer = ExecutionTracer()\n                tracer.start_tracing()\n                logs.append(\"Execution tracing enabled\")\n            \n            # Initialize MCP client with tracer\n            self.emit_progress(test_id, \"🔧 Initializing Playwright MCP client...\", \"info\")\n            mcp_client = PlaywrightMCPClient(tracer=tracer)\n            \n            # Connect to MCP server\n            self.emit_progress(test_id, f\"🌐 Launching {browser} browser...\", \"info\")\n            await mcp_client.connect(browser=browser, headless=headless)\n            logs.append(f\"Browser launched: {browser} ({'headless' if headless else 'headful'})\")\n            self.emit_progress(test_id, \"✅ MCP client connected successfully\", \"success\")\n            \n            # Initialize OpenAI client for NL processing\n            openai_client = AsyncOpenAI(api_key=self.openai_api_key)\n            \n            # Parse command into MCP actions using GPT\n            self.emit_progress(test_id, \"🧠 Analyzing command with AI...\", \"info\")\n            actions = await self._parse_command_to_actions(command, openai_client)\n            logs.append(f\"Parsed {len(actions)} automation steps\")\n            \n            # Execute actions sequentially with progress updates\n            for i, action in enumerate(actions, 1):\n                self.emit_progress(test_id, f\"▶️ Step {i}/{len(actions)}: {action['description']}\", \"info\")\n                logs.append(f\"STEP {i}: {action['description']}\")\n                \n                try:\n                    result = await self._execute_action(mcp_client, action)\n                    logs.append(f\"  ✓ Step {i} completed\")\n                    self.emit_progress(test_id, f\"✅ Step {i} completed\", \"success\")\n                    \n                    # Small delay between steps\n                    await asyncio.sleep(0.5)\n                    \n                except Exception as step_error:\n                    error_msg = f\"  ✗ Step {i} failed: {str(step_error)}\"\n                    logs.append(error_msg)\n                    self.emit_progress(test_id, f\"⚠️ {error_msg}\", \"warning\")\n                    # Continue to next step (non-blocking)\n            \n            # Take final screenshot\n            self.emit_progress(test_id, \"📸 Capturing final screenshot...\", \"info\")\n            screenshot_path = os.path.join(\n                self.screenshots_dir,\n                f\"mcp_{test_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png\"\n            )\n            \n            await mcp_client.screenshot(screenshot_path)\n            \n            if os.path.exists(screenshot_path):\n                with open(screenshot_path, 'rb') as f:\n                    screenshot = base64.b64encode(f.read()).decode()\n                logs.append(\"Screenshot captured\")\n                self.emit_screenshot(test_id, screenshot_path)\n            \n            success = True\n            logs.append(\"Automation completed successfully\")\n            self.emit_progress(test_id, \"🎉 Automation completed successfully!\", \"success\")\n            \n            # Generate code from trace if enabled\n            if enable_tracing and tracer:\n                tracer.stop_tracing()\n                trace_summary = tracer.get_trace_summary()\n                \n                if trace_summary['successful_actions'] > 0:\n                    self.emit_progress(test_id, \"📝 Generating Playwright code from execution trace...\", \"info\")\n                    generated_code = self.hybrid_codegen.generate_from_summary(\n                        trace_summary, \n                        browser=browser, \n                        headless=headless\n                    )\n                    logs.append(f\"Generated code with {trace_summary['successful_actions']} actions\")\n                    self.emit_progress(test_id, \"✅ Playwright code generated successfully\", \"success\")\n                else:\n                    logs.append(\"No successful actions to generate code from\")\n            \n        except Exception as e:\n            error_msg = f\"MCP automation failed: {str(e)}\"\n            error_trace = traceback.format_exc()\n            logs.append(error_msg)\n            logs.append(f\"Traceback: {error_trace}\")\n            self.emit_progress(test_id, f\"❌ {error_msg}\", \"error\")\n            logger.error(f\"MCP automation error: {error_trace}\")\n            \n        finally:\n            # Cleanup: close browser and MCP connection\n            if mcp_client:\n                try:\n                    self.emit_progress(test_id, \"🔄 Closing browser...\", \"info\")\n                    await mcp_client.close()\n                    logs.append(\"Browser closed\")\n                except Exception as cleanup_error:\n                    logger.error(f\"Cleanup error: {cleanup_error}\")\n        \n        return {\n            'success': success,\n            'logs': logs,\n            'screenshot': screenshot,\n            'code': generated_code,  # Generated Playwright code from trace\n            'page_html': '',  # MCP doesn't capture HTML by default\n            'current_step': len(actions) if 'actions' in locals() else 0\n        }\n    \n    async def _parse_command_to_actions(\n        self,\n        command: str,\n        openai_client: AsyncOpenAI\n    ) -> list[Dict[str, Any]]:\n        \"\"\"\n        Parse natural language command into MCP actions using GPT\n        \n        Returns:\n            List of action dictionaries with tool_name, args, and description\n        \"\"\"\n        system_prompt = \"\"\"You are an expert at converting natural language commands into Playwright browser automation actions.\n\nGiven a command, break it down into a sequence of browser actions. Return a JSON array of actions.\n\nEach action should have:\n- tool_name: The MCP tool to use (browser_navigate, browser_click, browser_fill_form, browser_type, etc.)\n- args: Dictionary of arguments for the tool\n- description: Human-readable description of the step\n\nAvailable MCP tools:\n- browser_navigate: Navigate to URL (args: {\"url\": \"...\"})\n- browser_click: Click element (args: {\"selector\": \"css selector\"})\n- browser_fill_form: Fill form field (args: {\"selector\": \"...\", \"value\": \"...\"})\n- browser_type: Type text (args: {\"selector\": \"...\", \"text\": \"...\", \"delay\": 50})\n- browser_wait_for: Wait for element (args: {\"selector\": \"...\"})\n- browser_press_key: Press keyboard key (args: {\"key\": \"Enter\"})\n- browser_take_screenshot: Take screenshot (args: {})\n\nUse semantic selectors when possible (role-based, aria-labels, placeholder, text content).\n\nExample:\nCommand: \"Go to Google and search for Python\"\nOutput:\n[\n  {\n    \"tool_name\": \"browser_navigate\",\n    \"args\": {\"url\": \"https://www.google.com\"},\n    \"description\": \"Navigate to Google homepage\"\n  },\n  {\n    \"tool_name\": \"browser_fill_form\",\n    \"args\": {\"selector\": \"textarea[name='q']\", \"value\": \"Python\"},\n    \"description\": \"Enter search term 'Python'\"\n  },\n  {\n    \"tool_name\": \"browser_press_key\",\n    \"args\": {\"key\": \"Enter\"},\n    \"description\": \"Submit search\"\n  }\n]\n\nReturn ONLY the JSON array, no explanations.\"\"\"\n        \n        try:\n            response = await openai_client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": f\"Command: {command}\"}\n                ],\n                temperature=0.3\n            )\n            \n            content = response.choices[0].message.content.strip()\n            \n            # Remove markdown code blocks if present\n            if content.startswith(\"```\"):\n                content = content.split(\"```\")[1]\n                if content.startswith(\"json\"):\n                    content = content[4:]\n                content = content.strip()\n            \n            import json\n            actions = json.loads(content)\n            \n            return actions\n            \n        except Exception as e:\n            logger.error(f\"Failed to parse command: {e}\")\n            # Fallback: simple navigate action\n            return [{\n                \"tool_name\": \"browser_navigate\",\n                \"args\": {\"url\": \"https://www.google.com\"},\n                \"description\": f\"Fallback: Navigate (parsing failed: {str(e)})\"\n            }]\n    \n    async def _execute_action(\n        self,\n        mcp_client: PlaywrightMCPClient,\n        action: Dict[str, Any]\n    ) -> Any:\n        \"\"\"Execute a single MCP action\"\"\"\n        tool_name = action['tool_name']\n        args = action.get('args', {})\n        \n        result = await mcp_client.call_tool(tool_name, args)\n        return result\n    \n    def cleanup_session(self, test_id: str):\n        \"\"\"Cleanup session resources\"\"\"\n        if test_id in self.active_sessions:\n            session = self.active_sessions[test_id]\n            # Cancel any running tasks\n            if 'task' in session and not session['task'].done():\n                session['task'].cancel()\n            del self.active_sessions[test_id]\n","size_bytes":13286},"visionvault/services/unified_engine.py":{"content":"\"\"\"\nUnified Intelligent Automation Engine\n\nMerges MCP (direct control) and Legacy Playwright (code generation) into one adaptive system\nwith intelligent strategy selection and progressive healing escalation.\n\nArchitecture:\n- MCP-first approach for speed and intelligence\n- Falls back to code generation when needed\n- Progressive healing: DOM → Vision → Multi-strategy → CodeGen → Manual Widget\n- Learns which approach works best for different task types\n\"\"\"\n\nimport asyncio\nimport os\nimport re\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Optional, Dict, Any, List\nfrom datetime import datetime\n\n\nclass StrategyType(Enum):\n    \"\"\"Automation execution strategies\"\"\"\n    MCP_DIRECT = \"mcp_direct\"  # Direct browser control via MCP\n    CODE_GEN = \"code_gen\"      # AI-generated Playwright code\n    HYBRID = \"hybrid\"           # MCP first, fallback to code gen\n\n\nclass TaskComplexity(Enum):\n    \"\"\"Task complexity levels\"\"\"\n    SIMPLE = \"simple\"           # Single action (click, navigate)\n    MODERATE = \"moderate\"       # 2-5 steps\n    COMPLEX = \"complex\"         # 6+ steps or conditional logic\n    ADVANCED = \"advanced\"       # Multi-page workflows, data extraction\n\n\n@dataclass\nclass ExecutionContext:\n    \"\"\"Shared context across all execution attempts\"\"\"\n    test_id: str\n    command: str\n    browser_name: str\n    headless: bool\n    \n    # Analysis results\n    url: Optional[str] = None\n    intent: Optional[str] = None\n    complexity: TaskComplexity = TaskComplexity.MODERATE\n    confidence_score: float = 0.0\n    \n    # DOM and page data\n    dom_analysis: Optional[Dict[str, Any]] = None\n    page_snapshot: Optional[str] = None\n    element_catalog: Optional[Dict[str, List]] = None\n    \n    # Execution state\n    current_strategy: Optional[StrategyType] = None\n    attempts: List[Dict[str, Any]] = field(default_factory=list)\n    failed_strategies: List[StrategyType] = field(default_factory=list)\n    \n    # Results\n    generated_code: Optional[str] = None\n    screenshot: Optional[str] = None\n    logs: List[str] = field(default_factory=list)\n    \n    # Timing\n    start_time: datetime = field(default_factory=datetime.now)\n    \n    def add_attempt(self, strategy: StrategyType, success: bool, error: Optional[str] = None):\n        \"\"\"Record an execution attempt\"\"\"\n        self.attempts.append({\n            'strategy': strategy.value,\n            'success': success,\n            'error': error,\n            'timestamp': datetime.now().isoformat()\n        })\n        if not success:\n            self.failed_strategies.append(strategy)\n\n\n@dataclass\nclass StrategyScore:\n    \"\"\"Score for a particular strategy\"\"\"\n    strategy: StrategyType\n    score: float  # 0-100\n    reasons: List[str]\n    can_execute: bool  # Whether we have required dependencies\n\n\nclass UnifiedAutomationEngine:\n    \"\"\"\n    Intelligent automation engine that adaptively chooses between MCP and CodeGen approaches.\n    \n    Decision Logic:\n    1. Analyze task complexity and intent\n    2. Check historical success rates for similar tasks\n    3. Score available strategies (MCP vs CodeGen)\n    4. Execute with highest-scoring strategy\n    5. Progressive healing escalation if failures occur\n    6. Learn from outcomes to improve future decisions\n    \"\"\"\n    \n    def __init__(self, socketio, openai_client=None, gemini_api_key=None):\n        self.socketio = socketio\n        self.openai_client = openai_client\n        self.gemini_api_key = gemini_api_key\n        \n        # Import heavy dependencies only when needed\n        self._mcp_manager = None\n        self._healing_executor = None\n        self._intelligent_planner = None\n        self._self_learning = None\n        self._dom_inspector = None\n        \n        # Strategy availability\n        # MCP needs OpenAI key (uses it internally for NL commands)\n        # CodeGen needs OpenAI client for code generation\n        # HYBRID needs both (executes with MCP, generates code)\n        self.openai_api_key = os.environ.get('OPENAI_API_KEY')\n        self.mcp_available = self.openai_api_key is not None\n        self.codegen_available = openai_client is not None\n        self.hybrid_available = self.mcp_available and self.codegen_available\n        \n        print(f\"✅ Unified Automation Engine initialized\")\n        print(f\"   MCP Direct: {'✅ Available' if self.mcp_available else '❌ Disabled (requires OPENAI_API_KEY)'}\")\n        print(f\"   Code Generation: {'✅ Available' if self.codegen_available else '❌ Disabled (requires OPENAI_API_KEY)'}\")\n        print(f\"   HYBRID (MCP + Code): {'✅ Available' if self.hybrid_available else '❌ Disabled (requires OPENAI_API_KEY)'}\")\n    \n    @property\n    def mcp_manager(self):\n        \"\"\"Lazy-load MCP manager\"\"\"\n        if self._mcp_manager is None:\n            from visionvault.services.mcp_manager import MCPAutomationManager\n            self._mcp_manager = MCPAutomationManager(\n                self.socketio,\n                os.environ.get('OPENAI_API_KEY')\n            )\n        return self._mcp_manager\n    \n    @property\n    def healing_executor(self):\n        \"\"\"Lazy-load healing executor\"\"\"\n        if self._healing_executor is None:\n            from visionvault.services.healing_executor import HealingExecutor\n            self._healing_executor = HealingExecutor(\n                self.socketio,\n                api_key=os.environ.get('OPENAI_API_KEY'),\n                use_gpt4o=True,\n                mcp_manager=self.mcp_manager if self.mcp_available else None  # Enable MCP-based healing (uses property to init)\n            )\n        return self._healing_executor\n    \n    @property\n    def intelligent_planner(self):\n        \"\"\"Lazy-load intelligent planner\"\"\"\n        if self._intelligent_planner is None and self.openai_client:\n            from visionvault.services.intelligent_planner import IntelligentPlanner\n            self._intelligent_planner = IntelligentPlanner(self.openai_client)\n        return self._intelligent_planner\n    \n    @property\n    def self_learning(self):\n        \"\"\"Lazy-load self-learning engine\"\"\"\n        if self._self_learning is None:\n            from visionvault.services.self_learning_engine import SelfLearningEngine\n            self._self_learning = SelfLearningEngine()\n        return self._self_learning\n    \n    @property\n    def dom_inspector(self):\n        \"\"\"Lazy-load DOM inspector\"\"\"\n        if self._dom_inspector is None:\n            from visionvault.services.dom_inspector import dom_inspector\n            self._dom_inspector = dom_inspector\n        return self._dom_inspector\n    \n    def extract_url_from_command(self, command: str) -> Optional[str]:\n        \"\"\"Extract URL from natural language command\"\"\"\n        url_pattern = r'(https?://[^\\s]+|www\\.[^\\s]+|[a-zA-Z0-9-]+\\.(com|org|net|io|dev|co|ai)[^\\s]*)'\n        urls = re.findall(url_pattern, command.lower())\n        \n        if urls:\n            url = urls[0] if isinstance(urls[0], str) else urls[0][0]\n            if not url.startswith('http'):\n                url = 'https://' + url\n            return url\n        \n        # Common sites\n        command_lower = command.lower()\n        patterns = [\n            r'(?:go to|navigate to|open|visit)\\s+([a-zA-Z0-9-]+(?:\\.[a-zA-Z]{2,})+)',\n            r'(?:search on|use)\\s+([a-zA-Z0-9-]+)(?:\\s|$)',\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, command_lower)\n            if match:\n                domain = match.group(1)\n                if domain in ['google', 'youtube', 'facebook', 'twitter', 'amazon', 'reddit', 'github', 'linkedin']:\n                    return f'https://www.{domain}.com'\n                elif '.' not in domain:\n                    return f'https://www.{domain}.com'\n                else:\n                    return f'https://{domain}' if not domain.startswith('http') else domain\n        \n        return None\n    \n    async def analyze_context(self, context: ExecutionContext) -> None:\n        \"\"\"\n        Analyze task and populate execution context with intelligence.\n        Uses: Intelligent Planner, Self-Learning Engine, DOM Inspector\n        \"\"\"\n        self.socketio.emit('execution_status', {\n            'test_id': context.test_id,\n            'status': 'analyzing',\n            'message': '🧠 Analyzing task with AI intelligence...'\n        })\n        \n        # Extract URL\n        context.url = self.extract_url_from_command(context.command)\n        \n        # Step 1: Intelligent planning (if available)\n        if self.intelligent_planner:\n            try:\n                plan = self.intelligent_planner.analyze_command(context.command)\n                context.intent = plan['intent']\n                context.confidence_score = plan['confidence_score']\n                \n                # Map complexity\n                complexity_map = {\n                    'simple': TaskComplexity.SIMPLE,\n                    'moderate': TaskComplexity.MODERATE,\n                    'complex': TaskComplexity.COMPLEX,\n                    'advanced': TaskComplexity.ADVANCED\n                }\n                context.complexity = complexity_map.get(plan['complexity'], TaskComplexity.MODERATE)\n                \n                context.logs.append(f\"📊 Analysis: {context.intent} (complexity: {context.complexity.value}, confidence: {context.confidence_score:.0f}%)\")\n            except Exception as e:\n                context.logs.append(f\"⚠️ Intelligent planning error: {str(e)}\")\n        \n        # Step 2: DOM inspection (if URL available)\n        if context.url and self.dom_inspector:\n            try:\n                context.logs.append(f\"🔍 Inspecting page: {context.url}\")\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n                dom_analysis = loop.run_until_complete(\n                    self.dom_inspector.analyze_page(context.url, context.command)\n                )\n                loop.close()\n                \n                if 'error' not in dom_analysis:\n                    context.dom_analysis = dom_analysis\n                    intent_matched = len(dom_analysis.get('intent_matched_elements', []))\n                    context.logs.append(f\"✅ Found {intent_matched} relevant elements on page\")\n            except Exception as e:\n                context.logs.append(f\"⚠️ DOM inspection skipped: {str(e)}\")\n    \n    def score_strategies(self, context: ExecutionContext) -> List[StrategyScore]:\n        \"\"\"\n        Score available strategies based on context and historical data.\n        Returns ordered list of strategies (highest score first).\n        \"\"\"\n        scores = []\n        \n        # Check historical recommendations from learning engine\n        historical_rec = None\n        if self.self_learning:\n            try:\n                historical_rec = self.self_learning.recommend_strategy(\n                    context.command,\n                    context.complexity.value\n                )\n            except Exception as e:\n                context.logs.append(f\"⚠️ Could not get historical recommendations: {str(e)}\")\n        \n        # Score MCP Direct\n        if self.mcp_available:\n            mcp_score = 50.0  # Base score\n            reasons = []\n            \n            # Apply historical learning\n            if historical_rec and historical_rec['recommended_strategy'] == 'mcp_direct':\n                bonus = min(25, historical_rec['confidence'] / 4)\n                mcp_score += bonus\n                reasons.append(f\"Historical data favors MCP ({historical_rec['confidence']:.0f}% confidence)\")\n            \n            # Bonus for simple tasks (MCP is faster)\n            if context.complexity == TaskComplexity.SIMPLE:\n                mcp_score += 20\n                reasons.append(\"Fast for simple tasks\")\n            \n            # Bonus if DOM analysis succeeded (MCP can use it)\n            if context.dom_analysis:\n                mcp_score += 15\n                reasons.append(\"DOM structure available\")\n            \n            # Bonus for high confidence\n            if context.confidence_score > 80:\n                mcp_score += 10\n                reasons.append(\"High confidence task\")\n            \n            # Penalty for complex tasks (code gen gives more control)\n            if context.complexity == TaskComplexity.COMPLEX:\n                mcp_score -= 10\n                reasons.append(\"Code gen better for complex workflows\")\n            \n            scores.append(StrategyScore(\n                strategy=StrategyType.MCP_DIRECT,\n                score=min(100, mcp_score),\n                reasons=reasons,\n                can_execute=True\n            ))\n        \n        # Score Code Generation\n        if self.codegen_available:\n            codegen_score = 50.0  # Base score\n            reasons = []\n            \n            # Apply historical learning\n            if historical_rec and historical_rec['recommended_strategy'] == 'code_gen':\n                bonus = min(25, historical_rec['confidence'] / 4)\n                codegen_score += bonus\n                reasons.append(f\"Historical data favors CodeGen ({historical_rec['confidence']:.0f}% confidence)\")\n            \n            # Bonus for complex tasks (more control, debugging)\n            if context.complexity in [TaskComplexity.COMPLEX, TaskComplexity.ADVANCED]:\n                codegen_score += 20\n                reasons.append(\"Better control for complex tasks\")\n            \n            # Bonus if user might want to see/modify code\n            if any(word in context.command.lower() for word in ['show', 'code', 'script', 'generate']):\n                codegen_score += 15\n                reasons.append(\"User may want to review code\")\n            \n            # Bonus for multi-step workflows\n            step_keywords = ['then', 'after', 'next', 'and then', 'finally']\n            if any(keyword in context.command.lower() for keyword in step_keywords):\n                codegen_score += 10\n                reasons.append(\"Multi-step workflow detected\")\n            \n            scores.append(StrategyScore(\n                strategy=StrategyType.CODE_GEN,\n                score=min(100, codegen_score),\n                reasons=reasons,\n                can_execute=True\n            ))\n        \n        # Score HYBRID Strategy (Best of both worlds)\n        if self.hybrid_available:\n            hybrid_score = 60.0  # Higher base than others\n            reasons = []\n            \n            # Apply historical learning\n            if historical_rec and historical_rec['recommended_strategy'] == 'hybrid':\n                bonus = min(30, historical_rec['confidence'] / 3)\n                hybrid_score += bonus\n                reasons.append(f\"Historical data favors HYBRID ({historical_rec['confidence']:.0f}% confidence)\")\n            \n            # HYBRID is ideal for moderate to complex tasks\n            if context.complexity in [TaskComplexity.MODERATE, TaskComplexity.COMPLEX]:\n                hybrid_score += 25\n                reasons.append(\"HYBRID optimal for moderate/complex tasks\")\n            \n            # Bonus for multi-step workflows (executes with MCP, provides reusable code)\n            step_keywords = ['then', 'after', 'next', 'and then', 'finally', 'verify', 'check']\n            if any(keyword in context.command.lower() for keyword in step_keywords):\n                hybrid_score += 15\n                reasons.append(\"Multi-step workflow benefits from HYBRID approach\")\n            \n            # Bonus for verifications/assertions (MCP handles, code captures)\n            verification_keywords = ['verify', 'check', 'assert', 'confirm', 'ensure', 'validate']\n            if any(keyword in context.command.lower() for keyword in verification_keywords):\n                hybrid_score += 10\n                reasons.append(\"Verifications benefit from HYBRID (smart execution + reliable code)\")\n            \n            # HYBRID gives best reliability\n            hybrid_score += 10\n            reasons.append(\"Provides both execution intelligence and reusable code\")\n            \n            scores.append(StrategyScore(\n                strategy=StrategyType.HYBRID,\n                score=min(100, hybrid_score),\n                reasons=reasons,\n                can_execute=True\n            ))\n        \n        # Sort by score (highest first)\n        scores.sort(key=lambda x: x.score, reverse=True)\n        return scores\n    \n    async def execute(self, test_id: str, command: str, browser_name: str = 'chromium', \n                     headless: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Main execution entry point.\n        Intelligently routes to best strategy with progressive healing.\n        \"\"\"\n        # Create execution context\n        context = ExecutionContext(\n            test_id=test_id,\n            command=command,\n            browser_name=browser_name,\n            headless=headless\n        )\n        \n        try:\n            # Step 1: Analyze context\n            await self.analyze_context(context)\n            \n            # Step 2: Score and select strategy\n            strategy_scores = self.score_strategies(context)\n            \n            if not strategy_scores:\n                return {\n                    'success': False,\n                    'logs': ['No execution strategies available. Please configure OPENAI_API_KEY.'],\n                    'screenshot': None,\n                    'code': None\n                }\n            \n            # Emit strategy selection\n            selected = strategy_scores[0]\n            context.current_strategy = selected.strategy\n            \n            self.socketio.emit('strategy_selected', {\n                'test_id': test_id,\n                'strategy': selected.strategy.value,\n                'score': selected.score,\n                'reasons': selected.reasons\n            })\n            \n            context.logs.append(f\"🎯 Selected strategy: {selected.strategy.value} (score: {selected.score:.0f}/100)\")\n            context.logs.append(f\"   Reasons: {', '.join(selected.reasons)}\")\n            \n            # Step 3: Execute with selected strategy\n            result = await self._execute_with_strategy(context, selected.strategy)\n            \n            # Step 4: If failed, try progressive escalation\n            if not result['success'] and len(strategy_scores) > 1:\n                context.logs.append(f\"⚠️ {selected.strategy.value} failed, trying alternative strategy...\")\n                \n                # Try next best strategy\n                for alt_strategy in strategy_scores[1:]:\n                    if alt_strategy.strategy not in context.failed_strategies:\n                        context.logs.append(f\"🔄 Escalating to: {alt_strategy.strategy.value}\")\n                        result = await self._execute_with_strategy(context, alt_strategy.strategy)\n                        \n                        if result['success']:\n                            break\n            \n            # Step 5: Learn from outcome\n            if self.self_learning:\n                try:\n                    # Map strategy type to learning engine format\n                    strategy_name = 'mcp_direct' if context.current_strategy == StrategyType.MCP_DIRECT else 'code_gen'\n                    \n                    self.self_learning.learn_strategy_outcome(\n                        command=command,\n                        strategy=strategy_name,\n                        complexity=context.complexity.value,\n                        success=result['success'],\n                        attempts=len(context.attempts)\n                    )\n                    context.logs.append(f\"📚 Strategy outcome recorded for future learning\")\n                except Exception as e:\n                    context.logs.append(f\"⚠️ Learning update failed: {str(e)}\")\n            \n            return result\n            \n        except Exception as e:\n            context.logs.append(f\"❌ Critical error: {str(e)}\")\n            return {\n                'success': False,\n                'logs': context.logs,\n                'screenshot': None,\n                'code': context.generated_code\n            }\n    \n    async def _execute_with_strategy(self, context: ExecutionContext, \n                                     strategy: StrategyType) -> Dict[str, Any]:\n        \"\"\"Execute with specific strategy\"\"\"\n        context.current_strategy = strategy\n        \n        try:\n            if strategy == StrategyType.MCP_DIRECT:\n                return await self._execute_mcp(context)\n            elif strategy == StrategyType.CODE_GEN:\n                return await self._execute_codegen(context)\n            elif strategy == StrategyType.HYBRID:\n                return await self._execute_hybrid(context)\n            else:\n                context.add_attempt(strategy, False, \"Unknown strategy\")\n                return {\n                    'success': False,\n                    'logs': context.logs + [f\"Unknown strategy: {strategy}\"],\n                    'screenshot': None,\n                    'code': None\n                }\n        except Exception as e:\n            context.add_attempt(strategy, False, str(e))\n            context.logs.append(f\"❌ {strategy.value} error: {str(e)}\")\n            return {\n                'success': False,\n                'logs': context.logs,\n                'screenshot': None,\n                'code': context.generated_code\n            }\n    \n    async def _execute_mcp(self, context: ExecutionContext) -> Dict[str, Any]:\n        \"\"\"Execute using MCP direct approach\"\"\"\n        context.logs.append(\"🚀 Executing with MCP Enhanced (direct browser control)...\")\n        \n        try:\n            result = await self.mcp_manager.execute_automation(\n                test_id=context.test_id,\n                command=context.command,\n                browser=context.browser_name,\n                headless=context.headless\n            )\n            \n            success = result.get('success', False)\n            context.add_attempt(StrategyType.MCP_DIRECT, success, \n                              None if success else result.get('error'))\n            \n            context.logs.extend(result.get('logs', []))\n            context.screenshot = result.get('screenshot')\n            \n            return {\n                'success': success,\n                'logs': context.logs,\n                'screenshot': context.screenshot,\n                'code': None  # MCP doesn't generate code\n            }\n        except Exception as e:\n            context.add_attempt(StrategyType.MCP_DIRECT, False, str(e))\n            raise\n    \n    async def _execute_codegen(self, context: ExecutionContext) -> Dict[str, Any]:\n        \"\"\"Execute using Code Generation approach with healing\"\"\"\n        context.logs.append(\"🔧 Executing with Code Generation (Playwright code)...\")\n        \n        try:\n            # Generate code (will import the function from app.py)\n            from visionvault.web.app import generate_playwright_code\n            \n            code = generate_playwright_code(\n                context.command,\n                browser=context.browser_name\n            )\n            \n            context.generated_code = code\n            context.logs.append(\"✅ Code generated successfully\")\n            \n            # Execute with healing\n            result = await self.healing_executor.execute_with_healing(\n                code=code,\n                test_id=context.test_id,\n                browser_name=context.browser_name,\n                headless=context.headless\n            )\n            \n            success = result.get('success', False)\n            context.add_attempt(StrategyType.CODE_GEN, success,\n                              None if success else result.get('error'))\n            \n            context.logs.extend(result.get('logs', []))\n            context.screenshot = result.get('screenshot')\n            \n            return {\n                'success': success,\n                'logs': context.logs,\n                'screenshot': context.screenshot,\n                'code': result.get('healed_script') or code\n            }\n        except Exception as e:\n            context.add_attempt(StrategyType.CODE_GEN, False, str(e))\n            raise\n    \n    async def _execute_hybrid(self, context: ExecutionContext) -> Dict[str, Any]:\n        \"\"\"\n        Execute using HYBRID approach: MCP intelligence + Code generation\n        \n        1. Execute with MCP (with tracing enabled)\n        2. Capture working selectors and actions\n        3. Generate reliable Playwright code from trace\n        4. Validate generated code works standalone\n        \"\"\"\n        context.logs.append(\"🎯 Executing with HYBRID strategy (MCP intelligence + Code generation)...\")\n        \n        try:\n            # Execute with MCP and enable tracing\n            context.logs.append(\"▶️ Phase 1: Execute with MCP to discover working selectors...\")\n            result = await self.mcp_manager.execute_automation(\n                test_id=context.test_id,\n                command=context.command,\n                browser=context.browser_name,\n                headless=context.headless,\n                enable_tracing=True  # Enable tracing to capture what worked\n            )\n            \n            success = result.get('success', False)\n            context.logs.extend(result.get('logs', []))\n            context.screenshot = result.get('screenshot')\n            context.generated_code = result.get('code')  # Code from MCP trace\n            \n            if success and context.generated_code:\n                context.logs.append(\"✅ Phase 1 complete: MCP execution successful\")\n                context.logs.append(\"✅ Phase 2 complete: Playwright code generated from working selectors\")\n                \n                # Optional: Validate the generated code works standalone\n                # (Skip validation for now to save time, trust the traced selectors)\n                context.add_attempt(StrategyType.HYBRID, True)\n                \n                return {\n                    'success': True,\n                    'logs': context.logs,\n                    'screenshot': context.screenshot,\n                    'code': context.generated_code\n                }\n            elif success and not context.generated_code:\n                # MCP succeeded but no code generated (no successful actions traced)\n                context.logs.append(\"⚠️ MCP succeeded but no code generated (no traceable actions)\")\n                context.add_attempt(StrategyType.HYBRID, True)\n                return {\n                    'success': True,\n                    'logs': context.logs,\n                    'screenshot': context.screenshot,\n                    'code': None\n                }\n            else:\n                # MCP failed\n                context.add_attempt(StrategyType.HYBRID, False, result.get('error'))\n                context.logs.append(\"❌ HYBRID failed: MCP execution unsuccessful\")\n                return {\n                    'success': False,\n                    'logs': context.logs,\n                    'screenshot': context.screenshot,\n                    'code': None\n                }\n                \n        except Exception as e:\n            context.add_attempt(StrategyType.HYBRID, False, str(e))\n            context.logs.append(f\"❌ HYBRID execution error: {str(e)}\")\n            raise\n","size_bytes":27424},"mcp/src/automation/execution_tracer.py":{"content":"\"\"\"\nExecution Tracer for MCP Actions\nCaptures what MCP actually did during execution to generate reliable Playwright code.\n\"\"\"\n\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nimport json\n\n\nclass ExecutionTrace:\n    \"\"\"Represents a single action performed by MCP\"\"\"\n    \n    def __init__(self, action_type: str, tool_name: str, arguments: Dict[str, Any]):\n        self.action_type = action_type\n        self.tool_name = tool_name\n        self.arguments = arguments\n        self.result: Optional[Any] = None\n        self.success: bool = False\n        self.error: Optional[str] = None\n        self.timestamp = datetime.now().isoformat()\n        self.metadata: Dict[str, Any] = {}\n        \n    def mark_success(self, result: Any, metadata: Optional[Dict[str, Any]] = None):\n        \"\"\"Mark action as successful and store result\"\"\"\n        self.success = True\n        self.result = result\n        if metadata:\n            self.metadata.update(metadata)\n    \n    def mark_failure(self, error: str):\n        \"\"\"Mark action as failed\"\"\"\n        self.success = False\n        self.error = error\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization\"\"\"\n        return {\n            'action_type': self.action_type,\n            'tool_name': self.tool_name,\n            'arguments': self.arguments,\n            'result': self.result,\n            'success': self.success,\n            'error': self.error,\n            'timestamp': self.timestamp,\n            'metadata': self.metadata\n        }\n\n\nclass ExecutionTracer:\n    \"\"\"\n    Tracks MCP execution to capture what actually worked.\n    Used to generate reliable Playwright code from successful MCP runs.\n    \"\"\"\n    \n    def __init__(self):\n        self.traces: List[ExecutionTrace] = []\n        self.enabled = False\n        self.current_url: Optional[str] = None\n        \n    def start_tracing(self):\n        \"\"\"Enable execution tracing\"\"\"\n        self.enabled = True\n        self.traces = []\n        \n    def stop_tracing(self) -> List[ExecutionTrace]:\n        \"\"\"Disable tracing and return captured traces\"\"\"\n        self.enabled = False\n        return self.traces\n    \n    def is_tracing(self) -> bool:\n        \"\"\"Check if tracing is currently enabled\"\"\"\n        return self.enabled\n    \n    def record_action(self, action_type: str, tool_name: str, arguments: Dict[str, Any]) -> ExecutionTrace:\n        \"\"\"Record a new action\"\"\"\n        trace = ExecutionTrace(action_type, tool_name, arguments)\n        if self.enabled:\n            self.traces.append(trace)\n        return trace\n    \n    def record_navigation(self, url: str) -> ExecutionTrace:\n        \"\"\"Record a page navigation\"\"\"\n        self.current_url = url\n        return self.record_action('navigate', 'browser_navigate', {'url': url})\n    \n    def record_click(self, selector: str) -> ExecutionTrace:\n        \"\"\"Record a click action\"\"\"\n        return self.record_action('click', 'browser_click', {'selector': selector})\n    \n    def record_fill(self, selector: str, value: str) -> ExecutionTrace:\n        \"\"\"Record filling a form field\"\"\"\n        return self.record_action('fill', 'browser_fill_form', {'selector': selector, 'value': value})\n    \n    def record_type(self, selector: str, text: str, delay: int = 50) -> ExecutionTrace:\n        \"\"\"Record typing text\"\"\"\n        return self.record_action('type', 'browser_type', {'selector': selector, 'text': text, 'delay': delay})\n    \n    def record_select(self, selector: str, value: str) -> ExecutionTrace:\n        \"\"\"Record selecting dropdown option\"\"\"\n        return self.record_action('select', 'browser_select_option', {'selector': selector, 'value': value})\n    \n    def record_wait(self, selector: str, timeout: int = 30000) -> ExecutionTrace:\n        \"\"\"Record waiting for selector\"\"\"\n        return self.record_action('wait', 'browser_wait_for', {'selector': selector, 'timeout': timeout})\n    \n    def record_assertion(self, assertion_type: str, details: Dict[str, Any]) -> ExecutionTrace:\n        \"\"\"Record an assertion/verification\"\"\"\n        return self.record_action('assert', f'assertion_{assertion_type}', details)\n    \n    def get_successful_traces(self) -> List[ExecutionTrace]:\n        \"\"\"Get only successful traces\"\"\"\n        return [t for t in self.traces if t.success]\n    \n    def get_trace_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of execution trace\"\"\"\n        successful = self.get_successful_traces()\n        return {\n            'total_actions': len(self.traces),\n            'successful_actions': len(successful),\n            'failed_actions': len(self.traces) - len(successful),\n            'current_url': self.current_url,\n            'traces': [t.to_dict() for t in self.traces]\n        }\n    \n    def export_to_json(self, filepath: str):\n        \"\"\"Export traces to JSON file\"\"\"\n        with open(filepath, 'w') as f:\n            json.dump(self.get_trace_summary(), f, indent=2)\n","size_bytes":4953},"visionvault/services/hybrid_codegen.py":{"content":"\"\"\"\nHybrid Code Generator\nConverts MCP execution traces into reliable Playwright code.\nUses actual working selectors discovered by MCP instead of LLM guessing.\n\"\"\"\n\nfrom typing import List, Dict, Any, Optional\nimport re\n\n\nclass HybridCodeGenerator:\n    \"\"\"\n    Generates Playwright code from MCP execution traces.\n    Uses proven selectors that actually worked during MCP execution.\n    \"\"\"\n    \n    def __init__(self):\n        self.indentation = \"    \"\n        \n    def generate_code(self, traces: List[Dict[str, Any]], browser: str = 'chromium', \n                     headless: bool = True) -> str:\n        \"\"\"\n        Generate Playwright code from execution traces.\n        \n        Args:\n            traces: List of execution trace dictionaries\n            browser: Browser type\n            headless: Whether to run headless\n            \n        Returns:\n            Complete Playwright Python code\n        \"\"\"\n        code_lines = self._generate_header(browser, headless)\n        \n        # Filter successful traces only\n        successful_traces = [t for t in traces if t.get('success', False)]\n        \n        if not successful_traces:\n            return self._generate_empty_code()\n        \n        # Generate code for each action\n        for trace in successful_traces:\n            action_code = self._generate_action_code(trace)\n            if action_code:\n                code_lines.extend(action_code)\n        \n        # Add screenshot at the end\n        code_lines.append(f\"{self.indentation}# Take final screenshot\")\n        code_lines.append(f\"{self.indentation}page.screenshot(path='final_result.png')\")\n        code_lines.append(\"\")\n        \n        # Add footer\n        code_lines.extend(self._generate_footer())\n        \n        return \"\\n\".join(code_lines)\n    \n    def _generate_header(self, browser: str, headless: bool) -> List[str]:\n        \"\"\"Generate code header with imports and setup\"\"\"\n        return [\n            \"from playwright.sync_api import sync_playwright, expect\",\n            \"import time\",\n            \"\",\n            \"def run():\",\n            f\"{self.indentation}with sync_playwright() as p:\",\n            f\"{self.indentation}{self.indentation}# Launch browser\",\n            f\"{self.indentation}{self.indentation}browser = p.{browser}.launch(headless={headless})\",\n            f\"{self.indentation}{self.indentation}context = browser.new_context()\",\n            f\"{self.indentation}{self.indentation}page = context.new_page()\",\n            f\"{self.indentation}{self.indentation}\",\n            f\"{self.indentation}{self.indentation}try:\",\n        ]\n    \n    def _generate_footer(self) -> List[str]:\n        \"\"\"Generate code footer with cleanup\"\"\"\n        return [\n            f\"{self.indentation}{self.indentation}except Exception as e:\",\n            f\"{self.indentation}{self.indentation}{self.indentation}print(f'Error: {{e}}')\",\n            f\"{self.indentation}{self.indentation}{self.indentation}page.screenshot(path='error.png')\",\n            f\"{self.indentation}{self.indentation}{self.indentation}raise\",\n            f\"{self.indentation}{self.indentation}finally:\",\n            f\"{self.indentation}{self.indentation}{self.indentation}# Cleanup\",\n            f\"{self.indentation}{self.indentation}{self.indentation}context.close()\",\n            f\"{self.indentation}{self.indentation}{self.indentation}browser.close()\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            f\"{self.indentation}run()\",\n        ]\n    \n    def _generate_empty_code(self) -> str:\n        \"\"\"Generate placeholder code when no successful traces\"\"\"\n        return \"# No successful actions to generate code from\\npass\"\n    \n    def _generate_action_code(self, trace: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate code for a single action based on trace\"\"\"\n        action_type = trace.get('action_type', '')\n        tool_name = trace.get('tool_name', '')\n        args = trace.get('arguments', {})\n        indent = f\"{self.indentation}{self.indentation}{self.indentation}\"\n        \n        lines = []\n        \n        # Navigate\n        if action_type == 'navigate':\n            url = args.get('url', '')\n            lines.append(f\"{indent}# Navigate to {url}\")\n            lines.append(f\"{indent}page.goto('{url}')\")\n            lines.append(f\"{indent}page.wait_for_load_state('networkidle')\")\n            lines.append(\"\")\n        \n        # Click\n        elif action_type == 'click':\n            selector = self._escape_selector(args.get('selector', ''))\n            comment = self._generate_comment_from_selector(selector, 'click')\n            lines.append(f\"{indent}# {comment}\")\n            lines.append(f\"{indent}page.locator(\\\"{selector}\\\").click()\")\n            lines.append(f\"{indent}time.sleep(0.5)  # Wait for action to complete\")\n            lines.append(\"\")\n        \n        # Fill form\n        elif action_type == 'fill':\n            selector = self._escape_selector(args.get('selector', ''))\n            value = args.get('value', '')\n            comment = self._generate_comment_from_selector(selector, f'fill with \"{value}\"')\n            lines.append(f\"{indent}# {comment}\")\n            lines.append(f\"{indent}page.locator(\\\"{selector}\\\").fill('{value}')\")\n            lines.append(\"\")\n        \n        # Type text\n        elif action_type == 'type':\n            selector = self._escape_selector(args.get('selector', ''))\n            text = args.get('text', '')\n            delay = args.get('delay', 50)\n            comment = self._generate_comment_from_selector(selector, f'type \"{text}\"')\n            lines.append(f\"{indent}# {comment}\")\n            lines.append(f\"{indent}page.locator(\\\"{selector}\\\").type('{text}', delay={delay})\")\n            lines.append(\"\")\n        \n        # Select dropdown\n        elif action_type == 'select':\n            selector = self._escape_selector(args.get('selector', ''))\n            value = args.get('value', '')\n            comment = self._generate_comment_from_selector(selector, f'select \"{value}\"')\n            lines.append(f\"{indent}# {comment}\")\n            lines.append(f\"{indent}page.locator(\\\"{selector}\\\").select_option('{value}')\")\n            lines.append(\"\")\n        \n        # Wait for element\n        elif action_type == 'wait':\n            selector = self._escape_selector(args.get('selector', ''))\n            timeout = args.get('timeout', 30000)\n            comment = self._generate_comment_from_selector(selector, 'wait for')\n            lines.append(f\"{indent}# {comment}\")\n            lines.append(f\"{indent}page.wait_for_selector(\\\"{selector}\\\", timeout={timeout})\")\n            lines.append(\"\")\n        \n        # Assertions\n        elif action_type == 'assert':\n            assertion_code = self._generate_assertion_code(trace, indent)\n            if assertion_code:\n                lines.extend(assertion_code)\n        \n        return lines\n    \n    def _generate_assertion_code(self, trace: Dict[str, Any], indent: str) -> List[str]:\n        \"\"\"Generate assertion code from trace\"\"\"\n        details = trace.get('arguments', {})\n        assertion_type = trace.get('tool_name', '').replace('assertion_', '')\n        \n        lines = []\n        \n        # URL assertion\n        if assertion_type == 'url_contains':\n            expected = details.get('expected', '')\n            lines.append(f\"{indent}# Verify URL contains '{expected}'\")\n            lines.append(f\"{indent}assert '{expected}' in page.url, f'Expected URL to contain {{expected}}, got {{page.url}}'\")\n            lines.append(\"\")\n        \n        # Text assertion\n        elif assertion_type == 'text_visible':\n            text = details.get('text', '')\n            lines.append(f\"{indent}# Verify text '{text}' is visible\")\n            lines.append(f\"{indent}expect(page.get_by_text('{text}')).to_be_visible()\")\n            lines.append(\"\")\n        \n        # Element visible\n        elif assertion_type == 'element_visible':\n            selector = self._escape_selector(details.get('selector', ''))\n            lines.append(f\"{indent}# Verify element is visible\")\n            lines.append(f\"{indent}expect(page.locator(\\\"{selector}\\\")).to_be_visible()\")\n            lines.append(\"\")\n        \n        return lines\n    \n    def _escape_selector(self, selector: str) -> str:\n        \"\"\"Escape selector for Python string\"\"\"\n        # Handle double quotes in selector\n        return selector.replace('\"', '\\\\\"')\n    \n    def _generate_comment_from_selector(self, selector: str, action: str) -> str:\n        \"\"\"Generate human-readable comment from selector\"\"\"\n        # Extract meaningful parts from selector\n        if 'get_by_role' in selector:\n            return f\"Action: {action} on element (role-based)\"\n        elif 'get_by_text' in selector:\n            match = re.search(r\"get_by_text\\(['\\\"]([^'\\\"]+)['\\\"]\\)\", selector)\n            if match:\n                return f\"Action: {action} on '{match.group(1)}'\"\n        elif 'get_by_placeholder' in selector:\n            match = re.search(r\"get_by_placeholder\\(['\\\"]([^'\\\"]+)['\\\"]\\)\", selector)\n            if match:\n                return f\"Action: {action} on field with placeholder '{match.group(1)}'\"\n        elif '#' in selector:\n            match = re.search(r'#([\\w-]+)', selector)\n            if match:\n                return f\"Action: {action} on element with id '{match.group(1)}'\"\n        \n        return f\"Action: {action}\"\n    \n    def generate_from_summary(self, trace_summary: Dict[str, Any], browser: str = 'chromium',\n                              headless: bool = True) -> str:\n        \"\"\"\n        Generate code from trace summary dictionary.\n        This is a convenience method that extracts traces from the summary.\n        \"\"\"\n        traces = trace_summary.get('traces', [])\n        return self.generate_code(traces, browser, headless)\n","size_bytes":9790}},"version":2}